[
  {
    "function_name": "user_key_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "997-1039",
    "snippet": "int\nuser_key_allowed(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    int auth_attempt, struct sshauthopt **authoptsp)\n{\n\tu_int success, i;\n\tchar *file;\n\tstruct sshauthopt *opts = NULL;\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\tif (sshkey_is_cert(key) &&\n\t    auth_key_is_revoked(key->cert->signature_key))\n\t\treturn 0;\n\n\tif ((success = user_cert_trusted_ca(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tif ((success = user_key_command_allowed2(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tfor (i = 0; !success && i < options.num_authkeys_files; i++) {\n\t\tif (strcasecmp(options.authorized_keys_files[i], \"none\") == 0)\n\t\t\tcontinue;\n\t\tfile = expand_authorized_keys(\n\t\t    options.authorized_keys_files[i], pw);\n\t\tsuccess = user_key_allowed2(ssh, pw, key, file, &opts);\n\t\tfree(file);\n\t}\n\n out:\n\tif (success && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn success;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshauthopt_free",
          "args": [
            "opts"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_key_allowed2",
          "args": [
            "ssh",
            "pw",
            "key",
            "file",
            "&opts"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "user_key_allowed2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "838-860",
          "snippet": "static int\nuser_key_allowed2(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    char *file, struct sshauthopt **authoptsp)\n{\n\tFILE *f;\n\tint found_key = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\t/* Temporarily use the user's uid. */\n\ttemporarily_use_uid(pw);\n\n\tdebug(\"trying public key file %s\", file);\n\tif ((f = auth_openkeyfile(file, pw, options.strict_modes)) != NULL) {\n\t\tfound_key = check_authkeys_file(ssh, pw, f, file,\n\t\t    key, authoptsp);\n\t\tfclose(f);\n\t}\n\n\trestore_uid();\n\treturn found_key;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\nuser_key_allowed2(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    char *file, struct sshauthopt **authoptsp)\n{\n\tFILE *f;\n\tint found_key = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\t/* Temporarily use the user's uid. */\n\ttemporarily_use_uid(pw);\n\n\tdebug(\"trying public key file %s\", file);\n\tif ((f = auth_openkeyfile(file, pw, options.strict_modes)) != NULL) {\n\t\tfound_key = check_authkeys_file(ssh, pw, f, file,\n\t\t    key, authoptsp);\n\t\tfclose(f);\n\t}\n\n\trestore_uid();\n\treturn found_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "expand_authorized_keys",
          "args": [
            "options.authorized_keys_files[i]",
            "pw"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "expand_authorized_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "425-448",
          "snippet": "char *\nexpand_authorized_keys(const char *filename, struct passwd *pw)\n{\n\tchar *file, uidstr[32], ret[PATH_MAX];\n\tint i;\n\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)pw->pw_uid);\n\tfile = percent_expand(filename, \"h\", pw->pw_dir,\n\t    \"u\", pw->pw_name, \"U\", uidstr, (char *)NULL);\n\n\t/*\n\t * Ensure that filename starts anchored. If not, be backward\n\t * compatible and prepend the '%h/'\n\t */\n\tif (*file == '/')\n\t\treturn (file);\n\n\ti = snprintf(ret, sizeof(ret), \"%s/%s\", pw->pw_dir, file);\n\tif (i < 0 || (size_t)i >= sizeof(ret))\n\t\tfatal(\"expand_authorized_keys: path too long\");\n\tfree(file);\n\treturn (xstrdup(ret));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nexpand_authorized_keys(const char *filename, struct passwd *pw)\n{\n\tchar *file, uidstr[32], ret[PATH_MAX];\n\tint i;\n\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)pw->pw_uid);\n\tfile = percent_expand(filename, \"h\", pw->pw_dir,\n\t    \"u\", pw->pw_name, \"U\", uidstr, (char *)NULL);\n\n\t/*\n\t * Ensure that filename starts anchored. If not, be backward\n\t * compatible and prepend the '%h/'\n\t */\n\tif (*file == '/')\n\t\treturn (file);\n\n\ti = snprintf(ret, sizeof(ret), \"%s/%s\", pw->pw_dir, file);\n\tif (i < 0 || (size_t)i >= sizeof(ret))\n\t\tfatal(\"expand_authorized_keys: path too long\");\n\tfree(file);\n\treturn (xstrdup(ret));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "options.authorized_keys_files[i]",
            "\"none\""
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_key_command_allowed2",
          "args": [
            "ssh",
            "pw",
            "key",
            "&opts"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "user_key_command_allowed2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "866-992",
          "snippet": "static int\nuser_key_command_allowed2(struct ssh *ssh, struct passwd *user_pw,\n    struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tstruct passwd *runas_pw = NULL;\n\tFILE *f = NULL;\n\tint r, ok, found_key = 0;\n\tint i, uid_swapped = 0, ac = 0;\n\tpid_t pid;\n\tchar *username = NULL, *key_fp = NULL, *keytext = NULL;\n\tchar uidstr[32], *tmp, *command = NULL, **av = NULL;\n\tvoid (*osigchld)(int);\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\tif (options.authorized_keys_command == NULL)\n\t\treturn 0;\n\tif (options.authorized_keys_command_user == NULL) {\n\t\terror(\"No user for AuthorizedKeysCommand specified, skipping\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * NB. all returns later this function should go via \"out\" to\n\t * ensure the original SIGCHLD handler is restored properly.\n\t */\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\n\t/* Prepare and verify the user for the command */\n\tusername = percent_expand(options.authorized_keys_command_user,\n\t    \"u\", user_pw->pw_name, (char *)NULL);\n\trunas_pw = getpwnam(username);\n\tif (runas_pw == NULL) {\n\t\terror(\"AuthorizedKeysCommandUser \\\"%s\\\" not found: %s\",\n\t\t    username, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* Prepare AuthorizedKeysCommand */\n\tif ((key_fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(key, &keytext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\t/* Turn the command into an argument vector */\n\tif (argv_split(options.authorized_keys_command, &ac, &av) != 0) {\n\t\terror(\"AuthorizedKeysCommand \\\"%s\\\" contains invalid quotes\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"AuthorizedKeysCommand \\\"%s\\\" yielded no arguments\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)user_pw->pw_uid);\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_expand(av[i],\n\t\t    \"U\", uidstr,\n\t\t    \"u\", user_pw->pw_name,\n\t\t    \"h\", user_pw->pw_dir,\n\t\t    \"t\", sshkey_ssh_name(key),\n\t\t    \"f\", key_fp,\n\t\t    \"k\", keytext,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal(\"%s: percent_expand failed\", __func__);\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t/* Prepare a printable command for logs, etc. */\n\tcommand = argv_assemble(ac, av);\n\n\t/*\n\t * If AuthorizedKeysCommand was run without arguments\n\t * then fall back to the old behaviour of passing the\n\t * target username as a single argument.\n\t */\n\tif (ac == 1) {\n\t\tav = xreallocarray(av, ac + 2, sizeof(*av));\n\t\tav[1] = xstrdup(user_pw->pw_name);\n\t\tav[2] = NULL;\n\t\t/* Fix up command too, since it is used in log messages */\n\t\tfree(command);\n\t\txasprintf(&command, \"%s %s\", av[0], av[1]);\n\t}\n\n\tif ((pid = subprocess(\"AuthorizedKeysCommand\", runas_pw, command,\n\t    ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD)) == 0)\n\t\tgoto out;\n\n\tuid_swapped = 1;\n\ttemporarily_use_uid(runas_pw);\n\n\tok = check_authkeys_file(ssh, user_pw, f,\n\t    options.authorized_keys_command, key, authoptsp);\n\n\tfclose(f);\n\tf = NULL;\n\n\tif (exited_cleanly(pid, \"AuthorizedKeysCommand\", command, 0) != 0)\n\t\tgoto out;\n\n\t/* Read completed successfully */\n\tfound_key = ok;\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tsignal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tif (uid_swapped)\n\t\trestore_uid();\n\tfree(command);\n\tfree(username);\n\tfree(key_fp);\n\tfree(keytext);\n\treturn found_key;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\nuser_key_command_allowed2(struct ssh *ssh, struct passwd *user_pw,\n    struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tstruct passwd *runas_pw = NULL;\n\tFILE *f = NULL;\n\tint r, ok, found_key = 0;\n\tint i, uid_swapped = 0, ac = 0;\n\tpid_t pid;\n\tchar *username = NULL, *key_fp = NULL, *keytext = NULL;\n\tchar uidstr[32], *tmp, *command = NULL, **av = NULL;\n\tvoid (*osigchld)(int);\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\tif (options.authorized_keys_command == NULL)\n\t\treturn 0;\n\tif (options.authorized_keys_command_user == NULL) {\n\t\terror(\"No user for AuthorizedKeysCommand specified, skipping\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * NB. all returns later this function should go via \"out\" to\n\t * ensure the original SIGCHLD handler is restored properly.\n\t */\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\n\t/* Prepare and verify the user for the command */\n\tusername = percent_expand(options.authorized_keys_command_user,\n\t    \"u\", user_pw->pw_name, (char *)NULL);\n\trunas_pw = getpwnam(username);\n\tif (runas_pw == NULL) {\n\t\terror(\"AuthorizedKeysCommandUser \\\"%s\\\" not found: %s\",\n\t\t    username, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* Prepare AuthorizedKeysCommand */\n\tif ((key_fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(key, &keytext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\t/* Turn the command into an argument vector */\n\tif (argv_split(options.authorized_keys_command, &ac, &av) != 0) {\n\t\terror(\"AuthorizedKeysCommand \\\"%s\\\" contains invalid quotes\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"AuthorizedKeysCommand \\\"%s\\\" yielded no arguments\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)user_pw->pw_uid);\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_expand(av[i],\n\t\t    \"U\", uidstr,\n\t\t    \"u\", user_pw->pw_name,\n\t\t    \"h\", user_pw->pw_dir,\n\t\t    \"t\", sshkey_ssh_name(key),\n\t\t    \"f\", key_fp,\n\t\t    \"k\", keytext,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal(\"%s: percent_expand failed\", __func__);\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t/* Prepare a printable command for logs, etc. */\n\tcommand = argv_assemble(ac, av);\n\n\t/*\n\t * If AuthorizedKeysCommand was run without arguments\n\t * then fall back to the old behaviour of passing the\n\t * target username as a single argument.\n\t */\n\tif (ac == 1) {\n\t\tav = xreallocarray(av, ac + 2, sizeof(*av));\n\t\tav[1] = xstrdup(user_pw->pw_name);\n\t\tav[2] = NULL;\n\t\t/* Fix up command too, since it is used in log messages */\n\t\tfree(command);\n\t\txasprintf(&command, \"%s %s\", av[0], av[1]);\n\t}\n\n\tif ((pid = subprocess(\"AuthorizedKeysCommand\", runas_pw, command,\n\t    ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD)) == 0)\n\t\tgoto out;\n\n\tuid_swapped = 1;\n\ttemporarily_use_uid(runas_pw);\n\n\tok = check_authkeys_file(ssh, user_pw, f,\n\t    options.authorized_keys_command, key, authoptsp);\n\n\tfclose(f);\n\tf = NULL;\n\n\tif (exited_cleanly(pid, \"AuthorizedKeysCommand\", command, 0) != 0)\n\t\tgoto out;\n\n\t/* Read completed successfully */\n\tfound_key = ok;\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tsignal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tif (uid_swapped)\n\t\trestore_uid();\n\tfree(command);\n\tfree(username);\n\tfree(key_fp);\n\tfree(keytext);\n\treturn found_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_cert_trusted_ca",
          "args": [
            "ssh",
            "pw",
            "key",
            "&opts"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "user_cert_trusted_ca",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "733-832",
          "snippet": "static int\nuser_cert_trusted_ca(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    struct sshauthopt **authoptsp)\n{\n\tchar *ca_fp, *principals_file = NULL;\n\tconst char *reason;\n\tstruct sshauthopt *principals_opts = NULL, *cert_opts = NULL;\n\tstruct sshauthopt *final_opts = NULL;\n\tint r, ret = 0, found_principal = 0, use_authorized_principals;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (!sshkey_is_cert(key) || options.trusted_user_ca_keys == NULL)\n\t\treturn 0;\n\n\tif ((ca_fp = sshkey_fingerprint(key->cert->signature_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\n\tif ((r = sshkey_in_file(key->cert->signature_key,\n\t    options.trusted_user_ca_keys, 1, 0)) != 0) {\n\t\tdebug2(\"%s: CA %s %s is not listed in %s: %s\", __func__,\n\t\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t\t    options.trusted_user_ca_keys, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/*\n\t * If AuthorizedPrincipals is in use, then compare the certificate\n\t * principals against the names in that file rather than matching\n\t * against the username.\n\t */\n\tif ((principals_file = authorized_principals_file(pw)) != NULL) {\n\t\tif (match_principals_file(ssh, pw, principals_file,\n\t\t    key->cert, &principals_opts))\n\t\t\tfound_principal = 1;\n\t}\n\t/* Try querying command if specified */\n\tif (!found_principal && match_principals_command(ssh, pw, key,\n\t    &principals_opts))\n\t\tfound_principal = 1;\n\t/* If principals file or command is specified, then require a match */\n\tuse_authorized_principals = principals_file != NULL ||\n            options.authorized_principals_command != NULL;\n\tif (!found_principal && use_authorized_principals) {\n\t\treason = \"Certificate does not contain an authorized principal\";\n\t\tgoto fail_reason;\n\t}\n\tif (use_authorized_principals && principals_opts == NULL)\n\t\tfatal(\"%s: internal error: missing principals_opts\", __func__);\n\tif (sshkey_cert_check_authority(key, 0, 1,\n\t    use_authorized_principals ? NULL : pw->pw_name, &reason) != 0)\n\t\tgoto fail_reason;\n\n\t/* Check authority from options in key and from principals file/cmd */\n\tif ((cert_opts = sshauthopt_from_cert(key)) == NULL) {\n\t\treason = \"Invalid certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (auth_authorise_keyopts(ssh, pw, cert_opts, 0, \"cert\") != 0) {\n\t\treason = \"Refused by certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (principals_opts == NULL) {\n\t\tfinal_opts = cert_opts;\n\t\tcert_opts = NULL;\n\t} else {\n\t\tif (auth_authorise_keyopts(ssh, pw, principals_opts, 0,\n\t\t    \"principals\") != 0) {\n\t\t\treason = \"Refused by certificate principals options\";\n\t\t\tgoto fail_reason;\n\t\t}\n\t\tif ((final_opts = sshauthopt_merge(principals_opts,\n\t\t    cert_opts, &reason)) == NULL) {\n fail_reason:\n\t\t\terror(\"%s\", reason);\n\t\t\tauth_debug_add(\"%s\", reason);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Success */\n\tverbose(\"Accepted certificate ID \\\"%s\\\" (serial %llu) signed by \"\n\t    \"%s CA %s via %s\", key->cert->key_id,\n\t    (unsigned long long)key->cert->serial,\n\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t    options.trusted_user_ca_keys);\n\tif (authoptsp != NULL) {\n\t\t*authoptsp = final_opts;\n\t\tfinal_opts = NULL;\n\t}\n\tret = 1;\n out:\n\tsshauthopt_free(principals_opts);\n\tsshauthopt_free(cert_opts);\n\tsshauthopt_free(final_opts);\n\tfree(principals_file);\n\tfree(ca_fp);\n\treturn ret;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\nuser_cert_trusted_ca(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    struct sshauthopt **authoptsp)\n{\n\tchar *ca_fp, *principals_file = NULL;\n\tconst char *reason;\n\tstruct sshauthopt *principals_opts = NULL, *cert_opts = NULL;\n\tstruct sshauthopt *final_opts = NULL;\n\tint r, ret = 0, found_principal = 0, use_authorized_principals;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (!sshkey_is_cert(key) || options.trusted_user_ca_keys == NULL)\n\t\treturn 0;\n\n\tif ((ca_fp = sshkey_fingerprint(key->cert->signature_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\n\tif ((r = sshkey_in_file(key->cert->signature_key,\n\t    options.trusted_user_ca_keys, 1, 0)) != 0) {\n\t\tdebug2(\"%s: CA %s %s is not listed in %s: %s\", __func__,\n\t\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t\t    options.trusted_user_ca_keys, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/*\n\t * If AuthorizedPrincipals is in use, then compare the certificate\n\t * principals against the names in that file rather than matching\n\t * against the username.\n\t */\n\tif ((principals_file = authorized_principals_file(pw)) != NULL) {\n\t\tif (match_principals_file(ssh, pw, principals_file,\n\t\t    key->cert, &principals_opts))\n\t\t\tfound_principal = 1;\n\t}\n\t/* Try querying command if specified */\n\tif (!found_principal && match_principals_command(ssh, pw, key,\n\t    &principals_opts))\n\t\tfound_principal = 1;\n\t/* If principals file or command is specified, then require a match */\n\tuse_authorized_principals = principals_file != NULL ||\n            options.authorized_principals_command != NULL;\n\tif (!found_principal && use_authorized_principals) {\n\t\treason = \"Certificate does not contain an authorized principal\";\n\t\tgoto fail_reason;\n\t}\n\tif (use_authorized_principals && principals_opts == NULL)\n\t\tfatal(\"%s: internal error: missing principals_opts\", __func__);\n\tif (sshkey_cert_check_authority(key, 0, 1,\n\t    use_authorized_principals ? NULL : pw->pw_name, &reason) != 0)\n\t\tgoto fail_reason;\n\n\t/* Check authority from options in key and from principals file/cmd */\n\tif ((cert_opts = sshauthopt_from_cert(key)) == NULL) {\n\t\treason = \"Invalid certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (auth_authorise_keyopts(ssh, pw, cert_opts, 0, \"cert\") != 0) {\n\t\treason = \"Refused by certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (principals_opts == NULL) {\n\t\tfinal_opts = cert_opts;\n\t\tcert_opts = NULL;\n\t} else {\n\t\tif (auth_authorise_keyopts(ssh, pw, principals_opts, 0,\n\t\t    \"principals\") != 0) {\n\t\t\treason = \"Refused by certificate principals options\";\n\t\t\tgoto fail_reason;\n\t\t}\n\t\tif ((final_opts = sshauthopt_merge(principals_opts,\n\t\t    cert_opts, &reason)) == NULL) {\n fail_reason:\n\t\t\terror(\"%s\", reason);\n\t\t\tauth_debug_add(\"%s\", reason);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Success */\n\tverbose(\"Accepted certificate ID \\\"%s\\\" (serial %llu) signed by \"\n\t    \"%s CA %s via %s\", key->cert->key_id,\n\t    (unsigned long long)key->cert->serial,\n\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t    options.trusted_user_ca_keys);\n\tif (authoptsp != NULL) {\n\t\t*authoptsp = final_opts;\n\t\tfinal_opts = NULL;\n\t}\n\tret = 1;\n out:\n\tsshauthopt_free(principals_opts);\n\tsshauthopt_free(cert_opts);\n\tsshauthopt_free(final_opts);\n\tfree(principals_file);\n\tfree(ca_fp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_key_is_revoked",
          "args": [
            "key->cert->signature_key"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "auth_key_is_revoked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "635-671",
          "snippet": "int\nauth_key_is_revoked(struct sshkey *key)\n{\n\tchar *fp = NULL;\n\tint r;\n\n\tif (options.revoked_keys_file == NULL)\n\t\treturn 0;\n\tif ((fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\terror(\"%s: fingerprint key: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\tr = sshkey_check_revoked(key, options.revoked_keys_file);\n\tswitch (r) {\n\tcase 0:\n\t\tbreak; /* not revoked */\n\tcase SSH_ERR_KEY_REVOKED:\n\t\terror(\"Authentication key %s %s revoked by file %s\",\n\t\t    sshkey_type(key), fp, options.revoked_keys_file);\n\t\tgoto out;\n\tdefault:\n\t\terror(\"Error checking authentication key %s %s in \"\n\t\t    \"revoked keys file %s: %s\", sshkey_type(key), fp,\n\t\t    options.revoked_keys_file, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\t/* Success */\n\tr = 0;\n\n out:\n\tfree(fp);\n\treturn r == 0 ? 0 : 1;\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nint\nauth_key_is_revoked(struct sshkey *key)\n{\n\tchar *fp = NULL;\n\tint r;\n\n\tif (options.revoked_keys_file == NULL)\n\t\treturn 0;\n\tif ((fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\terror(\"%s: fingerprint key: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\tr = sshkey_check_revoked(key, options.revoked_keys_file);\n\tswitch (r) {\n\tcase 0:\n\t\tbreak; /* not revoked */\n\tcase SSH_ERR_KEY_REVOKED:\n\t\terror(\"Authentication key %s %s revoked by file %s\",\n\t\t    sshkey_type(key), fp, options.revoked_keys_file);\n\t\tgoto out;\n\tdefault:\n\t\terror(\"Error checking authentication key %s %s in \"\n\t\t    \"revoked keys file %s: %s\", sshkey_type(key), fp,\n\t\t    options.revoked_keys_file, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\t/* Success */\n\tr = 0;\n\n out:\n\tfree(fp);\n\treturn r == 0 ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nint\nuser_key_allowed(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    int auth_attempt, struct sshauthopt **authoptsp)\n{\n\tu_int success, i;\n\tchar *file;\n\tstruct sshauthopt *opts = NULL;\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\tif (sshkey_is_cert(key) &&\n\t    auth_key_is_revoked(key->cert->signature_key))\n\t\treturn 0;\n\n\tif ((success = user_cert_trusted_ca(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tif ((success = user_key_command_allowed2(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tfor (i = 0; !success && i < options.num_authkeys_files; i++) {\n\t\tif (strcasecmp(options.authorized_keys_files[i], \"none\") == 0)\n\t\t\tcontinue;\n\t\tfile = expand_authorized_keys(\n\t\t    options.authorized_keys_files[i], pw);\n\t\tsuccess = user_key_allowed2(ssh, pw, key, file, &opts);\n\t\tfree(file);\n\t}\n\n out:\n\tif (success && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn success;\n}"
  },
  {
    "function_name": "user_key_command_allowed2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "866-992",
    "snippet": "static int\nuser_key_command_allowed2(struct ssh *ssh, struct passwd *user_pw,\n    struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tstruct passwd *runas_pw = NULL;\n\tFILE *f = NULL;\n\tint r, ok, found_key = 0;\n\tint i, uid_swapped = 0, ac = 0;\n\tpid_t pid;\n\tchar *username = NULL, *key_fp = NULL, *keytext = NULL;\n\tchar uidstr[32], *tmp, *command = NULL, **av = NULL;\n\tvoid (*osigchld)(int);\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\tif (options.authorized_keys_command == NULL)\n\t\treturn 0;\n\tif (options.authorized_keys_command_user == NULL) {\n\t\terror(\"No user for AuthorizedKeysCommand specified, skipping\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * NB. all returns later this function should go via \"out\" to\n\t * ensure the original SIGCHLD handler is restored properly.\n\t */\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\n\t/* Prepare and verify the user for the command */\n\tusername = percent_expand(options.authorized_keys_command_user,\n\t    \"u\", user_pw->pw_name, (char *)NULL);\n\trunas_pw = getpwnam(username);\n\tif (runas_pw == NULL) {\n\t\terror(\"AuthorizedKeysCommandUser \\\"%s\\\" not found: %s\",\n\t\t    username, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* Prepare AuthorizedKeysCommand */\n\tif ((key_fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(key, &keytext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\t/* Turn the command into an argument vector */\n\tif (argv_split(options.authorized_keys_command, &ac, &av) != 0) {\n\t\terror(\"AuthorizedKeysCommand \\\"%s\\\" contains invalid quotes\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"AuthorizedKeysCommand \\\"%s\\\" yielded no arguments\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)user_pw->pw_uid);\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_expand(av[i],\n\t\t    \"U\", uidstr,\n\t\t    \"u\", user_pw->pw_name,\n\t\t    \"h\", user_pw->pw_dir,\n\t\t    \"t\", sshkey_ssh_name(key),\n\t\t    \"f\", key_fp,\n\t\t    \"k\", keytext,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal(\"%s: percent_expand failed\", __func__);\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t/* Prepare a printable command for logs, etc. */\n\tcommand = argv_assemble(ac, av);\n\n\t/*\n\t * If AuthorizedKeysCommand was run without arguments\n\t * then fall back to the old behaviour of passing the\n\t * target username as a single argument.\n\t */\n\tif (ac == 1) {\n\t\tav = xreallocarray(av, ac + 2, sizeof(*av));\n\t\tav[1] = xstrdup(user_pw->pw_name);\n\t\tav[2] = NULL;\n\t\t/* Fix up command too, since it is used in log messages */\n\t\tfree(command);\n\t\txasprintf(&command, \"%s %s\", av[0], av[1]);\n\t}\n\n\tif ((pid = subprocess(\"AuthorizedKeysCommand\", runas_pw, command,\n\t    ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD)) == 0)\n\t\tgoto out;\n\n\tuid_swapped = 1;\n\ttemporarily_use_uid(runas_pw);\n\n\tok = check_authkeys_file(ssh, user_pw, f,\n\t    options.authorized_keys_command, key, authoptsp);\n\n\tfclose(f);\n\tf = NULL;\n\n\tif (exited_cleanly(pid, \"AuthorizedKeysCommand\", command, 0) != 0)\n\t\tgoto out;\n\n\t/* Read completed successfully */\n\tfound_key = ok;\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tsignal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tif (uid_swapped)\n\t\trestore_uid();\n\tfree(command);\n\tfree(username);\n\tfree(key_fp);\n\tfree(keytext);\n\treturn found_key;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "keytext"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_uid",
          "args": [],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "restore_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "141-172",
          "snippet": "void\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGCHLD",
            "osigchld"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exited_cleanly",
          "args": [
            "pid",
            "\"AuthorizedKeysCommand\"",
            "command",
            "0"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "exited_cleanly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1733-1753",
          "snippet": "int\nexited_cleanly(pid_t pid, const char *tag, const char *cmd, int quiet)\n{\n\tint status;\n\n\twhile (waitpid(pid, &status, 0) == -1) {\n\t\tif (errno != EINTR) {\n\t\t\terror(\"%s: waitpid: %s\", tag, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (WIFSIGNALED(status)) {\n\t\terror(\"%s %s exited on signal %d\", tag, cmd, WTERMSIG(status));\n\t\treturn -1;\n\t} else if (WEXITSTATUS(status) != 0) {\n\t\tdo_log2(quiet ? SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_INFO,\n\t\t    \"%s %s failed, status %d\", tag, cmd, WEXITSTATUS(status));\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nexited_cleanly(pid_t pid, const char *tag, const char *cmd, int quiet)\n{\n\tint status;\n\n\twhile (waitpid(pid, &status, 0) == -1) {\n\t\tif (errno != EINTR) {\n\t\t\terror(\"%s: waitpid: %s\", tag, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (WIFSIGNALED(status)) {\n\t\terror(\"%s %s exited on signal %d\", tag, cmd, WTERMSIG(status));\n\t\treturn -1;\n\t} else if (WEXITSTATUS(status) != 0) {\n\t\tdo_log2(quiet ? SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_INFO,\n\t\t    \"%s %s failed, status %d\", tag, cmd, WEXITSTATUS(status));\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_authkeys_file",
          "args": [
            "ssh",
            "user_pw",
            "f",
            "options.authorized_keys_command",
            "key",
            "authoptsp"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "check_authkeys_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "701-730",
          "snippet": "static int\ncheck_authkeys_file(struct ssh *ssh, struct passwd *pw, FILE *f,\n    char *file, struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tchar *cp, *line = NULL, loc[256];\n\tsize_t linesize = 0;\n\tint found_key = 0;\n\tu_long linenum = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire file */\n\t\tif (found_key)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace, empty and comment lines. */\n\t\tcp = line;\n\t\tskip_space(&cp);\n\t\tif (!*cp || *cp == '\\n' || *cp == '#')\n\t\t\tcontinue;\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_authkey_line(ssh, pw, key, cp, loc, authoptsp) == 0)\n\t\t\tfound_key = 1;\n\t}\n\tfree(line);\n\treturn found_key;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncheck_authkeys_file(struct ssh *ssh, struct passwd *pw, FILE *f,\n    char *file, struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tchar *cp, *line = NULL, loc[256];\n\tsize_t linesize = 0;\n\tint found_key = 0;\n\tu_long linenum = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire file */\n\t\tif (found_key)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace, empty and comment lines. */\n\t\tcp = line;\n\t\tskip_space(&cp);\n\t\tif (!*cp || *cp == '\\n' || *cp == '#')\n\t\t\tcontinue;\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_authkey_line(ssh, pw, key, cp, loc, authoptsp) == 0)\n\t\t\tfound_key = 1;\n\t}\n\tfree(line);\n\treturn found_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "temporarily_use_uid",
          "args": [
            "runas_pw"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "temporarily_use_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "60-136",
          "snippet": "void\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static uid_t\tuser_groups_uid;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "subprocess",
          "args": [
            "\"AuthorizedKeysCommand\"",
            "runas_pw",
            "command",
            "ac",
            "av",
            "&f",
            "SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "subprocess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "863-1004",
          "snippet": "pid_t\nsubprocess(const char *tag, struct passwd *pw, const char *command,\n    int ac, char **av, FILE **child, u_int flags)\n{\n\tFILE *f = NULL;\n\tstruct stat st;\n\tint fd, devnull, p[2], i;\n\tpid_t pid;\n\tchar *cp, errmsg[512];\n\tu_int envsize;\n\tchar **child_env;\n\n\tif (child != NULL)\n\t\t*child = NULL;\n\n\tdebug3(\"%s: %s command \\\"%s\\\" running as %s (flags 0x%x)\", __func__,\n\t    tag, command, pw->pw_name, flags);\n\n\t/* Check consistency */\n\tif ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0 &&\n\t    (flags & SSH_SUBPROCESS_STDOUT_CAPTURE) != 0) {\n\t\terror(\"%s: inconsistent flags\", __func__);\n\t\treturn 0;\n\t}\n\tif (((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0) != (child == NULL)) {\n\t\terror(\"%s: inconsistent flags/output\", __func__);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If executing an explicit binary, then verify the it exists\n\t * and appears safe-ish to execute\n\t */\n\tif (*av[0] != '/') {\n\t\terror(\"%s path is not absolute\", tag);\n\t\treturn 0;\n\t}\n\ttemporarily_use_uid(pw);\n\tif (stat(av[0], &st) < 0) {\n\t\terror(\"Could not stat %s \\\"%s\\\": %s\", tag,\n\t\t    av[0], strerror(errno));\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\tif (safe_path(av[0], &st, NULL, 0, errmsg, sizeof(errmsg)) != 0) {\n\t\terror(\"Unsafe %s \\\"%s\\\": %s\", tag, av[0], errmsg);\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\t/* Prepare to keep the child's stdout if requested */\n\tif (pipe(p) != 0) {\n\t\terror(\"%s: pipe: %s\", tag, strerror(errno));\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\trestore_uid();\n\n\tswitch ((pid = fork())) {\n\tcase -1: /* error */\n\t\terror(\"%s: fork: %s\", tag, strerror(errno));\n\t\tclose(p[0]);\n\t\tclose(p[1]);\n\t\treturn 0;\n\tcase 0: /* child */\n\t\t/* Prepare a minimal environment for the child. */\n\t\tenvsize = 5;\n\t\tchild_env = xcalloc(sizeof(*child_env), envsize);\n\t\tchild_set_env(&child_env, &envsize, \"PATH\", _PATH_STDPATH);\n\t\tchild_set_env(&child_env, &envsize, \"USER\", pw->pw_name);\n\t\tchild_set_env(&child_env, &envsize, \"LOGNAME\", pw->pw_name);\n\t\tchild_set_env(&child_env, &envsize, \"HOME\", pw->pw_dir);\n\t\tif ((cp = getenv(\"LANG\")) != NULL)\n\t\t\tchild_set_env(&child_env, &envsize, \"LANG\", cp);\n\n\t\tfor (i = 0; i < NSIG; i++)\n\t\t\tsignal(i, SIG_DFL);\n\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\t\terror(\"%s: open %s: %s\", tag, _PATH_DEVNULL,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (dup2(devnull, STDIN_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\n\t\t/* Set up stdout as requested; leave stderr in place for now. */\n\t\tfd = -1;\n\t\tif ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) != 0)\n\t\t\tfd = p[1];\n\t\telse if ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0)\n\t\t\tfd = devnull;\n\t\tif (fd != -1 && dup2(fd, STDOUT_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\t/* Don't use permanently_set_uid() here to avoid fatal() */\n\t\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0) {\n\t\t\terror(\"%s: setresgid %u: %s\", tag, (u_int)pw->pw_gid,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0) {\n\t\t\terror(\"%s: setresuid %u: %s\", tag, (u_int)pw->pw_uid,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\t/* stdin is pointed to /dev/null at this point */\n\t\tif ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0 &&\n\t\t    dup2(STDIN_FILENO, STDERR_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\n\t\texecve(av[0], av, child_env);\n\t\terror(\"%s exec \\\"%s\\\": %s\", tag, command, strerror(errno));\n\t\t_exit(127);\n\tdefault: /* parent */\n\t\tbreak;\n\t}\n\n\tclose(p[1]);\n\tif ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0)\n\t\tclose(p[0]);\n\telse if ((f = fdopen(p[0], \"r\")) == NULL) {\n\t\terror(\"%s: fdopen: %s\", tag, strerror(errno));\n\t\tclose(p[0]);\n\t\t/* Don't leave zombie child */\n\t\tkill(pid, SIGTERM);\n\t\twhile (waitpid(pid, NULL, 0) == -1 && errno == EINTR)\n\t\t\t;\n\t\treturn 0;\n\t}\n\t/* Success */\n\tdebug3(\"%s: %s pid %ld\", __func__, tag, (long)pid);\n\tif (child != NULL)\n\t\t*child = f;\n\treturn pid;\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\npid_t\nsubprocess(const char *tag, struct passwd *pw, const char *command,\n    int ac, char **av, FILE **child, u_int flags)\n{\n\tFILE *f = NULL;\n\tstruct stat st;\n\tint fd, devnull, p[2], i;\n\tpid_t pid;\n\tchar *cp, errmsg[512];\n\tu_int envsize;\n\tchar **child_env;\n\n\tif (child != NULL)\n\t\t*child = NULL;\n\n\tdebug3(\"%s: %s command \\\"%s\\\" running as %s (flags 0x%x)\", __func__,\n\t    tag, command, pw->pw_name, flags);\n\n\t/* Check consistency */\n\tif ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0 &&\n\t    (flags & SSH_SUBPROCESS_STDOUT_CAPTURE) != 0) {\n\t\terror(\"%s: inconsistent flags\", __func__);\n\t\treturn 0;\n\t}\n\tif (((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0) != (child == NULL)) {\n\t\terror(\"%s: inconsistent flags/output\", __func__);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If executing an explicit binary, then verify the it exists\n\t * and appears safe-ish to execute\n\t */\n\tif (*av[0] != '/') {\n\t\terror(\"%s path is not absolute\", tag);\n\t\treturn 0;\n\t}\n\ttemporarily_use_uid(pw);\n\tif (stat(av[0], &st) < 0) {\n\t\terror(\"Could not stat %s \\\"%s\\\": %s\", tag,\n\t\t    av[0], strerror(errno));\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\tif (safe_path(av[0], &st, NULL, 0, errmsg, sizeof(errmsg)) != 0) {\n\t\terror(\"Unsafe %s \\\"%s\\\": %s\", tag, av[0], errmsg);\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\t/* Prepare to keep the child's stdout if requested */\n\tif (pipe(p) != 0) {\n\t\terror(\"%s: pipe: %s\", tag, strerror(errno));\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\trestore_uid();\n\n\tswitch ((pid = fork())) {\n\tcase -1: /* error */\n\t\terror(\"%s: fork: %s\", tag, strerror(errno));\n\t\tclose(p[0]);\n\t\tclose(p[1]);\n\t\treturn 0;\n\tcase 0: /* child */\n\t\t/* Prepare a minimal environment for the child. */\n\t\tenvsize = 5;\n\t\tchild_env = xcalloc(sizeof(*child_env), envsize);\n\t\tchild_set_env(&child_env, &envsize, \"PATH\", _PATH_STDPATH);\n\t\tchild_set_env(&child_env, &envsize, \"USER\", pw->pw_name);\n\t\tchild_set_env(&child_env, &envsize, \"LOGNAME\", pw->pw_name);\n\t\tchild_set_env(&child_env, &envsize, \"HOME\", pw->pw_dir);\n\t\tif ((cp = getenv(\"LANG\")) != NULL)\n\t\t\tchild_set_env(&child_env, &envsize, \"LANG\", cp);\n\n\t\tfor (i = 0; i < NSIG; i++)\n\t\t\tsignal(i, SIG_DFL);\n\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\t\terror(\"%s: open %s: %s\", tag, _PATH_DEVNULL,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (dup2(devnull, STDIN_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\n\t\t/* Set up stdout as requested; leave stderr in place for now. */\n\t\tfd = -1;\n\t\tif ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) != 0)\n\t\t\tfd = p[1];\n\t\telse if ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0)\n\t\t\tfd = devnull;\n\t\tif (fd != -1 && dup2(fd, STDOUT_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\t/* Don't use permanently_set_uid() here to avoid fatal() */\n\t\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0) {\n\t\t\terror(\"%s: setresgid %u: %s\", tag, (u_int)pw->pw_gid,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0) {\n\t\t\terror(\"%s: setresuid %u: %s\", tag, (u_int)pw->pw_uid,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\t/* stdin is pointed to /dev/null at this point */\n\t\tif ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0 &&\n\t\t    dup2(STDIN_FILENO, STDERR_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\n\t\texecve(av[0], av, child_env);\n\t\terror(\"%s exec \\\"%s\\\": %s\", tag, command, strerror(errno));\n\t\t_exit(127);\n\tdefault: /* parent */\n\t\tbreak;\n\t}\n\n\tclose(p[1]);\n\tif ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0)\n\t\tclose(p[0]);\n\telse if ((f = fdopen(p[0], \"r\")) == NULL) {\n\t\terror(\"%s: fdopen: %s\", tag, strerror(errno));\n\t\tclose(p[0]);\n\t\t/* Don't leave zombie child */\n\t\tkill(pid, SIGTERM);\n\t\twhile (waitpid(pid, NULL, 0) == -1 && errno == EINTR)\n\t\t\t;\n\t\treturn 0;\n\t}\n\t/* Success */\n\tdebug3(\"%s: %s pid %ld\", __func__, tag, (long)pid);\n\tif (child != NULL)\n\t\t*child = f;\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&command",
            "\"%s %s\"",
            "av[0]",
            "av[1]"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "user_pw->pw_name"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xreallocarray",
          "args": [
            "av",
            "ac + 2",
            "sizeof(*av)"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "xreallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "68-78",
          "snippet": "void *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv_assemble",
          "args": [
            "ac",
            "av"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "argv_assemble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1681-1730",
          "snippet": "char *\nargv_assemble(int argc, char **argv)\n{\n\tint i, j, ws, r;\n\tchar c, *ret;\n\tstruct sshbuf *buf, *arg;\n\n\tif ((buf = sshbuf_new()) == NULL || (arg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tfor (i = 0; i < argc; i++) {\n\t\tws = 0;\n\t\tsshbuf_reset(arg);\n\t\tfor (j = 0; argv[i][j] != '\\0'; j++) {\n\t\t\tr = 0;\n\t\t\tc = argv[i][j];\n\t\t\tswitch (c) {\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\t\tws = 1;\n\t\t\t\tr = sshbuf_put_u8(arg, c);\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tif ((r = sshbuf_put_u8(arg, '\\\\')) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tr = sshbuf_put_u8(arg, c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (r != 0)\n\t\t\t\tfatal(\"%s: sshbuf_put_u8: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif ((i != 0 && (r = sshbuf_put_u8(buf, ' ')) != 0) ||\n\t\t    (ws != 0 && (r = sshbuf_put_u8(buf, '\"')) != 0) ||\n\t\t    (r = sshbuf_putb(buf, arg)) != 0 ||\n\t\t    (ws != 0 && (r = sshbuf_put_u8(buf, '\"')) != 0))\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif ((ret = malloc(sshbuf_len(buf) + 1)) == NULL)\n\t\tfatal(\"%s: malloc failed\", __func__);\n\tmemcpy(ret, sshbuf_ptr(buf), sshbuf_len(buf));\n\tret[sshbuf_len(buf)] = '\\0';\n\tsshbuf_free(buf);\n\tsshbuf_free(arg);\n\treturn ret;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nargv_assemble(int argc, char **argv)\n{\n\tint i, j, ws, r;\n\tchar c, *ret;\n\tstruct sshbuf *buf, *arg;\n\n\tif ((buf = sshbuf_new()) == NULL || (arg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tfor (i = 0; i < argc; i++) {\n\t\tws = 0;\n\t\tsshbuf_reset(arg);\n\t\tfor (j = 0; argv[i][j] != '\\0'; j++) {\n\t\t\tr = 0;\n\t\t\tc = argv[i][j];\n\t\t\tswitch (c) {\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\t\tws = 1;\n\t\t\t\tr = sshbuf_put_u8(arg, c);\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tif ((r = sshbuf_put_u8(arg, '\\\\')) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tr = sshbuf_put_u8(arg, c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (r != 0)\n\t\t\t\tfatal(\"%s: sshbuf_put_u8: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif ((i != 0 && (r = sshbuf_put_u8(buf, ' ')) != 0) ||\n\t\t    (ws != 0 && (r = sshbuf_put_u8(buf, '\"')) != 0) ||\n\t\t    (r = sshbuf_putb(buf, arg)) != 0 ||\n\t\t    (ws != 0 && (r = sshbuf_put_u8(buf, '\"')) != 0))\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif ((ret = malloc(sshbuf_len(buf) + 1)) == NULL)\n\t\tfatal(\"%s: malloc failed\", __func__);\n\tmemcpy(ret, sshbuf_ptr(buf), sshbuf_len(buf));\n\tret[sshbuf_len(buf)] = '\\0';\n\tsshbuf_free(buf);\n\tsshbuf_free(arg);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: percent_expand failed\"",
            "__func__"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percent_expand",
          "args": [
            "av[i]",
            "\"U\"",
            "uidstr",
            "\"u\"",
            "user_pw->pw_name",
            "\"h\"",
            "user_pw->pw_dir",
            "\"t\"",
            "sshkey_ssh_name(key)",
            "\"f\"",
            "key_fp",
            "\"k\"",
            "keytext",
            "(char *)NULL"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "percent_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "973-1029",
          "snippet": "char *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define EXPAND_MAX_KEYS\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define EXPAND_MAX_KEYS\t16\n\nchar *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "key"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "uidstr",
            "sizeof(uidstr)",
            "\"%llu\"",
            "(unsigned long long)user_pw->pw_uid"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"AuthorizedKeysCommand \\\"%s\\\" yielded no arguments\"",
            "command"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv_split",
          "args": [
            "options.authorized_keys_command",
            "&ac",
            "&av"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "argv_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1607-1675",
          "snippet": "int\nargv_split(const char *s, int *argcp, char ***argvp)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tint argc = 0, quote, i, j;\n\tchar *arg, **argv = xcalloc(1, sizeof(*argv));\n\n\t*argvp = NULL;\n\t*argcp = 0;\n\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\t/* Skip leading whitespace */\n\t\tif (s[i] == ' ' || s[i] == '\\t')\n\t\t\tcontinue;\n\n\t\t/* Start of a token */\n\t\tquote = 0;\n\t\tif (s[i] == '\\\\' &&\n\t\t    (s[i + 1] == '\\'' || s[i + 1] == '\\\"' || s[i + 1] == '\\\\'))\n\t\t\ti++;\n\t\telse if (s[i] == '\\'' || s[i] == '\"')\n\t\t\tquote = s[i++];\n\n\t\targv = xreallocarray(argv, (argc + 2), sizeof(*argv));\n\t\targ = argv[argc++] = xcalloc(1, strlen(s + i) + 1);\n\t\targv[argc] = NULL;\n\n\t\t/* Copy the token in, removing escapes */\n\t\tfor (j = 0; s[i] != '\\0'; i++) {\n\t\t\tif (s[i] == '\\\\') {\n\t\t\t\tif (s[i + 1] == '\\'' ||\n\t\t\t\t    s[i + 1] == '\\\"' ||\n\t\t\t\t    s[i + 1] == '\\\\') {\n\t\t\t\t\ti++; /* Skip '\\' */\n\t\t\t\t\targ[j++] = s[i];\n\t\t\t\t} else {\n\t\t\t\t\t/* Unrecognised escape */\n\t\t\t\t\targ[j++] = s[i];\n\t\t\t\t}\n\t\t\t} else if (quote == 0 && (s[i] == ' ' || s[i] == '\\t'))\n\t\t\t\tbreak; /* done */\n\t\t\telse if (quote != 0 && s[i] == quote)\n\t\t\t\tbreak; /* done */\n\t\t\telse\n\t\t\t\targ[j++] = s[i];\n\t\t}\n\t\tif (s[i] == '\\0') {\n\t\t\tif (quote != 0) {\n\t\t\t\t/* Ran out of string looking for close quote */\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Success */\n\t*argcp = argc;\n\t*argvp = argv;\n\targc = 0;\n\targv = NULL;\n\tr = 0;\n out:\n\tif (argc != 0 && argv != NULL) {\n\t\tfor (i = 0; i < argc; i++)\n\t\t\tfree(argv[i]);\n\t\tfree(argv);\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nargv_split(const char *s, int *argcp, char ***argvp)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tint argc = 0, quote, i, j;\n\tchar *arg, **argv = xcalloc(1, sizeof(*argv));\n\n\t*argvp = NULL;\n\t*argcp = 0;\n\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\t/* Skip leading whitespace */\n\t\tif (s[i] == ' ' || s[i] == '\\t')\n\t\t\tcontinue;\n\n\t\t/* Start of a token */\n\t\tquote = 0;\n\t\tif (s[i] == '\\\\' &&\n\t\t    (s[i + 1] == '\\'' || s[i + 1] == '\\\"' || s[i + 1] == '\\\\'))\n\t\t\ti++;\n\t\telse if (s[i] == '\\'' || s[i] == '\"')\n\t\t\tquote = s[i++];\n\n\t\targv = xreallocarray(argv, (argc + 2), sizeof(*argv));\n\t\targ = argv[argc++] = xcalloc(1, strlen(s + i) + 1);\n\t\targv[argc] = NULL;\n\n\t\t/* Copy the token in, removing escapes */\n\t\tfor (j = 0; s[i] != '\\0'; i++) {\n\t\t\tif (s[i] == '\\\\') {\n\t\t\t\tif (s[i + 1] == '\\'' ||\n\t\t\t\t    s[i + 1] == '\\\"' ||\n\t\t\t\t    s[i + 1] == '\\\\') {\n\t\t\t\t\ti++; /* Skip '\\' */\n\t\t\t\t\targ[j++] = s[i];\n\t\t\t\t} else {\n\t\t\t\t\t/* Unrecognised escape */\n\t\t\t\t\targ[j++] = s[i];\n\t\t\t\t}\n\t\t\t} else if (quote == 0 && (s[i] == ' ' || s[i] == '\\t'))\n\t\t\t\tbreak; /* done */\n\t\t\telse if (quote != 0 && s[i] == quote)\n\t\t\t\tbreak; /* done */\n\t\t\telse\n\t\t\t\targ[j++] = s[i];\n\t\t}\n\t\tif (s[i] == '\\0') {\n\t\t\tif (quote != 0) {\n\t\t\t\t/* Ran out of string looking for close quote */\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Success */\n\t*argcp = argc;\n\t*argvp = argv;\n\targc = 0;\n\targv = NULL;\n\tr = 0;\n out:\n\tif (argc != 0 && argv != NULL) {\n\t\tfor (i = 0; i < argc; i++)\n\t\t\tfree(argv[i]);\n\t\tfree(argv);\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_to_base64",
          "args": [
            "key",
            "&keytext"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_to_base64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1382-1409",
          "snippet": "int\nsshkey_to_base64(const struct sshkey *key, char **b64p)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\tchar *uu = NULL;\n\n\tif (b64p != NULL)\n\t\t*b64p = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_putb(key, b)) != 0)\n\t\tgoto out;\n\tif ((uu = sshbuf_dtob64(b)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tif (b64p != NULL) {\n\t\t*b64p = uu;\n\t\tuu = NULL;\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tfree(uu);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_base64(const struct sshkey *key, char **b64p)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\tchar *uu = NULL;\n\n\tif (b64p != NULL)\n\t\t*b64p = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_putb(key, b)) != 0)\n\t\tgoto out;\n\tif ((uu = sshbuf_dtob64(b)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tif (b64p != NULL) {\n\t\t*b64p = uu;\n\t\tuu = NULL;\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tfree(uu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "key",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "username"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "getpwnamallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "560-632",
          "snippet": "struct passwd *\ngetpwnamallow(const char *user)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n#ifdef HAVE_LOGIN_CAP\n\textern login_cap_t *lc;\n#ifdef BSD_AUTH\n\tauth_session_t *as;\n#endif\n#endif\n\tstruct passwd *pw;\n\tstruct connection_info *ci = get_connection_info(1, options.use_dns);\n\n\tci->user = user;\n\tparse_server_match_config(&options, ci);\n\tlog_change_level(options.log_level);\n\tprocess_permitopen(ssh, &options);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_setauthdb(user);\n#endif\n\n\tpw = getpwnam(user);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_restoreauthdb();\n#endif\n#ifdef HAVE_CYGWIN\n\t/*\n\t * Windows usernames are case-insensitive.  To avoid later problems\n\t * when trying to match the username, the user is only allowed to\n\t * login if the username is given in the same case as stored in the\n\t * user database.\n\t */\n\tif (pw != NULL && strcmp(user, pw->pw_name) != 0) {\n\t\tlogit(\"Login name %.100s does not match stored username %.100s\",\n\t\t    user, pw->pw_name);\n\t\tpw = NULL;\n\t}\n#endif\n\tif (pw == NULL) {\n\t\tlogit(\"Invalid user %.100s from %.100s port %d\",\n\t\t    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#ifdef CUSTOM_FAILED_LOGIN\n\t\trecord_failed_login(user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(SSH_INVALID_USER);\n#endif /* SSH_AUDIT_EVENTS */\n\t\treturn (NULL);\n\t}\n\tif (!allowed_user(pw))\n\t\treturn (NULL);\n#ifdef HAVE_LOGIN_CAP\n\tif ((lc = login_getclass(pw->pw_class)) == NULL) {\n\t\tdebug(\"unable to get login class: %s\", user);\n\t\treturn (NULL);\n\t}\n#ifdef BSD_AUTH\n\tif ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||\n\t    auth_approval(as, lc, pw->pw_name, \"ssh\") <= 0) {\n\t\tdebug(\"Approval failure for %s\", user);\n\t\tpw = NULL;\n\t}\n\tif (as != NULL)\n\t\tauth_close(as);\n#endif\n#endif\n\tif (pw != NULL)\n\t\treturn (pwcopy(pw));\n\treturn (NULL);\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstruct passwd *\ngetpwnamallow(const char *user)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n#ifdef HAVE_LOGIN_CAP\n\textern login_cap_t *lc;\n#ifdef BSD_AUTH\n\tauth_session_t *as;\n#endif\n#endif\n\tstruct passwd *pw;\n\tstruct connection_info *ci = get_connection_info(1, options.use_dns);\n\n\tci->user = user;\n\tparse_server_match_config(&options, ci);\n\tlog_change_level(options.log_level);\n\tprocess_permitopen(ssh, &options);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_setauthdb(user);\n#endif\n\n\tpw = getpwnam(user);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_restoreauthdb();\n#endif\n#ifdef HAVE_CYGWIN\n\t/*\n\t * Windows usernames are case-insensitive.  To avoid later problems\n\t * when trying to match the username, the user is only allowed to\n\t * login if the username is given in the same case as stored in the\n\t * user database.\n\t */\n\tif (pw != NULL && strcmp(user, pw->pw_name) != 0) {\n\t\tlogit(\"Login name %.100s does not match stored username %.100s\",\n\t\t    user, pw->pw_name);\n\t\tpw = NULL;\n\t}\n#endif\n\tif (pw == NULL) {\n\t\tlogit(\"Invalid user %.100s from %.100s port %d\",\n\t\t    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#ifdef CUSTOM_FAILED_LOGIN\n\t\trecord_failed_login(user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(SSH_INVALID_USER);\n#endif /* SSH_AUDIT_EVENTS */\n\t\treturn (NULL);\n\t}\n\tif (!allowed_user(pw))\n\t\treturn (NULL);\n#ifdef HAVE_LOGIN_CAP\n\tif ((lc = login_getclass(pw->pw_class)) == NULL) {\n\t\tdebug(\"unable to get login class: %s\", user);\n\t\treturn (NULL);\n\t}\n#ifdef BSD_AUTH\n\tif ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||\n\t    auth_approval(as, lc, pw->pw_name, \"ssh\") <= 0) {\n\t\tdebug(\"Approval failure for %s\", user);\n\t\tpw = NULL;\n\t}\n\tif (as != NULL)\n\t\tauth_close(as);\n#endif\n#endif\n\tif (pw != NULL)\n\t\treturn (pwcopy(pw));\n\treturn (NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\nuser_key_command_allowed2(struct ssh *ssh, struct passwd *user_pw,\n    struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tstruct passwd *runas_pw = NULL;\n\tFILE *f = NULL;\n\tint r, ok, found_key = 0;\n\tint i, uid_swapped = 0, ac = 0;\n\tpid_t pid;\n\tchar *username = NULL, *key_fp = NULL, *keytext = NULL;\n\tchar uidstr[32], *tmp, *command = NULL, **av = NULL;\n\tvoid (*osigchld)(int);\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\tif (options.authorized_keys_command == NULL)\n\t\treturn 0;\n\tif (options.authorized_keys_command_user == NULL) {\n\t\terror(\"No user for AuthorizedKeysCommand specified, skipping\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * NB. all returns later this function should go via \"out\" to\n\t * ensure the original SIGCHLD handler is restored properly.\n\t */\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\n\t/* Prepare and verify the user for the command */\n\tusername = percent_expand(options.authorized_keys_command_user,\n\t    \"u\", user_pw->pw_name, (char *)NULL);\n\trunas_pw = getpwnam(username);\n\tif (runas_pw == NULL) {\n\t\terror(\"AuthorizedKeysCommandUser \\\"%s\\\" not found: %s\",\n\t\t    username, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* Prepare AuthorizedKeysCommand */\n\tif ((key_fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(key, &keytext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\t/* Turn the command into an argument vector */\n\tif (argv_split(options.authorized_keys_command, &ac, &av) != 0) {\n\t\terror(\"AuthorizedKeysCommand \\\"%s\\\" contains invalid quotes\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"AuthorizedKeysCommand \\\"%s\\\" yielded no arguments\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)user_pw->pw_uid);\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_expand(av[i],\n\t\t    \"U\", uidstr,\n\t\t    \"u\", user_pw->pw_name,\n\t\t    \"h\", user_pw->pw_dir,\n\t\t    \"t\", sshkey_ssh_name(key),\n\t\t    \"f\", key_fp,\n\t\t    \"k\", keytext,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal(\"%s: percent_expand failed\", __func__);\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t/* Prepare a printable command for logs, etc. */\n\tcommand = argv_assemble(ac, av);\n\n\t/*\n\t * If AuthorizedKeysCommand was run without arguments\n\t * then fall back to the old behaviour of passing the\n\t * target username as a single argument.\n\t */\n\tif (ac == 1) {\n\t\tav = xreallocarray(av, ac + 2, sizeof(*av));\n\t\tav[1] = xstrdup(user_pw->pw_name);\n\t\tav[2] = NULL;\n\t\t/* Fix up command too, since it is used in log messages */\n\t\tfree(command);\n\t\txasprintf(&command, \"%s %s\", av[0], av[1]);\n\t}\n\n\tif ((pid = subprocess(\"AuthorizedKeysCommand\", runas_pw, command,\n\t    ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD)) == 0)\n\t\tgoto out;\n\n\tuid_swapped = 1;\n\ttemporarily_use_uid(runas_pw);\n\n\tok = check_authkeys_file(ssh, user_pw, f,\n\t    options.authorized_keys_command, key, authoptsp);\n\n\tfclose(f);\n\tf = NULL;\n\n\tif (exited_cleanly(pid, \"AuthorizedKeysCommand\", command, 0) != 0)\n\t\tgoto out;\n\n\t/* Read completed successfully */\n\tfound_key = ok;\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tsignal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tif (uid_swapped)\n\t\trestore_uid();\n\tfree(command);\n\tfree(username);\n\tfree(key_fp);\n\tfree(keytext);\n\treturn found_key;\n}"
  },
  {
    "function_name": "user_key_allowed2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "838-860",
    "snippet": "static int\nuser_key_allowed2(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    char *file, struct sshauthopt **authoptsp)\n{\n\tFILE *f;\n\tint found_key = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\t/* Temporarily use the user's uid. */\n\ttemporarily_use_uid(pw);\n\n\tdebug(\"trying public key file %s\", file);\n\tif ((f = auth_openkeyfile(file, pw, options.strict_modes)) != NULL) {\n\t\tfound_key = check_authkeys_file(ssh, pw, f, file,\n\t\t    key, authoptsp);\n\t\tfclose(f);\n\t}\n\n\trestore_uid();\n\treturn found_key;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "restore_uid",
          "args": [],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "restore_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "141-172",
          "snippet": "void\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_authkeys_file",
          "args": [
            "ssh",
            "pw",
            "f",
            "file",
            "key",
            "authoptsp"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "check_authkeys_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "701-730",
          "snippet": "static int\ncheck_authkeys_file(struct ssh *ssh, struct passwd *pw, FILE *f,\n    char *file, struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tchar *cp, *line = NULL, loc[256];\n\tsize_t linesize = 0;\n\tint found_key = 0;\n\tu_long linenum = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire file */\n\t\tif (found_key)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace, empty and comment lines. */\n\t\tcp = line;\n\t\tskip_space(&cp);\n\t\tif (!*cp || *cp == '\\n' || *cp == '#')\n\t\t\tcontinue;\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_authkey_line(ssh, pw, key, cp, loc, authoptsp) == 0)\n\t\t\tfound_key = 1;\n\t}\n\tfree(line);\n\treturn found_key;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncheck_authkeys_file(struct ssh *ssh, struct passwd *pw, FILE *f,\n    char *file, struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tchar *cp, *line = NULL, loc[256];\n\tsize_t linesize = 0;\n\tint found_key = 0;\n\tu_long linenum = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire file */\n\t\tif (found_key)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace, empty and comment lines. */\n\t\tcp = line;\n\t\tskip_space(&cp);\n\t\tif (!*cp || *cp == '\\n' || *cp == '#')\n\t\t\tcontinue;\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_authkey_line(ssh, pw, key, cp, loc, authoptsp) == 0)\n\t\t\tfound_key = 1;\n\t}\n\tfree(line);\n\treturn found_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_openkeyfile",
          "args": [
            "file",
            "pw",
            "options.strict_modes"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "auth_openkeyfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "547-551",
          "snippet": "FILE *\nauth_openkeyfile(const char *file, struct passwd *pw, int strict_modes)\n{\n\treturn auth_openfile(file, pw, strict_modes, 1, \"authorized keys\");\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nFILE *\nauth_openkeyfile(const char *file, struct passwd *pw, int strict_modes)\n{\n\treturn auth_openfile(file, pw, strict_modes, 1, \"authorized keys\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"trying public key file %s\"",
            "file"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "temporarily_use_uid",
          "args": [
            "pw"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "temporarily_use_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "60-136",
          "snippet": "void\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static uid_t\tuser_groups_uid;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\nuser_key_allowed2(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    char *file, struct sshauthopt **authoptsp)\n{\n\tFILE *f;\n\tint found_key = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\t/* Temporarily use the user's uid. */\n\ttemporarily_use_uid(pw);\n\n\tdebug(\"trying public key file %s\", file);\n\tif ((f = auth_openkeyfile(file, pw, options.strict_modes)) != NULL) {\n\t\tfound_key = check_authkeys_file(ssh, pw, f, file,\n\t\t    key, authoptsp);\n\t\tfclose(f);\n\t}\n\n\trestore_uid();\n\treturn found_key;\n}"
  },
  {
    "function_name": "user_cert_trusted_ca",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "733-832",
    "snippet": "static int\nuser_cert_trusted_ca(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    struct sshauthopt **authoptsp)\n{\n\tchar *ca_fp, *principals_file = NULL;\n\tconst char *reason;\n\tstruct sshauthopt *principals_opts = NULL, *cert_opts = NULL;\n\tstruct sshauthopt *final_opts = NULL;\n\tint r, ret = 0, found_principal = 0, use_authorized_principals;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (!sshkey_is_cert(key) || options.trusted_user_ca_keys == NULL)\n\t\treturn 0;\n\n\tif ((ca_fp = sshkey_fingerprint(key->cert->signature_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\n\tif ((r = sshkey_in_file(key->cert->signature_key,\n\t    options.trusted_user_ca_keys, 1, 0)) != 0) {\n\t\tdebug2(\"%s: CA %s %s is not listed in %s: %s\", __func__,\n\t\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t\t    options.trusted_user_ca_keys, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/*\n\t * If AuthorizedPrincipals is in use, then compare the certificate\n\t * principals against the names in that file rather than matching\n\t * against the username.\n\t */\n\tif ((principals_file = authorized_principals_file(pw)) != NULL) {\n\t\tif (match_principals_file(ssh, pw, principals_file,\n\t\t    key->cert, &principals_opts))\n\t\t\tfound_principal = 1;\n\t}\n\t/* Try querying command if specified */\n\tif (!found_principal && match_principals_command(ssh, pw, key,\n\t    &principals_opts))\n\t\tfound_principal = 1;\n\t/* If principals file or command is specified, then require a match */\n\tuse_authorized_principals = principals_file != NULL ||\n            options.authorized_principals_command != NULL;\n\tif (!found_principal && use_authorized_principals) {\n\t\treason = \"Certificate does not contain an authorized principal\";\n\t\tgoto fail_reason;\n\t}\n\tif (use_authorized_principals && principals_opts == NULL)\n\t\tfatal(\"%s: internal error: missing principals_opts\", __func__);\n\tif (sshkey_cert_check_authority(key, 0, 1,\n\t    use_authorized_principals ? NULL : pw->pw_name, &reason) != 0)\n\t\tgoto fail_reason;\n\n\t/* Check authority from options in key and from principals file/cmd */\n\tif ((cert_opts = sshauthopt_from_cert(key)) == NULL) {\n\t\treason = \"Invalid certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (auth_authorise_keyopts(ssh, pw, cert_opts, 0, \"cert\") != 0) {\n\t\treason = \"Refused by certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (principals_opts == NULL) {\n\t\tfinal_opts = cert_opts;\n\t\tcert_opts = NULL;\n\t} else {\n\t\tif (auth_authorise_keyopts(ssh, pw, principals_opts, 0,\n\t\t    \"principals\") != 0) {\n\t\t\treason = \"Refused by certificate principals options\";\n\t\t\tgoto fail_reason;\n\t\t}\n\t\tif ((final_opts = sshauthopt_merge(principals_opts,\n\t\t    cert_opts, &reason)) == NULL) {\n fail_reason:\n\t\t\terror(\"%s\", reason);\n\t\t\tauth_debug_add(\"%s\", reason);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Success */\n\tverbose(\"Accepted certificate ID \\\"%s\\\" (serial %llu) signed by \"\n\t    \"%s CA %s via %s\", key->cert->key_id,\n\t    (unsigned long long)key->cert->serial,\n\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t    options.trusted_user_ca_keys);\n\tif (authoptsp != NULL) {\n\t\t*authoptsp = final_opts;\n\t\tfinal_opts = NULL;\n\t}\n\tret = 1;\n out:\n\tsshauthopt_free(principals_opts);\n\tsshauthopt_free(cert_opts);\n\tsshauthopt_free(final_opts);\n\tfree(principals_file);\n\tfree(ca_fp);\n\treturn ret;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ca_fp"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_free",
          "args": [
            "final_opts"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Accepted certificate ID \\\"%s\\\" (serial %llu) signed by \"\n\t    \"%s CA %s via %s\"",
            "key->cert->key_id",
            "(unsigned long long)key->cert->serial",
            "sshkey_type(key->cert->signature_key)",
            "ca_fp",
            "options.trusted_user_ca_keys"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "key->cert->signature_key"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_debug_add",
          "args": [
            "\"%s\"",
            "reason"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "673-688",
          "snippet": "void\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s\"",
            "reason"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_merge",
          "args": [
            "principals_opts",
            "cert_opts",
            "&reason"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "572-690",
          "snippet": "struct sshauthopt *\nsshauthopt_merge(const struct sshauthopt *primary,\n    const struct sshauthopt *additional, const char **errstrp)\n{\n\tstruct sshauthopt *ret;\n\tconst char *errstr = \"internal error\";\n\tconst char *tmp;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\tgoto alloc_fail;\n\n\t/* cert_authority and cert_principals are cleared in result */\n\n\t/* Prefer access lists from primary. */\n\t/* XXX err is both set and mismatch? */\n\ttmp = primary->required_from_host_cert;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_cert;\n\tif (tmp != NULL && (ret->required_from_host_cert = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\ttmp = primary->required_from_host_keys;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_keys;\n\tif (tmp != NULL && (ret->required_from_host_keys = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\n\t/*\n\t * force_tun_device, permitopen/permitlisten and environment all\n\t * prefer the primary.\n\t */\n\tret->force_tun_device = primary->force_tun_device;\n\tif (ret->force_tun_device == -1)\n\t\tret->force_tun_device = additional->force_tun_device;\n\tif (primary->nenv > 0) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    primary->env, primary->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->nenv) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    additional->env, additional->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\tif (primary->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    primary->permitopen, primary->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    additional->permitopen, additional->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\tif (primary->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    primary->permitlisten, primary->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    additional->permitlisten, additional->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\t/* Flags are logical-AND (i.e. must be set in both for permission) */\n#define OPTFLAG(x) ret->x = (primary->x == 1) && (additional->x == 1)\n\tOPTFLAG(permit_port_forwarding_flag);\n\tOPTFLAG(permit_agent_forwarding_flag);\n\tOPTFLAG(permit_x11_forwarding_flag);\n\tOPTFLAG(permit_pty_flag);\n\tOPTFLAG(permit_user_rc);\n#undef OPTFLAG\n\n\t/* Earliest expiry time should win */\n\tif (primary->valid_before != 0)\n\t\tret->valid_before = primary->valid_before;\n\tif (additional->valid_before != 0 &&\n\t    additional->valid_before < ret->valid_before)\n\t\tret->valid_before = additional->valid_before;\n\n\t/*\n\t * When both multiple forced-command are specified, only\n\t * proceed if they are identical, otherwise fail.\n\t */\n\tif (primary->force_command != NULL &&\n\t    additional->force_command != NULL) {\n\t\tif (strcmp(primary->force_command,\n\t\t    additional->force_command) == 0) {\n\t\t\t/* ok */\n\t\t\tret->force_command = strdup(primary->force_command);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t} else {\n\t\t\terrstr = \"forced command options do not match\";\n\t\t\tgoto fail;\n\t\t}\n\t} else if (primary->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    primary->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    additional->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t}\n\t/* success */\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\n alloc_fail:\n\terrstr = \"memory allocation failed\";\n fail:\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\tsshauthopt_free(ret);\n\treturn NULL;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_merge(const struct sshauthopt *primary,\n    const struct sshauthopt *additional, const char **errstrp)\n{\n\tstruct sshauthopt *ret;\n\tconst char *errstr = \"internal error\";\n\tconst char *tmp;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\tgoto alloc_fail;\n\n\t/* cert_authority and cert_principals are cleared in result */\n\n\t/* Prefer access lists from primary. */\n\t/* XXX err is both set and mismatch? */\n\ttmp = primary->required_from_host_cert;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_cert;\n\tif (tmp != NULL && (ret->required_from_host_cert = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\ttmp = primary->required_from_host_keys;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_keys;\n\tif (tmp != NULL && (ret->required_from_host_keys = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\n\t/*\n\t * force_tun_device, permitopen/permitlisten and environment all\n\t * prefer the primary.\n\t */\n\tret->force_tun_device = primary->force_tun_device;\n\tif (ret->force_tun_device == -1)\n\t\tret->force_tun_device = additional->force_tun_device;\n\tif (primary->nenv > 0) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    primary->env, primary->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->nenv) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    additional->env, additional->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\tif (primary->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    primary->permitopen, primary->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    additional->permitopen, additional->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\tif (primary->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    primary->permitlisten, primary->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    additional->permitlisten, additional->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\t/* Flags are logical-AND (i.e. must be set in both for permission) */\n#define OPTFLAG(x) ret->x = (primary->x == 1) && (additional->x == 1)\n\tOPTFLAG(permit_port_forwarding_flag);\n\tOPTFLAG(permit_agent_forwarding_flag);\n\tOPTFLAG(permit_x11_forwarding_flag);\n\tOPTFLAG(permit_pty_flag);\n\tOPTFLAG(permit_user_rc);\n#undef OPTFLAG\n\n\t/* Earliest expiry time should win */\n\tif (primary->valid_before != 0)\n\t\tret->valid_before = primary->valid_before;\n\tif (additional->valid_before != 0 &&\n\t    additional->valid_before < ret->valid_before)\n\t\tret->valid_before = additional->valid_before;\n\n\t/*\n\t * When both multiple forced-command are specified, only\n\t * proceed if they are identical, otherwise fail.\n\t */\n\tif (primary->force_command != NULL &&\n\t    additional->force_command != NULL) {\n\t\tif (strcmp(primary->force_command,\n\t\t    additional->force_command) == 0) {\n\t\t\t/* ok */\n\t\t\tret->force_command = strdup(primary->force_command);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t} else {\n\t\t\terrstr = \"forced command options do not match\";\n\t\t\tgoto fail;\n\t\t}\n\t} else if (primary->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    primary->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    additional->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t}\n\t/* success */\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\n alloc_fail:\n\terrstr = \"memory allocation failed\";\n fail:\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\tsshauthopt_free(ret);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_authorise_keyopts",
          "args": [
            "ssh",
            "pw",
            "principals_opts",
            "0",
            "\"principals\""
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "auth_authorise_keyopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "1109-1202",
          "snippet": "int\nauth_authorise_keyopts(struct ssh *ssh, struct passwd *pw,\n    struct sshauthopt *opts, int allow_cert_authority, const char *loc)\n{\n\tconst char *remote_ip = ssh_remote_ipaddr(ssh);\n\tconst char *remote_host = auth_get_canonical_hostname(ssh,\n\t    options.use_dns);\n\ttime_t now = time(NULL);\n\tchar buf[64];\n\n\t/*\n\t * Check keys/principals file expiry time.\n\t * NB. validity interval in certificate is handled elsewhere.\n\t */\n\tif (opts->valid_before && now > 0 &&\n\t    opts->valid_before < (uint64_t)now) {\n\t\tformat_absolute_time(opts->valid_before, buf, sizeof(buf));\n\t\tdebug(\"%s: entry expired at %s\", loc, buf);\n\t\tauth_debug_add(\"%s: entry expired at %s\", loc, buf);\n\t\treturn -1;\n\t}\n\t/* Consistency checks */\n\tif (opts->cert_principals != NULL && !opts->cert_authority) {\n\t\tdebug(\"%s: principals on non-CA key\", loc);\n\t\tauth_debug_add(\"%s: principals on non-CA key\", loc);\n\t\t/* deny access */\n\t\treturn -1;\n\t}\n\t/* cert-authority flag isn't valid in authorized_principals files */\n\tif (!allow_cert_authority && opts->cert_authority) {\n\t\tdebug(\"%s: cert-authority flag invalid here\", loc);\n\t\tauth_debug_add(\"%s: cert-authority flag invalid here\", loc);\n\t\t/* deny access */\n\t\treturn -1;\n\t}\n\n\t/* Perform from= checks */\n\tif (opts->required_from_host_keys != NULL) {\n\t\tswitch (match_host_and_ip(remote_host, remote_ip,\n\t\t    opts->required_from_host_keys )) {\n\t\tcase 1:\n\t\t\t/* Host name matches. */\n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\tdebug(\"%s: invalid from criteria\", loc);\n\t\t\tauth_debug_add(\"%s: invalid from criteria\", loc);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 0:\n\t\t\tlogit(\"%s: Authentication tried for %.100s with \"\n\t\t\t    \"correct key but not from a permitted \"\n\t\t\t    \"host (host=%.200s, ip=%.200s, required=%.200s).\",\n\t\t\t    loc, pw->pw_name, remote_host, remote_ip,\n\t\t\t    opts->required_from_host_keys);\n\t\t\tauth_debug_add(\"%s: Your host '%.200s' is not \"\n\t\t\t    \"permitted to use this key for login.\",\n\t\t\t    loc, remote_host);\n\t\t\t/* deny access */\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* Check source-address restriction from certificate */\n\tif (opts->required_from_host_cert != NULL) {\n\t\tswitch (addr_match_cidr_list(remote_ip,\n\t\t    opts->required_from_host_cert)) {\n\t\tcase 1:\n\t\t\t/* accepted */\n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\t/* invalid */\n\t\t\terror(\"%s: Certificate source-address invalid\",\n\t\t\t    loc);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 0:\n\t\t\tlogit(\"%s: Authentication tried for %.100s with valid \"\n\t\t\t    \"certificate but not from a permitted source \"\n\t\t\t    \"address (%.200s).\", loc, pw->pw_name, remote_ip);\n\t\t\tauth_debug_add(\"%s: Your address '%.200s' is not \"\n\t\t\t    \"permitted to use this certificate for login.\",\n\t\t\t    loc, remote_ip);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/*\n\t *\n\t * XXX this is spammy. We should report remotely only for keys\n\t *     that are successful in actual auth attempts, and not PK_OK\n\t *     tests.\n\t */\n\tauth_log_authopts(loc, opts, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nint\nauth_authorise_keyopts(struct ssh *ssh, struct passwd *pw,\n    struct sshauthopt *opts, int allow_cert_authority, const char *loc)\n{\n\tconst char *remote_ip = ssh_remote_ipaddr(ssh);\n\tconst char *remote_host = auth_get_canonical_hostname(ssh,\n\t    options.use_dns);\n\ttime_t now = time(NULL);\n\tchar buf[64];\n\n\t/*\n\t * Check keys/principals file expiry time.\n\t * NB. validity interval in certificate is handled elsewhere.\n\t */\n\tif (opts->valid_before && now > 0 &&\n\t    opts->valid_before < (uint64_t)now) {\n\t\tformat_absolute_time(opts->valid_before, buf, sizeof(buf));\n\t\tdebug(\"%s: entry expired at %s\", loc, buf);\n\t\tauth_debug_add(\"%s: entry expired at %s\", loc, buf);\n\t\treturn -1;\n\t}\n\t/* Consistency checks */\n\tif (opts->cert_principals != NULL && !opts->cert_authority) {\n\t\tdebug(\"%s: principals on non-CA key\", loc);\n\t\tauth_debug_add(\"%s: principals on non-CA key\", loc);\n\t\t/* deny access */\n\t\treturn -1;\n\t}\n\t/* cert-authority flag isn't valid in authorized_principals files */\n\tif (!allow_cert_authority && opts->cert_authority) {\n\t\tdebug(\"%s: cert-authority flag invalid here\", loc);\n\t\tauth_debug_add(\"%s: cert-authority flag invalid here\", loc);\n\t\t/* deny access */\n\t\treturn -1;\n\t}\n\n\t/* Perform from= checks */\n\tif (opts->required_from_host_keys != NULL) {\n\t\tswitch (match_host_and_ip(remote_host, remote_ip,\n\t\t    opts->required_from_host_keys )) {\n\t\tcase 1:\n\t\t\t/* Host name matches. */\n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\tdebug(\"%s: invalid from criteria\", loc);\n\t\t\tauth_debug_add(\"%s: invalid from criteria\", loc);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 0:\n\t\t\tlogit(\"%s: Authentication tried for %.100s with \"\n\t\t\t    \"correct key but not from a permitted \"\n\t\t\t    \"host (host=%.200s, ip=%.200s, required=%.200s).\",\n\t\t\t    loc, pw->pw_name, remote_host, remote_ip,\n\t\t\t    opts->required_from_host_keys);\n\t\t\tauth_debug_add(\"%s: Your host '%.200s' is not \"\n\t\t\t    \"permitted to use this key for login.\",\n\t\t\t    loc, remote_host);\n\t\t\t/* deny access */\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* Check source-address restriction from certificate */\n\tif (opts->required_from_host_cert != NULL) {\n\t\tswitch (addr_match_cidr_list(remote_ip,\n\t\t    opts->required_from_host_cert)) {\n\t\tcase 1:\n\t\t\t/* accepted */\n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\t/* invalid */\n\t\t\terror(\"%s: Certificate source-address invalid\",\n\t\t\t    loc);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 0:\n\t\t\tlogit(\"%s: Authentication tried for %.100s with valid \"\n\t\t\t    \"certificate but not from a permitted source \"\n\t\t\t    \"address (%.200s).\", loc, pw->pw_name, remote_ip);\n\t\t\tauth_debug_add(\"%s: Your address '%.200s' is not \"\n\t\t\t    \"permitted to use this certificate for login.\",\n\t\t\t    loc, remote_ip);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/*\n\t *\n\t * XXX this is spammy. We should report remotely only for keys\n\t *     that are successful in actual auth attempts, and not PK_OK\n\t *     tests.\n\t */\n\tauth_log_authopts(loc, opts, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_from_cert",
          "args": [
            "key"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_from_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "541-566",
          "snippet": "struct sshauthopt *\nsshauthopt_from_cert(struct sshkey *k)\n{\n\tstruct sshauthopt *ret;\n\n\tif (k == NULL || !sshkey_type_is_cert(k->type) || k->cert == NULL ||\n\t    k->cert->type != SSH2_CERT_TYPE_USER)\n\t\treturn NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Handle options and critical extensions separately */\n\tif (cert_option_list(ret, k->cert->critical,\n\t    OPTIONS_CRITICAL, 1) == -1) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\tif (cert_option_list(ret, k->cert->extensions,\n\t    OPTIONS_EXTENSIONS, 0) == -1) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\t/* success */\n\treturn ret;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define OPTIONS_EXTENSIONS\t2",
            "#define OPTIONS_CRITICAL\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define OPTIONS_EXTENSIONS\t2\n#define OPTIONS_CRITICAL\t1\n\nstruct sshauthopt *\nsshauthopt_from_cert(struct sshkey *k)\n{\n\tstruct sshauthopt *ret;\n\n\tif (k == NULL || !sshkey_type_is_cert(k->type) || k->cert == NULL ||\n\t    k->cert->type != SSH2_CERT_TYPE_USER)\n\t\treturn NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Handle options and critical extensions separately */\n\tif (cert_option_list(ret, k->cert->critical,\n\t    OPTIONS_CRITICAL, 1) == -1) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\tif (cert_option_list(ret, k->cert->extensions,\n\t    OPTIONS_EXTENSIONS, 0) == -1) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\t/* success */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_cert_check_authority",
          "args": [
            "key",
            "0",
            "1",
            "use_authorized_principals ? NULL : pw->pw_name",
            "&reason"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_cert_check_authority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2673-2728",
          "snippet": "int\nsshkey_cert_check_authority(const struct sshkey *k,\n    int want_host, int require_principal,\n    const char *name, const char **reason)\n{\n\tu_int i, principal_matches;\n\ttime_t now = time(NULL);\n\n\tif (reason != NULL)\n\t\t*reason = NULL;\n\n\tif (want_host) {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_HOST) {\n\t\t\t*reason = \"Certificate invalid: not a host certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_USER) {\n\t\t\t*reason = \"Certificate invalid: not a user certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\tif (now < 0) {\n\t\t/* yikes - system clock before epoch! */\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now < k->cert->valid_after) {\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now >= k->cert->valid_before) {\n\t\t*reason = \"Certificate invalid: expired\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif (k->cert->nprincipals == 0) {\n\t\tif (require_principal) {\n\t\t\t*reason = \"Certificate lacks principal list\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else if (name != NULL) {\n\t\tprincipal_matches = 0;\n\t\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\t\tif (strcmp(name, k->cert->principals[i]) == 0) {\n\t\t\t\tprincipal_matches = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!principal_matches) {\n\t\t\t*reason = \"Certificate invalid: name is not a listed \"\n\t\t\t    \"principal\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_cert_check_authority(const struct sshkey *k,\n    int want_host, int require_principal,\n    const char *name, const char **reason)\n{\n\tu_int i, principal_matches;\n\ttime_t now = time(NULL);\n\n\tif (reason != NULL)\n\t\t*reason = NULL;\n\n\tif (want_host) {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_HOST) {\n\t\t\t*reason = \"Certificate invalid: not a host certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_USER) {\n\t\t\t*reason = \"Certificate invalid: not a user certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\tif (now < 0) {\n\t\t/* yikes - system clock before epoch! */\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now < k->cert->valid_after) {\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now >= k->cert->valid_before) {\n\t\t*reason = \"Certificate invalid: expired\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif (k->cert->nprincipals == 0) {\n\t\tif (require_principal) {\n\t\t\t*reason = \"Certificate lacks principal list\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else if (name != NULL) {\n\t\tprincipal_matches = 0;\n\t\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\t\tif (strcmp(name, k->cert->principals[i]) == 0) {\n\t\t\t\tprincipal_matches = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!principal_matches) {\n\t\t\t*reason = \"Certificate invalid: name is not a listed \"\n\t\t\t    \"principal\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: internal error: missing principals_opts\"",
            "__func__"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_principals_command",
          "args": [
            "ssh",
            "pw",
            "key",
            "&principals_opts"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "match_principals_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "393-523",
          "snippet": "static int\nmatch_principals_command(struct ssh *ssh, struct passwd *user_pw,\n    const struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tstruct passwd *runas_pw = NULL;\n\tconst struct sshkey_cert *cert = key->cert;\n\tFILE *f = NULL;\n\tint r, ok, found_principal = 0;\n\tint i, ac = 0, uid_swapped = 0;\n\tpid_t pid;\n\tchar *tmp, *username = NULL, *command = NULL, **av = NULL;\n\tchar *ca_fp = NULL, *key_fp = NULL, *catext = NULL, *keytext = NULL;\n\tchar serial_s[16], uidstr[32];\n\tvoid (*osigchld)(int);\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\tif (options.authorized_principals_command == NULL)\n\t\treturn 0;\n\tif (options.authorized_principals_command_user == NULL) {\n\t\terror(\"No user for AuthorizedPrincipalsCommand specified, \"\n\t\t    \"skipping\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * NB. all returns later this function should go via \"out\" to\n\t * ensure the original SIGCHLD handler is restored properly.\n\t */\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\n\t/* Prepare and verify the user for the command */\n\tusername = percent_expand(options.authorized_principals_command_user,\n\t    \"u\", user_pw->pw_name, (char *)NULL);\n\trunas_pw = getpwnam(username);\n\tif (runas_pw == NULL) {\n\t\terror(\"AuthorizedPrincipalsCommandUser \\\"%s\\\" not found: %s\",\n\t\t    username, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* Turn the command into an argument vector */\n\tif (argv_split(options.authorized_principals_command, &ac, &av) != 0) {\n\t\terror(\"AuthorizedPrincipalsCommand \\\"%s\\\" contains \"\n\t\t    \"invalid quotes\", command);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"AuthorizedPrincipalsCommand \\\"%s\\\" yielded no arguments\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tif ((ca_fp = sshkey_fingerprint(cert->signature_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((key_fp = sshkey_fingerprint(key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(cert->signature_key, &catext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(key, &keytext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tsnprintf(serial_s, sizeof(serial_s), \"%llu\",\n\t    (unsigned long long)cert->serial);\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)user_pw->pw_uid);\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_expand(av[i],\n\t\t    \"U\", uidstr,\n\t\t    \"u\", user_pw->pw_name,\n\t\t    \"h\", user_pw->pw_dir,\n\t\t    \"t\", sshkey_ssh_name(key),\n\t\t    \"T\", sshkey_ssh_name(cert->signature_key),\n\t\t    \"f\", key_fp,\n\t\t    \"F\", ca_fp,\n\t\t    \"k\", keytext,\n\t\t    \"K\", catext,\n\t\t    \"i\", cert->key_id,\n\t\t    \"s\", serial_s,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal(\"%s: percent_expand failed\", __func__);\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t/* Prepare a printable command for logs, etc. */\n\tcommand = argv_assemble(ac, av);\n\n\tif ((pid = subprocess(\"AuthorizedPrincipalsCommand\", runas_pw, command,\n\t    ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD)) == 0)\n\t\tgoto out;\n\n\tuid_swapped = 1;\n\ttemporarily_use_uid(runas_pw);\n\n\tok = process_principals(ssh, f, \"(command)\", cert, authoptsp);\n\n\tfclose(f);\n\tf = NULL;\n\n\tif (exited_cleanly(pid, \"AuthorizedPrincipalsCommand\", command, 0) != 0)\n\t\tgoto out;\n\n\t/* Read completed successfully */\n\tfound_principal = ok;\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tsignal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tif (uid_swapped)\n\t\trestore_uid();\n\tfree(command);\n\tfree(username);\n\tfree(ca_fp);\n\tfree(key_fp);\n\tfree(catext);\n\tfree(keytext);\n\treturn found_principal;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\nmatch_principals_command(struct ssh *ssh, struct passwd *user_pw,\n    const struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tstruct passwd *runas_pw = NULL;\n\tconst struct sshkey_cert *cert = key->cert;\n\tFILE *f = NULL;\n\tint r, ok, found_principal = 0;\n\tint i, ac = 0, uid_swapped = 0;\n\tpid_t pid;\n\tchar *tmp, *username = NULL, *command = NULL, **av = NULL;\n\tchar *ca_fp = NULL, *key_fp = NULL, *catext = NULL, *keytext = NULL;\n\tchar serial_s[16], uidstr[32];\n\tvoid (*osigchld)(int);\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\tif (options.authorized_principals_command == NULL)\n\t\treturn 0;\n\tif (options.authorized_principals_command_user == NULL) {\n\t\terror(\"No user for AuthorizedPrincipalsCommand specified, \"\n\t\t    \"skipping\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * NB. all returns later this function should go via \"out\" to\n\t * ensure the original SIGCHLD handler is restored properly.\n\t */\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\n\t/* Prepare and verify the user for the command */\n\tusername = percent_expand(options.authorized_principals_command_user,\n\t    \"u\", user_pw->pw_name, (char *)NULL);\n\trunas_pw = getpwnam(username);\n\tif (runas_pw == NULL) {\n\t\terror(\"AuthorizedPrincipalsCommandUser \\\"%s\\\" not found: %s\",\n\t\t    username, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* Turn the command into an argument vector */\n\tif (argv_split(options.authorized_principals_command, &ac, &av) != 0) {\n\t\terror(\"AuthorizedPrincipalsCommand \\\"%s\\\" contains \"\n\t\t    \"invalid quotes\", command);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"AuthorizedPrincipalsCommand \\\"%s\\\" yielded no arguments\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tif ((ca_fp = sshkey_fingerprint(cert->signature_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((key_fp = sshkey_fingerprint(key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(cert->signature_key, &catext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(key, &keytext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tsnprintf(serial_s, sizeof(serial_s), \"%llu\",\n\t    (unsigned long long)cert->serial);\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)user_pw->pw_uid);\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_expand(av[i],\n\t\t    \"U\", uidstr,\n\t\t    \"u\", user_pw->pw_name,\n\t\t    \"h\", user_pw->pw_dir,\n\t\t    \"t\", sshkey_ssh_name(key),\n\t\t    \"T\", sshkey_ssh_name(cert->signature_key),\n\t\t    \"f\", key_fp,\n\t\t    \"F\", ca_fp,\n\t\t    \"k\", keytext,\n\t\t    \"K\", catext,\n\t\t    \"i\", cert->key_id,\n\t\t    \"s\", serial_s,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal(\"%s: percent_expand failed\", __func__);\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t/* Prepare a printable command for logs, etc. */\n\tcommand = argv_assemble(ac, av);\n\n\tif ((pid = subprocess(\"AuthorizedPrincipalsCommand\", runas_pw, command,\n\t    ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD)) == 0)\n\t\tgoto out;\n\n\tuid_swapped = 1;\n\ttemporarily_use_uid(runas_pw);\n\n\tok = process_principals(ssh, f, \"(command)\", cert, authoptsp);\n\n\tfclose(f);\n\tf = NULL;\n\n\tif (exited_cleanly(pid, \"AuthorizedPrincipalsCommand\", command, 0) != 0)\n\t\tgoto out;\n\n\t/* Read completed successfully */\n\tfound_principal = ok;\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tsignal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tif (uid_swapped)\n\t\trestore_uid();\n\tfree(command);\n\tfree(username);\n\tfree(ca_fp);\n\tfree(key_fp);\n\tfree(catext);\n\tfree(keytext);\n\treturn found_principal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_principals_file",
          "args": [
            "ssh",
            "pw",
            "principals_file",
            "key->cert",
            "&principals_opts"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "match_principals_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "367-387",
          "snippet": "static int\nmatch_principals_file(struct ssh *ssh, struct passwd *pw, char *file,\n    struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tFILE *f;\n\tint success;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\ttemporarily_use_uid(pw);\n\tdebug(\"trying authorized principals file %s\", file);\n\tif ((f = auth_openprincipals(file, pw, options.strict_modes)) == NULL) {\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\tsuccess = process_principals(ssh, f, file, cert, authoptsp);\n\tfclose(f);\n\trestore_uid();\n\treturn success;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\nmatch_principals_file(struct ssh *ssh, struct passwd *pw, char *file,\n    struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tFILE *f;\n\tint success;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\ttemporarily_use_uid(pw);\n\tdebug(\"trying authorized principals file %s\", file);\n\tif ((f = auth_openprincipals(file, pw, options.strict_modes)) == NULL) {\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\tsuccess = process_principals(ssh, f, file, cert, authoptsp);\n\tfclose(f);\n\trestore_uid();\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "authorized_principals_file",
          "args": [
            "pw"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "authorized_principals_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "450-456",
          "snippet": "char *\nauthorized_principals_file(struct passwd *pw)\n{\n\tif (options.authorized_principals_file == NULL)\n\t\treturn NULL;\n\treturn expand_authorized_keys(options.authorized_principals_file, pw);\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nchar *\nauthorized_principals_file(struct passwd *pw)\n{\n\tif (options.authorized_principals_file == NULL)\n\t\treturn NULL;\n\treturn expand_authorized_keys(options.authorized_principals_file, pw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: CA %s %s is not listed in %s: %s\"",
            "__func__",
            "sshkey_type(key->cert->signature_key)",
            "ca_fp",
            "options.trusted_user_ca_keys",
            "ssh_err(r)"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_in_file",
          "args": [
            "key->cert->signature_key",
            "options.trusted_user_ca_keys",
            "1",
            "0"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_in_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "445-503",
          "snippet": "int\nsshkey_in_file(struct sshkey *key, const char *filename, int strict_type,\n    int check_ca)\n{\n\tFILE *f;\n\tchar *line = NULL, *cp;\n\tsize_t linesize = 0;\n\tint r = 0;\n\tstruct sshkey *pub = NULL;\n\n\tint (*sshkey_compare)(const struct sshkey *, const struct sshkey *) =\n\t    strict_type ?  sshkey_equal : sshkey_equal_public;\n\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tsshkey_free(pub);\n\t\tpub = NULL;\n\t\tcp = line;\n\n\t\t/* Skip leading whitespace. */\n\t\tfor (; *cp && (*cp == ' ' || *cp == '\\t'); cp++)\n\t\t\t;\n\n\t\t/* Skip comments and empty lines */\n\t\tswitch (*cp) {\n\t\tcase '#':\n\t\tcase '\\n':\n\t\tcase '\\0':\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tswitch (r = sshkey_read(pub, &cp)) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase SSH_ERR_KEY_LENGTH:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshkey_compare(key, pub) ||\n\t\t    (check_ca && sshkey_is_cert(key) &&\n\t\t    sshkey_compare(key->cert->signature_key, pub))) {\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tr = SSH_ERR_KEY_NOT_FOUND;\n out:\n\tfree(line);\n\tsshkey_free(pub);\n\tfclose(f);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_in_file(struct sshkey *key, const char *filename, int strict_type,\n    int check_ca)\n{\n\tFILE *f;\n\tchar *line = NULL, *cp;\n\tsize_t linesize = 0;\n\tint r = 0;\n\tstruct sshkey *pub = NULL;\n\n\tint (*sshkey_compare)(const struct sshkey *, const struct sshkey *) =\n\t    strict_type ?  sshkey_equal : sshkey_equal_public;\n\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tsshkey_free(pub);\n\t\tpub = NULL;\n\t\tcp = line;\n\n\t\t/* Skip leading whitespace. */\n\t\tfor (; *cp && (*cp == ' ' || *cp == '\\t'); cp++)\n\t\t\t;\n\n\t\t/* Skip comments and empty lines */\n\t\tswitch (*cp) {\n\t\tcase '#':\n\t\tcase '\\n':\n\t\tcase '\\0':\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tswitch (r = sshkey_read(pub, &cp)) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase SSH_ERR_KEY_LENGTH:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshkey_compare(key, pub) ||\n\t\t    (check_ca && sshkey_is_cert(key) &&\n\t\t    sshkey_compare(key->cert->signature_key, pub))) {\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tr = SSH_ERR_KEY_NOT_FOUND;\n out:\n\tfree(line);\n\tsshkey_free(pub);\n\tfclose(f);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "key->cert->signature_key",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\nuser_cert_trusted_ca(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    struct sshauthopt **authoptsp)\n{\n\tchar *ca_fp, *principals_file = NULL;\n\tconst char *reason;\n\tstruct sshauthopt *principals_opts = NULL, *cert_opts = NULL;\n\tstruct sshauthopt *final_opts = NULL;\n\tint r, ret = 0, found_principal = 0, use_authorized_principals;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (!sshkey_is_cert(key) || options.trusted_user_ca_keys == NULL)\n\t\treturn 0;\n\n\tif ((ca_fp = sshkey_fingerprint(key->cert->signature_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\n\tif ((r = sshkey_in_file(key->cert->signature_key,\n\t    options.trusted_user_ca_keys, 1, 0)) != 0) {\n\t\tdebug2(\"%s: CA %s %s is not listed in %s: %s\", __func__,\n\t\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t\t    options.trusted_user_ca_keys, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/*\n\t * If AuthorizedPrincipals is in use, then compare the certificate\n\t * principals against the names in that file rather than matching\n\t * against the username.\n\t */\n\tif ((principals_file = authorized_principals_file(pw)) != NULL) {\n\t\tif (match_principals_file(ssh, pw, principals_file,\n\t\t    key->cert, &principals_opts))\n\t\t\tfound_principal = 1;\n\t}\n\t/* Try querying command if specified */\n\tif (!found_principal && match_principals_command(ssh, pw, key,\n\t    &principals_opts))\n\t\tfound_principal = 1;\n\t/* If principals file or command is specified, then require a match */\n\tuse_authorized_principals = principals_file != NULL ||\n            options.authorized_principals_command != NULL;\n\tif (!found_principal && use_authorized_principals) {\n\t\treason = \"Certificate does not contain an authorized principal\";\n\t\tgoto fail_reason;\n\t}\n\tif (use_authorized_principals && principals_opts == NULL)\n\t\tfatal(\"%s: internal error: missing principals_opts\", __func__);\n\tif (sshkey_cert_check_authority(key, 0, 1,\n\t    use_authorized_principals ? NULL : pw->pw_name, &reason) != 0)\n\t\tgoto fail_reason;\n\n\t/* Check authority from options in key and from principals file/cmd */\n\tif ((cert_opts = sshauthopt_from_cert(key)) == NULL) {\n\t\treason = \"Invalid certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (auth_authorise_keyopts(ssh, pw, cert_opts, 0, \"cert\") != 0) {\n\t\treason = \"Refused by certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (principals_opts == NULL) {\n\t\tfinal_opts = cert_opts;\n\t\tcert_opts = NULL;\n\t} else {\n\t\tif (auth_authorise_keyopts(ssh, pw, principals_opts, 0,\n\t\t    \"principals\") != 0) {\n\t\t\treason = \"Refused by certificate principals options\";\n\t\t\tgoto fail_reason;\n\t\t}\n\t\tif ((final_opts = sshauthopt_merge(principals_opts,\n\t\t    cert_opts, &reason)) == NULL) {\n fail_reason:\n\t\t\terror(\"%s\", reason);\n\t\t\tauth_debug_add(\"%s\", reason);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Success */\n\tverbose(\"Accepted certificate ID \\\"%s\\\" (serial %llu) signed by \"\n\t    \"%s CA %s via %s\", key->cert->key_id,\n\t    (unsigned long long)key->cert->serial,\n\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t    options.trusted_user_ca_keys);\n\tif (authoptsp != NULL) {\n\t\t*authoptsp = final_opts;\n\t\tfinal_opts = NULL;\n\t}\n\tret = 1;\n out:\n\tsshauthopt_free(principals_opts);\n\tsshauthopt_free(cert_opts);\n\tsshauthopt_free(final_opts);\n\tfree(principals_file);\n\tfree(ca_fp);\n\treturn ret;\n}"
  },
  {
    "function_name": "check_authkeys_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "701-730",
    "snippet": "static int\ncheck_authkeys_file(struct ssh *ssh, struct passwd *pw, FILE *f,\n    char *file, struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tchar *cp, *line = NULL, loc[256];\n\tsize_t linesize = 0;\n\tint found_key = 0;\n\tu_long linenum = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire file */\n\t\tif (found_key)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace, empty and comment lines. */\n\t\tcp = line;\n\t\tskip_space(&cp);\n\t\tif (!*cp || *cp == '\\n' || *cp == '#')\n\t\t\tcontinue;\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_authkey_line(ssh, pw, key, cp, loc, authoptsp) == 0)\n\t\t\tfound_key = 1;\n\t}\n\tfree(line);\n\treturn found_key;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_authkey_line",
          "args": [
            "ssh",
            "pw",
            "key",
            "cp",
            "loc",
            "authoptsp"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "check_authkey_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "562-695",
          "snippet": "static int\ncheck_authkey_line(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    char *cp, const char *loc, struct sshauthopt **authoptsp)\n{\n\tint want_keytype = sshkey_is_cert(key) ? KEY_UNSPEC : key->type;\n\tstruct sshkey *found = NULL;\n\tstruct sshauthopt *keyopts = NULL, *certopts = NULL, *finalopts = NULL;\n\tchar *key_options = NULL, *fp = NULL;\n\tconst char *reason = NULL;\n\tint ret = -1;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif ((found = sshkey_new(want_keytype)) == NULL) {\n\t\tdebug3(\"%s: keytype %d failed\", __func__, want_keytype);\n\t\tgoto out;\n\t}\n\n\t/* XXX djm: peek at key type in line and skip if unwanted */\n\n\tif (sshkey_read(found, &cp) != 0) {\n\t\t/* no key?  check for options */\n\t\tdebug2(\"%s: check options: '%s'\", loc, cp);\n\t\tkey_options = cp;\n\t\tif (advance_past_options(&cp) != 0) {\n\t\t\treason = \"invalid key option string\";\n\t\t\tgoto fail_reason;\n\t\t}\n\t\tskip_space(&cp);\n\t\tif (sshkey_read(found, &cp) != 0) {\n\t\t\t/* still no key?  advance to next line*/\n\t\t\tdebug2(\"%s: advance: '%s'\", loc, cp);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Parse key options now; we need to know if this is a CA key */\n\tif ((keyopts = sshauthopt_parse(key_options, &reason)) == NULL) {\n\t\tdebug(\"%s: bad key options: %s\", loc, reason);\n\t\tauth_debug_add(\"%s: bad key options: %s\", loc, reason);\n\t\tgoto out;\n\t}\n\t/* Ignore keys that don't match or incorrectly marked as CAs */\n\tif (sshkey_is_cert(key)) {\n\t\t/* Certificate; check signature key against CA */\n\t\tif (!sshkey_equal(found, key->cert->signature_key) ||\n\t\t    !keyopts->cert_authority)\n\t\t\tgoto out;\n\t} else {\n\t\t/* Plain key: check it against key found in file */\n\t\tif (!sshkey_equal(found, key) || keyopts->cert_authority)\n\t\t\tgoto out;\n\t}\n\n\t/* We have a candidate key, perform authorisation checks */\n\tif ((fp = sshkey_fingerprint(found,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\tfatal(\"%s: fingerprint failed\", __func__);\n\n\tdebug(\"%s: matching %s found: %s %s\", loc,\n\t    sshkey_is_cert(key) ? \"CA\" : \"key\", sshkey_type(found), fp);\n\n\tif (auth_authorise_keyopts(ssh, pw, keyopts,\n\t    sshkey_is_cert(key), loc) != 0) {\n\t\treason = \"Refused by key options\";\n\t\tgoto fail_reason;\n\t}\n\t/* That's all we need for plain keys. */\n\tif (!sshkey_is_cert(key)) {\n\t\tverbose(\"Accepted key %s %s found at %s\",\n\t\t    sshkey_type(found), fp, loc);\n\t\tfinalopts = keyopts;\n\t\tkeyopts = NULL;\n\t\tgoto success;\n\t}\n\n\t/*\n\t * Additional authorisation for certificates.\n\t */\n\n\t/* Parse and check options present in certificate */\n\tif ((certopts = sshauthopt_from_cert(key)) == NULL) {\n\t\treason = \"Invalid certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (auth_authorise_keyopts(ssh, pw, certopts, 0, loc) != 0) {\n\t\treason = \"Refused by certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif ((finalopts = sshauthopt_merge(keyopts, certopts, &reason)) == NULL)\n\t\tgoto fail_reason;\n\n\t/*\n\t * If the user has specified a list of principals as\n\t * a key option, then prefer that list to matching\n\t * their username in the certificate principals list.\n\t */\n\tif (keyopts->cert_principals != NULL &&\n\t    !match_principals_option(keyopts->cert_principals, key->cert)) {\n\t\treason = \"Certificate does not contain an authorized principal\";\n\t\tgoto fail_reason;\n\t}\n\tif (sshkey_cert_check_authority(key, 0, 0,\n\t   keyopts->cert_principals == NULL ? pw->pw_name : NULL, &reason) != 0)\n\t\tgoto fail_reason;\n\n\tverbose(\"Accepted certificate ID \\\"%s\\\" (serial %llu) \"\n\t    \"signed by CA %s %s found at %s\",\n\t    key->cert->key_id,\n\t    (unsigned long long)key->cert->serial,\n\t    sshkey_type(found), fp, loc);\n\n success:\n\tif (finalopts == NULL)\n\t\tfatal(\"%s: internal error: missing options\", __func__);\n\tif (authoptsp != NULL) {\n\t\t*authoptsp = finalopts;\n\t\tfinalopts = NULL;\n\t}\n\t/* success */\n\tret = 0;\n\tgoto out;\n\n fail_reason:\n\terror(\"%s\", reason);\n\tauth_debug_add(\"%s\", reason);\n out:\n\tfree(fp);\n\tsshauthopt_free(keyopts);\n\tsshauthopt_free(certopts);\n\tsshauthopt_free(finalopts);\n\tsshkey_free(found);\n\treturn ret;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\ncheck_authkey_line(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    char *cp, const char *loc, struct sshauthopt **authoptsp)\n{\n\tint want_keytype = sshkey_is_cert(key) ? KEY_UNSPEC : key->type;\n\tstruct sshkey *found = NULL;\n\tstruct sshauthopt *keyopts = NULL, *certopts = NULL, *finalopts = NULL;\n\tchar *key_options = NULL, *fp = NULL;\n\tconst char *reason = NULL;\n\tint ret = -1;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif ((found = sshkey_new(want_keytype)) == NULL) {\n\t\tdebug3(\"%s: keytype %d failed\", __func__, want_keytype);\n\t\tgoto out;\n\t}\n\n\t/* XXX djm: peek at key type in line and skip if unwanted */\n\n\tif (sshkey_read(found, &cp) != 0) {\n\t\t/* no key?  check for options */\n\t\tdebug2(\"%s: check options: '%s'\", loc, cp);\n\t\tkey_options = cp;\n\t\tif (advance_past_options(&cp) != 0) {\n\t\t\treason = \"invalid key option string\";\n\t\t\tgoto fail_reason;\n\t\t}\n\t\tskip_space(&cp);\n\t\tif (sshkey_read(found, &cp) != 0) {\n\t\t\t/* still no key?  advance to next line*/\n\t\t\tdebug2(\"%s: advance: '%s'\", loc, cp);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Parse key options now; we need to know if this is a CA key */\n\tif ((keyopts = sshauthopt_parse(key_options, &reason)) == NULL) {\n\t\tdebug(\"%s: bad key options: %s\", loc, reason);\n\t\tauth_debug_add(\"%s: bad key options: %s\", loc, reason);\n\t\tgoto out;\n\t}\n\t/* Ignore keys that don't match or incorrectly marked as CAs */\n\tif (sshkey_is_cert(key)) {\n\t\t/* Certificate; check signature key against CA */\n\t\tif (!sshkey_equal(found, key->cert->signature_key) ||\n\t\t    !keyopts->cert_authority)\n\t\t\tgoto out;\n\t} else {\n\t\t/* Plain key: check it against key found in file */\n\t\tif (!sshkey_equal(found, key) || keyopts->cert_authority)\n\t\t\tgoto out;\n\t}\n\n\t/* We have a candidate key, perform authorisation checks */\n\tif ((fp = sshkey_fingerprint(found,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\tfatal(\"%s: fingerprint failed\", __func__);\n\n\tdebug(\"%s: matching %s found: %s %s\", loc,\n\t    sshkey_is_cert(key) ? \"CA\" : \"key\", sshkey_type(found), fp);\n\n\tif (auth_authorise_keyopts(ssh, pw, keyopts,\n\t    sshkey_is_cert(key), loc) != 0) {\n\t\treason = \"Refused by key options\";\n\t\tgoto fail_reason;\n\t}\n\t/* That's all we need for plain keys. */\n\tif (!sshkey_is_cert(key)) {\n\t\tverbose(\"Accepted key %s %s found at %s\",\n\t\t    sshkey_type(found), fp, loc);\n\t\tfinalopts = keyopts;\n\t\tkeyopts = NULL;\n\t\tgoto success;\n\t}\n\n\t/*\n\t * Additional authorisation for certificates.\n\t */\n\n\t/* Parse and check options present in certificate */\n\tif ((certopts = sshauthopt_from_cert(key)) == NULL) {\n\t\treason = \"Invalid certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (auth_authorise_keyopts(ssh, pw, certopts, 0, loc) != 0) {\n\t\treason = \"Refused by certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif ((finalopts = sshauthopt_merge(keyopts, certopts, &reason)) == NULL)\n\t\tgoto fail_reason;\n\n\t/*\n\t * If the user has specified a list of principals as\n\t * a key option, then prefer that list to matching\n\t * their username in the certificate principals list.\n\t */\n\tif (keyopts->cert_principals != NULL &&\n\t    !match_principals_option(keyopts->cert_principals, key->cert)) {\n\t\treason = \"Certificate does not contain an authorized principal\";\n\t\tgoto fail_reason;\n\t}\n\tif (sshkey_cert_check_authority(key, 0, 0,\n\t   keyopts->cert_principals == NULL ? pw->pw_name : NULL, &reason) != 0)\n\t\tgoto fail_reason;\n\n\tverbose(\"Accepted certificate ID \\\"%s\\\" (serial %llu) \"\n\t    \"signed by CA %s %s found at %s\",\n\t    key->cert->key_id,\n\t    (unsigned long long)key->cert->serial,\n\t    sshkey_type(found), fp, loc);\n\n success:\n\tif (finalopts == NULL)\n\t\tfatal(\"%s: internal error: missing options\", __func__);\n\tif (authoptsp != NULL) {\n\t\t*authoptsp = finalopts;\n\t\tfinalopts = NULL;\n\t}\n\t/* success */\n\tret = 0;\n\tgoto out;\n\n fail_reason:\n\terror(\"%s\", reason);\n\tauth_debug_add(\"%s\", reason);\n out:\n\tfree(fp);\n\tsshauthopt_free(keyopts);\n\tsshauthopt_free(certopts);\n\tsshauthopt_free(finalopts);\n\tsshkey_free(found);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "loc",
            "sizeof(loc)",
            "\"%.200s:%lu\"",
            "file",
            "linenum"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_space",
          "args": [
            "&cp"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "skip_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "525-533",
          "snippet": "static void\nskip_space(char **cpp)\n{\n\tchar *cp;\n\n\tfor (cp = *cpp; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\t*cpp = cp;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nskip_space(char **cpp)\n{\n\tchar *cp;\n\n\tfor (cp = *cpp; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\t*cpp = cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&linesize",
            "f"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-getline.c",
          "lines": "92-96",
          "snippet": "ssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"file.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"file.h\"\n#include \"includes.h\"\n\nssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncheck_authkeys_file(struct ssh *ssh, struct passwd *pw, FILE *f,\n    char *file, struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tchar *cp, *line = NULL, loc[256];\n\tsize_t linesize = 0;\n\tint found_key = 0;\n\tu_long linenum = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire file */\n\t\tif (found_key)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace, empty and comment lines. */\n\t\tcp = line;\n\t\tskip_space(&cp);\n\t\tif (!*cp || *cp == '\\n' || *cp == '#')\n\t\t\tcontinue;\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_authkey_line(ssh, pw, key, cp, loc, authoptsp) == 0)\n\t\t\tfound_key = 1;\n\t}\n\tfree(line);\n\treturn found_key;\n}"
  },
  {
    "function_name": "check_authkey_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "562-695",
    "snippet": "static int\ncheck_authkey_line(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    char *cp, const char *loc, struct sshauthopt **authoptsp)\n{\n\tint want_keytype = sshkey_is_cert(key) ? KEY_UNSPEC : key->type;\n\tstruct sshkey *found = NULL;\n\tstruct sshauthopt *keyopts = NULL, *certopts = NULL, *finalopts = NULL;\n\tchar *key_options = NULL, *fp = NULL;\n\tconst char *reason = NULL;\n\tint ret = -1;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif ((found = sshkey_new(want_keytype)) == NULL) {\n\t\tdebug3(\"%s: keytype %d failed\", __func__, want_keytype);\n\t\tgoto out;\n\t}\n\n\t/* XXX djm: peek at key type in line and skip if unwanted */\n\n\tif (sshkey_read(found, &cp) != 0) {\n\t\t/* no key?  check for options */\n\t\tdebug2(\"%s: check options: '%s'\", loc, cp);\n\t\tkey_options = cp;\n\t\tif (advance_past_options(&cp) != 0) {\n\t\t\treason = \"invalid key option string\";\n\t\t\tgoto fail_reason;\n\t\t}\n\t\tskip_space(&cp);\n\t\tif (sshkey_read(found, &cp) != 0) {\n\t\t\t/* still no key?  advance to next line*/\n\t\t\tdebug2(\"%s: advance: '%s'\", loc, cp);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Parse key options now; we need to know if this is a CA key */\n\tif ((keyopts = sshauthopt_parse(key_options, &reason)) == NULL) {\n\t\tdebug(\"%s: bad key options: %s\", loc, reason);\n\t\tauth_debug_add(\"%s: bad key options: %s\", loc, reason);\n\t\tgoto out;\n\t}\n\t/* Ignore keys that don't match or incorrectly marked as CAs */\n\tif (sshkey_is_cert(key)) {\n\t\t/* Certificate; check signature key against CA */\n\t\tif (!sshkey_equal(found, key->cert->signature_key) ||\n\t\t    !keyopts->cert_authority)\n\t\t\tgoto out;\n\t} else {\n\t\t/* Plain key: check it against key found in file */\n\t\tif (!sshkey_equal(found, key) || keyopts->cert_authority)\n\t\t\tgoto out;\n\t}\n\n\t/* We have a candidate key, perform authorisation checks */\n\tif ((fp = sshkey_fingerprint(found,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\tfatal(\"%s: fingerprint failed\", __func__);\n\n\tdebug(\"%s: matching %s found: %s %s\", loc,\n\t    sshkey_is_cert(key) ? \"CA\" : \"key\", sshkey_type(found), fp);\n\n\tif (auth_authorise_keyopts(ssh, pw, keyopts,\n\t    sshkey_is_cert(key), loc) != 0) {\n\t\treason = \"Refused by key options\";\n\t\tgoto fail_reason;\n\t}\n\t/* That's all we need for plain keys. */\n\tif (!sshkey_is_cert(key)) {\n\t\tverbose(\"Accepted key %s %s found at %s\",\n\t\t    sshkey_type(found), fp, loc);\n\t\tfinalopts = keyopts;\n\t\tkeyopts = NULL;\n\t\tgoto success;\n\t}\n\n\t/*\n\t * Additional authorisation for certificates.\n\t */\n\n\t/* Parse and check options present in certificate */\n\tif ((certopts = sshauthopt_from_cert(key)) == NULL) {\n\t\treason = \"Invalid certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (auth_authorise_keyopts(ssh, pw, certopts, 0, loc) != 0) {\n\t\treason = \"Refused by certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif ((finalopts = sshauthopt_merge(keyopts, certopts, &reason)) == NULL)\n\t\tgoto fail_reason;\n\n\t/*\n\t * If the user has specified a list of principals as\n\t * a key option, then prefer that list to matching\n\t * their username in the certificate principals list.\n\t */\n\tif (keyopts->cert_principals != NULL &&\n\t    !match_principals_option(keyopts->cert_principals, key->cert)) {\n\t\treason = \"Certificate does not contain an authorized principal\";\n\t\tgoto fail_reason;\n\t}\n\tif (sshkey_cert_check_authority(key, 0, 0,\n\t   keyopts->cert_principals == NULL ? pw->pw_name : NULL, &reason) != 0)\n\t\tgoto fail_reason;\n\n\tverbose(\"Accepted certificate ID \\\"%s\\\" (serial %llu) \"\n\t    \"signed by CA %s %s found at %s\",\n\t    key->cert->key_id,\n\t    (unsigned long long)key->cert->serial,\n\t    sshkey_type(found), fp, loc);\n\n success:\n\tif (finalopts == NULL)\n\t\tfatal(\"%s: internal error: missing options\", __func__);\n\tif (authoptsp != NULL) {\n\t\t*authoptsp = finalopts;\n\t\tfinalopts = NULL;\n\t}\n\t/* success */\n\tret = 0;\n\tgoto out;\n\n fail_reason:\n\terror(\"%s\", reason);\n\tauth_debug_add(\"%s\", reason);\n out:\n\tfree(fp);\n\tsshauthopt_free(keyopts);\n\tsshauthopt_free(certopts);\n\tsshauthopt_free(finalopts);\n\tsshkey_free(found);\n\treturn ret;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "found"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_free",
          "args": [
            "finalopts"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fp"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_debug_add",
          "args": [
            "\"%s\"",
            "reason"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "673-688",
          "snippet": "void\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s\"",
            "reason"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: internal error: missing options\"",
            "__func__"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Accepted certificate ID \\\"%s\\\" (serial %llu) \"\n\t    \"signed by CA %s %s found at %s\"",
            "key->cert->key_id",
            "(unsigned long long)key->cert->serial",
            "sshkey_type(found)",
            "fp",
            "loc"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "found"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_cert_check_authority",
          "args": [
            "key",
            "0",
            "0",
            "keyopts->cert_principals == NULL ? pw->pw_name : NULL",
            "&reason"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_cert_check_authority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2673-2728",
          "snippet": "int\nsshkey_cert_check_authority(const struct sshkey *k,\n    int want_host, int require_principal,\n    const char *name, const char **reason)\n{\n\tu_int i, principal_matches;\n\ttime_t now = time(NULL);\n\n\tif (reason != NULL)\n\t\t*reason = NULL;\n\n\tif (want_host) {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_HOST) {\n\t\t\t*reason = \"Certificate invalid: not a host certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_USER) {\n\t\t\t*reason = \"Certificate invalid: not a user certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\tif (now < 0) {\n\t\t/* yikes - system clock before epoch! */\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now < k->cert->valid_after) {\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now >= k->cert->valid_before) {\n\t\t*reason = \"Certificate invalid: expired\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif (k->cert->nprincipals == 0) {\n\t\tif (require_principal) {\n\t\t\t*reason = \"Certificate lacks principal list\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else if (name != NULL) {\n\t\tprincipal_matches = 0;\n\t\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\t\tif (strcmp(name, k->cert->principals[i]) == 0) {\n\t\t\t\tprincipal_matches = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!principal_matches) {\n\t\t\t*reason = \"Certificate invalid: name is not a listed \"\n\t\t\t    \"principal\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_cert_check_authority(const struct sshkey *k,\n    int want_host, int require_principal,\n    const char *name, const char **reason)\n{\n\tu_int i, principal_matches;\n\ttime_t now = time(NULL);\n\n\tif (reason != NULL)\n\t\t*reason = NULL;\n\n\tif (want_host) {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_HOST) {\n\t\t\t*reason = \"Certificate invalid: not a host certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_USER) {\n\t\t\t*reason = \"Certificate invalid: not a user certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\tif (now < 0) {\n\t\t/* yikes - system clock before epoch! */\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now < k->cert->valid_after) {\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now >= k->cert->valid_before) {\n\t\t*reason = \"Certificate invalid: expired\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif (k->cert->nprincipals == 0) {\n\t\tif (require_principal) {\n\t\t\t*reason = \"Certificate lacks principal list\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else if (name != NULL) {\n\t\tprincipal_matches = 0;\n\t\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\t\tif (strcmp(name, k->cert->principals[i]) == 0) {\n\t\t\t\tprincipal_matches = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!principal_matches) {\n\t\t\t*reason = \"Certificate invalid: name is not a listed \"\n\t\t\t    \"principal\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_principals_option",
          "args": [
            "keyopts->cert_principals",
            "key->cert"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "match_principals_option",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "255-273",
          "snippet": "static int\nmatch_principals_option(const char *principal_list, struct sshkey_cert *cert)\n{\n\tchar *result;\n\tu_int i;\n\n\t/* XXX percent_expand() sequences for authorized_principals? */\n\n\tfor (i = 0; i < cert->nprincipals; i++) {\n\t\tif ((result = match_list(cert->principals[i],\n\t\t    principal_list, NULL)) != NULL) {\n\t\t\tdebug3(\"matched principal from key options \\\"%.100s\\\"\",\n\t\t\t    result);\n\t\t\tfree(result);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\nmatch_principals_option(const char *principal_list, struct sshkey_cert *cert)\n{\n\tchar *result;\n\tu_int i;\n\n\t/* XXX percent_expand() sequences for authorized_principals? */\n\n\tfor (i = 0; i < cert->nprincipals; i++) {\n\t\tif ((result = match_list(cert->principals[i],\n\t\t    principal_list, NULL)) != NULL) {\n\t\t\tdebug3(\"matched principal from key options \\\"%.100s\\\"\",\n\t\t\t    result);\n\t\t\tfree(result);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_merge",
          "args": [
            "keyopts",
            "certopts",
            "&reason"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "572-690",
          "snippet": "struct sshauthopt *\nsshauthopt_merge(const struct sshauthopt *primary,\n    const struct sshauthopt *additional, const char **errstrp)\n{\n\tstruct sshauthopt *ret;\n\tconst char *errstr = \"internal error\";\n\tconst char *tmp;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\tgoto alloc_fail;\n\n\t/* cert_authority and cert_principals are cleared in result */\n\n\t/* Prefer access lists from primary. */\n\t/* XXX err is both set and mismatch? */\n\ttmp = primary->required_from_host_cert;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_cert;\n\tif (tmp != NULL && (ret->required_from_host_cert = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\ttmp = primary->required_from_host_keys;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_keys;\n\tif (tmp != NULL && (ret->required_from_host_keys = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\n\t/*\n\t * force_tun_device, permitopen/permitlisten and environment all\n\t * prefer the primary.\n\t */\n\tret->force_tun_device = primary->force_tun_device;\n\tif (ret->force_tun_device == -1)\n\t\tret->force_tun_device = additional->force_tun_device;\n\tif (primary->nenv > 0) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    primary->env, primary->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->nenv) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    additional->env, additional->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\tif (primary->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    primary->permitopen, primary->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    additional->permitopen, additional->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\tif (primary->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    primary->permitlisten, primary->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    additional->permitlisten, additional->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\t/* Flags are logical-AND (i.e. must be set in both for permission) */\n#define OPTFLAG(x) ret->x = (primary->x == 1) && (additional->x == 1)\n\tOPTFLAG(permit_port_forwarding_flag);\n\tOPTFLAG(permit_agent_forwarding_flag);\n\tOPTFLAG(permit_x11_forwarding_flag);\n\tOPTFLAG(permit_pty_flag);\n\tOPTFLAG(permit_user_rc);\n#undef OPTFLAG\n\n\t/* Earliest expiry time should win */\n\tif (primary->valid_before != 0)\n\t\tret->valid_before = primary->valid_before;\n\tif (additional->valid_before != 0 &&\n\t    additional->valid_before < ret->valid_before)\n\t\tret->valid_before = additional->valid_before;\n\n\t/*\n\t * When both multiple forced-command are specified, only\n\t * proceed if they are identical, otherwise fail.\n\t */\n\tif (primary->force_command != NULL &&\n\t    additional->force_command != NULL) {\n\t\tif (strcmp(primary->force_command,\n\t\t    additional->force_command) == 0) {\n\t\t\t/* ok */\n\t\t\tret->force_command = strdup(primary->force_command);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t} else {\n\t\t\terrstr = \"forced command options do not match\";\n\t\t\tgoto fail;\n\t\t}\n\t} else if (primary->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    primary->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    additional->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t}\n\t/* success */\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\n alloc_fail:\n\terrstr = \"memory allocation failed\";\n fail:\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\tsshauthopt_free(ret);\n\treturn NULL;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_merge(const struct sshauthopt *primary,\n    const struct sshauthopt *additional, const char **errstrp)\n{\n\tstruct sshauthopt *ret;\n\tconst char *errstr = \"internal error\";\n\tconst char *tmp;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\tgoto alloc_fail;\n\n\t/* cert_authority and cert_principals are cleared in result */\n\n\t/* Prefer access lists from primary. */\n\t/* XXX err is both set and mismatch? */\n\ttmp = primary->required_from_host_cert;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_cert;\n\tif (tmp != NULL && (ret->required_from_host_cert = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\ttmp = primary->required_from_host_keys;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_keys;\n\tif (tmp != NULL && (ret->required_from_host_keys = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\n\t/*\n\t * force_tun_device, permitopen/permitlisten and environment all\n\t * prefer the primary.\n\t */\n\tret->force_tun_device = primary->force_tun_device;\n\tif (ret->force_tun_device == -1)\n\t\tret->force_tun_device = additional->force_tun_device;\n\tif (primary->nenv > 0) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    primary->env, primary->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->nenv) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    additional->env, additional->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\tif (primary->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    primary->permitopen, primary->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    additional->permitopen, additional->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\tif (primary->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    primary->permitlisten, primary->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    additional->permitlisten, additional->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\t/* Flags are logical-AND (i.e. must be set in both for permission) */\n#define OPTFLAG(x) ret->x = (primary->x == 1) && (additional->x == 1)\n\tOPTFLAG(permit_port_forwarding_flag);\n\tOPTFLAG(permit_agent_forwarding_flag);\n\tOPTFLAG(permit_x11_forwarding_flag);\n\tOPTFLAG(permit_pty_flag);\n\tOPTFLAG(permit_user_rc);\n#undef OPTFLAG\n\n\t/* Earliest expiry time should win */\n\tif (primary->valid_before != 0)\n\t\tret->valid_before = primary->valid_before;\n\tif (additional->valid_before != 0 &&\n\t    additional->valid_before < ret->valid_before)\n\t\tret->valid_before = additional->valid_before;\n\n\t/*\n\t * When both multiple forced-command are specified, only\n\t * proceed if they are identical, otherwise fail.\n\t */\n\tif (primary->force_command != NULL &&\n\t    additional->force_command != NULL) {\n\t\tif (strcmp(primary->force_command,\n\t\t    additional->force_command) == 0) {\n\t\t\t/* ok */\n\t\t\tret->force_command = strdup(primary->force_command);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t} else {\n\t\t\terrstr = \"forced command options do not match\";\n\t\t\tgoto fail;\n\t\t}\n\t} else if (primary->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    primary->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    additional->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t}\n\t/* success */\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\n alloc_fail:\n\terrstr = \"memory allocation failed\";\n fail:\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\tsshauthopt_free(ret);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_authorise_keyopts",
          "args": [
            "ssh",
            "pw",
            "certopts",
            "0",
            "loc"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "auth_authorise_keyopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "1109-1202",
          "snippet": "int\nauth_authorise_keyopts(struct ssh *ssh, struct passwd *pw,\n    struct sshauthopt *opts, int allow_cert_authority, const char *loc)\n{\n\tconst char *remote_ip = ssh_remote_ipaddr(ssh);\n\tconst char *remote_host = auth_get_canonical_hostname(ssh,\n\t    options.use_dns);\n\ttime_t now = time(NULL);\n\tchar buf[64];\n\n\t/*\n\t * Check keys/principals file expiry time.\n\t * NB. validity interval in certificate is handled elsewhere.\n\t */\n\tif (opts->valid_before && now > 0 &&\n\t    opts->valid_before < (uint64_t)now) {\n\t\tformat_absolute_time(opts->valid_before, buf, sizeof(buf));\n\t\tdebug(\"%s: entry expired at %s\", loc, buf);\n\t\tauth_debug_add(\"%s: entry expired at %s\", loc, buf);\n\t\treturn -1;\n\t}\n\t/* Consistency checks */\n\tif (opts->cert_principals != NULL && !opts->cert_authority) {\n\t\tdebug(\"%s: principals on non-CA key\", loc);\n\t\tauth_debug_add(\"%s: principals on non-CA key\", loc);\n\t\t/* deny access */\n\t\treturn -1;\n\t}\n\t/* cert-authority flag isn't valid in authorized_principals files */\n\tif (!allow_cert_authority && opts->cert_authority) {\n\t\tdebug(\"%s: cert-authority flag invalid here\", loc);\n\t\tauth_debug_add(\"%s: cert-authority flag invalid here\", loc);\n\t\t/* deny access */\n\t\treturn -1;\n\t}\n\n\t/* Perform from= checks */\n\tif (opts->required_from_host_keys != NULL) {\n\t\tswitch (match_host_and_ip(remote_host, remote_ip,\n\t\t    opts->required_from_host_keys )) {\n\t\tcase 1:\n\t\t\t/* Host name matches. */\n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\tdebug(\"%s: invalid from criteria\", loc);\n\t\t\tauth_debug_add(\"%s: invalid from criteria\", loc);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 0:\n\t\t\tlogit(\"%s: Authentication tried for %.100s with \"\n\t\t\t    \"correct key but not from a permitted \"\n\t\t\t    \"host (host=%.200s, ip=%.200s, required=%.200s).\",\n\t\t\t    loc, pw->pw_name, remote_host, remote_ip,\n\t\t\t    opts->required_from_host_keys);\n\t\t\tauth_debug_add(\"%s: Your host '%.200s' is not \"\n\t\t\t    \"permitted to use this key for login.\",\n\t\t\t    loc, remote_host);\n\t\t\t/* deny access */\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* Check source-address restriction from certificate */\n\tif (opts->required_from_host_cert != NULL) {\n\t\tswitch (addr_match_cidr_list(remote_ip,\n\t\t    opts->required_from_host_cert)) {\n\t\tcase 1:\n\t\t\t/* accepted */\n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\t/* invalid */\n\t\t\terror(\"%s: Certificate source-address invalid\",\n\t\t\t    loc);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 0:\n\t\t\tlogit(\"%s: Authentication tried for %.100s with valid \"\n\t\t\t    \"certificate but not from a permitted source \"\n\t\t\t    \"address (%.200s).\", loc, pw->pw_name, remote_ip);\n\t\t\tauth_debug_add(\"%s: Your address '%.200s' is not \"\n\t\t\t    \"permitted to use this certificate for login.\",\n\t\t\t    loc, remote_ip);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/*\n\t *\n\t * XXX this is spammy. We should report remotely only for keys\n\t *     that are successful in actual auth attempts, and not PK_OK\n\t *     tests.\n\t */\n\tauth_log_authopts(loc, opts, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nint\nauth_authorise_keyopts(struct ssh *ssh, struct passwd *pw,\n    struct sshauthopt *opts, int allow_cert_authority, const char *loc)\n{\n\tconst char *remote_ip = ssh_remote_ipaddr(ssh);\n\tconst char *remote_host = auth_get_canonical_hostname(ssh,\n\t    options.use_dns);\n\ttime_t now = time(NULL);\n\tchar buf[64];\n\n\t/*\n\t * Check keys/principals file expiry time.\n\t * NB. validity interval in certificate is handled elsewhere.\n\t */\n\tif (opts->valid_before && now > 0 &&\n\t    opts->valid_before < (uint64_t)now) {\n\t\tformat_absolute_time(opts->valid_before, buf, sizeof(buf));\n\t\tdebug(\"%s: entry expired at %s\", loc, buf);\n\t\tauth_debug_add(\"%s: entry expired at %s\", loc, buf);\n\t\treturn -1;\n\t}\n\t/* Consistency checks */\n\tif (opts->cert_principals != NULL && !opts->cert_authority) {\n\t\tdebug(\"%s: principals on non-CA key\", loc);\n\t\tauth_debug_add(\"%s: principals on non-CA key\", loc);\n\t\t/* deny access */\n\t\treturn -1;\n\t}\n\t/* cert-authority flag isn't valid in authorized_principals files */\n\tif (!allow_cert_authority && opts->cert_authority) {\n\t\tdebug(\"%s: cert-authority flag invalid here\", loc);\n\t\tauth_debug_add(\"%s: cert-authority flag invalid here\", loc);\n\t\t/* deny access */\n\t\treturn -1;\n\t}\n\n\t/* Perform from= checks */\n\tif (opts->required_from_host_keys != NULL) {\n\t\tswitch (match_host_and_ip(remote_host, remote_ip,\n\t\t    opts->required_from_host_keys )) {\n\t\tcase 1:\n\t\t\t/* Host name matches. */\n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\tdebug(\"%s: invalid from criteria\", loc);\n\t\t\tauth_debug_add(\"%s: invalid from criteria\", loc);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 0:\n\t\t\tlogit(\"%s: Authentication tried for %.100s with \"\n\t\t\t    \"correct key but not from a permitted \"\n\t\t\t    \"host (host=%.200s, ip=%.200s, required=%.200s).\",\n\t\t\t    loc, pw->pw_name, remote_host, remote_ip,\n\t\t\t    opts->required_from_host_keys);\n\t\t\tauth_debug_add(\"%s: Your host '%.200s' is not \"\n\t\t\t    \"permitted to use this key for login.\",\n\t\t\t    loc, remote_host);\n\t\t\t/* deny access */\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* Check source-address restriction from certificate */\n\tif (opts->required_from_host_cert != NULL) {\n\t\tswitch (addr_match_cidr_list(remote_ip,\n\t\t    opts->required_from_host_cert)) {\n\t\tcase 1:\n\t\t\t/* accepted */\n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\t/* invalid */\n\t\t\terror(\"%s: Certificate source-address invalid\",\n\t\t\t    loc);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 0:\n\t\t\tlogit(\"%s: Authentication tried for %.100s with valid \"\n\t\t\t    \"certificate but not from a permitted source \"\n\t\t\t    \"address (%.200s).\", loc, pw->pw_name, remote_ip);\n\t\t\tauth_debug_add(\"%s: Your address '%.200s' is not \"\n\t\t\t    \"permitted to use this certificate for login.\",\n\t\t\t    loc, remote_ip);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/*\n\t *\n\t * XXX this is spammy. We should report remotely only for keys\n\t *     that are successful in actual auth attempts, and not PK_OK\n\t *     tests.\n\t */\n\tauth_log_authopts(loc, opts, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_from_cert",
          "args": [
            "key"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_from_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "541-566",
          "snippet": "struct sshauthopt *\nsshauthopt_from_cert(struct sshkey *k)\n{\n\tstruct sshauthopt *ret;\n\n\tif (k == NULL || !sshkey_type_is_cert(k->type) || k->cert == NULL ||\n\t    k->cert->type != SSH2_CERT_TYPE_USER)\n\t\treturn NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Handle options and critical extensions separately */\n\tif (cert_option_list(ret, k->cert->critical,\n\t    OPTIONS_CRITICAL, 1) == -1) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\tif (cert_option_list(ret, k->cert->extensions,\n\t    OPTIONS_EXTENSIONS, 0) == -1) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\t/* success */\n\treturn ret;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define OPTIONS_EXTENSIONS\t2",
            "#define OPTIONS_CRITICAL\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define OPTIONS_EXTENSIONS\t2\n#define OPTIONS_CRITICAL\t1\n\nstruct sshauthopt *\nsshauthopt_from_cert(struct sshkey *k)\n{\n\tstruct sshauthopt *ret;\n\n\tif (k == NULL || !sshkey_type_is_cert(k->type) || k->cert == NULL ||\n\t    k->cert->type != SSH2_CERT_TYPE_USER)\n\t\treturn NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Handle options and critical extensions separately */\n\tif (cert_option_list(ret, k->cert->critical,\n\t    OPTIONS_CRITICAL, 1) == -1) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\tif (cert_option_list(ret, k->cert->extensions,\n\t    OPTIONS_EXTENSIONS, 0) == -1) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\t/* success */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: matching %s found: %s %s\"",
            "loc",
            "sshkey_is_cert(key) ? \"CA\" : \"key\"",
            "sshkey_type(found)",
            "fp"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "found",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "found",
            "key"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_parse",
          "args": [
            "key_options",
            "&reason"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "383-539",
          "snippet": "struct sshauthopt *\nsshauthopt_parse(const char *opts, const char **errstrp)\n{\n\tchar **oarray, *opt, *cp, *tmp;\n\tint r;\n\tstruct sshauthopt *ret = NULL;\n\tconst char *errstr = \"unknown error\";\n\tuint64_t valid_before;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\tif ((ret = sshauthopt_new_with_keys_defaults()) == NULL)\n\t\tgoto alloc_fail;\n\n\tif (opts == NULL)\n\t\treturn ret;\n\n\twhile (*opts && *opts != ' ' && *opts != '\\t') {\n\t\t/* flag options */\n\t\tif ((r = opt_flag(\"restrict\", 0, &opts)) != -1) {\n\t\t\tret->restricted = 1;\n\t\t\tret->permit_port_forwarding_flag = 0;\n\t\t\tret->permit_agent_forwarding_flag = 0;\n\t\t\tret->permit_x11_forwarding_flag = 0;\n\t\t\tret->permit_pty_flag = 0;\n\t\t\tret->permit_user_rc = 0;\n\t\t} else if ((r = opt_flag(\"cert-authority\", 0, &opts)) != -1) {\n\t\t\tret->cert_authority = r;\n\t\t} else if ((r = opt_flag(\"port-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_port_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"agent-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_agent_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"x11-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_x11_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"pty\", 1, &opts)) != -1) {\n\t\t\tret->permit_pty_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"user-rc\", 1, &opts)) != -1) {\n\t\t\tret->permit_user_rc = r == 1;\n\t\t} else if (opt_match(&opts, \"command\")) {\n\t\t\tif (ret->force_command != NULL) {\n\t\t\t\terrstr = \"multiple \\\"command\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->force_command = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"principals\")) {\n\t\t\tif (ret->cert_principals != NULL) {\n\t\t\t\terrstr = \"multiple \\\"principals\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->cert_principals = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->cert_principals == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"from\")) {\n\t\t\tif (ret->required_from_host_keys != NULL) {\n\t\t\t\terrstr = \"multiple \\\"from\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->required_from_host_keys = opt_dequote(&opts,\n\t\t\t    &errstr);\n\t\t\tif (ret->required_from_host_keys == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"expiry-time\")) {\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tif (parse_absolute_time(opt, &valid_before) != 0 ||\n\t\t\t    valid_before == 0) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid expires time\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(opt);\n\t\t\tif (ret->valid_before == 0 ||\n\t\t\t    valid_before < ret->valid_before)\n\t\t\t\tret->valid_before = valid_before;\n\t\t} else if (opt_match(&opts, \"environment\")) {\n\t\t\tif (ret->nenv > INT_MAX) {\n\t\t\t\terrstr = \"too many environment strings\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\t/* env name must be alphanumeric and followed by '=' */\n\t\t\tif ((tmp = strchr(opt, '=')) == NULL) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid environment string\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((cp = strdup(opt)) == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t\tcp[tmp - opt] = '\\0'; /* truncate at '=' */\n\t\t\tif (!valid_env_name(cp)) {\n\t\t\t\tfree(cp);\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid environment string\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(cp);\n\t\t\t/* Append it. */\n\t\t\toarray = ret->env;\n\t\t\tif ((ret->env = recallocarray(ret->env, ret->nenv,\n\t\t\t    ret->nenv + 1, sizeof(*ret->env))) == NULL) {\n\t\t\t\tfree(opt);\n\t\t\t\tret->env = oarray; /* put it back for cleanup */\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\tret->env[ret->nenv++] = opt;\n\t\t} else if (opt_match(&opts, \"permitopen\")) {\n\t\t\tif (handle_permit(&opts, 0, &ret->permitopen,\n\t\t\t    &ret->npermitopen, &errstr) != 0)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"permitlisten\")) {\n\t\t\tif (handle_permit(&opts, 1, &ret->permitlisten,\n\t\t\t    &ret->npermitlisten, &errstr) != 0)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"tunnel\")) {\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tret->force_tun_device = a2tun(opt, NULL);\n\t\t\tfree(opt);\n\t\t\tif (ret->force_tun_device == SSH_TUNID_ERR) {\n\t\t\t\terrstr = \"invalid tun device\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Skip the comma, and move to the next option\n\t\t * (or break out if there are no more).\n\t\t */\n\t\tif (*opts == '\\0' || *opts == ' ' || *opts == '\\t')\n\t\t\tbreak;\t\t/* End of options. */\n\t\t/* Anything other than a comma is an unknown option */\n\t\tif (*opts != ',') {\n\t\t\terrstr = \"unknown key option\";\n\t\t\tgoto fail;\n\t\t}\n\t\topts++;\n\t\tif (*opts == '\\0') {\n\t\t\terrstr = \"unexpected end-of-options\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* success */\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\nalloc_fail:\n\terrstr = \"memory allocation failed\";\nfail:\n\tsshauthopt_free(ret);\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\treturn NULL;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_parse(const char *opts, const char **errstrp)\n{\n\tchar **oarray, *opt, *cp, *tmp;\n\tint r;\n\tstruct sshauthopt *ret = NULL;\n\tconst char *errstr = \"unknown error\";\n\tuint64_t valid_before;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\tif ((ret = sshauthopt_new_with_keys_defaults()) == NULL)\n\t\tgoto alloc_fail;\n\n\tif (opts == NULL)\n\t\treturn ret;\n\n\twhile (*opts && *opts != ' ' && *opts != '\\t') {\n\t\t/* flag options */\n\t\tif ((r = opt_flag(\"restrict\", 0, &opts)) != -1) {\n\t\t\tret->restricted = 1;\n\t\t\tret->permit_port_forwarding_flag = 0;\n\t\t\tret->permit_agent_forwarding_flag = 0;\n\t\t\tret->permit_x11_forwarding_flag = 0;\n\t\t\tret->permit_pty_flag = 0;\n\t\t\tret->permit_user_rc = 0;\n\t\t} else if ((r = opt_flag(\"cert-authority\", 0, &opts)) != -1) {\n\t\t\tret->cert_authority = r;\n\t\t} else if ((r = opt_flag(\"port-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_port_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"agent-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_agent_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"x11-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_x11_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"pty\", 1, &opts)) != -1) {\n\t\t\tret->permit_pty_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"user-rc\", 1, &opts)) != -1) {\n\t\t\tret->permit_user_rc = r == 1;\n\t\t} else if (opt_match(&opts, \"command\")) {\n\t\t\tif (ret->force_command != NULL) {\n\t\t\t\terrstr = \"multiple \\\"command\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->force_command = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"principals\")) {\n\t\t\tif (ret->cert_principals != NULL) {\n\t\t\t\terrstr = \"multiple \\\"principals\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->cert_principals = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->cert_principals == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"from\")) {\n\t\t\tif (ret->required_from_host_keys != NULL) {\n\t\t\t\terrstr = \"multiple \\\"from\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->required_from_host_keys = opt_dequote(&opts,\n\t\t\t    &errstr);\n\t\t\tif (ret->required_from_host_keys == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"expiry-time\")) {\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tif (parse_absolute_time(opt, &valid_before) != 0 ||\n\t\t\t    valid_before == 0) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid expires time\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(opt);\n\t\t\tif (ret->valid_before == 0 ||\n\t\t\t    valid_before < ret->valid_before)\n\t\t\t\tret->valid_before = valid_before;\n\t\t} else if (opt_match(&opts, \"environment\")) {\n\t\t\tif (ret->nenv > INT_MAX) {\n\t\t\t\terrstr = \"too many environment strings\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\t/* env name must be alphanumeric and followed by '=' */\n\t\t\tif ((tmp = strchr(opt, '=')) == NULL) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid environment string\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((cp = strdup(opt)) == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t\tcp[tmp - opt] = '\\0'; /* truncate at '=' */\n\t\t\tif (!valid_env_name(cp)) {\n\t\t\t\tfree(cp);\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid environment string\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(cp);\n\t\t\t/* Append it. */\n\t\t\toarray = ret->env;\n\t\t\tif ((ret->env = recallocarray(ret->env, ret->nenv,\n\t\t\t    ret->nenv + 1, sizeof(*ret->env))) == NULL) {\n\t\t\t\tfree(opt);\n\t\t\t\tret->env = oarray; /* put it back for cleanup */\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\tret->env[ret->nenv++] = opt;\n\t\t} else if (opt_match(&opts, \"permitopen\")) {\n\t\t\tif (handle_permit(&opts, 0, &ret->permitopen,\n\t\t\t    &ret->npermitopen, &errstr) != 0)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"permitlisten\")) {\n\t\t\tif (handle_permit(&opts, 1, &ret->permitlisten,\n\t\t\t    &ret->npermitlisten, &errstr) != 0)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"tunnel\")) {\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tret->force_tun_device = a2tun(opt, NULL);\n\t\t\tfree(opt);\n\t\t\tif (ret->force_tun_device == SSH_TUNID_ERR) {\n\t\t\t\terrstr = \"invalid tun device\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Skip the comma, and move to the next option\n\t\t * (or break out if there are no more).\n\t\t */\n\t\tif (*opts == '\\0' || *opts == ' ' || *opts == '\\t')\n\t\t\tbreak;\t\t/* End of options. */\n\t\t/* Anything other than a comma is an unknown option */\n\t\tif (*opts != ',') {\n\t\t\terrstr = \"unknown key option\";\n\t\t\tgoto fail;\n\t\t}\n\t\topts++;\n\t\tif (*opts == '\\0') {\n\t\t\terrstr = \"unexpected end-of-options\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* success */\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\nalloc_fail:\n\terrstr = \"memory allocation failed\";\nfail:\n\tsshauthopt_free(ret);\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: advance: '%s'\"",
            "loc",
            "cp"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_read",
          "args": [
            "found",
            "&cp"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1219-1379",
          "snippet": "int\nsshkey_read(struct sshkey *ret, char **cpp)\n{\n\tstruct sshkey *k;\n\tchar *cp, *blobcopy;\n\tsize_t space;\n\tint r, type, curve_nid = -1;\n\tstruct sshbuf *blob;\n\n\tif (ret == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tswitch (ret->type) {\n\tcase KEY_UNSPEC:\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\tbreak; /* ok */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\n\t/* Decode type */\n\tcp = *cpp;\n\tspace = strcspn(cp, \" \\t\");\n\tif (space == strlen(cp))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((type = peek_type_nid(cp, space, &curve_nid)) == KEY_UNSPEC)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* skip whitespace */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\tif (*cp == '\\0')\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (ret->type != KEY_UNSPEC && ret->type != type)\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\tif ((blob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* find end of keyblob and decode */\n\tspace = strcspn(cp, \" \\t\");\n\tif ((blobcopy = strndup(cp, space)) == NULL) {\n\t\tsshbuf_free(blob);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_b64tod(blob, blobcopy)) != 0) {\n\t\tfree(blobcopy);\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tfree(blobcopy);\n\tif ((r = sshkey_fromb(blob, &k)) != 0) {\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tsshbuf_free(blob);\n\n\t/* skip whitespace and leave cp at start of comment */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\n\t/* ensure type of blob matches type at start of line */\n\tif (k->type != type) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\t}\n\tif (sshkey_type_plain(type) == KEY_ECDSA && curve_nid != k->ecdsa_nid) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_EC_CURVE_MISMATCH;\n\t}\n\n\t/* Fill in ret from parsed key */\n\tret->type = type;\n\tif (sshkey_is_cert(ret)) {\n\t\tif (!sshkey_is_cert(k)) {\n\t\t\tsshkey_free(k);\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\t}\n\t\tif (ret->cert != NULL)\n\t\t\tcert_free(ret->cert);\n\t\tret->cert = k->cert;\n\t\tk->cert = NULL;\n\t}\n\tswitch (sshkey_type_plain(ret->type)) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_free(ret->rsa);\n\t\tret->rsa = k->rsa;\n\t\tk->rsa = NULL;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, ret->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_free(ret->dsa);\n\t\tret->dsa = k->dsa;\n\t\tk->dsa = NULL;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, ret->dsa, 8);\n#endif\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tEC_KEY_free(ret->ecdsa);\n\t\tret->ecdsa = k->ecdsa;\n\t\tret->ecdsa_nid = k->ecdsa_nid;\n\t\tk->ecdsa = NULL;\n\t\tk->ecdsa_nid = -1;\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_key(ret->ecdsa);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tfreezero(ret->ed25519_pk, ED25519_PK_SZ);\n\t\tret->ed25519_pk = k->ed25519_pk;\n\t\tk->ed25519_pk = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tfree(ret->xmss_pk);\n\t\tret->xmss_pk = k->xmss_pk;\n\t\tk->xmss_pk = NULL;\n\t\tfree(ret->xmss_state);\n\t\tret->xmss_state = k->xmss_state;\n\t\tk->xmss_state = NULL;\n\t\tfree(ret->xmss_name);\n\t\tret->xmss_name = k->xmss_name;\n\t\tk->xmss_name = NULL;\n\t\tfree(ret->xmss_filename);\n\t\tret->xmss_filename = k->xmss_filename;\n\t\tk->xmss_filename = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tsshkey_free(k);\n\n\t/* success */\n\t*cpp = cp;\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_read(struct sshkey *ret, char **cpp)\n{\n\tstruct sshkey *k;\n\tchar *cp, *blobcopy;\n\tsize_t space;\n\tint r, type, curve_nid = -1;\n\tstruct sshbuf *blob;\n\n\tif (ret == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tswitch (ret->type) {\n\tcase KEY_UNSPEC:\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\tbreak; /* ok */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\n\t/* Decode type */\n\tcp = *cpp;\n\tspace = strcspn(cp, \" \\t\");\n\tif (space == strlen(cp))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((type = peek_type_nid(cp, space, &curve_nid)) == KEY_UNSPEC)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* skip whitespace */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\tif (*cp == '\\0')\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (ret->type != KEY_UNSPEC && ret->type != type)\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\tif ((blob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* find end of keyblob and decode */\n\tspace = strcspn(cp, \" \\t\");\n\tif ((blobcopy = strndup(cp, space)) == NULL) {\n\t\tsshbuf_free(blob);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_b64tod(blob, blobcopy)) != 0) {\n\t\tfree(blobcopy);\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tfree(blobcopy);\n\tif ((r = sshkey_fromb(blob, &k)) != 0) {\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tsshbuf_free(blob);\n\n\t/* skip whitespace and leave cp at start of comment */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\n\t/* ensure type of blob matches type at start of line */\n\tif (k->type != type) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\t}\n\tif (sshkey_type_plain(type) == KEY_ECDSA && curve_nid != k->ecdsa_nid) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_EC_CURVE_MISMATCH;\n\t}\n\n\t/* Fill in ret from parsed key */\n\tret->type = type;\n\tif (sshkey_is_cert(ret)) {\n\t\tif (!sshkey_is_cert(k)) {\n\t\t\tsshkey_free(k);\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\t}\n\t\tif (ret->cert != NULL)\n\t\t\tcert_free(ret->cert);\n\t\tret->cert = k->cert;\n\t\tk->cert = NULL;\n\t}\n\tswitch (sshkey_type_plain(ret->type)) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_free(ret->rsa);\n\t\tret->rsa = k->rsa;\n\t\tk->rsa = NULL;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, ret->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_free(ret->dsa);\n\t\tret->dsa = k->dsa;\n\t\tk->dsa = NULL;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, ret->dsa, 8);\n#endif\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tEC_KEY_free(ret->ecdsa);\n\t\tret->ecdsa = k->ecdsa;\n\t\tret->ecdsa_nid = k->ecdsa_nid;\n\t\tk->ecdsa = NULL;\n\t\tk->ecdsa_nid = -1;\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_key(ret->ecdsa);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tfreezero(ret->ed25519_pk, ED25519_PK_SZ);\n\t\tret->ed25519_pk = k->ed25519_pk;\n\t\tk->ed25519_pk = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tfree(ret->xmss_pk);\n\t\tret->xmss_pk = k->xmss_pk;\n\t\tk->xmss_pk = NULL;\n\t\tfree(ret->xmss_state);\n\t\tret->xmss_state = k->xmss_state;\n\t\tk->xmss_state = NULL;\n\t\tfree(ret->xmss_name);\n\t\tret->xmss_name = k->xmss_name;\n\t\tk->xmss_name = NULL;\n\t\tfree(ret->xmss_filename);\n\t\tret->xmss_filename = k->xmss_filename;\n\t\tk->xmss_filename = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tsshkey_free(k);\n\n\t/* success */\n\t*cpp = cp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_space",
          "args": [
            "&cp"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "skip_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "525-533",
          "snippet": "static void\nskip_space(char **cpp)\n{\n\tchar *cp;\n\n\tfor (cp = *cpp; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\t*cpp = cp;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nskip_space(char **cpp)\n{\n\tchar *cp;\n\n\tfor (cp = *cpp; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\t*cpp = cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "advance_past_options",
          "args": [
            "&cp"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "advance_past_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "540-555",
          "snippet": "static int\nadvance_past_options(char **cpp)\n{\n\tchar *cp = *cpp;\n\tint quoted = 0;\n\n\tfor (; *cp && (quoted || (*cp != ' ' && *cp != '\\t')); cp++) {\n\t\tif (*cp == '\\\\' && cp[1] == '\"')\n\t\t\tcp++;\t/* Skip both */\n\t\telse if (*cp == '\"')\n\t\t\tquoted = !quoted;\n\t}\n\t*cpp = cp;\n\t/* return failure for unterminated quotes */\n\treturn (*cp == '\\0' && quoted) ? -1 : 0;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nadvance_past_options(char **cpp)\n{\n\tchar *cp = *cpp;\n\tint quoted = 0;\n\n\tfor (; *cp && (quoted || (*cp != ' ' && *cp != '\\t')); cp++) {\n\t\tif (*cp == '\\\\' && cp[1] == '\"')\n\t\t\tcp++;\t/* Skip both */\n\t\telse if (*cp == '\"')\n\t\t\tquoted = !quoted;\n\t}\n\t*cpp = cp;\n\t/* return failure for unterminated quotes */\n\treturn (*cp == '\\0' && quoted) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_new",
          "args": [
            "want_keytype"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "485-550",
          "snippet": "struct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\ncheck_authkey_line(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    char *cp, const char *loc, struct sshauthopt **authoptsp)\n{\n\tint want_keytype = sshkey_is_cert(key) ? KEY_UNSPEC : key->type;\n\tstruct sshkey *found = NULL;\n\tstruct sshauthopt *keyopts = NULL, *certopts = NULL, *finalopts = NULL;\n\tchar *key_options = NULL, *fp = NULL;\n\tconst char *reason = NULL;\n\tint ret = -1;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif ((found = sshkey_new(want_keytype)) == NULL) {\n\t\tdebug3(\"%s: keytype %d failed\", __func__, want_keytype);\n\t\tgoto out;\n\t}\n\n\t/* XXX djm: peek at key type in line and skip if unwanted */\n\n\tif (sshkey_read(found, &cp) != 0) {\n\t\t/* no key?  check for options */\n\t\tdebug2(\"%s: check options: '%s'\", loc, cp);\n\t\tkey_options = cp;\n\t\tif (advance_past_options(&cp) != 0) {\n\t\t\treason = \"invalid key option string\";\n\t\t\tgoto fail_reason;\n\t\t}\n\t\tskip_space(&cp);\n\t\tif (sshkey_read(found, &cp) != 0) {\n\t\t\t/* still no key?  advance to next line*/\n\t\t\tdebug2(\"%s: advance: '%s'\", loc, cp);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Parse key options now; we need to know if this is a CA key */\n\tif ((keyopts = sshauthopt_parse(key_options, &reason)) == NULL) {\n\t\tdebug(\"%s: bad key options: %s\", loc, reason);\n\t\tauth_debug_add(\"%s: bad key options: %s\", loc, reason);\n\t\tgoto out;\n\t}\n\t/* Ignore keys that don't match or incorrectly marked as CAs */\n\tif (sshkey_is_cert(key)) {\n\t\t/* Certificate; check signature key against CA */\n\t\tif (!sshkey_equal(found, key->cert->signature_key) ||\n\t\t    !keyopts->cert_authority)\n\t\t\tgoto out;\n\t} else {\n\t\t/* Plain key: check it against key found in file */\n\t\tif (!sshkey_equal(found, key) || keyopts->cert_authority)\n\t\t\tgoto out;\n\t}\n\n\t/* We have a candidate key, perform authorisation checks */\n\tif ((fp = sshkey_fingerprint(found,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\tfatal(\"%s: fingerprint failed\", __func__);\n\n\tdebug(\"%s: matching %s found: %s %s\", loc,\n\t    sshkey_is_cert(key) ? \"CA\" : \"key\", sshkey_type(found), fp);\n\n\tif (auth_authorise_keyopts(ssh, pw, keyopts,\n\t    sshkey_is_cert(key), loc) != 0) {\n\t\treason = \"Refused by key options\";\n\t\tgoto fail_reason;\n\t}\n\t/* That's all we need for plain keys. */\n\tif (!sshkey_is_cert(key)) {\n\t\tverbose(\"Accepted key %s %s found at %s\",\n\t\t    sshkey_type(found), fp, loc);\n\t\tfinalopts = keyopts;\n\t\tkeyopts = NULL;\n\t\tgoto success;\n\t}\n\n\t/*\n\t * Additional authorisation for certificates.\n\t */\n\n\t/* Parse and check options present in certificate */\n\tif ((certopts = sshauthopt_from_cert(key)) == NULL) {\n\t\treason = \"Invalid certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (auth_authorise_keyopts(ssh, pw, certopts, 0, loc) != 0) {\n\t\treason = \"Refused by certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif ((finalopts = sshauthopt_merge(keyopts, certopts, &reason)) == NULL)\n\t\tgoto fail_reason;\n\n\t/*\n\t * If the user has specified a list of principals as\n\t * a key option, then prefer that list to matching\n\t * their username in the certificate principals list.\n\t */\n\tif (keyopts->cert_principals != NULL &&\n\t    !match_principals_option(keyopts->cert_principals, key->cert)) {\n\t\treason = \"Certificate does not contain an authorized principal\";\n\t\tgoto fail_reason;\n\t}\n\tif (sshkey_cert_check_authority(key, 0, 0,\n\t   keyopts->cert_principals == NULL ? pw->pw_name : NULL, &reason) != 0)\n\t\tgoto fail_reason;\n\n\tverbose(\"Accepted certificate ID \\\"%s\\\" (serial %llu) \"\n\t    \"signed by CA %s %s found at %s\",\n\t    key->cert->key_id,\n\t    (unsigned long long)key->cert->serial,\n\t    sshkey_type(found), fp, loc);\n\n success:\n\tif (finalopts == NULL)\n\t\tfatal(\"%s: internal error: missing options\", __func__);\n\tif (authoptsp != NULL) {\n\t\t*authoptsp = finalopts;\n\t\tfinalopts = NULL;\n\t}\n\t/* success */\n\tret = 0;\n\tgoto out;\n\n fail_reason:\n\terror(\"%s\", reason);\n\tauth_debug_add(\"%s\", reason);\n out:\n\tfree(fp);\n\tsshauthopt_free(keyopts);\n\tsshauthopt_free(certopts);\n\tsshauthopt_free(finalopts);\n\tsshkey_free(found);\n\treturn ret;\n}"
  },
  {
    "function_name": "advance_past_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "540-555",
    "snippet": "static int\nadvance_past_options(char **cpp)\n{\n\tchar *cp = *cpp;\n\tint quoted = 0;\n\n\tfor (; *cp && (quoted || (*cp != ' ' && *cp != '\\t')); cp++) {\n\t\tif (*cp == '\\\\' && cp[1] == '\"')\n\t\t\tcp++;\t/* Skip both */\n\t\telse if (*cp == '\"')\n\t\t\tquoted = !quoted;\n\t}\n\t*cpp = cp;\n\t/* return failure for unterminated quotes */\n\treturn (*cp == '\\0' && quoted) ? -1 : 0;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nadvance_past_options(char **cpp)\n{\n\tchar *cp = *cpp;\n\tint quoted = 0;\n\n\tfor (; *cp && (quoted || (*cp != ' ' && *cp != '\\t')); cp++) {\n\t\tif (*cp == '\\\\' && cp[1] == '\"')\n\t\t\tcp++;\t/* Skip both */\n\t\telse if (*cp == '\"')\n\t\t\tquoted = !quoted;\n\t}\n\t*cpp = cp;\n\t/* return failure for unterminated quotes */\n\treturn (*cp == '\\0' && quoted) ? -1 : 0;\n}"
  },
  {
    "function_name": "skip_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "525-533",
    "snippet": "static void\nskip_space(char **cpp)\n{\n\tchar *cp;\n\n\tfor (cp = *cpp; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\t*cpp = cp;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nskip_space(char **cpp)\n{\n\tchar *cp;\n\n\tfor (cp = *cpp; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\t*cpp = cp;\n}"
  },
  {
    "function_name": "match_principals_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "393-523",
    "snippet": "static int\nmatch_principals_command(struct ssh *ssh, struct passwd *user_pw,\n    const struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tstruct passwd *runas_pw = NULL;\n\tconst struct sshkey_cert *cert = key->cert;\n\tFILE *f = NULL;\n\tint r, ok, found_principal = 0;\n\tint i, ac = 0, uid_swapped = 0;\n\tpid_t pid;\n\tchar *tmp, *username = NULL, *command = NULL, **av = NULL;\n\tchar *ca_fp = NULL, *key_fp = NULL, *catext = NULL, *keytext = NULL;\n\tchar serial_s[16], uidstr[32];\n\tvoid (*osigchld)(int);\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\tif (options.authorized_principals_command == NULL)\n\t\treturn 0;\n\tif (options.authorized_principals_command_user == NULL) {\n\t\terror(\"No user for AuthorizedPrincipalsCommand specified, \"\n\t\t    \"skipping\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * NB. all returns later this function should go via \"out\" to\n\t * ensure the original SIGCHLD handler is restored properly.\n\t */\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\n\t/* Prepare and verify the user for the command */\n\tusername = percent_expand(options.authorized_principals_command_user,\n\t    \"u\", user_pw->pw_name, (char *)NULL);\n\trunas_pw = getpwnam(username);\n\tif (runas_pw == NULL) {\n\t\terror(\"AuthorizedPrincipalsCommandUser \\\"%s\\\" not found: %s\",\n\t\t    username, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* Turn the command into an argument vector */\n\tif (argv_split(options.authorized_principals_command, &ac, &av) != 0) {\n\t\terror(\"AuthorizedPrincipalsCommand \\\"%s\\\" contains \"\n\t\t    \"invalid quotes\", command);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"AuthorizedPrincipalsCommand \\\"%s\\\" yielded no arguments\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tif ((ca_fp = sshkey_fingerprint(cert->signature_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((key_fp = sshkey_fingerprint(key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(cert->signature_key, &catext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(key, &keytext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tsnprintf(serial_s, sizeof(serial_s), \"%llu\",\n\t    (unsigned long long)cert->serial);\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)user_pw->pw_uid);\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_expand(av[i],\n\t\t    \"U\", uidstr,\n\t\t    \"u\", user_pw->pw_name,\n\t\t    \"h\", user_pw->pw_dir,\n\t\t    \"t\", sshkey_ssh_name(key),\n\t\t    \"T\", sshkey_ssh_name(cert->signature_key),\n\t\t    \"f\", key_fp,\n\t\t    \"F\", ca_fp,\n\t\t    \"k\", keytext,\n\t\t    \"K\", catext,\n\t\t    \"i\", cert->key_id,\n\t\t    \"s\", serial_s,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal(\"%s: percent_expand failed\", __func__);\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t/* Prepare a printable command for logs, etc. */\n\tcommand = argv_assemble(ac, av);\n\n\tif ((pid = subprocess(\"AuthorizedPrincipalsCommand\", runas_pw, command,\n\t    ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD)) == 0)\n\t\tgoto out;\n\n\tuid_swapped = 1;\n\ttemporarily_use_uid(runas_pw);\n\n\tok = process_principals(ssh, f, \"(command)\", cert, authoptsp);\n\n\tfclose(f);\n\tf = NULL;\n\n\tif (exited_cleanly(pid, \"AuthorizedPrincipalsCommand\", command, 0) != 0)\n\t\tgoto out;\n\n\t/* Read completed successfully */\n\tfound_principal = ok;\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tsignal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tif (uid_swapped)\n\t\trestore_uid();\n\tfree(command);\n\tfree(username);\n\tfree(ca_fp);\n\tfree(key_fp);\n\tfree(catext);\n\tfree(keytext);\n\treturn found_principal;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "keytext"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_uid",
          "args": [],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "restore_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "141-172",
          "snippet": "void\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGCHLD",
            "osigchld"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exited_cleanly",
          "args": [
            "pid",
            "\"AuthorizedPrincipalsCommand\"",
            "command",
            "0"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "exited_cleanly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1733-1753",
          "snippet": "int\nexited_cleanly(pid_t pid, const char *tag, const char *cmd, int quiet)\n{\n\tint status;\n\n\twhile (waitpid(pid, &status, 0) == -1) {\n\t\tif (errno != EINTR) {\n\t\t\terror(\"%s: waitpid: %s\", tag, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (WIFSIGNALED(status)) {\n\t\terror(\"%s %s exited on signal %d\", tag, cmd, WTERMSIG(status));\n\t\treturn -1;\n\t} else if (WEXITSTATUS(status) != 0) {\n\t\tdo_log2(quiet ? SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_INFO,\n\t\t    \"%s %s failed, status %d\", tag, cmd, WEXITSTATUS(status));\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nexited_cleanly(pid_t pid, const char *tag, const char *cmd, int quiet)\n{\n\tint status;\n\n\twhile (waitpid(pid, &status, 0) == -1) {\n\t\tif (errno != EINTR) {\n\t\t\terror(\"%s: waitpid: %s\", tag, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (WIFSIGNALED(status)) {\n\t\terror(\"%s %s exited on signal %d\", tag, cmd, WTERMSIG(status));\n\t\treturn -1;\n\t} else if (WEXITSTATUS(status) != 0) {\n\t\tdo_log2(quiet ? SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_INFO,\n\t\t    \"%s %s failed, status %d\", tag, cmd, WEXITSTATUS(status));\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_principals",
          "args": [
            "ssh",
            "f",
            "\"(command)\"",
            "cert",
            "authoptsp"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "process_principals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "330-363",
          "snippet": "static int\nprocess_principals(struct ssh *ssh, FILE *f, const char *file,\n    const struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tchar loc[256], *line = NULL, *cp, *ep;\n\tsize_t linesize = 0;\n\tu_long linenum = 0;\n\tu_int found_principal = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire input */\n\t\tif (found_principal)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace. */\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\t/* Skip blank and comment lines. */\n\t\tif ((ep = strchr(cp, '#')) != NULL)\n\t\t\t*ep = '\\0';\n\t\tif (!*cp || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_principals_line(ssh, cp, cert, loc, authoptsp) == 0)\n\t\t\tfound_principal = 1;\n\t}\n\tfree(line);\n\treturn found_principal;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nprocess_principals(struct ssh *ssh, FILE *f, const char *file,\n    const struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tchar loc[256], *line = NULL, *cp, *ep;\n\tsize_t linesize = 0;\n\tu_long linenum = 0;\n\tu_int found_principal = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire input */\n\t\tif (found_principal)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace. */\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\t/* Skip blank and comment lines. */\n\t\tif ((ep = strchr(cp, '#')) != NULL)\n\t\t\t*ep = '\\0';\n\t\tif (!*cp || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_principals_line(ssh, cp, cert, loc, authoptsp) == 0)\n\t\t\tfound_principal = 1;\n\t}\n\tfree(line);\n\treturn found_principal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "temporarily_use_uid",
          "args": [
            "runas_pw"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "temporarily_use_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "60-136",
          "snippet": "void\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static uid_t\tuser_groups_uid;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "subprocess",
          "args": [
            "\"AuthorizedPrincipalsCommand\"",
            "runas_pw",
            "command",
            "ac",
            "av",
            "&f",
            "SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "subprocess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "863-1004",
          "snippet": "pid_t\nsubprocess(const char *tag, struct passwd *pw, const char *command,\n    int ac, char **av, FILE **child, u_int flags)\n{\n\tFILE *f = NULL;\n\tstruct stat st;\n\tint fd, devnull, p[2], i;\n\tpid_t pid;\n\tchar *cp, errmsg[512];\n\tu_int envsize;\n\tchar **child_env;\n\n\tif (child != NULL)\n\t\t*child = NULL;\n\n\tdebug3(\"%s: %s command \\\"%s\\\" running as %s (flags 0x%x)\", __func__,\n\t    tag, command, pw->pw_name, flags);\n\n\t/* Check consistency */\n\tif ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0 &&\n\t    (flags & SSH_SUBPROCESS_STDOUT_CAPTURE) != 0) {\n\t\terror(\"%s: inconsistent flags\", __func__);\n\t\treturn 0;\n\t}\n\tif (((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0) != (child == NULL)) {\n\t\terror(\"%s: inconsistent flags/output\", __func__);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If executing an explicit binary, then verify the it exists\n\t * and appears safe-ish to execute\n\t */\n\tif (*av[0] != '/') {\n\t\terror(\"%s path is not absolute\", tag);\n\t\treturn 0;\n\t}\n\ttemporarily_use_uid(pw);\n\tif (stat(av[0], &st) < 0) {\n\t\terror(\"Could not stat %s \\\"%s\\\": %s\", tag,\n\t\t    av[0], strerror(errno));\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\tif (safe_path(av[0], &st, NULL, 0, errmsg, sizeof(errmsg)) != 0) {\n\t\terror(\"Unsafe %s \\\"%s\\\": %s\", tag, av[0], errmsg);\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\t/* Prepare to keep the child's stdout if requested */\n\tif (pipe(p) != 0) {\n\t\terror(\"%s: pipe: %s\", tag, strerror(errno));\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\trestore_uid();\n\n\tswitch ((pid = fork())) {\n\tcase -1: /* error */\n\t\terror(\"%s: fork: %s\", tag, strerror(errno));\n\t\tclose(p[0]);\n\t\tclose(p[1]);\n\t\treturn 0;\n\tcase 0: /* child */\n\t\t/* Prepare a minimal environment for the child. */\n\t\tenvsize = 5;\n\t\tchild_env = xcalloc(sizeof(*child_env), envsize);\n\t\tchild_set_env(&child_env, &envsize, \"PATH\", _PATH_STDPATH);\n\t\tchild_set_env(&child_env, &envsize, \"USER\", pw->pw_name);\n\t\tchild_set_env(&child_env, &envsize, \"LOGNAME\", pw->pw_name);\n\t\tchild_set_env(&child_env, &envsize, \"HOME\", pw->pw_dir);\n\t\tif ((cp = getenv(\"LANG\")) != NULL)\n\t\t\tchild_set_env(&child_env, &envsize, \"LANG\", cp);\n\n\t\tfor (i = 0; i < NSIG; i++)\n\t\t\tsignal(i, SIG_DFL);\n\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\t\terror(\"%s: open %s: %s\", tag, _PATH_DEVNULL,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (dup2(devnull, STDIN_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\n\t\t/* Set up stdout as requested; leave stderr in place for now. */\n\t\tfd = -1;\n\t\tif ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) != 0)\n\t\t\tfd = p[1];\n\t\telse if ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0)\n\t\t\tfd = devnull;\n\t\tif (fd != -1 && dup2(fd, STDOUT_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\t/* Don't use permanently_set_uid() here to avoid fatal() */\n\t\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0) {\n\t\t\terror(\"%s: setresgid %u: %s\", tag, (u_int)pw->pw_gid,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0) {\n\t\t\terror(\"%s: setresuid %u: %s\", tag, (u_int)pw->pw_uid,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\t/* stdin is pointed to /dev/null at this point */\n\t\tif ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0 &&\n\t\t    dup2(STDIN_FILENO, STDERR_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\n\t\texecve(av[0], av, child_env);\n\t\terror(\"%s exec \\\"%s\\\": %s\", tag, command, strerror(errno));\n\t\t_exit(127);\n\tdefault: /* parent */\n\t\tbreak;\n\t}\n\n\tclose(p[1]);\n\tif ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0)\n\t\tclose(p[0]);\n\telse if ((f = fdopen(p[0], \"r\")) == NULL) {\n\t\terror(\"%s: fdopen: %s\", tag, strerror(errno));\n\t\tclose(p[0]);\n\t\t/* Don't leave zombie child */\n\t\tkill(pid, SIGTERM);\n\t\twhile (waitpid(pid, NULL, 0) == -1 && errno == EINTR)\n\t\t\t;\n\t\treturn 0;\n\t}\n\t/* Success */\n\tdebug3(\"%s: %s pid %ld\", __func__, tag, (long)pid);\n\tif (child != NULL)\n\t\t*child = f;\n\treturn pid;\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\npid_t\nsubprocess(const char *tag, struct passwd *pw, const char *command,\n    int ac, char **av, FILE **child, u_int flags)\n{\n\tFILE *f = NULL;\n\tstruct stat st;\n\tint fd, devnull, p[2], i;\n\tpid_t pid;\n\tchar *cp, errmsg[512];\n\tu_int envsize;\n\tchar **child_env;\n\n\tif (child != NULL)\n\t\t*child = NULL;\n\n\tdebug3(\"%s: %s command \\\"%s\\\" running as %s (flags 0x%x)\", __func__,\n\t    tag, command, pw->pw_name, flags);\n\n\t/* Check consistency */\n\tif ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0 &&\n\t    (flags & SSH_SUBPROCESS_STDOUT_CAPTURE) != 0) {\n\t\terror(\"%s: inconsistent flags\", __func__);\n\t\treturn 0;\n\t}\n\tif (((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0) != (child == NULL)) {\n\t\terror(\"%s: inconsistent flags/output\", __func__);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If executing an explicit binary, then verify the it exists\n\t * and appears safe-ish to execute\n\t */\n\tif (*av[0] != '/') {\n\t\terror(\"%s path is not absolute\", tag);\n\t\treturn 0;\n\t}\n\ttemporarily_use_uid(pw);\n\tif (stat(av[0], &st) < 0) {\n\t\terror(\"Could not stat %s \\\"%s\\\": %s\", tag,\n\t\t    av[0], strerror(errno));\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\tif (safe_path(av[0], &st, NULL, 0, errmsg, sizeof(errmsg)) != 0) {\n\t\terror(\"Unsafe %s \\\"%s\\\": %s\", tag, av[0], errmsg);\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\t/* Prepare to keep the child's stdout if requested */\n\tif (pipe(p) != 0) {\n\t\terror(\"%s: pipe: %s\", tag, strerror(errno));\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\trestore_uid();\n\n\tswitch ((pid = fork())) {\n\tcase -1: /* error */\n\t\terror(\"%s: fork: %s\", tag, strerror(errno));\n\t\tclose(p[0]);\n\t\tclose(p[1]);\n\t\treturn 0;\n\tcase 0: /* child */\n\t\t/* Prepare a minimal environment for the child. */\n\t\tenvsize = 5;\n\t\tchild_env = xcalloc(sizeof(*child_env), envsize);\n\t\tchild_set_env(&child_env, &envsize, \"PATH\", _PATH_STDPATH);\n\t\tchild_set_env(&child_env, &envsize, \"USER\", pw->pw_name);\n\t\tchild_set_env(&child_env, &envsize, \"LOGNAME\", pw->pw_name);\n\t\tchild_set_env(&child_env, &envsize, \"HOME\", pw->pw_dir);\n\t\tif ((cp = getenv(\"LANG\")) != NULL)\n\t\t\tchild_set_env(&child_env, &envsize, \"LANG\", cp);\n\n\t\tfor (i = 0; i < NSIG; i++)\n\t\t\tsignal(i, SIG_DFL);\n\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\t\terror(\"%s: open %s: %s\", tag, _PATH_DEVNULL,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (dup2(devnull, STDIN_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\n\t\t/* Set up stdout as requested; leave stderr in place for now. */\n\t\tfd = -1;\n\t\tif ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) != 0)\n\t\t\tfd = p[1];\n\t\telse if ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0)\n\t\t\tfd = devnull;\n\t\tif (fd != -1 && dup2(fd, STDOUT_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\t/* Don't use permanently_set_uid() here to avoid fatal() */\n\t\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0) {\n\t\t\terror(\"%s: setresgid %u: %s\", tag, (u_int)pw->pw_gid,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0) {\n\t\t\terror(\"%s: setresuid %u: %s\", tag, (u_int)pw->pw_uid,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\t/* stdin is pointed to /dev/null at this point */\n\t\tif ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0 &&\n\t\t    dup2(STDIN_FILENO, STDERR_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\n\t\texecve(av[0], av, child_env);\n\t\terror(\"%s exec \\\"%s\\\": %s\", tag, command, strerror(errno));\n\t\t_exit(127);\n\tdefault: /* parent */\n\t\tbreak;\n\t}\n\n\tclose(p[1]);\n\tif ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0)\n\t\tclose(p[0]);\n\telse if ((f = fdopen(p[0], \"r\")) == NULL) {\n\t\terror(\"%s: fdopen: %s\", tag, strerror(errno));\n\t\tclose(p[0]);\n\t\t/* Don't leave zombie child */\n\t\tkill(pid, SIGTERM);\n\t\twhile (waitpid(pid, NULL, 0) == -1 && errno == EINTR)\n\t\t\t;\n\t\treturn 0;\n\t}\n\t/* Success */\n\tdebug3(\"%s: %s pid %ld\", __func__, tag, (long)pid);\n\tif (child != NULL)\n\t\t*child = f;\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv_assemble",
          "args": [
            "ac",
            "av"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "argv_assemble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1681-1730",
          "snippet": "char *\nargv_assemble(int argc, char **argv)\n{\n\tint i, j, ws, r;\n\tchar c, *ret;\n\tstruct sshbuf *buf, *arg;\n\n\tif ((buf = sshbuf_new()) == NULL || (arg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tfor (i = 0; i < argc; i++) {\n\t\tws = 0;\n\t\tsshbuf_reset(arg);\n\t\tfor (j = 0; argv[i][j] != '\\0'; j++) {\n\t\t\tr = 0;\n\t\t\tc = argv[i][j];\n\t\t\tswitch (c) {\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\t\tws = 1;\n\t\t\t\tr = sshbuf_put_u8(arg, c);\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tif ((r = sshbuf_put_u8(arg, '\\\\')) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tr = sshbuf_put_u8(arg, c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (r != 0)\n\t\t\t\tfatal(\"%s: sshbuf_put_u8: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif ((i != 0 && (r = sshbuf_put_u8(buf, ' ')) != 0) ||\n\t\t    (ws != 0 && (r = sshbuf_put_u8(buf, '\"')) != 0) ||\n\t\t    (r = sshbuf_putb(buf, arg)) != 0 ||\n\t\t    (ws != 0 && (r = sshbuf_put_u8(buf, '\"')) != 0))\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif ((ret = malloc(sshbuf_len(buf) + 1)) == NULL)\n\t\tfatal(\"%s: malloc failed\", __func__);\n\tmemcpy(ret, sshbuf_ptr(buf), sshbuf_len(buf));\n\tret[sshbuf_len(buf)] = '\\0';\n\tsshbuf_free(buf);\n\tsshbuf_free(arg);\n\treturn ret;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nargv_assemble(int argc, char **argv)\n{\n\tint i, j, ws, r;\n\tchar c, *ret;\n\tstruct sshbuf *buf, *arg;\n\n\tif ((buf = sshbuf_new()) == NULL || (arg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tfor (i = 0; i < argc; i++) {\n\t\tws = 0;\n\t\tsshbuf_reset(arg);\n\t\tfor (j = 0; argv[i][j] != '\\0'; j++) {\n\t\t\tr = 0;\n\t\t\tc = argv[i][j];\n\t\t\tswitch (c) {\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\t\tws = 1;\n\t\t\t\tr = sshbuf_put_u8(arg, c);\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tif ((r = sshbuf_put_u8(arg, '\\\\')) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tr = sshbuf_put_u8(arg, c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (r != 0)\n\t\t\t\tfatal(\"%s: sshbuf_put_u8: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif ((i != 0 && (r = sshbuf_put_u8(buf, ' ')) != 0) ||\n\t\t    (ws != 0 && (r = sshbuf_put_u8(buf, '\"')) != 0) ||\n\t\t    (r = sshbuf_putb(buf, arg)) != 0 ||\n\t\t    (ws != 0 && (r = sshbuf_put_u8(buf, '\"')) != 0))\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif ((ret = malloc(sshbuf_len(buf) + 1)) == NULL)\n\t\tfatal(\"%s: malloc failed\", __func__);\n\tmemcpy(ret, sshbuf_ptr(buf), sshbuf_len(buf));\n\tret[sshbuf_len(buf)] = '\\0';\n\tsshbuf_free(buf);\n\tsshbuf_free(arg);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: percent_expand failed\"",
            "__func__"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percent_expand",
          "args": [
            "av[i]",
            "\"U\"",
            "uidstr",
            "\"u\"",
            "user_pw->pw_name",
            "\"h\"",
            "user_pw->pw_dir",
            "\"t\"",
            "sshkey_ssh_name(key)",
            "\"T\"",
            "sshkey_ssh_name(cert->signature_key)",
            "\"f\"",
            "key_fp",
            "\"F\"",
            "ca_fp",
            "\"k\"",
            "keytext",
            "\"K\"",
            "catext",
            "\"i\"",
            "cert->key_id",
            "\"s\"",
            "serial_s",
            "(char *)NULL"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "percent_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "973-1029",
          "snippet": "char *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define EXPAND_MAX_KEYS\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define EXPAND_MAX_KEYS\t16\n\nchar *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "cert->signature_key"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "uidstr",
            "sizeof(uidstr)",
            "\"%llu\"",
            "(unsigned long long)user_pw->pw_uid"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: sshkey_to_base64 failed: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_to_base64",
          "args": [
            "key",
            "&keytext"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_to_base64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1382-1409",
          "snippet": "int\nsshkey_to_base64(const struct sshkey *key, char **b64p)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\tchar *uu = NULL;\n\n\tif (b64p != NULL)\n\t\t*b64p = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_putb(key, b)) != 0)\n\t\tgoto out;\n\tif ((uu = sshbuf_dtob64(b)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tif (b64p != NULL) {\n\t\t*b64p = uu;\n\t\tuu = NULL;\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tfree(uu);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_base64(const struct sshkey *key, char **b64p)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\tchar *uu = NULL;\n\n\tif (b64p != NULL)\n\t\t*b64p = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_putb(key, b)) != 0)\n\t\tgoto out;\n\tif ((uu = sshbuf_dtob64(b)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tif (b64p != NULL) {\n\t\t*b64p = uu;\n\t\tuu = NULL;\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tfree(uu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "key",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv_split",
          "args": [
            "options.authorized_principals_command",
            "&ac",
            "&av"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "argv_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1607-1675",
          "snippet": "int\nargv_split(const char *s, int *argcp, char ***argvp)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tint argc = 0, quote, i, j;\n\tchar *arg, **argv = xcalloc(1, sizeof(*argv));\n\n\t*argvp = NULL;\n\t*argcp = 0;\n\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\t/* Skip leading whitespace */\n\t\tif (s[i] == ' ' || s[i] == '\\t')\n\t\t\tcontinue;\n\n\t\t/* Start of a token */\n\t\tquote = 0;\n\t\tif (s[i] == '\\\\' &&\n\t\t    (s[i + 1] == '\\'' || s[i + 1] == '\\\"' || s[i + 1] == '\\\\'))\n\t\t\ti++;\n\t\telse if (s[i] == '\\'' || s[i] == '\"')\n\t\t\tquote = s[i++];\n\n\t\targv = xreallocarray(argv, (argc + 2), sizeof(*argv));\n\t\targ = argv[argc++] = xcalloc(1, strlen(s + i) + 1);\n\t\targv[argc] = NULL;\n\n\t\t/* Copy the token in, removing escapes */\n\t\tfor (j = 0; s[i] != '\\0'; i++) {\n\t\t\tif (s[i] == '\\\\') {\n\t\t\t\tif (s[i + 1] == '\\'' ||\n\t\t\t\t    s[i + 1] == '\\\"' ||\n\t\t\t\t    s[i + 1] == '\\\\') {\n\t\t\t\t\ti++; /* Skip '\\' */\n\t\t\t\t\targ[j++] = s[i];\n\t\t\t\t} else {\n\t\t\t\t\t/* Unrecognised escape */\n\t\t\t\t\targ[j++] = s[i];\n\t\t\t\t}\n\t\t\t} else if (quote == 0 && (s[i] == ' ' || s[i] == '\\t'))\n\t\t\t\tbreak; /* done */\n\t\t\telse if (quote != 0 && s[i] == quote)\n\t\t\t\tbreak; /* done */\n\t\t\telse\n\t\t\t\targ[j++] = s[i];\n\t\t}\n\t\tif (s[i] == '\\0') {\n\t\t\tif (quote != 0) {\n\t\t\t\t/* Ran out of string looking for close quote */\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Success */\n\t*argcp = argc;\n\t*argvp = argv;\n\targc = 0;\n\targv = NULL;\n\tr = 0;\n out:\n\tif (argc != 0 && argv != NULL) {\n\t\tfor (i = 0; i < argc; i++)\n\t\t\tfree(argv[i]);\n\t\tfree(argv);\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nargv_split(const char *s, int *argcp, char ***argvp)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tint argc = 0, quote, i, j;\n\tchar *arg, **argv = xcalloc(1, sizeof(*argv));\n\n\t*argvp = NULL;\n\t*argcp = 0;\n\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\t/* Skip leading whitespace */\n\t\tif (s[i] == ' ' || s[i] == '\\t')\n\t\t\tcontinue;\n\n\t\t/* Start of a token */\n\t\tquote = 0;\n\t\tif (s[i] == '\\\\' &&\n\t\t    (s[i + 1] == '\\'' || s[i + 1] == '\\\"' || s[i + 1] == '\\\\'))\n\t\t\ti++;\n\t\telse if (s[i] == '\\'' || s[i] == '\"')\n\t\t\tquote = s[i++];\n\n\t\targv = xreallocarray(argv, (argc + 2), sizeof(*argv));\n\t\targ = argv[argc++] = xcalloc(1, strlen(s + i) + 1);\n\t\targv[argc] = NULL;\n\n\t\t/* Copy the token in, removing escapes */\n\t\tfor (j = 0; s[i] != '\\0'; i++) {\n\t\t\tif (s[i] == '\\\\') {\n\t\t\t\tif (s[i + 1] == '\\'' ||\n\t\t\t\t    s[i + 1] == '\\\"' ||\n\t\t\t\t    s[i + 1] == '\\\\') {\n\t\t\t\t\ti++; /* Skip '\\' */\n\t\t\t\t\targ[j++] = s[i];\n\t\t\t\t} else {\n\t\t\t\t\t/* Unrecognised escape */\n\t\t\t\t\targ[j++] = s[i];\n\t\t\t\t}\n\t\t\t} else if (quote == 0 && (s[i] == ' ' || s[i] == '\\t'))\n\t\t\t\tbreak; /* done */\n\t\t\telse if (quote != 0 && s[i] == quote)\n\t\t\t\tbreak; /* done */\n\t\t\telse\n\t\t\t\targ[j++] = s[i];\n\t\t}\n\t\tif (s[i] == '\\0') {\n\t\t\tif (quote != 0) {\n\t\t\t\t/* Ran out of string looking for close quote */\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Success */\n\t*argcp = argc;\n\t*argvp = argv;\n\targc = 0;\n\targv = NULL;\n\tr = 0;\n out:\n\tif (argc != 0 && argv != NULL) {\n\t\tfor (i = 0; i < argc; i++)\n\t\t\tfree(argv[i]);\n\t\tfree(argv);\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "username"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "getpwnamallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "560-632",
          "snippet": "struct passwd *\ngetpwnamallow(const char *user)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n#ifdef HAVE_LOGIN_CAP\n\textern login_cap_t *lc;\n#ifdef BSD_AUTH\n\tauth_session_t *as;\n#endif\n#endif\n\tstruct passwd *pw;\n\tstruct connection_info *ci = get_connection_info(1, options.use_dns);\n\n\tci->user = user;\n\tparse_server_match_config(&options, ci);\n\tlog_change_level(options.log_level);\n\tprocess_permitopen(ssh, &options);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_setauthdb(user);\n#endif\n\n\tpw = getpwnam(user);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_restoreauthdb();\n#endif\n#ifdef HAVE_CYGWIN\n\t/*\n\t * Windows usernames are case-insensitive.  To avoid later problems\n\t * when trying to match the username, the user is only allowed to\n\t * login if the username is given in the same case as stored in the\n\t * user database.\n\t */\n\tif (pw != NULL && strcmp(user, pw->pw_name) != 0) {\n\t\tlogit(\"Login name %.100s does not match stored username %.100s\",\n\t\t    user, pw->pw_name);\n\t\tpw = NULL;\n\t}\n#endif\n\tif (pw == NULL) {\n\t\tlogit(\"Invalid user %.100s from %.100s port %d\",\n\t\t    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#ifdef CUSTOM_FAILED_LOGIN\n\t\trecord_failed_login(user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(SSH_INVALID_USER);\n#endif /* SSH_AUDIT_EVENTS */\n\t\treturn (NULL);\n\t}\n\tif (!allowed_user(pw))\n\t\treturn (NULL);\n#ifdef HAVE_LOGIN_CAP\n\tif ((lc = login_getclass(pw->pw_class)) == NULL) {\n\t\tdebug(\"unable to get login class: %s\", user);\n\t\treturn (NULL);\n\t}\n#ifdef BSD_AUTH\n\tif ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||\n\t    auth_approval(as, lc, pw->pw_name, \"ssh\") <= 0) {\n\t\tdebug(\"Approval failure for %s\", user);\n\t\tpw = NULL;\n\t}\n\tif (as != NULL)\n\t\tauth_close(as);\n#endif\n#endif\n\tif (pw != NULL)\n\t\treturn (pwcopy(pw));\n\treturn (NULL);\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstruct passwd *\ngetpwnamallow(const char *user)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n#ifdef HAVE_LOGIN_CAP\n\textern login_cap_t *lc;\n#ifdef BSD_AUTH\n\tauth_session_t *as;\n#endif\n#endif\n\tstruct passwd *pw;\n\tstruct connection_info *ci = get_connection_info(1, options.use_dns);\n\n\tci->user = user;\n\tparse_server_match_config(&options, ci);\n\tlog_change_level(options.log_level);\n\tprocess_permitopen(ssh, &options);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_setauthdb(user);\n#endif\n\n\tpw = getpwnam(user);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_restoreauthdb();\n#endif\n#ifdef HAVE_CYGWIN\n\t/*\n\t * Windows usernames are case-insensitive.  To avoid later problems\n\t * when trying to match the username, the user is only allowed to\n\t * login if the username is given in the same case as stored in the\n\t * user database.\n\t */\n\tif (pw != NULL && strcmp(user, pw->pw_name) != 0) {\n\t\tlogit(\"Login name %.100s does not match stored username %.100s\",\n\t\t    user, pw->pw_name);\n\t\tpw = NULL;\n\t}\n#endif\n\tif (pw == NULL) {\n\t\tlogit(\"Invalid user %.100s from %.100s port %d\",\n\t\t    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#ifdef CUSTOM_FAILED_LOGIN\n\t\trecord_failed_login(user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(SSH_INVALID_USER);\n#endif /* SSH_AUDIT_EVENTS */\n\t\treturn (NULL);\n\t}\n\tif (!allowed_user(pw))\n\t\treturn (NULL);\n#ifdef HAVE_LOGIN_CAP\n\tif ((lc = login_getclass(pw->pw_class)) == NULL) {\n\t\tdebug(\"unable to get login class: %s\", user);\n\t\treturn (NULL);\n\t}\n#ifdef BSD_AUTH\n\tif ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||\n\t    auth_approval(as, lc, pw->pw_name, \"ssh\") <= 0) {\n\t\tdebug(\"Approval failure for %s\", user);\n\t\tpw = NULL;\n\t}\n\tif (as != NULL)\n\t\tauth_close(as);\n#endif\n#endif\n\tif (pw != NULL)\n\t\treturn (pwcopy(pw));\n\treturn (NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\nmatch_principals_command(struct ssh *ssh, struct passwd *user_pw,\n    const struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tstruct passwd *runas_pw = NULL;\n\tconst struct sshkey_cert *cert = key->cert;\n\tFILE *f = NULL;\n\tint r, ok, found_principal = 0;\n\tint i, ac = 0, uid_swapped = 0;\n\tpid_t pid;\n\tchar *tmp, *username = NULL, *command = NULL, **av = NULL;\n\tchar *ca_fp = NULL, *key_fp = NULL, *catext = NULL, *keytext = NULL;\n\tchar serial_s[16], uidstr[32];\n\tvoid (*osigchld)(int);\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\tif (options.authorized_principals_command == NULL)\n\t\treturn 0;\n\tif (options.authorized_principals_command_user == NULL) {\n\t\terror(\"No user for AuthorizedPrincipalsCommand specified, \"\n\t\t    \"skipping\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * NB. all returns later this function should go via \"out\" to\n\t * ensure the original SIGCHLD handler is restored properly.\n\t */\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\n\t/* Prepare and verify the user for the command */\n\tusername = percent_expand(options.authorized_principals_command_user,\n\t    \"u\", user_pw->pw_name, (char *)NULL);\n\trunas_pw = getpwnam(username);\n\tif (runas_pw == NULL) {\n\t\terror(\"AuthorizedPrincipalsCommandUser \\\"%s\\\" not found: %s\",\n\t\t    username, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* Turn the command into an argument vector */\n\tif (argv_split(options.authorized_principals_command, &ac, &av) != 0) {\n\t\terror(\"AuthorizedPrincipalsCommand \\\"%s\\\" contains \"\n\t\t    \"invalid quotes\", command);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"AuthorizedPrincipalsCommand \\\"%s\\\" yielded no arguments\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tif ((ca_fp = sshkey_fingerprint(cert->signature_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((key_fp = sshkey_fingerprint(key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(cert->signature_key, &catext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(key, &keytext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tsnprintf(serial_s, sizeof(serial_s), \"%llu\",\n\t    (unsigned long long)cert->serial);\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)user_pw->pw_uid);\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_expand(av[i],\n\t\t    \"U\", uidstr,\n\t\t    \"u\", user_pw->pw_name,\n\t\t    \"h\", user_pw->pw_dir,\n\t\t    \"t\", sshkey_ssh_name(key),\n\t\t    \"T\", sshkey_ssh_name(cert->signature_key),\n\t\t    \"f\", key_fp,\n\t\t    \"F\", ca_fp,\n\t\t    \"k\", keytext,\n\t\t    \"K\", catext,\n\t\t    \"i\", cert->key_id,\n\t\t    \"s\", serial_s,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal(\"%s: percent_expand failed\", __func__);\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t/* Prepare a printable command for logs, etc. */\n\tcommand = argv_assemble(ac, av);\n\n\tif ((pid = subprocess(\"AuthorizedPrincipalsCommand\", runas_pw, command,\n\t    ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD)) == 0)\n\t\tgoto out;\n\n\tuid_swapped = 1;\n\ttemporarily_use_uid(runas_pw);\n\n\tok = process_principals(ssh, f, \"(command)\", cert, authoptsp);\n\n\tfclose(f);\n\tf = NULL;\n\n\tif (exited_cleanly(pid, \"AuthorizedPrincipalsCommand\", command, 0) != 0)\n\t\tgoto out;\n\n\t/* Read completed successfully */\n\tfound_principal = ok;\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tsignal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tif (uid_swapped)\n\t\trestore_uid();\n\tfree(command);\n\tfree(username);\n\tfree(ca_fp);\n\tfree(key_fp);\n\tfree(catext);\n\tfree(keytext);\n\treturn found_principal;\n}"
  },
  {
    "function_name": "match_principals_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "367-387",
    "snippet": "static int\nmatch_principals_file(struct ssh *ssh, struct passwd *pw, char *file,\n    struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tFILE *f;\n\tint success;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\ttemporarily_use_uid(pw);\n\tdebug(\"trying authorized principals file %s\", file);\n\tif ((f = auth_openprincipals(file, pw, options.strict_modes)) == NULL) {\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\tsuccess = process_principals(ssh, f, file, cert, authoptsp);\n\tfclose(f);\n\trestore_uid();\n\treturn success;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "restore_uid",
          "args": [],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "restore_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "141-172",
          "snippet": "void\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_principals",
          "args": [
            "ssh",
            "f",
            "file",
            "cert",
            "authoptsp"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "process_principals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "330-363",
          "snippet": "static int\nprocess_principals(struct ssh *ssh, FILE *f, const char *file,\n    const struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tchar loc[256], *line = NULL, *cp, *ep;\n\tsize_t linesize = 0;\n\tu_long linenum = 0;\n\tu_int found_principal = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire input */\n\t\tif (found_principal)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace. */\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\t/* Skip blank and comment lines. */\n\t\tif ((ep = strchr(cp, '#')) != NULL)\n\t\t\t*ep = '\\0';\n\t\tif (!*cp || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_principals_line(ssh, cp, cert, loc, authoptsp) == 0)\n\t\t\tfound_principal = 1;\n\t}\n\tfree(line);\n\treturn found_principal;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nprocess_principals(struct ssh *ssh, FILE *f, const char *file,\n    const struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tchar loc[256], *line = NULL, *cp, *ep;\n\tsize_t linesize = 0;\n\tu_long linenum = 0;\n\tu_int found_principal = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire input */\n\t\tif (found_principal)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace. */\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\t/* Skip blank and comment lines. */\n\t\tif ((ep = strchr(cp, '#')) != NULL)\n\t\t\t*ep = '\\0';\n\t\tif (!*cp || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_principals_line(ssh, cp, cert, loc, authoptsp) == 0)\n\t\t\tfound_principal = 1;\n\t}\n\tfree(line);\n\treturn found_principal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_openprincipals",
          "args": [
            "file",
            "pw",
            "options.strict_modes"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "auth_openprincipals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "553-558",
          "snippet": "FILE *\nauth_openprincipals(const char *file, struct passwd *pw, int strict_modes)\n{\n\treturn auth_openfile(file, pw, strict_modes, 0,\n\t    \"authorized principals\");\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nFILE *\nauth_openprincipals(const char *file, struct passwd *pw, int strict_modes)\n{\n\treturn auth_openfile(file, pw, strict_modes, 0,\n\t    \"authorized principals\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"trying authorized principals file %s\"",
            "file"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "temporarily_use_uid",
          "args": [
            "pw"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "temporarily_use_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "60-136",
          "snippet": "void\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static uid_t\tuser_groups_uid;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\nmatch_principals_file(struct ssh *ssh, struct passwd *pw, char *file,\n    struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tFILE *f;\n\tint success;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\ttemporarily_use_uid(pw);\n\tdebug(\"trying authorized principals file %s\", file);\n\tif ((f = auth_openprincipals(file, pw, options.strict_modes)) == NULL) {\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\tsuccess = process_principals(ssh, f, file, cert, authoptsp);\n\tfclose(f);\n\trestore_uid();\n\treturn success;\n}"
  },
  {
    "function_name": "process_principals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "330-363",
    "snippet": "static int\nprocess_principals(struct ssh *ssh, FILE *f, const char *file,\n    const struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tchar loc[256], *line = NULL, *cp, *ep;\n\tsize_t linesize = 0;\n\tu_long linenum = 0;\n\tu_int found_principal = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire input */\n\t\tif (found_principal)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace. */\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\t/* Skip blank and comment lines. */\n\t\tif ((ep = strchr(cp, '#')) != NULL)\n\t\t\t*ep = '\\0';\n\t\tif (!*cp || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_principals_line(ssh, cp, cert, loc, authoptsp) == 0)\n\t\t\tfound_principal = 1;\n\t}\n\tfree(line);\n\treturn found_principal;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_principals_line",
          "args": [
            "ssh",
            "cp",
            "cert",
            "loc",
            "authoptsp"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "check_principals_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "280-328",
          "snippet": "static int\ncheck_principals_line(struct ssh *ssh, char *cp, const struct sshkey_cert *cert,\n    const char *loc, struct sshauthopt **authoptsp)\n{\n\tu_int i, found = 0;\n\tchar *ep, *line_opts;\n\tconst char *reason = NULL;\n\tstruct sshauthopt *opts = NULL;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\t/* Trim trailing whitespace. */\n\tep = cp + strlen(cp) - 1;\n\twhile (ep > cp && (*ep == '\\n' || *ep == ' ' || *ep == '\\t'))\n\t\t*ep-- = '\\0';\n\n\t/*\n\t * If the line has internal whitespace then assume it has\n\t * key options.\n\t */\n\tline_opts = NULL;\n\tif ((ep = strrchr(cp, ' ')) != NULL ||\n\t    (ep = strrchr(cp, '\\t')) != NULL) {\n\t\tfor (; *ep == ' ' || *ep == '\\t'; ep++)\n\t\t\t;\n\t\tline_opts = cp;\n\t\tcp = ep;\n\t}\n\tif ((opts = sshauthopt_parse(line_opts, &reason)) == NULL) {\n\t\tdebug(\"%s: bad principals options: %s\", loc, reason);\n\t\tauth_debug_add(\"%s: bad principals options: %s\", loc, reason);\n\t\treturn -1;\n\t}\n\t/* Check principals in cert against those on line */\n\tfor (i = 0; i < cert->nprincipals; i++) {\n\t\tif (strcmp(cp, cert->principals[i]) != 0)\n\t\t\tcontinue;\n\t\tdebug3(\"%s: matched principal \\\"%.100s\\\"\",\n\t\t    loc, cert->principals[i]);\n\t\tfound = 1;\n\t}\n\tif (found && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn found ? 0 : -1;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\ncheck_principals_line(struct ssh *ssh, char *cp, const struct sshkey_cert *cert,\n    const char *loc, struct sshauthopt **authoptsp)\n{\n\tu_int i, found = 0;\n\tchar *ep, *line_opts;\n\tconst char *reason = NULL;\n\tstruct sshauthopt *opts = NULL;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\t/* Trim trailing whitespace. */\n\tep = cp + strlen(cp) - 1;\n\twhile (ep > cp && (*ep == '\\n' || *ep == ' ' || *ep == '\\t'))\n\t\t*ep-- = '\\0';\n\n\t/*\n\t * If the line has internal whitespace then assume it has\n\t * key options.\n\t */\n\tline_opts = NULL;\n\tif ((ep = strrchr(cp, ' ')) != NULL ||\n\t    (ep = strrchr(cp, '\\t')) != NULL) {\n\t\tfor (; *ep == ' ' || *ep == '\\t'; ep++)\n\t\t\t;\n\t\tline_opts = cp;\n\t\tcp = ep;\n\t}\n\tif ((opts = sshauthopt_parse(line_opts, &reason)) == NULL) {\n\t\tdebug(\"%s: bad principals options: %s\", loc, reason);\n\t\tauth_debug_add(\"%s: bad principals options: %s\", loc, reason);\n\t\treturn -1;\n\t}\n\t/* Check principals in cert against those on line */\n\tfor (i = 0; i < cert->nprincipals; i++) {\n\t\tif (strcmp(cp, cert->principals[i]) != 0)\n\t\t\tcontinue;\n\t\tdebug3(\"%s: matched principal \\\"%.100s\\\"\",\n\t\t    loc, cert->principals[i]);\n\t\tfound = 1;\n\t}\n\tif (found && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn found ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "loc",
            "sizeof(loc)",
            "\"%.200s:%lu\"",
            "file",
            "linenum"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "'#'"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&linesize",
            "f"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-getline.c",
          "lines": "92-96",
          "snippet": "ssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"file.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"file.h\"\n#include \"includes.h\"\n\nssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nprocess_principals(struct ssh *ssh, FILE *f, const char *file,\n    const struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tchar loc[256], *line = NULL, *cp, *ep;\n\tsize_t linesize = 0;\n\tu_long linenum = 0;\n\tu_int found_principal = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire input */\n\t\tif (found_principal)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace. */\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\t/* Skip blank and comment lines. */\n\t\tif ((ep = strchr(cp, '#')) != NULL)\n\t\t\t*ep = '\\0';\n\t\tif (!*cp || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_principals_line(ssh, cp, cert, loc, authoptsp) == 0)\n\t\t\tfound_principal = 1;\n\t}\n\tfree(line);\n\treturn found_principal;\n}"
  },
  {
    "function_name": "check_principals_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "280-328",
    "snippet": "static int\ncheck_principals_line(struct ssh *ssh, char *cp, const struct sshkey_cert *cert,\n    const char *loc, struct sshauthopt **authoptsp)\n{\n\tu_int i, found = 0;\n\tchar *ep, *line_opts;\n\tconst char *reason = NULL;\n\tstruct sshauthopt *opts = NULL;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\t/* Trim trailing whitespace. */\n\tep = cp + strlen(cp) - 1;\n\twhile (ep > cp && (*ep == '\\n' || *ep == ' ' || *ep == '\\t'))\n\t\t*ep-- = '\\0';\n\n\t/*\n\t * If the line has internal whitespace then assume it has\n\t * key options.\n\t */\n\tline_opts = NULL;\n\tif ((ep = strrchr(cp, ' ')) != NULL ||\n\t    (ep = strrchr(cp, '\\t')) != NULL) {\n\t\tfor (; *ep == ' ' || *ep == '\\t'; ep++)\n\t\t\t;\n\t\tline_opts = cp;\n\t\tcp = ep;\n\t}\n\tif ((opts = sshauthopt_parse(line_opts, &reason)) == NULL) {\n\t\tdebug(\"%s: bad principals options: %s\", loc, reason);\n\t\tauth_debug_add(\"%s: bad principals options: %s\", loc, reason);\n\t\treturn -1;\n\t}\n\t/* Check principals in cert against those on line */\n\tfor (i = 0; i < cert->nprincipals; i++) {\n\t\tif (strcmp(cp, cert->principals[i]) != 0)\n\t\t\tcontinue;\n\t\tdebug3(\"%s: matched principal \\\"%.100s\\\"\",\n\t\t    loc, cert->principals[i]);\n\t\tfound = 1;\n\t}\n\tif (found && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn found ? 0 : -1;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshauthopt_free",
          "args": [
            "opts"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: matched principal \\\"%.100s\\\"\"",
            "loc",
            "cert->principals[i]"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cp",
            "cert->principals[i]"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_debug_add",
          "args": [
            "\"%s: bad principals options: %s\"",
            "loc",
            "reason"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "673-688",
          "snippet": "void\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_parse",
          "args": [
            "line_opts",
            "&reason"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "383-539",
          "snippet": "struct sshauthopt *\nsshauthopt_parse(const char *opts, const char **errstrp)\n{\n\tchar **oarray, *opt, *cp, *tmp;\n\tint r;\n\tstruct sshauthopt *ret = NULL;\n\tconst char *errstr = \"unknown error\";\n\tuint64_t valid_before;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\tif ((ret = sshauthopt_new_with_keys_defaults()) == NULL)\n\t\tgoto alloc_fail;\n\n\tif (opts == NULL)\n\t\treturn ret;\n\n\twhile (*opts && *opts != ' ' && *opts != '\\t') {\n\t\t/* flag options */\n\t\tif ((r = opt_flag(\"restrict\", 0, &opts)) != -1) {\n\t\t\tret->restricted = 1;\n\t\t\tret->permit_port_forwarding_flag = 0;\n\t\t\tret->permit_agent_forwarding_flag = 0;\n\t\t\tret->permit_x11_forwarding_flag = 0;\n\t\t\tret->permit_pty_flag = 0;\n\t\t\tret->permit_user_rc = 0;\n\t\t} else if ((r = opt_flag(\"cert-authority\", 0, &opts)) != -1) {\n\t\t\tret->cert_authority = r;\n\t\t} else if ((r = opt_flag(\"port-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_port_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"agent-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_agent_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"x11-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_x11_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"pty\", 1, &opts)) != -1) {\n\t\t\tret->permit_pty_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"user-rc\", 1, &opts)) != -1) {\n\t\t\tret->permit_user_rc = r == 1;\n\t\t} else if (opt_match(&opts, \"command\")) {\n\t\t\tif (ret->force_command != NULL) {\n\t\t\t\terrstr = \"multiple \\\"command\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->force_command = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"principals\")) {\n\t\t\tif (ret->cert_principals != NULL) {\n\t\t\t\terrstr = \"multiple \\\"principals\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->cert_principals = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->cert_principals == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"from\")) {\n\t\t\tif (ret->required_from_host_keys != NULL) {\n\t\t\t\terrstr = \"multiple \\\"from\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->required_from_host_keys = opt_dequote(&opts,\n\t\t\t    &errstr);\n\t\t\tif (ret->required_from_host_keys == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"expiry-time\")) {\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tif (parse_absolute_time(opt, &valid_before) != 0 ||\n\t\t\t    valid_before == 0) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid expires time\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(opt);\n\t\t\tif (ret->valid_before == 0 ||\n\t\t\t    valid_before < ret->valid_before)\n\t\t\t\tret->valid_before = valid_before;\n\t\t} else if (opt_match(&opts, \"environment\")) {\n\t\t\tif (ret->nenv > INT_MAX) {\n\t\t\t\terrstr = \"too many environment strings\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\t/* env name must be alphanumeric and followed by '=' */\n\t\t\tif ((tmp = strchr(opt, '=')) == NULL) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid environment string\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((cp = strdup(opt)) == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t\tcp[tmp - opt] = '\\0'; /* truncate at '=' */\n\t\t\tif (!valid_env_name(cp)) {\n\t\t\t\tfree(cp);\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid environment string\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(cp);\n\t\t\t/* Append it. */\n\t\t\toarray = ret->env;\n\t\t\tif ((ret->env = recallocarray(ret->env, ret->nenv,\n\t\t\t    ret->nenv + 1, sizeof(*ret->env))) == NULL) {\n\t\t\t\tfree(opt);\n\t\t\t\tret->env = oarray; /* put it back for cleanup */\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\tret->env[ret->nenv++] = opt;\n\t\t} else if (opt_match(&opts, \"permitopen\")) {\n\t\t\tif (handle_permit(&opts, 0, &ret->permitopen,\n\t\t\t    &ret->npermitopen, &errstr) != 0)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"permitlisten\")) {\n\t\t\tif (handle_permit(&opts, 1, &ret->permitlisten,\n\t\t\t    &ret->npermitlisten, &errstr) != 0)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"tunnel\")) {\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tret->force_tun_device = a2tun(opt, NULL);\n\t\t\tfree(opt);\n\t\t\tif (ret->force_tun_device == SSH_TUNID_ERR) {\n\t\t\t\terrstr = \"invalid tun device\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Skip the comma, and move to the next option\n\t\t * (or break out if there are no more).\n\t\t */\n\t\tif (*opts == '\\0' || *opts == ' ' || *opts == '\\t')\n\t\t\tbreak;\t\t/* End of options. */\n\t\t/* Anything other than a comma is an unknown option */\n\t\tif (*opts != ',') {\n\t\t\terrstr = \"unknown key option\";\n\t\t\tgoto fail;\n\t\t}\n\t\topts++;\n\t\tif (*opts == '\\0') {\n\t\t\terrstr = \"unexpected end-of-options\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* success */\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\nalloc_fail:\n\terrstr = \"memory allocation failed\";\nfail:\n\tsshauthopt_free(ret);\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\treturn NULL;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_parse(const char *opts, const char **errstrp)\n{\n\tchar **oarray, *opt, *cp, *tmp;\n\tint r;\n\tstruct sshauthopt *ret = NULL;\n\tconst char *errstr = \"unknown error\";\n\tuint64_t valid_before;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\tif ((ret = sshauthopt_new_with_keys_defaults()) == NULL)\n\t\tgoto alloc_fail;\n\n\tif (opts == NULL)\n\t\treturn ret;\n\n\twhile (*opts && *opts != ' ' && *opts != '\\t') {\n\t\t/* flag options */\n\t\tif ((r = opt_flag(\"restrict\", 0, &opts)) != -1) {\n\t\t\tret->restricted = 1;\n\t\t\tret->permit_port_forwarding_flag = 0;\n\t\t\tret->permit_agent_forwarding_flag = 0;\n\t\t\tret->permit_x11_forwarding_flag = 0;\n\t\t\tret->permit_pty_flag = 0;\n\t\t\tret->permit_user_rc = 0;\n\t\t} else if ((r = opt_flag(\"cert-authority\", 0, &opts)) != -1) {\n\t\t\tret->cert_authority = r;\n\t\t} else if ((r = opt_flag(\"port-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_port_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"agent-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_agent_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"x11-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_x11_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"pty\", 1, &opts)) != -1) {\n\t\t\tret->permit_pty_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"user-rc\", 1, &opts)) != -1) {\n\t\t\tret->permit_user_rc = r == 1;\n\t\t} else if (opt_match(&opts, \"command\")) {\n\t\t\tif (ret->force_command != NULL) {\n\t\t\t\terrstr = \"multiple \\\"command\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->force_command = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"principals\")) {\n\t\t\tif (ret->cert_principals != NULL) {\n\t\t\t\terrstr = \"multiple \\\"principals\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->cert_principals = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->cert_principals == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"from\")) {\n\t\t\tif (ret->required_from_host_keys != NULL) {\n\t\t\t\terrstr = \"multiple \\\"from\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->required_from_host_keys = opt_dequote(&opts,\n\t\t\t    &errstr);\n\t\t\tif (ret->required_from_host_keys == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"expiry-time\")) {\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tif (parse_absolute_time(opt, &valid_before) != 0 ||\n\t\t\t    valid_before == 0) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid expires time\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(opt);\n\t\t\tif (ret->valid_before == 0 ||\n\t\t\t    valid_before < ret->valid_before)\n\t\t\t\tret->valid_before = valid_before;\n\t\t} else if (opt_match(&opts, \"environment\")) {\n\t\t\tif (ret->nenv > INT_MAX) {\n\t\t\t\terrstr = \"too many environment strings\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\t/* env name must be alphanumeric and followed by '=' */\n\t\t\tif ((tmp = strchr(opt, '=')) == NULL) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid environment string\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((cp = strdup(opt)) == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t\tcp[tmp - opt] = '\\0'; /* truncate at '=' */\n\t\t\tif (!valid_env_name(cp)) {\n\t\t\t\tfree(cp);\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid environment string\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(cp);\n\t\t\t/* Append it. */\n\t\t\toarray = ret->env;\n\t\t\tif ((ret->env = recallocarray(ret->env, ret->nenv,\n\t\t\t    ret->nenv + 1, sizeof(*ret->env))) == NULL) {\n\t\t\t\tfree(opt);\n\t\t\t\tret->env = oarray; /* put it back for cleanup */\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\tret->env[ret->nenv++] = opt;\n\t\t} else if (opt_match(&opts, \"permitopen\")) {\n\t\t\tif (handle_permit(&opts, 0, &ret->permitopen,\n\t\t\t    &ret->npermitopen, &errstr) != 0)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"permitlisten\")) {\n\t\t\tif (handle_permit(&opts, 1, &ret->permitlisten,\n\t\t\t    &ret->npermitlisten, &errstr) != 0)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"tunnel\")) {\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tret->force_tun_device = a2tun(opt, NULL);\n\t\t\tfree(opt);\n\t\t\tif (ret->force_tun_device == SSH_TUNID_ERR) {\n\t\t\t\terrstr = \"invalid tun device\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Skip the comma, and move to the next option\n\t\t * (or break out if there are no more).\n\t\t */\n\t\tif (*opts == '\\0' || *opts == ' ' || *opts == '\\t')\n\t\t\tbreak;\t\t/* End of options. */\n\t\t/* Anything other than a comma is an unknown option */\n\t\tif (*opts != ',') {\n\t\t\terrstr = \"unknown key option\";\n\t\t\tgoto fail;\n\t\t}\n\t\topts++;\n\t\tif (*opts == '\\0') {\n\t\t\terrstr = \"unexpected end-of-options\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* success */\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\nalloc_fail:\n\terrstr = \"memory allocation failed\";\nfail:\n\tsshauthopt_free(ret);\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "cp",
            "'\\t'"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "cp",
            "' '"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\ncheck_principals_line(struct ssh *ssh, char *cp, const struct sshkey_cert *cert,\n    const char *loc, struct sshauthopt **authoptsp)\n{\n\tu_int i, found = 0;\n\tchar *ep, *line_opts;\n\tconst char *reason = NULL;\n\tstruct sshauthopt *opts = NULL;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\t/* Trim trailing whitespace. */\n\tep = cp + strlen(cp) - 1;\n\twhile (ep > cp && (*ep == '\\n' || *ep == ' ' || *ep == '\\t'))\n\t\t*ep-- = '\\0';\n\n\t/*\n\t * If the line has internal whitespace then assume it has\n\t * key options.\n\t */\n\tline_opts = NULL;\n\tif ((ep = strrchr(cp, ' ')) != NULL ||\n\t    (ep = strrchr(cp, '\\t')) != NULL) {\n\t\tfor (; *ep == ' ' || *ep == '\\t'; ep++)\n\t\t\t;\n\t\tline_opts = cp;\n\t\tcp = ep;\n\t}\n\tif ((opts = sshauthopt_parse(line_opts, &reason)) == NULL) {\n\t\tdebug(\"%s: bad principals options: %s\", loc, reason);\n\t\tauth_debug_add(\"%s: bad principals options: %s\", loc, reason);\n\t\treturn -1;\n\t}\n\t/* Check principals in cert against those on line */\n\tfor (i = 0; i < cert->nprincipals; i++) {\n\t\tif (strcmp(cp, cert->principals[i]) != 0)\n\t\t\tcontinue;\n\t\tdebug3(\"%s: matched principal \\\"%.100s\\\"\",\n\t\t    loc, cert->principals[i]);\n\t\tfound = 1;\n\t}\n\tif (found && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn found ? 0 : -1;\n}"
  },
  {
    "function_name": "match_principals_option",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "255-273",
    "snippet": "static int\nmatch_principals_option(const char *principal_list, struct sshkey_cert *cert)\n{\n\tchar *result;\n\tu_int i;\n\n\t/* XXX percent_expand() sequences for authorized_principals? */\n\n\tfor (i = 0; i < cert->nprincipals; i++) {\n\t\tif ((result = match_list(cert->principals[i],\n\t\t    principal_list, NULL)) != NULL) {\n\t\t\tdebug3(\"matched principal from key options \\\"%.100s\\\"\",\n\t\t\t    result);\n\t\t\tfree(result);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "result"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"matched principal from key options \\\"%.100s\\\"\"",
            "result"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_list",
          "args": [
            "cert->principals[i]",
            "principal_list",
            "NULL"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "match_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "256-294",
          "snippet": "char *\nmatch_list(const char *client, const char *server, u_int *next)\n{\n\tchar *sproposals[MAX_PROP];\n\tchar *c, *s, *p, *ret, *cp, *sp;\n\tint i, j, nproposals;\n\n\tc = cp = xstrdup(client);\n\ts = sp = xstrdup(server);\n\n\tfor ((p = strsep(&sp, SEP)), i=0; p && *p != '\\0';\n\t    (p = strsep(&sp, SEP)), i++) {\n\t\tif (i < MAX_PROP)\n\t\t\tsproposals[i] = p;\n\t\telse\n\t\t\tbreak;\n\t}\n\tnproposals = i;\n\n\tfor ((p = strsep(&cp, SEP)), i=0; p && *p != '\\0';\n\t    (p = strsep(&cp, SEP)), i++) {\n\t\tfor (j = 0; j < nproposals; j++) {\n\t\t\tif (strcmp(p, sproposals[j]) == 0) {\n\t\t\t\tret = xstrdup(p);\n\t\t\t\tif (next != NULL)\n\t\t\t\t\t*next = (cp == NULL) ?\n\t\t\t\t\t    strlen(c) : (u_int)(cp - c);\n\t\t\t\tfree(c);\n\t\t\t\tfree(s);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tif (next != NULL)\n\t\t*next = strlen(c);\n\tfree(c);\n\tfree(s);\n\treturn NULL;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tSEP\t\",\"",
            "#define\tMAX_PROP\t40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tSEP\t\",\"\n#define\tMAX_PROP\t40\n\nchar *\nmatch_list(const char *client, const char *server, u_int *next)\n{\n\tchar *sproposals[MAX_PROP];\n\tchar *c, *s, *p, *ret, *cp, *sp;\n\tint i, j, nproposals;\n\n\tc = cp = xstrdup(client);\n\ts = sp = xstrdup(server);\n\n\tfor ((p = strsep(&sp, SEP)), i=0; p && *p != '\\0';\n\t    (p = strsep(&sp, SEP)), i++) {\n\t\tif (i < MAX_PROP)\n\t\t\tsproposals[i] = p;\n\t\telse\n\t\t\tbreak;\n\t}\n\tnproposals = i;\n\n\tfor ((p = strsep(&cp, SEP)), i=0; p && *p != '\\0';\n\t    (p = strsep(&cp, SEP)), i++) {\n\t\tfor (j = 0; j < nproposals; j++) {\n\t\t\tif (strcmp(p, sproposals[j]) == 0) {\n\t\t\t\tret = xstrdup(p);\n\t\t\t\tif (next != NULL)\n\t\t\t\t\t*next = (cp == NULL) ?\n\t\t\t\t\t    strlen(c) : (u_int)(cp - c);\n\t\t\t\tfree(c);\n\t\t\t\tfree(s);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tif (next != NULL)\n\t\t*next = strlen(c);\n\tfree(c);\n\tfree(s);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic int\nmatch_principals_option(const char *principal_list, struct sshkey_cert *cert)\n{\n\tchar *result;\n\tu_int i;\n\n\t/* XXX percent_expand() sequences for authorized_principals? */\n\n\tfor (i = 0; i < cert->nprincipals; i++) {\n\t\tif ((result = match_list(cert->principals[i],\n\t\t    principal_list, NULL)) != NULL) {\n\t\t\tdebug3(\"matched principal from key options \\\"%.100s\\\"\",\n\t\t\t    result);\n\t\t\tfree(result);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "userauth_pubkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "87-253",
    "snippet": "static int\nuserauth_pubkey(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tstruct sshbuf *b = NULL;\n\tstruct sshkey *key = NULL;\n\tchar *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;\n\tu_char *pkblob = NULL, *sig = NULL, have_sig;\n\tsize_t blen, slen;\n\tint r, pktype;\n\tint authenticated = 0;\n\tstruct sshauthopt *authopts = NULL;\n\n\tif ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)\n\t\tfatal(\"%s: parse request failed: %s\", __func__, ssh_err(r));\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC) {\n\t\t/* this is perfectly legal */\n\t\tverbose(\"%s: unsupported public key algorithm: %s\",\n\t\t    __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror(\"%s: could not parse key: %s\", __func__, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif (key == NULL) {\n\t\terror(\"%s: cannot decode key: %s\", __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror(\"%s: type mismatch for decoded key \"\n\t\t    \"(received %d, expected %d)\", __func__, key->type, pktype);\n\t\tgoto done;\n\t}\n\tif (sshkey_type_plain(key->type) == KEY_RSA &&\n\t    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\tlogit(\"Refusing RSA key because client uses unsafe \"\n\t\t    \"signature scheme\");\n\t\tgoto done;\n\t}\n\tif (auth2_key_already_used(authctxt, key)) {\n\t\tlogit(\"refusing previously-used %s key\", sshkey_type(key));\n\t\tgoto done;\n\t}\n\tif (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {\n\t\tlogit(\"%s: key type %s not in PubkeyAcceptedKeyTypes\",\n\t\t    __func__, sshkey_ssh_name(key));\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_check_cert_sigtype(key,\n\t    options.ca_sign_algorithms)) != 0) {\n\t\tlogit(\"%s: certificate signature algorithm %s: %s\", __func__,\n\t\t    (key->cert == NULL || key->cert->signature_type == NULL) ?\n\t\t    \"(null)\" : key->cert->signature_type, ssh_err(r));\n\t\tgoto done;\n\t}\n\tkey_s = format_key(key);\n\tif (sshkey_is_cert(key))\n\t\tca_s = format_key(key->cert->signature_key);\n\n\tif (have_sig) {\n\t\tdebug3(\"%s: have %s signature for %s%s%s\",\n\t\t    __func__, pkalg, key_s,\n\t\t    ca_s == NULL ? \"\" : \" CA \",\n\t\t    ca_s == NULL ? \"\" : ca_s);\n\t\tif ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||\n\t\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tif (ssh->compat & SSH_OLD_SESSIONID) {\n\t\t\tif ((r = sshbuf_put(b, session_id2,\n\t\t\t    session_id2_len)) != 0)\n\t\t\t\tfatal(\"%s: sshbuf_put session id: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t} else {\n\t\t\tif ((r = sshbuf_put_string(b, session_id2,\n\t\t\t    session_id2_len)) != 0)\n\t\t\t\tfatal(\"%s: sshbuf_put_string session id: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\t\tdebug2(\"%s: disabled because of invalid user\",\n\t\t\t    __func__);\n\t\t\tgoto done;\n\t\t}\n\t\t/* reconstruct packet */\n\t\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t\t    authctxt->style ? \":\" : \"\",\n\t\t    authctxt->style ? authctxt->style : \"\");\n\t\tif ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, \"publickey\")) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, have_sig)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, pkalg)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, pkblob, blen)) != 0)\n\t\t\tfatal(\"%s: build packet failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n#ifdef DEBUG_PK\n\t\tsshbuf_dump(b, stderr);\n#endif\n\t\t/* test for correct signature */\n\t\tauthenticated = 0;\n\t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&\n\t\t    PRIVSEP(sshkey_verify(key, sig, slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b),\n\t\t    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,\n\t\t    ssh->compat)) == 0) {\n\t\t\tauthenticated = 1;\n\t\t}\n\t\tauth2_record_key(authctxt, authenticated, key);\n\t} else {\n\t\tdebug(\"%s: test pkalg %s pkblob %s%s%s\",\n\t\t    __func__, pkalg, key_s,\n\t\t    ca_s == NULL ? \"\" : \" CA \",\n\t\t    ca_s == NULL ? \"\" : ca_s);\n\n\t\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\t\tdebug2(\"%s: disabled because of invalid user\",\n\t\t\t    __func__);\n\t\t\tgoto done;\n\t\t}\n\t\t/* XXX fake reply and always send PK_OK ? */\n\t\t/*\n\t\t * XXX this allows testing whether a user is allowed\n\t\t * to login: if you happen to have a valid pubkey this\n\t\t * message is sent. the message is NEVER sent at all\n\t\t * if a user is not allowed to login. is this an\n\t\t * issue? -markus\n\t\t */\n\t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))\n\t\t\t    != 0 ||\n\t\t\t    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t\tauthctxt->postponed = 1;\n\t\t}\n\t}\ndone:\n\tif (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {\n\t\tdebug(\"%s: key options inconsistent with existing\", __func__);\n\t\tauthenticated = 0;\n\t}\n\tdebug2(\"%s: authenticated %d pkalg %s\", __func__, authenticated, pkalg);\n\n\tsshbuf_free(b);\n\tsshauthopt_free(authopts);\n\tsshkey_free(key);\n\tfree(userstyle);\n\tfree(pkalg);\n\tfree(pkblob);\n\tfree(key_s);\n\tfree(ca_s);\n\tfree(sig);\n\treturn authenticated;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "extern u_char *session_id2;",
      "extern u_int session_id2_len;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sig"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_free",
          "args": [
            "authopts"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: authenticated %d pkalg %s\"",
            "__func__",
            "authenticated",
            "pkalg"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: key options inconsistent with existing\"",
            "__func__"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_activate_options",
          "args": [
            "ssh",
            "authopts"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "auth_activate_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "1077-1089",
          "snippet": "int\nauth_activate_options(struct ssh *ssh, struct sshauthopt *opts)\n{\n\tstruct sshauthopt *old = auth_opts;\n\tconst char *emsg = NULL;\n\n\tdebug(\"%s: setting new authentication options\", __func__);\n\tif ((auth_opts = sshauthopt_merge(old, opts, &emsg)) == NULL) {\n\t\terror(\"Inconsistent authentication options: %s\", emsg);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern struct sshauthopt *auth_opts;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nint\nauth_activate_options(struct ssh *ssh, struct sshauthopt *opts)\n{\n\tstruct sshauthopt *old = auth_opts;\n\tconst char *emsg = NULL;\n\n\tdebug(\"%s: setting new authentication options\", __func__);\n\tif ((auth_opts = sshauthopt_merge(old, opts, &emsg)) == NULL) {\n\t\terror(\"Inconsistent authentication options: %s\", emsg);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_write_wait",
          "args": [
            "ssh"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_write_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1930-1985",
          "snippet": "int\nssh_packet_write_wait(struct ssh *ssh)\n{\n\tfd_set *setp;\n\tint ret, r, ms_remain = 0;\n\tstruct timeval start, timeout, *timeoutp = NULL;\n\tstruct session_state *state = ssh->state;\n\n\tsetp = calloc(howmany(state->connection_out + 1,\n\t    NFDBITS), sizeof(fd_mask));\n\tif (setp == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\tfree(setp);\n\t\treturn r;\n\t}\n\twhile (ssh_packet_have_data_to_write(ssh)) {\n\t\tmemset(setp, 0, howmany(state->connection_out + 1,\n\t\t    NFDBITS) * sizeof(fd_mask));\n\t\tFD_SET(state->connection_out, setp);\n\n\t\tif (state->packet_timeout_ms > 0) {\n\t\t\tms_remain = state->packet_timeout_ms;\n\t\t\ttimeoutp = &timeout;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (state->packet_timeout_ms != -1) {\n\t\t\t\tms_to_timeval(&timeout, ms_remain);\n\t\t\t\tmonotime_tv(&start);\n\t\t\t}\n\t\t\tif ((ret = select(state->connection_out + 1,\n\t\t\t    NULL, setp, NULL, timeoutp)) >= 0)\n\t\t\t\tbreak;\n\t\t\tif (errno != EAGAIN && errno != EINTR &&\n\t\t\t    errno != EWOULDBLOCK)\n\t\t\t\tbreak;\n\t\t\tif (state->packet_timeout_ms == -1)\n\t\t\t\tcontinue;\n\t\t\tms_subtract_diff(&start, &ms_remain);\n\t\t\tif (ms_remain <= 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tfree(setp);\n\t\t\treturn SSH_ERR_CONN_TIMEOUT;\n\t\t}\n\t\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\t\tfree(setp);\n\t\t\treturn r;\n\t\t}\n\t}\n\tfree(setp);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_write_wait(struct ssh *ssh)\n{\n\tfd_set *setp;\n\tint ret, r, ms_remain = 0;\n\tstruct timeval start, timeout, *timeoutp = NULL;\n\tstruct session_state *state = ssh->state;\n\n\tsetp = calloc(howmany(state->connection_out + 1,\n\t    NFDBITS), sizeof(fd_mask));\n\tif (setp == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\tfree(setp);\n\t\treturn r;\n\t}\n\twhile (ssh_packet_have_data_to_write(ssh)) {\n\t\tmemset(setp, 0, howmany(state->connection_out + 1,\n\t\t    NFDBITS) * sizeof(fd_mask));\n\t\tFD_SET(state->connection_out, setp);\n\n\t\tif (state->packet_timeout_ms > 0) {\n\t\t\tms_remain = state->packet_timeout_ms;\n\t\t\ttimeoutp = &timeout;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (state->packet_timeout_ms != -1) {\n\t\t\t\tms_to_timeval(&timeout, ms_remain);\n\t\t\t\tmonotime_tv(&start);\n\t\t\t}\n\t\t\tif ((ret = select(state->connection_out + 1,\n\t\t\t    NULL, setp, NULL, timeoutp)) >= 0)\n\t\t\t\tbreak;\n\t\t\tif (errno != EAGAIN && errno != EINTR &&\n\t\t\t    errno != EWOULDBLOCK)\n\t\t\t\tbreak;\n\t\t\tif (state->packet_timeout_ms == -1)\n\t\t\t\tcontinue;\n\t\t\tms_subtract_diff(&start, &ms_remain);\n\t\t\tif (ms_remain <= 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tfree(setp);\n\t\t\treturn SSH_ERR_CONN_TIMEOUT;\n\t\t}\n\t\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\t\tfree(setp);\n\t\t\treturn r;\n\t\t}\n\t}\n\tfree(setp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_string",
          "args": [
            "ssh",
            "pkblob",
            "blen"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2453-2457",
          "snippet": "int\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "pkalg"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_PK_OK"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "user_key_allowed(ssh, pw, key, 0, NULL)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_key_allowed",
          "args": [
            "ssh",
            "pw",
            "key",
            "0",
            "NULL"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "user_key_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "997-1039",
          "snippet": "int\nuser_key_allowed(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    int auth_attempt, struct sshauthopt **authoptsp)\n{\n\tu_int success, i;\n\tchar *file;\n\tstruct sshauthopt *opts = NULL;\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\tif (sshkey_is_cert(key) &&\n\t    auth_key_is_revoked(key->cert->signature_key))\n\t\treturn 0;\n\n\tif ((success = user_cert_trusted_ca(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tif ((success = user_key_command_allowed2(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tfor (i = 0; !success && i < options.num_authkeys_files; i++) {\n\t\tif (strcasecmp(options.authorized_keys_files[i], \"none\") == 0)\n\t\t\tcontinue;\n\t\tfile = expand_authorized_keys(\n\t\t    options.authorized_keys_files[i], pw);\n\t\tsuccess = user_key_allowed2(ssh, pw, key, file, &opts);\n\t\tfree(file);\n\t}\n\n out:\n\tif (success && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn success;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nint\nuser_key_allowed(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    int auth_attempt, struct sshauthopt **authoptsp)\n{\n\tu_int success, i;\n\tchar *file;\n\tstruct sshauthopt *opts = NULL;\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\tif (sshkey_is_cert(key) &&\n\t    auth_key_is_revoked(key->cert->signature_key))\n\t\treturn 0;\n\n\tif ((success = user_cert_trusted_ca(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tif ((success = user_key_command_allowed2(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tfor (i = 0; !success && i < options.num_authkeys_files; i++) {\n\t\tif (strcasecmp(options.authorized_keys_files[i], \"none\") == 0)\n\t\t\tcontinue;\n\t\tfile = expand_authorized_keys(\n\t\t    options.authorized_keys_files[i], pw);\n\t\tsuccess = user_key_allowed2(ssh, pw, key, file, &opts);\n\t\tfree(file);\n\t}\n\n out:\n\tif (success && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_end",
          "args": [
            "ssh"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2555-2561",
          "snippet": "int\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_record_key",
          "args": [
            "authctxt",
            "authenticated",
            "key"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_record_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "702-728",
          "snippet": "void\nauth2_record_key(Authctxt *authctxt, int authenticated,\n    const struct sshkey *key)\n{\n\tstruct sshkey **tmp, *dup;\n\tint r;\n\n\tif ((r = sshkey_from_private(key, &dup)) != 0)\n\t\tfatal(\"%s: copy key: %s\", __func__, ssh_err(r));\n\tsshkey_free(authctxt->auth_method_key);\n\tauthctxt->auth_method_key = dup;\n\n\tif (!authenticated)\n\t\treturn;\n\n\t/* If authenticated, make sure we don't accept this key again */\n\tif ((r = sshkey_from_private(key, &dup)) != 0)\n\t\tfatal(\"%s: copy key: %s\", __func__, ssh_err(r));\n\tif (authctxt->nprev_keys >= INT_MAX ||\n\t    (tmp = recallocarray(authctxt->prev_keys, authctxt->nprev_keys,\n\t    authctxt->nprev_keys + 1, sizeof(*authctxt->prev_keys))) == NULL)\n\t\tfatal(\"%s: reallocarray failed\", __func__);\n\tauthctxt->prev_keys = tmp;\n\tauthctxt->prev_keys[authctxt->nprev_keys] = dup;\n\tauthctxt->nprev_keys++;\n\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nvoid\nauth2_record_key(Authctxt *authctxt, int authenticated,\n    const struct sshkey *key)\n{\n\tstruct sshkey **tmp, *dup;\n\tint r;\n\n\tif ((r = sshkey_from_private(key, &dup)) != 0)\n\t\tfatal(\"%s: copy key: %s\", __func__, ssh_err(r));\n\tsshkey_free(authctxt->auth_method_key);\n\tauthctxt->auth_method_key = dup;\n\n\tif (!authenticated)\n\t\treturn;\n\n\t/* If authenticated, make sure we don't accept this key again */\n\tif ((r = sshkey_from_private(key, &dup)) != 0)\n\t\tfatal(\"%s: copy key: %s\", __func__, ssh_err(r));\n\tif (authctxt->nprev_keys >= INT_MAX ||\n\t    (tmp = recallocarray(authctxt->prev_keys, authctxt->nprev_keys,\n\t    authctxt->nprev_keys + 1, sizeof(*authctxt->prev_keys))) == NULL)\n\t\tfatal(\"%s: reallocarray failed\", __func__);\n\tauthctxt->prev_keys = tmp;\n\tauthctxt->prev_keys[authctxt->nprev_keys] = dup;\n\tauthctxt->nprev_keys++;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "sshkey_verify(key, sig, slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b),\n\t\t    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,\n\t\t    ssh->compat)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_verify",
          "args": [
            "key",
            "sig",
            "slen",
            "sshbuf_ptr(b)",
            "sshbuf_len(b)",
            "(ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL",
            "ssh->compat"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2427-2459",
          "snippet": "int\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "b"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "user_key_allowed(ssh, pw, key, 1, &authopts)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_dump",
          "args": [
            "b",
            "stderr"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "65-70",
          "snippet": "void\nsshbuf_dump(struct sshbuf *buf, FILE *f)\n{\n\tfprintf(f, \"buffer %p len = %zu\\n\", buf, sshbuf_len(buf));\n\tsshbuf_dump_data(sshbuf_ptr(buf), sshbuf_len(buf), f);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_dump(struct sshbuf *buf, FILE *f)\n{\n\tfprintf(f, \"buffer %p len = %zu\\n\", buf, sshbuf_len(buf));\n\tsshbuf_dump_data(sshbuf_ptr(buf), sshbuf_len(buf), f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "b",
            "pkblob",
            "blen"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "b",
            "pkalg"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "b",
            "have_sig"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&userstyle",
            "\"%s%s%s\"",
            "authctxt->user",
            "authctxt->style ? \":\" : \"\"",
            "authctxt->style ? authctxt->style : \"\""
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "b",
            "session_id2",
            "session_id2_len"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string",
          "args": [
            "ssh",
            "&sig",
            "&slen"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_key",
          "args": [
            "key->cert->signature_key"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "format_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "76-85",
          "snippet": "static char *\nformat_key(const struct sshkey *key)\n{\n\tchar *ret, *fp = sshkey_fingerprint(key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\n\txasprintf(&ret, \"%s %s\", sshkey_type(key), fp);\n\tfree(fp);\n\treturn ret;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic char *\nformat_key(const struct sshkey *key)\n{\n\tchar *ret, *fp = sshkey_fingerprint(key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\n\txasprintf(&ret, \"%s %s\", sshkey_type(key), fp);\n\tfree(fp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s: certificate signature algorithm %s: %s\"",
            "__func__",
            "(key->cert == NULL || key->cert->signature_type == NULL) ?\n\t\t    \"(null)\" : key->cert->signature_type",
            "ssh_err(r)"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_check_cert_sigtype",
          "args": [
            "key",
            "options.ca_sign_algorithms"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_check_cert_sigtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2327-2339",
          "snippet": "int\nsshkey_check_cert_sigtype(const struct sshkey *key, const char *allowed)\n{\n\tif (key == NULL || allowed == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_type_is_cert(key->type))\n\t\treturn 0;\n\tif (key->cert == NULL || key->cert->signature_type == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (match_pattern_list(key->cert->signature_type, allowed, 0) != 1)\n\t\treturn SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_check_cert_sigtype(const struct sshkey *key, const char *allowed)\n{\n\tif (key == NULL || allowed == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_type_is_cert(key->type))\n\t\treturn 0;\n\tif (key->cert == NULL || key->cert->signature_type == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (match_pattern_list(key->cert->signature_type, allowed, 0) != 1)\n\t\treturn SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "key"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "pkalg",
            "options.pubkey_key_types",
            "0"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "key"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_key_already_used",
          "args": [
            "authctxt",
            "key"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_key_already_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "731-749",
          "snippet": "int\nauth2_key_already_used(Authctxt *authctxt, const struct sshkey *key)\n{\n\tu_int i;\n\tchar *fp;\n\n\tfor (i = 0; i < authctxt->nprev_keys; i++) {\n\t\tif (sshkey_equal_public(key, authctxt->prev_keys[i])) {\n\t\t\tfp = sshkey_fingerprint(authctxt->prev_keys[i],\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tdebug3(\"%s: key already used: %s %s\", __func__,\n\t\t\t    sshkey_type(authctxt->prev_keys[i]),\n\t\t\t    fp == NULL ? \"UNKNOWN\" : fp);\n\t\t\tfree(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nint\nauth2_key_already_used(Authctxt *authctxt, const struct sshkey *key)\n{\n\tu_int i;\n\tchar *fp;\n\n\tfor (i = 0; i < authctxt->nprev_keys; i++) {\n\t\tif (sshkey_equal_public(key, authctxt->prev_keys[i])) {\n\t\t\tfp = sshkey_fingerprint(authctxt->prev_keys[i],\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tdebug3(\"%s: key already used: %s %s\", __func__,\n\t\t\t    sshkey_type(authctxt->prev_keys[i]),\n\t\t\t    fp == NULL ? \"UNKNOWN\" : fp);\n\t\t\tfree(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: type mismatch for decoded key \"\n\t\t    \"(received %d, expected %d)\"",
            "__func__",
            "key->type",
            "pktype"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob",
          "args": [
            "pkblob",
            "blen",
            "&key"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2263-2274",
          "snippet": "int\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"%s: unsupported public key algorithm: %s\"",
            "__func__",
            "pkalg"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "pkalg"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_cstring",
          "args": [
            "ssh",
            "&pkalg",
            "NULL"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2532-2536",
          "snippet": "int\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_u8",
          "args": [
            "ssh",
            "&have_sig"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2496-2500",
          "snippet": "int\nsshpkt_get_u8(struct ssh *ssh, u_char *valp)\n{\n\treturn sshbuf_get_u8(ssh->state->incoming_packet, valp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_u8(struct ssh *ssh, u_char *valp)\n{\n\treturn sshbuf_get_u8(ssh->state->incoming_packet, valp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern u_char *session_id2;\nextern u_int session_id2_len;\n\nstatic int\nuserauth_pubkey(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tstruct sshbuf *b = NULL;\n\tstruct sshkey *key = NULL;\n\tchar *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;\n\tu_char *pkblob = NULL, *sig = NULL, have_sig;\n\tsize_t blen, slen;\n\tint r, pktype;\n\tint authenticated = 0;\n\tstruct sshauthopt *authopts = NULL;\n\n\tif ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)\n\t\tfatal(\"%s: parse request failed: %s\", __func__, ssh_err(r));\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC) {\n\t\t/* this is perfectly legal */\n\t\tverbose(\"%s: unsupported public key algorithm: %s\",\n\t\t    __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror(\"%s: could not parse key: %s\", __func__, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif (key == NULL) {\n\t\terror(\"%s: cannot decode key: %s\", __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror(\"%s: type mismatch for decoded key \"\n\t\t    \"(received %d, expected %d)\", __func__, key->type, pktype);\n\t\tgoto done;\n\t}\n\tif (sshkey_type_plain(key->type) == KEY_RSA &&\n\t    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\tlogit(\"Refusing RSA key because client uses unsafe \"\n\t\t    \"signature scheme\");\n\t\tgoto done;\n\t}\n\tif (auth2_key_already_used(authctxt, key)) {\n\t\tlogit(\"refusing previously-used %s key\", sshkey_type(key));\n\t\tgoto done;\n\t}\n\tif (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {\n\t\tlogit(\"%s: key type %s not in PubkeyAcceptedKeyTypes\",\n\t\t    __func__, sshkey_ssh_name(key));\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_check_cert_sigtype(key,\n\t    options.ca_sign_algorithms)) != 0) {\n\t\tlogit(\"%s: certificate signature algorithm %s: %s\", __func__,\n\t\t    (key->cert == NULL || key->cert->signature_type == NULL) ?\n\t\t    \"(null)\" : key->cert->signature_type, ssh_err(r));\n\t\tgoto done;\n\t}\n\tkey_s = format_key(key);\n\tif (sshkey_is_cert(key))\n\t\tca_s = format_key(key->cert->signature_key);\n\n\tif (have_sig) {\n\t\tdebug3(\"%s: have %s signature for %s%s%s\",\n\t\t    __func__, pkalg, key_s,\n\t\t    ca_s == NULL ? \"\" : \" CA \",\n\t\t    ca_s == NULL ? \"\" : ca_s);\n\t\tif ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||\n\t\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tif (ssh->compat & SSH_OLD_SESSIONID) {\n\t\t\tif ((r = sshbuf_put(b, session_id2,\n\t\t\t    session_id2_len)) != 0)\n\t\t\t\tfatal(\"%s: sshbuf_put session id: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t} else {\n\t\t\tif ((r = sshbuf_put_string(b, session_id2,\n\t\t\t    session_id2_len)) != 0)\n\t\t\t\tfatal(\"%s: sshbuf_put_string session id: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\t\tdebug2(\"%s: disabled because of invalid user\",\n\t\t\t    __func__);\n\t\t\tgoto done;\n\t\t}\n\t\t/* reconstruct packet */\n\t\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t\t    authctxt->style ? \":\" : \"\",\n\t\t    authctxt->style ? authctxt->style : \"\");\n\t\tif ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, \"publickey\")) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, have_sig)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, pkalg)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, pkblob, blen)) != 0)\n\t\t\tfatal(\"%s: build packet failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n#ifdef DEBUG_PK\n\t\tsshbuf_dump(b, stderr);\n#endif\n\t\t/* test for correct signature */\n\t\tauthenticated = 0;\n\t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&\n\t\t    PRIVSEP(sshkey_verify(key, sig, slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b),\n\t\t    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,\n\t\t    ssh->compat)) == 0) {\n\t\t\tauthenticated = 1;\n\t\t}\n\t\tauth2_record_key(authctxt, authenticated, key);\n\t} else {\n\t\tdebug(\"%s: test pkalg %s pkblob %s%s%s\",\n\t\t    __func__, pkalg, key_s,\n\t\t    ca_s == NULL ? \"\" : \" CA \",\n\t\t    ca_s == NULL ? \"\" : ca_s);\n\n\t\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\t\tdebug2(\"%s: disabled because of invalid user\",\n\t\t\t    __func__);\n\t\t\tgoto done;\n\t\t}\n\t\t/* XXX fake reply and always send PK_OK ? */\n\t\t/*\n\t\t * XXX this allows testing whether a user is allowed\n\t\t * to login: if you happen to have a valid pubkey this\n\t\t * message is sent. the message is NEVER sent at all\n\t\t * if a user is not allowed to login. is this an\n\t\t * issue? -markus\n\t\t */\n\t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))\n\t\t\t    != 0 ||\n\t\t\t    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t\tauthctxt->postponed = 1;\n\t\t}\n\t}\ndone:\n\tif (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {\n\t\tdebug(\"%s: key options inconsistent with existing\", __func__);\n\t\tauthenticated = 0;\n\t}\n\tdebug2(\"%s: authenticated %d pkalg %s\", __func__, authenticated, pkalg);\n\n\tsshbuf_free(b);\n\tsshauthopt_free(authopts);\n\tsshkey_free(key);\n\tfree(userstyle);\n\tfree(pkalg);\n\tfree(pkblob);\n\tfree(key_s);\n\tfree(ca_s);\n\tfree(sig);\n\treturn authenticated;\n}"
  },
  {
    "function_name": "format_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
    "lines": "76-85",
    "snippet": "static char *\nformat_key(const struct sshkey *key)\n{\n\tchar *ret, *fp = sshkey_fingerprint(key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\n\txasprintf(&ret, \"%s %s\", sshkey_type(key), fp);\n\tfree(fp);\n\treturn ret;\n}",
    "includes": [
      "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
      "#include \"channels.h\" /* XXX for session.h */",
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fp"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&ret",
            "\"%s %s\"",
            "sshkey_type(key)",
            "fp"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "key"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "key",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic char *\nformat_key(const struct sshkey *key)\n{\n\tchar *ret, *fp = sshkey_fingerprint(key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\n\txasprintf(&ret, \"%s %s\", sshkey_type(key), fp);\n\tfree(fp);\n\treturn ret;\n}"
  }
]