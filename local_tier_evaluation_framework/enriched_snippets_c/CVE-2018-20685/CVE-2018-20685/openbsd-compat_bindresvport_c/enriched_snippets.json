[
  {
    "function_name": "bindresvport_sa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bindresvport.c",
    "lines": "52-117",
    "snippet": "int\nbindresvport_sa(int sd, struct sockaddr *sa)\n{\n\tint error, af;\n\tstruct sockaddr_storage myaddr;\n\tstruct sockaddr_in *in;\n\tstruct sockaddr_in6 *in6;\n\tu_int16_t *portp;\n\tu_int16_t port;\n\tsocklen_t salen;\n\tint i;\n\n\tif (sa == NULL) {\n\t\tmemset(&myaddr, 0, sizeof(myaddr));\n\t\tsa = (struct sockaddr *)&myaddr;\n\t\tsalen = sizeof(myaddr);\n\n\t\tif (getsockname(sd, sa, &salen) == -1)\n\t\t\treturn -1;\t/* errno is correctly set */\n\n\t\taf = sa->sa_family;\n\t\tmemset(&myaddr, 0, salen);\n\t} else\n\t\taf = sa->sa_family;\n\n\tif (af == AF_INET) {\n\t\tin = (struct sockaddr_in *)sa;\n\t\tsalen = sizeof(struct sockaddr_in);\n\t\tportp = &in->sin_port;\n\t} else if (af == AF_INET6) {\n\t\tin6 = (struct sockaddr_in6 *)sa;\n\t\tsalen = sizeof(struct sockaddr_in6);\n\t\tportp = &in6->sin6_port;\n\t} else {\n\t\terrno = EPFNOSUPPORT;\n\t\treturn (-1);\n\t}\n\tsa->sa_family = af;\n\n\tport = ntohs(*portp);\n\tif (port == 0)\n\t\tport = arc4random_uniform(NPORTS) + STARTPORT;\n\n\t/* Avoid warning */\n\terror = -1;\n\n\tfor(i = 0; i < NPORTS; i++) {\n\t\t*portp = htons(port);\n\t\t\n\t\terror = bind(sd, sa, salen);\n\n\t\t/* Terminate on success */\n\t\tif (error == 0)\n\t\t\tbreak;\n\t\t\t\n\t\t/* Terminate on errors, except \"address already in use\" */\n\t\tif ((error < 0) && !((errno == EADDRINUSE) || (errno == EINVAL)))\n\t\t\tbreak;\n\t\t\t\n\t\tport++;\n\t\tif (port > ENDPORT)\n\t\t\tport = STARTPORT;\n\t}\n\n\treturn (error);\n}",
    "includes": [
      "#include <string.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define NPORTS\t(ENDPORT - STARTPORT + 1)",
      "#define ENDPORT (IPPORT_RESERVED - 1)",
      "#define STARTPORT 600"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "sd",
            "sa",
            "salen"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arc4random_uniform",
          "args": [
            "NPORTS"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_uniform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "291-315",
          "snippet": "u_int32_t\narc4random_uniform(u_int32_t upper_bound)\n{\n\tu_int32_t r, min;\n\n\tif (upper_bound < 2)\n\t\treturn 0;\n\n\t/* 2**32 % x == (2**32 - x) % x */\n\tmin = -upper_bound % upper_bound;\n\n\t/*\n\t * This could theoretically loop forever but each retry has\n\t * p > 0.5 (worst case, usually far better) of selecting a\n\t * number inside the range we need, so it should rarely need\n\t * to re-roll.\n\t */\n\tfor (;;) {\n\t\tr = arc4random();\n\t\tif (r >= min)\n\t\t\tbreak;\n\t}\n\n\treturn r % upper_bound;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\narc4random_uniform(u_int32_t upper_bound)\n{\n\tu_int32_t r, min;\n\n\tif (upper_bound < 2)\n\t\treturn 0;\n\n\t/* 2**32 % x == (2**32 - x) % x */\n\tmin = -upper_bound % upper_bound;\n\n\t/*\n\t * This could theoretically loop forever but each retry has\n\t * p > 0.5 (worst case, usually far better) of selecting a\n\t * number inside the range we need, so it should rarely need\n\t * to re-roll.\n\t */\n\tfor (;;) {\n\t\tr = arc4random();\n\t\tif (r >= min)\n\t\t\tbreak;\n\t}\n\n\treturn r % upper_bound;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "*portp"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&myaddr",
            "0",
            "salen"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "sd",
            "sa",
            "&salen"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&myaddr",
            "0",
            "sizeof(myaddr)"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define NPORTS\t(ENDPORT - STARTPORT + 1)\n#define ENDPORT (IPPORT_RESERVED - 1)\n#define STARTPORT 600\n\nint\nbindresvport_sa(int sd, struct sockaddr *sa)\n{\n\tint error, af;\n\tstruct sockaddr_storage myaddr;\n\tstruct sockaddr_in *in;\n\tstruct sockaddr_in6 *in6;\n\tu_int16_t *portp;\n\tu_int16_t port;\n\tsocklen_t salen;\n\tint i;\n\n\tif (sa == NULL) {\n\t\tmemset(&myaddr, 0, sizeof(myaddr));\n\t\tsa = (struct sockaddr *)&myaddr;\n\t\tsalen = sizeof(myaddr);\n\n\t\tif (getsockname(sd, sa, &salen) == -1)\n\t\t\treturn -1;\t/* errno is correctly set */\n\n\t\taf = sa->sa_family;\n\t\tmemset(&myaddr, 0, salen);\n\t} else\n\t\taf = sa->sa_family;\n\n\tif (af == AF_INET) {\n\t\tin = (struct sockaddr_in *)sa;\n\t\tsalen = sizeof(struct sockaddr_in);\n\t\tportp = &in->sin_port;\n\t} else if (af == AF_INET6) {\n\t\tin6 = (struct sockaddr_in6 *)sa;\n\t\tsalen = sizeof(struct sockaddr_in6);\n\t\tportp = &in6->sin6_port;\n\t} else {\n\t\terrno = EPFNOSUPPORT;\n\t\treturn (-1);\n\t}\n\tsa->sa_family = af;\n\n\tport = ntohs(*portp);\n\tif (port == 0)\n\t\tport = arc4random_uniform(NPORTS) + STARTPORT;\n\n\t/* Avoid warning */\n\terror = -1;\n\n\tfor(i = 0; i < NPORTS; i++) {\n\t\t*portp = htons(port);\n\t\t\n\t\terror = bind(sd, sa, salen);\n\n\t\t/* Terminate on success */\n\t\tif (error == 0)\n\t\t\tbreak;\n\t\t\t\n\t\t/* Terminate on errors, except \"address already in use\" */\n\t\tif ((error < 0) && !((errno == EADDRINUSE) || (errno == EINVAL)))\n\t\t\tbreak;\n\t\t\t\n\t\tport++;\n\t\tif (port > ENDPORT)\n\t\t\tport = STARTPORT;\n\t}\n\n\treturn (error);\n}"
  }
]