[
  {
    "function_name": "addr_match_cidr_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "435-498",
    "snippet": "int\naddr_match_cidr_list(const char *addr, const char *_list)\n{\n\tchar *list, *cp, *o;\n\tstruct xaddr try_addr, match_addr;\n\tu_int masklen;\n\tint ret = 0, r;\n\n\tif (addr != NULL && addr_pton(addr, &try_addr) != 0) {\n\t\tdebug2(\"%s: couldn't parse address %.100s\", __func__, addr);\n\t\treturn 0;\n\t}\n\tif ((o = list = strdup(_list)) == NULL)\n\t\treturn -1;\n\twhile ((cp = strsep(&list, \",\")) != NULL) {\n\t\tif (*cp == '\\0') {\n\t\t\terror(\"%s: empty entry in list \\\"%.100s\\\"\",\n\t\t\t    __func__, o);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * NB. This function is called in pre-auth with untrusted data,\n\t\t * so be extra paranoid about junk reaching getaddrino (via\n\t\t * addr_pton_cidr).\n\t\t */\n\n\t\t/* Stop junk from reaching getaddrinfo. +3 is for masklen */\n\t\tif (strlen(cp) > INET6_ADDRSTRLEN + 3) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" too long\",\n\t\t\t    __func__, cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\"\n\t\tif (strspn(cp, VALID_CIDR_CHARS) != strlen(cp)) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" contains invalid \"\n\t\t\t    \"characters\", __func__, cp);\n\t\t\tret = -1;\n\t\t}\n\n\t\t/* Prefer CIDR address matching */\n\t\tr = addr_pton_cidr(cp, &match_addr, &masklen);\n\t\tif (r == -1) {\n\t\t\terror(\"Invalid network entry \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == -2) {\n\t\t\terror(\"Inconsistent mask length for \"\n\t\t\t    \"network \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == 0 && addr != NULL) {\n\t\t\tif (addr_netmatch(&try_addr, &match_addr,\n\t\t\t    masklen) == 0)\n\t\t\t\tret = 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tfree(o);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "o"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_netmatch",
          "args": [
            "&try_addr",
            "&match_addr",
            "masklen"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "addr_netmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "348-361",
          "snippet": "static int\naddr_netmatch(const struct xaddr *host, const struct xaddr *net, u_int masklen)\n{\n\tstruct xaddr tmp_mask, tmp_result;\n\n\tif (host->af != net->af)\n\t\treturn -1;\n\n\tif (addr_netmask(host->af, masklen, &tmp_mask) == -1)\n\t\treturn -1;\n\tif (addr_and(&tmp_result, host, &tmp_mask) == -1)\n\t\treturn -1;\n\treturn addr_cmp(&tmp_result, net);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_netmatch(const struct xaddr *host, const struct xaddr *net, u_int masklen)\n{\n\tstruct xaddr tmp_mask, tmp_result;\n\n\tif (host->af != net->af)\n\t\treturn -1;\n\n\tif (addr_netmask(host->af, masklen, &tmp_mask) == -1)\n\t\treturn -1;\n\tif (addr_and(&tmp_result, host, &tmp_mask) == -1)\n\t\treturn -1;\n\treturn addr_cmp(&tmp_result, net);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Inconsistent mask length for \"\n\t\t\t    \"network \\\"%.100s\\\"\"",
            "cp"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_pton_cidr",
          "args": [
            "cp",
            "&match_addr",
            "&masklen"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "addr_pton_cidr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "311-346",
          "snippet": "static int\naddr_pton_cidr(const char *p, struct xaddr *n, u_int *l)\n{\n\tstruct xaddr tmp;\n\tlong unsigned int masklen = 999;\n\tchar addrbuf[64], *mp, *cp;\n\n\t/* Don't modify argument */\n\tif (p == NULL || strlcpy(addrbuf, p, sizeof(addrbuf)) >= sizeof(addrbuf))\n\t\treturn -1;\n\n\tif ((mp = strchr(addrbuf, '/')) != NULL) {\n\t\t*mp = '\\0';\n\t\tmp++;\n\t\tmasklen = strtoul(mp, &cp, 10);\n\t\tif (*mp == '\\0' || *cp != '\\0' || masklen > 128)\n\t\t\treturn -1;\n\t}\n\n\tif (addr_pton(addrbuf, &tmp) == -1)\n\t\treturn -1;\n\n\tif (mp == NULL)\n\t\tmasklen = addr_unicast_masklen(tmp.af);\n\tif (masklen_valid(tmp.af, masklen) == -1)\n\t\treturn -2;\n\tif (addr_host_is_all0s(&tmp, masklen) != 0)\n\t\treturn -2;\n\n\tif (n != NULL)\n\t\tmemcpy(n, &tmp, sizeof(*n));\n\tif (l != NULL)\n\t\t*l = masklen;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_pton_cidr(const char *p, struct xaddr *n, u_int *l)\n{\n\tstruct xaddr tmp;\n\tlong unsigned int masklen = 999;\n\tchar addrbuf[64], *mp, *cp;\n\n\t/* Don't modify argument */\n\tif (p == NULL || strlcpy(addrbuf, p, sizeof(addrbuf)) >= sizeof(addrbuf))\n\t\treturn -1;\n\n\tif ((mp = strchr(addrbuf, '/')) != NULL) {\n\t\t*mp = '\\0';\n\t\tmp++;\n\t\tmasklen = strtoul(mp, &cp, 10);\n\t\tif (*mp == '\\0' || *cp != '\\0' || masklen > 128)\n\t\t\treturn -1;\n\t}\n\n\tif (addr_pton(addrbuf, &tmp) == -1)\n\t\treturn -1;\n\n\tif (mp == NULL)\n\t\tmasklen = addr_unicast_masklen(tmp.af);\n\tif (masklen_valid(tmp.af, masklen) == -1)\n\t\treturn -2;\n\tif (addr_host_is_all0s(&tmp, masklen) != 0)\n\t\treturn -2;\n\n\tif (n != NULL)\n\t\tmemcpy(n, &tmp, sizeof(*n));\n\tif (l != NULL)\n\t\t*l = masklen;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "VALID_CIDR_CHARS"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&list",
            "\",\""
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "xstrsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keyscan.c",
          "lines": "162-178",
          "snippet": "static char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}",
          "includes": [
            "#include \"dns.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"myproposal.h\"",
            "#include \"compat.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <openssl/bn.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/resource.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"compat.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <netdb.h>\n#include <openssl/bn.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/resource.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "_list"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: couldn't parse address %.100s\"",
            "__func__",
            "addr"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_pton",
          "args": [
            "addr",
            "&try_addr"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "addr_pton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "205-226",
          "snippet": "static int\naddr_pton(const char *p, struct xaddr *n)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint ret = -1;\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (p == NULL || getaddrinfo(p, NULL, &hints, &ai) != 0)\n\t\tgoto out;\n\tif (ai == NULL || ai->ai_addr == NULL)\n\t\tgoto out;\n\tif (n != NULL && addr_sa_to_xaddr(ai->ai_addr, ai->ai_addrlen, n) == -1)\n\t\tgoto out;\n\t/* success */\n\tret = 0;\n out:\n\tif (ai != NULL)\n\t\tfreeaddrinfo(ai);\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_pton(const char *p, struct xaddr *n)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint ret = -1;\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (p == NULL || getaddrinfo(p, NULL, &hints, &ai) != 0)\n\t\tgoto out;\n\tif (ai == NULL || ai->ai_addr == NULL)\n\t\tgoto out;\n\tif (n != NULL && addr_sa_to_xaddr(ai->ai_addr, ai->ai_addrlen, n) == -1)\n\t\tgoto out;\n\t/* success */\n\tret = 0;\n out:\n\tif (ai != NULL)\n\t\tfreeaddrinfo(ai);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\"\n\nint\naddr_match_cidr_list(const char *addr, const char *_list)\n{\n\tchar *list, *cp, *o;\n\tstruct xaddr try_addr, match_addr;\n\tu_int masklen;\n\tint ret = 0, r;\n\n\tif (addr != NULL && addr_pton(addr, &try_addr) != 0) {\n\t\tdebug2(\"%s: couldn't parse address %.100s\", __func__, addr);\n\t\treturn 0;\n\t}\n\tif ((o = list = strdup(_list)) == NULL)\n\t\treturn -1;\n\twhile ((cp = strsep(&list, \",\")) != NULL) {\n\t\tif (*cp == '\\0') {\n\t\t\terror(\"%s: empty entry in list \\\"%.100s\\\"\",\n\t\t\t    __func__, o);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * NB. This function is called in pre-auth with untrusted data,\n\t\t * so be extra paranoid about junk reaching getaddrino (via\n\t\t * addr_pton_cidr).\n\t\t */\n\n\t\t/* Stop junk from reaching getaddrinfo. +3 is for masklen */\n\t\tif (strlen(cp) > INET6_ADDRSTRLEN + 3) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" too long\",\n\t\t\t    __func__, cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\"\n\t\tif (strspn(cp, VALID_CIDR_CHARS) != strlen(cp)) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" contains invalid \"\n\t\t\t    \"characters\", __func__, cp);\n\t\t\tret = -1;\n\t\t}\n\n\t\t/* Prefer CIDR address matching */\n\t\tr = addr_pton_cidr(cp, &match_addr, &masklen);\n\t\tif (r == -1) {\n\t\t\terror(\"Invalid network entry \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == -2) {\n\t\t\terror(\"Inconsistent mask length for \"\n\t\t\t    \"network \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == 0 && addr != NULL) {\n\t\t\tif (addr_netmatch(&try_addr, &match_addr,\n\t\t\t    masklen) == 0)\n\t\t\t\tret = 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tfree(o);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "addr_match_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "375-424",
    "snippet": "int\naddr_match_list(const char *addr, const char *_list)\n{\n\tchar *list, *cp, *o;\n\tstruct xaddr try_addr, match_addr;\n\tu_int masklen, neg;\n\tint ret = 0, r;\n\n\tif (addr != NULL && addr_pton(addr, &try_addr) != 0) {\n\t\tdebug2(\"%s: couldn't parse address %.100s\", __func__, addr);\n\t\treturn 0;\n\t}\n\tif ((o = list = strdup(_list)) == NULL)\n\t\treturn -1;\n\twhile ((cp = strsep(&list, \",\")) != NULL) {\n\t\tneg = *cp == '!';\n\t\tif (neg)\n\t\t\tcp++;\n\t\tif (*cp == '\\0') {\n\t\t\tret = -2;\n\t\t\tbreak;\n\t\t}\n\t\t/* Prefer CIDR address matching */\n\t\tr = addr_pton_cidr(cp, &match_addr, &masklen);\n\t\tif (r == -2) {\n\t\t\tdebug2(\"%s: inconsistent mask length for \"\n\t\t\t    \"match network \\\"%.100s\\\"\", __func__, cp);\n\t\t\tret = -2;\n\t\t\tbreak;\n\t\t} else if (r == 0) {\n\t\t\tif (addr != NULL && addr_netmatch(&try_addr,\n                           &match_addr, masklen) == 0) {\n foundit:\n\t\t\t\tif (neg) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* If CIDR parse failed, try wildcard string match */\n\t\t\tif (addr != NULL && match_pattern(addr, cp) == 1)\n\t\t\t\tgoto foundit;\n\t\t}\n\t}\n\tfree(o);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "o"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern",
          "args": [
            "addr",
            "cp"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "56-112",
          "snippet": "int\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_netmatch",
          "args": [
            "&try_addr",
            "&match_addr",
            "masklen"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "addr_netmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "348-361",
          "snippet": "static int\naddr_netmatch(const struct xaddr *host, const struct xaddr *net, u_int masklen)\n{\n\tstruct xaddr tmp_mask, tmp_result;\n\n\tif (host->af != net->af)\n\t\treturn -1;\n\n\tif (addr_netmask(host->af, masklen, &tmp_mask) == -1)\n\t\treturn -1;\n\tif (addr_and(&tmp_result, host, &tmp_mask) == -1)\n\t\treturn -1;\n\treturn addr_cmp(&tmp_result, net);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_netmatch(const struct xaddr *host, const struct xaddr *net, u_int masklen)\n{\n\tstruct xaddr tmp_mask, tmp_result;\n\n\tif (host->af != net->af)\n\t\treturn -1;\n\n\tif (addr_netmask(host->af, masklen, &tmp_mask) == -1)\n\t\treturn -1;\n\tif (addr_and(&tmp_result, host, &tmp_mask) == -1)\n\t\treturn -1;\n\treturn addr_cmp(&tmp_result, net);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: inconsistent mask length for \"\n\t\t\t    \"match network \\\"%.100s\\\"\"",
            "__func__",
            "cp"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_pton_cidr",
          "args": [
            "cp",
            "&match_addr",
            "&masklen"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "addr_pton_cidr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "311-346",
          "snippet": "static int\naddr_pton_cidr(const char *p, struct xaddr *n, u_int *l)\n{\n\tstruct xaddr tmp;\n\tlong unsigned int masklen = 999;\n\tchar addrbuf[64], *mp, *cp;\n\n\t/* Don't modify argument */\n\tif (p == NULL || strlcpy(addrbuf, p, sizeof(addrbuf)) >= sizeof(addrbuf))\n\t\treturn -1;\n\n\tif ((mp = strchr(addrbuf, '/')) != NULL) {\n\t\t*mp = '\\0';\n\t\tmp++;\n\t\tmasklen = strtoul(mp, &cp, 10);\n\t\tif (*mp == '\\0' || *cp != '\\0' || masklen > 128)\n\t\t\treturn -1;\n\t}\n\n\tif (addr_pton(addrbuf, &tmp) == -1)\n\t\treturn -1;\n\n\tif (mp == NULL)\n\t\tmasklen = addr_unicast_masklen(tmp.af);\n\tif (masklen_valid(tmp.af, masklen) == -1)\n\t\treturn -2;\n\tif (addr_host_is_all0s(&tmp, masklen) != 0)\n\t\treturn -2;\n\n\tif (n != NULL)\n\t\tmemcpy(n, &tmp, sizeof(*n));\n\tif (l != NULL)\n\t\t*l = masklen;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_pton_cidr(const char *p, struct xaddr *n, u_int *l)\n{\n\tstruct xaddr tmp;\n\tlong unsigned int masklen = 999;\n\tchar addrbuf[64], *mp, *cp;\n\n\t/* Don't modify argument */\n\tif (p == NULL || strlcpy(addrbuf, p, sizeof(addrbuf)) >= sizeof(addrbuf))\n\t\treturn -1;\n\n\tif ((mp = strchr(addrbuf, '/')) != NULL) {\n\t\t*mp = '\\0';\n\t\tmp++;\n\t\tmasklen = strtoul(mp, &cp, 10);\n\t\tif (*mp == '\\0' || *cp != '\\0' || masklen > 128)\n\t\t\treturn -1;\n\t}\n\n\tif (addr_pton(addrbuf, &tmp) == -1)\n\t\treturn -1;\n\n\tif (mp == NULL)\n\t\tmasklen = addr_unicast_masklen(tmp.af);\n\tif (masklen_valid(tmp.af, masklen) == -1)\n\t\treturn -2;\n\tif (addr_host_is_all0s(&tmp, masklen) != 0)\n\t\treturn -2;\n\n\tif (n != NULL)\n\t\tmemcpy(n, &tmp, sizeof(*n));\n\tif (l != NULL)\n\t\t*l = masklen;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&list",
            "\",\""
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "xstrsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keyscan.c",
          "lines": "162-178",
          "snippet": "static char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}",
          "includes": [
            "#include \"dns.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"myproposal.h\"",
            "#include \"compat.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <openssl/bn.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/resource.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"compat.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <netdb.h>\n#include <openssl/bn.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/resource.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "_list"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_pton",
          "args": [
            "addr",
            "&try_addr"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "addr_pton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "205-226",
          "snippet": "static int\naddr_pton(const char *p, struct xaddr *n)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint ret = -1;\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (p == NULL || getaddrinfo(p, NULL, &hints, &ai) != 0)\n\t\tgoto out;\n\tif (ai == NULL || ai->ai_addr == NULL)\n\t\tgoto out;\n\tif (n != NULL && addr_sa_to_xaddr(ai->ai_addr, ai->ai_addrlen, n) == -1)\n\t\tgoto out;\n\t/* success */\n\tret = 0;\n out:\n\tif (ai != NULL)\n\t\tfreeaddrinfo(ai);\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_pton(const char *p, struct xaddr *n)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint ret = -1;\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (p == NULL || getaddrinfo(p, NULL, &hints, &ai) != 0)\n\t\tgoto out;\n\tif (ai == NULL || ai->ai_addr == NULL)\n\t\tgoto out;\n\tif (n != NULL && addr_sa_to_xaddr(ai->ai_addr, ai->ai_addrlen, n) == -1)\n\t\tgoto out;\n\t/* success */\n\tret = 0;\n out:\n\tif (ai != NULL)\n\t\tfreeaddrinfo(ai);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\naddr_match_list(const char *addr, const char *_list)\n{\n\tchar *list, *cp, *o;\n\tstruct xaddr try_addr, match_addr;\n\tu_int masklen, neg;\n\tint ret = 0, r;\n\n\tif (addr != NULL && addr_pton(addr, &try_addr) != 0) {\n\t\tdebug2(\"%s: couldn't parse address %.100s\", __func__, addr);\n\t\treturn 0;\n\t}\n\tif ((o = list = strdup(_list)) == NULL)\n\t\treturn -1;\n\twhile ((cp = strsep(&list, \",\")) != NULL) {\n\t\tneg = *cp == '!';\n\t\tif (neg)\n\t\t\tcp++;\n\t\tif (*cp == '\\0') {\n\t\t\tret = -2;\n\t\t\tbreak;\n\t\t}\n\t\t/* Prefer CIDR address matching */\n\t\tr = addr_pton_cidr(cp, &match_addr, &masklen);\n\t\tif (r == -2) {\n\t\t\tdebug2(\"%s: inconsistent mask length for \"\n\t\t\t    \"match network \\\"%.100s\\\"\", __func__, cp);\n\t\t\tret = -2;\n\t\t\tbreak;\n\t\t} else if (r == 0) {\n\t\t\tif (addr != NULL && addr_netmatch(&try_addr,\n                           &match_addr, masklen) == 0) {\n foundit:\n\t\t\t\tif (neg) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* If CIDR parse failed, try wildcard string match */\n\t\t\tif (addr != NULL && match_pattern(addr, cp) == 1)\n\t\t\t\tgoto foundit;\n\t\t}\n\t}\n\tfree(o);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "addr_netmatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "348-361",
    "snippet": "static int\naddr_netmatch(const struct xaddr *host, const struct xaddr *net, u_int masklen)\n{\n\tstruct xaddr tmp_mask, tmp_result;\n\n\tif (host->af != net->af)\n\t\treturn -1;\n\n\tif (addr_netmask(host->af, masklen, &tmp_mask) == -1)\n\t\treturn -1;\n\tif (addr_and(&tmp_result, host, &tmp_mask) == -1)\n\t\treturn -1;\n\treturn addr_cmp(&tmp_result, net);\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addr_cmp",
          "args": [
            "&tmp_result",
            "net"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "addr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "176-199",
          "snippet": "static int\naddr_cmp(const struct xaddr *a, const struct xaddr *b)\n{\n\tint i;\n\n\tif (a->af != b->af)\n\t\treturn a->af == AF_INET6 ? 1 : -1;\n\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\tif (a->v4.s_addr == b->v4.s_addr)\n\t\t\treturn 0;\n\t\treturn ntohl(a->v4.s_addr) > ntohl(b->v4.s_addr) ? 1 : -1;\n\tcase AF_INET6:\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tif (a->addr8[i] - b->addr8[i] != 0)\n\t\t\t\treturn a->addr8[i] > b->addr8[i] ? 1 : -1;\n\t\tif (a->scope_id == b->scope_id)\n\t\t\treturn 0;\n\t\treturn a->scope_id > b->scope_id ? 1 : -1;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define addr8\txa.addr8",
            "#define v4\txa.v4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define addr8\txa.addr8\n#define v4\txa.v4\n\nstatic int\naddr_cmp(const struct xaddr *a, const struct xaddr *b)\n{\n\tint i;\n\n\tif (a->af != b->af)\n\t\treturn a->af == AF_INET6 ? 1 : -1;\n\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\tif (a->v4.s_addr == b->v4.s_addr)\n\t\t\treturn 0;\n\t\treturn ntohl(a->v4.s_addr) > ntohl(b->v4.s_addr) ? 1 : -1;\n\tcase AF_INET6:\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tif (a->addr8[i] - b->addr8[i] != 0)\n\t\t\t\treturn a->addr8[i] > b->addr8[i] ? 1 : -1;\n\t\tif (a->scope_id == b->scope_id)\n\t\t\treturn 0;\n\t\treturn a->scope_id > b->scope_id ? 1 : -1;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_and",
          "args": [
            "&tmp_result",
            "host",
            "&tmp_mask"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "addr_and",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "149-170",
          "snippet": "static int\naddr_and(struct xaddr *dst, const struct xaddr *a, const struct xaddr *b)\n{\n\tint i;\n\n\tif (dst == NULL || a == NULL || b == NULL || a->af != b->af)\n\t\treturn -1;\n\n\tmemcpy(dst, a, sizeof(*dst));\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\tdst->v4.s_addr &= b->v4.s_addr;\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tdst->scope_id = a->scope_id;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tdst->addr32[i] &= b->addr32[i];\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define addr32\txa.addr32",
            "#define v4\txa.v4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define addr32\txa.addr32\n#define v4\txa.v4\n\nstatic int\naddr_and(struct xaddr *dst, const struct xaddr *a, const struct xaddr *b)\n{\n\tint i;\n\n\tif (dst == NULL || a == NULL || b == NULL || a->af != b->af)\n\t\treturn -1;\n\n\tmemcpy(dst, a, sizeof(*dst));\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\tdst->v4.s_addr &= b->v4.s_addr;\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tdst->scope_id = a->scope_id;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tdst->addr32[i] &= b->addr32[i];\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_netmask",
          "args": [
            "host->af",
            "masklen",
            "&tmp_mask"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "addr_netmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "116-143",
          "snippet": "static int\naddr_netmask(int af, u_int l, struct xaddr *n)\n{\n\tint i;\n\n\tif (masklen_valid(af, l) != 0 || n == NULL)\n\t\treturn -1;\n\n\tmemset(n, '\\0', sizeof(*n));\n\tswitch (af) {\n\tcase AF_INET:\n\t\tn->af = AF_INET;\n\t\tif (l == 0)\n\t\t\treturn 0;\n\t\tn->v4.s_addr = htonl((0xffffffff << (32 - l)) & 0xffffffff);\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tn->af = AF_INET6;\n\t\tfor (i = 0; i < 4 && l >= 32; i++, l -= 32)\n\t\t\tn->addr32[i] = 0xffffffffU;\n\t\tif (i < 4 && l != 0)\n\t\t\tn->addr32[i] = htonl((0xffffffff << (32 - l)) &\n\t\t\t    0xffffffff);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define addr32\txa.addr32",
            "#define v4\txa.v4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define addr32\txa.addr32\n#define v4\txa.v4\n\nstatic int\naddr_netmask(int af, u_int l, struct xaddr *n)\n{\n\tint i;\n\n\tif (masklen_valid(af, l) != 0 || n == NULL)\n\t\treturn -1;\n\n\tmemset(n, '\\0', sizeof(*n));\n\tswitch (af) {\n\tcase AF_INET:\n\t\tn->af = AF_INET;\n\t\tif (l == 0)\n\t\t\treturn 0;\n\t\tn->v4.s_addr = htonl((0xffffffff << (32 - l)) & 0xffffffff);\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tn->af = AF_INET6;\n\t\tfor (i = 0; i < 4 && l >= 32; i++, l -= 32)\n\t\t\tn->addr32[i] = 0xffffffffU;\n\t\tif (i < 4 && l != 0)\n\t\t\tn->addr32[i] = htonl((0xffffffff << (32 - l)) &\n\t\t\t    0xffffffff);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_netmatch(const struct xaddr *host, const struct xaddr *net, u_int masklen)\n{\n\tstruct xaddr tmp_mask, tmp_result;\n\n\tif (host->af != net->af)\n\t\treturn -1;\n\n\tif (addr_netmask(host->af, masklen, &tmp_mask) == -1)\n\t\treturn -1;\n\tif (addr_and(&tmp_result, host, &tmp_mask) == -1)\n\t\treturn -1;\n\treturn addr_cmp(&tmp_result, net);\n}"
  },
  {
    "function_name": "addr_pton_cidr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "311-346",
    "snippet": "static int\naddr_pton_cidr(const char *p, struct xaddr *n, u_int *l)\n{\n\tstruct xaddr tmp;\n\tlong unsigned int masklen = 999;\n\tchar addrbuf[64], *mp, *cp;\n\n\t/* Don't modify argument */\n\tif (p == NULL || strlcpy(addrbuf, p, sizeof(addrbuf)) >= sizeof(addrbuf))\n\t\treturn -1;\n\n\tif ((mp = strchr(addrbuf, '/')) != NULL) {\n\t\t*mp = '\\0';\n\t\tmp++;\n\t\tmasklen = strtoul(mp, &cp, 10);\n\t\tif (*mp == '\\0' || *cp != '\\0' || masklen > 128)\n\t\t\treturn -1;\n\t}\n\n\tif (addr_pton(addrbuf, &tmp) == -1)\n\t\treturn -1;\n\n\tif (mp == NULL)\n\t\tmasklen = addr_unicast_masklen(tmp.af);\n\tif (masklen_valid(tmp.af, masklen) == -1)\n\t\treturn -2;\n\tif (addr_host_is_all0s(&tmp, masklen) != 0)\n\t\treturn -2;\n\n\tif (n != NULL)\n\t\tmemcpy(n, &tmp, sizeof(*n));\n\tif (l != NULL)\n\t\t*l = masklen;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "n",
            "&tmp",
            "sizeof(*n)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr_host_is_all0s",
          "args": [
            "&tmp",
            "masklen"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "addr_host_is_all0s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "294-305",
          "snippet": "static int\naddr_host_is_all0s(const struct xaddr *a, u_int masklen)\n{\n\tstruct xaddr tmp_addr, tmp_mask, tmp_result;\n\n\tmemcpy(&tmp_addr, a, sizeof(tmp_addr));\n\tif (addr_hostmask(a->af, masklen, &tmp_mask) == -1)\n\t\treturn (-1);\n\tif (addr_and(&tmp_result, &tmp_addr, &tmp_mask) == -1)\n\t\treturn (-1);\n\treturn (addr_is_all0s(&tmp_result));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_host_is_all0s(const struct xaddr *a, u_int masklen)\n{\n\tstruct xaddr tmp_addr, tmp_mask, tmp_result;\n\n\tmemcpy(&tmp_addr, a, sizeof(tmp_addr));\n\tif (addr_hostmask(a->af, masklen, &tmp_mask) == -1)\n\t\treturn (-1);\n\tif (addr_and(&tmp_result, &tmp_addr, &tmp_mask) == -1)\n\t\treturn (-1);\n\treturn (addr_is_all0s(&tmp_result));\n}"
        }
      },
      {
        "call_info": {
          "callee": "masklen_valid",
          "args": [
            "tmp.af",
            "masklen"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "masklen_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "63-74",
          "snippet": "static inline int\nmasklen_valid(int af, u_int masklen)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn masklen <= 32 ? 0 : -1;\n\tcase AF_INET6:\n\t\treturn masklen <= 128 ? 0 : -1;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nmasklen_valid(int af, u_int masklen)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn masklen <= 32 ? 0 : -1;\n\tcase AF_INET6:\n\t\treturn masklen <= 128 ? 0 : -1;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_unicast_masklen",
          "args": [
            "tmp.af"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "addr_unicast_masklen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "50-61",
          "snippet": "static int\naddr_unicast_masklen(int af)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn 32;\n\tcase AF_INET6:\n\t\treturn 128;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_unicast_masklen(int af)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn 32;\n\tcase AF_INET6:\n\t\treturn 128;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_pton",
          "args": [
            "addrbuf",
            "&tmp"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "addr_pton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "205-226",
          "snippet": "static int\naddr_pton(const char *p, struct xaddr *n)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint ret = -1;\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (p == NULL || getaddrinfo(p, NULL, &hints, &ai) != 0)\n\t\tgoto out;\n\tif (ai == NULL || ai->ai_addr == NULL)\n\t\tgoto out;\n\tif (n != NULL && addr_sa_to_xaddr(ai->ai_addr, ai->ai_addrlen, n) == -1)\n\t\tgoto out;\n\t/* success */\n\tret = 0;\n out:\n\tif (ai != NULL)\n\t\tfreeaddrinfo(ai);\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_pton(const char *p, struct xaddr *n)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint ret = -1;\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (p == NULL || getaddrinfo(p, NULL, &hints, &ai) != 0)\n\t\tgoto out;\n\tif (ai == NULL || ai->ai_addr == NULL)\n\t\tgoto out;\n\tif (n != NULL && addr_sa_to_xaddr(ai->ai_addr, ai->ai_addrlen, n) == -1)\n\t\tgoto out;\n\t/* success */\n\tret = 0;\n out:\n\tif (ai != NULL)\n\t\tfreeaddrinfo(ai);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "mp",
            "&cp",
            "10"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "strtoull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtoull.c",
          "lines": "49-109",
          "snippet": "unsigned long long\nstrtoull(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tunsigned long long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * See strtoq for comments as to the logic used.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else { \n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\tcutoff = ULLONG_MAX / (unsigned long long)base;\n\tcutlim = ULLONG_MAX % (unsigned long long)base;\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\tany = -1;\n\t\t\tacc = ULLONG_MAX;\n\t\t\terrno = ERANGE;\n\t\t} else {\n\t\t\tany = 1;\n\t\t\tacc *= (unsigned long long)base;\n\t\t\tacc += c;\n\t\t}\n\t}\n\tif (neg && any > 0)\n\t\tacc = -acc;\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nunsigned long long\nstrtoull(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tunsigned long long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * See strtoq for comments as to the logic used.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else { \n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\tcutoff = ULLONG_MAX / (unsigned long long)base;\n\tcutlim = ULLONG_MAX % (unsigned long long)base;\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\tany = -1;\n\t\t\tacc = ULLONG_MAX;\n\t\t\terrno = ERANGE;\n\t\t} else {\n\t\t\tany = 1;\n\t\t\tacc *= (unsigned long long)base;\n\t\t\tacc += c;\n\t\t}\n\t}\n\tif (neg && any > 0)\n\t\tacc = -acc;\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "addrbuf",
            "'/'"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "addrbuf",
            "p",
            "sizeof(addrbuf)"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_pton_cidr(const char *p, struct xaddr *n, u_int *l)\n{\n\tstruct xaddr tmp;\n\tlong unsigned int masklen = 999;\n\tchar addrbuf[64], *mp, *cp;\n\n\t/* Don't modify argument */\n\tif (p == NULL || strlcpy(addrbuf, p, sizeof(addrbuf)) >= sizeof(addrbuf))\n\t\treturn -1;\n\n\tif ((mp = strchr(addrbuf, '/')) != NULL) {\n\t\t*mp = '\\0';\n\t\tmp++;\n\t\tmasklen = strtoul(mp, &cp, 10);\n\t\tif (*mp == '\\0' || *cp != '\\0' || masklen > 128)\n\t\t\treturn -1;\n\t}\n\n\tif (addr_pton(addrbuf, &tmp) == -1)\n\t\treturn -1;\n\n\tif (mp == NULL)\n\t\tmasklen = addr_unicast_masklen(tmp.af);\n\tif (masklen_valid(tmp.af, masklen) == -1)\n\t\treturn -2;\n\tif (addr_host_is_all0s(&tmp, masklen) != 0)\n\t\treturn -2;\n\n\tif (n != NULL)\n\t\tmemcpy(n, &tmp, sizeof(*n));\n\tif (l != NULL)\n\t\t*l = masklen;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "addr_host_is_all0s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "294-305",
    "snippet": "static int\naddr_host_is_all0s(const struct xaddr *a, u_int masklen)\n{\n\tstruct xaddr tmp_addr, tmp_mask, tmp_result;\n\n\tmemcpy(&tmp_addr, a, sizeof(tmp_addr));\n\tif (addr_hostmask(a->af, masklen, &tmp_mask) == -1)\n\t\treturn (-1);\n\tif (addr_and(&tmp_result, &tmp_addr, &tmp_mask) == -1)\n\t\treturn (-1);\n\treturn (addr_is_all0s(&tmp_result));\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addr_is_all0s",
          "args": [
            "&tmp_result"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "addr_is_all0s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "270-286",
          "snippet": "static int\naddr_is_all0s(const struct xaddr *a)\n{\n\tint i;\n\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\treturn (a->v4.s_addr == 0 ? 0 : -1);\n\tcase AF_INET6:;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tif (a->addr32[i] != 0)\n\t\t\t\treturn (-1);\n\t\treturn (0);\n\tdefault:\n\t\treturn (-1);\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define addr32\txa.addr32",
            "#define v4\txa.v4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define addr32\txa.addr32\n#define v4\txa.v4\n\nstatic int\naddr_is_all0s(const struct xaddr *a)\n{\n\tint i;\n\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\treturn (a->v4.s_addr == 0 ? 0 : -1);\n\tcase AF_INET6:;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tif (a->addr32[i] != 0)\n\t\t\t\treturn (-1);\n\t\treturn (0);\n\tdefault:\n\t\treturn (-1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_and",
          "args": [
            "&tmp_result",
            "&tmp_addr",
            "&tmp_mask"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "addr_and",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "149-170",
          "snippet": "static int\naddr_and(struct xaddr *dst, const struct xaddr *a, const struct xaddr *b)\n{\n\tint i;\n\n\tif (dst == NULL || a == NULL || b == NULL || a->af != b->af)\n\t\treturn -1;\n\n\tmemcpy(dst, a, sizeof(*dst));\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\tdst->v4.s_addr &= b->v4.s_addr;\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tdst->scope_id = a->scope_id;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tdst->addr32[i] &= b->addr32[i];\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define addr32\txa.addr32",
            "#define v4\txa.v4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define addr32\txa.addr32\n#define v4\txa.v4\n\nstatic int\naddr_and(struct xaddr *dst, const struct xaddr *a, const struct xaddr *b)\n{\n\tint i;\n\n\tif (dst == NULL || a == NULL || b == NULL || a->af != b->af)\n\t\treturn -1;\n\n\tmemcpy(dst, a, sizeof(*dst));\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\tdst->v4.s_addr &= b->v4.s_addr;\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tdst->scope_id = a->scope_id;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tdst->addr32[i] &= b->addr32[i];\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_hostmask",
          "args": [
            "a->af",
            "masklen",
            "&tmp_mask"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "addr_hostmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "258-264",
          "snippet": "static int\naddr_hostmask(int af, u_int l, struct xaddr *n)\n{\n\tif (addr_netmask(af, l, n) == -1 || addr_invert(n) == -1)\n\t\treturn (-1);\n\treturn (0);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_hostmask(int af, u_int l, struct xaddr *n)\n{\n\tif (addr_netmask(af, l, n) == -1 || addr_invert(n) == -1)\n\t\treturn (-1);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tmp_addr",
            "a",
            "sizeof(tmp_addr)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_host_is_all0s(const struct xaddr *a, u_int masklen)\n{\n\tstruct xaddr tmp_addr, tmp_mask, tmp_result;\n\n\tmemcpy(&tmp_addr, a, sizeof(tmp_addr));\n\tif (addr_hostmask(a->af, masklen, &tmp_mask) == -1)\n\t\treturn (-1);\n\tif (addr_and(&tmp_result, &tmp_addr, &tmp_mask) == -1)\n\t\treturn (-1);\n\treturn (addr_is_all0s(&tmp_result));\n}"
  },
  {
    "function_name": "addr_is_all0s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "270-286",
    "snippet": "static int\naddr_is_all0s(const struct xaddr *a)\n{\n\tint i;\n\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\treturn (a->v4.s_addr == 0 ? 0 : -1);\n\tcase AF_INET6:;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tif (a->addr32[i] != 0)\n\t\t\t\treturn (-1);\n\t\treturn (0);\n\tdefault:\n\t\treturn (-1);\n\t}\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define addr32\txa.addr32",
      "#define v4\txa.v4"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define addr32\txa.addr32\n#define v4\txa.v4\n\nstatic int\naddr_is_all0s(const struct xaddr *a)\n{\n\tint i;\n\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\treturn (a->v4.s_addr == 0 ? 0 : -1);\n\tcase AF_INET6:;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tif (a->addr32[i] != 0)\n\t\t\t\treturn (-1);\n\t\treturn (0);\n\tdefault:\n\t\treturn (-1);\n\t}\n}"
  },
  {
    "function_name": "addr_hostmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "258-264",
    "snippet": "static int\naddr_hostmask(int af, u_int l, struct xaddr *n)\n{\n\tif (addr_netmask(af, l, n) == -1 || addr_invert(n) == -1)\n\t\treturn (-1);\n\treturn (0);\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addr_invert",
          "args": [
            "n"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "addr_invert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "232-251",
          "snippet": "static int\naddr_invert(struct xaddr *n)\n{\n\tint i;\n\n\tif (n == NULL)\n\t\treturn (-1);\n\n\tswitch (n->af) {\n\tcase AF_INET:\n\t\tn->v4.s_addr = ~n->v4.s_addr;\n\t\treturn (0);\n\tcase AF_INET6:\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tn->addr32[i] = ~n->addr32[i];\n\t\treturn (0);\n\tdefault:\n\t\treturn (-1);\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define addr32\txa.addr32",
            "#define v4\txa.v4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define addr32\txa.addr32\n#define v4\txa.v4\n\nstatic int\naddr_invert(struct xaddr *n)\n{\n\tint i;\n\n\tif (n == NULL)\n\t\treturn (-1);\n\n\tswitch (n->af) {\n\tcase AF_INET:\n\t\tn->v4.s_addr = ~n->v4.s_addr;\n\t\treturn (0);\n\tcase AF_INET6:\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tn->addr32[i] = ~n->addr32[i];\n\t\treturn (0);\n\tdefault:\n\t\treturn (-1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_netmask",
          "args": [
            "af",
            "l",
            "n"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "addr_netmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "116-143",
          "snippet": "static int\naddr_netmask(int af, u_int l, struct xaddr *n)\n{\n\tint i;\n\n\tif (masklen_valid(af, l) != 0 || n == NULL)\n\t\treturn -1;\n\n\tmemset(n, '\\0', sizeof(*n));\n\tswitch (af) {\n\tcase AF_INET:\n\t\tn->af = AF_INET;\n\t\tif (l == 0)\n\t\t\treturn 0;\n\t\tn->v4.s_addr = htonl((0xffffffff << (32 - l)) & 0xffffffff);\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tn->af = AF_INET6;\n\t\tfor (i = 0; i < 4 && l >= 32; i++, l -= 32)\n\t\t\tn->addr32[i] = 0xffffffffU;\n\t\tif (i < 4 && l != 0)\n\t\t\tn->addr32[i] = htonl((0xffffffff << (32 - l)) &\n\t\t\t    0xffffffff);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define addr32\txa.addr32",
            "#define v4\txa.v4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define addr32\txa.addr32\n#define v4\txa.v4\n\nstatic int\naddr_netmask(int af, u_int l, struct xaddr *n)\n{\n\tint i;\n\n\tif (masklen_valid(af, l) != 0 || n == NULL)\n\t\treturn -1;\n\n\tmemset(n, '\\0', sizeof(*n));\n\tswitch (af) {\n\tcase AF_INET:\n\t\tn->af = AF_INET;\n\t\tif (l == 0)\n\t\t\treturn 0;\n\t\tn->v4.s_addr = htonl((0xffffffff << (32 - l)) & 0xffffffff);\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tn->af = AF_INET6;\n\t\tfor (i = 0; i < 4 && l >= 32; i++, l -= 32)\n\t\t\tn->addr32[i] = 0xffffffffU;\n\t\tif (i < 4 && l != 0)\n\t\t\tn->addr32[i] = htonl((0xffffffff << (32 - l)) &\n\t\t\t    0xffffffff);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_hostmask(int af, u_int l, struct xaddr *n)\n{\n\tif (addr_netmask(af, l, n) == -1 || addr_invert(n) == -1)\n\t\treturn (-1);\n\treturn (0);\n}"
  },
  {
    "function_name": "addr_invert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "232-251",
    "snippet": "static int\naddr_invert(struct xaddr *n)\n{\n\tint i;\n\n\tif (n == NULL)\n\t\treturn (-1);\n\n\tswitch (n->af) {\n\tcase AF_INET:\n\t\tn->v4.s_addr = ~n->v4.s_addr;\n\t\treturn (0);\n\tcase AF_INET6:\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tn->addr32[i] = ~n->addr32[i];\n\t\treturn (0);\n\tdefault:\n\t\treturn (-1);\n\t}\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define addr32\txa.addr32",
      "#define v4\txa.v4"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define addr32\txa.addr32\n#define v4\txa.v4\n\nstatic int\naddr_invert(struct xaddr *n)\n{\n\tint i;\n\n\tif (n == NULL)\n\t\treturn (-1);\n\n\tswitch (n->af) {\n\tcase AF_INET:\n\t\tn->v4.s_addr = ~n->v4.s_addr;\n\t\treturn (0);\n\tcase AF_INET6:\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tn->addr32[i] = ~n->addr32[i];\n\t\treturn (0);\n\tdefault:\n\t\treturn (-1);\n\t}\n}"
  },
  {
    "function_name": "addr_pton",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "205-226",
    "snippet": "static int\naddr_pton(const char *p, struct xaddr *n)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint ret = -1;\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (p == NULL || getaddrinfo(p, NULL, &hints, &ai) != 0)\n\t\tgoto out;\n\tif (ai == NULL || ai->ai_addr == NULL)\n\t\tgoto out;\n\tif (n != NULL && addr_sa_to_xaddr(ai->ai_addr, ai->ai_addrlen, n) == -1)\n\t\tgoto out;\n\t/* success */\n\tret = 0;\n out:\n\tif (ai != NULL)\n\t\tfreeaddrinfo(ai);\n\treturn ret;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "ai"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_sa_to_xaddr",
          "args": [
            "ai->ai_addr",
            "ai->ai_addrlen",
            "n"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "addr_sa_to_xaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "80-109",
          "snippet": "static int\naddr_sa_to_xaddr(struct sockaddr *sa, socklen_t slen, struct xaddr *xa)\n{\n\tstruct sockaddr_in *in4 = (struct sockaddr_in *)sa;\n\tstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *)sa;\n\n\tmemset(xa, '\\0', sizeof(*xa));\n\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\t\tif (slen < (socklen_t)sizeof(*in4))\n\t\t\treturn -1;\n\t\txa->af = AF_INET;\n\t\tmemcpy(&xa->v4, &in4->sin_addr, sizeof(xa->v4));\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (slen < (socklen_t)sizeof(*in6))\n\t\t\treturn -1;\n\t\txa->af = AF_INET6;\n\t\tmemcpy(&xa->v6, &in6->sin6_addr, sizeof(xa->v6));\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n\t\txa->scope_id = in6->sin6_scope_id;\n#endif\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define v6\txa.v6",
            "#define v4\txa.v4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define v6\txa.v6\n#define v4\txa.v4\n\nstatic int\naddr_sa_to_xaddr(struct sockaddr *sa, socklen_t slen, struct xaddr *xa)\n{\n\tstruct sockaddr_in *in4 = (struct sockaddr_in *)sa;\n\tstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *)sa;\n\n\tmemset(xa, '\\0', sizeof(*xa));\n\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\t\tif (slen < (socklen_t)sizeof(*in4))\n\t\t\treturn -1;\n\t\txa->af = AF_INET;\n\t\tmemcpy(&xa->v4, &in4->sin_addr, sizeof(xa->v4));\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (slen < (socklen_t)sizeof(*in6))\n\t\t\treturn -1;\n\t\txa->af = AF_INET6;\n\t\tmemcpy(&xa->v6, &in6->sin6_addr, sizeof(xa->v6));\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n\t\txa->scope_id = in6->sin6_scope_id;\n#endif\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "p",
            "NULL",
            "&hints",
            "&ai"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "'\\0'",
            "sizeof(hints)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_pton(const char *p, struct xaddr *n)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint ret = -1;\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (p == NULL || getaddrinfo(p, NULL, &hints, &ai) != 0)\n\t\tgoto out;\n\tif (ai == NULL || ai->ai_addr == NULL)\n\t\tgoto out;\n\tif (n != NULL && addr_sa_to_xaddr(ai->ai_addr, ai->ai_addrlen, n) == -1)\n\t\tgoto out;\n\t/* success */\n\tret = 0;\n out:\n\tif (ai != NULL)\n\t\tfreeaddrinfo(ai);\n\treturn ret;\n}"
  },
  {
    "function_name": "addr_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "176-199",
    "snippet": "static int\naddr_cmp(const struct xaddr *a, const struct xaddr *b)\n{\n\tint i;\n\n\tif (a->af != b->af)\n\t\treturn a->af == AF_INET6 ? 1 : -1;\n\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\tif (a->v4.s_addr == b->v4.s_addr)\n\t\t\treturn 0;\n\t\treturn ntohl(a->v4.s_addr) > ntohl(b->v4.s_addr) ? 1 : -1;\n\tcase AF_INET6:\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tif (a->addr8[i] - b->addr8[i] != 0)\n\t\t\t\treturn a->addr8[i] > b->addr8[i] ? 1 : -1;\n\t\tif (a->scope_id == b->scope_id)\n\t\t\treturn 0;\n\t\treturn a->scope_id > b->scope_id ? 1 : -1;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define addr8\txa.addr8",
      "#define v4\txa.v4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "b->v4.s_addr"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "a->v4.s_addr"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define addr8\txa.addr8\n#define v4\txa.v4\n\nstatic int\naddr_cmp(const struct xaddr *a, const struct xaddr *b)\n{\n\tint i;\n\n\tif (a->af != b->af)\n\t\treturn a->af == AF_INET6 ? 1 : -1;\n\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\tif (a->v4.s_addr == b->v4.s_addr)\n\t\t\treturn 0;\n\t\treturn ntohl(a->v4.s_addr) > ntohl(b->v4.s_addr) ? 1 : -1;\n\tcase AF_INET6:\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tif (a->addr8[i] - b->addr8[i] != 0)\n\t\t\t\treturn a->addr8[i] > b->addr8[i] ? 1 : -1;\n\t\tif (a->scope_id == b->scope_id)\n\t\t\treturn 0;\n\t\treturn a->scope_id > b->scope_id ? 1 : -1;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "addr_and",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "149-170",
    "snippet": "static int\naddr_and(struct xaddr *dst, const struct xaddr *a, const struct xaddr *b)\n{\n\tint i;\n\n\tif (dst == NULL || a == NULL || b == NULL || a->af != b->af)\n\t\treturn -1;\n\n\tmemcpy(dst, a, sizeof(*dst));\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\tdst->v4.s_addr &= b->v4.s_addr;\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tdst->scope_id = a->scope_id;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tdst->addr32[i] &= b->addr32[i];\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define addr32\txa.addr32",
      "#define v4\txa.v4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "a",
            "sizeof(*dst)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define addr32\txa.addr32\n#define v4\txa.v4\n\nstatic int\naddr_and(struct xaddr *dst, const struct xaddr *a, const struct xaddr *b)\n{\n\tint i;\n\n\tif (dst == NULL || a == NULL || b == NULL || a->af != b->af)\n\t\treturn -1;\n\n\tmemcpy(dst, a, sizeof(*dst));\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\tdst->v4.s_addr &= b->v4.s_addr;\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tdst->scope_id = a->scope_id;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tdst->addr32[i] &= b->addr32[i];\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "addr_netmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "116-143",
    "snippet": "static int\naddr_netmask(int af, u_int l, struct xaddr *n)\n{\n\tint i;\n\n\tif (masklen_valid(af, l) != 0 || n == NULL)\n\t\treturn -1;\n\n\tmemset(n, '\\0', sizeof(*n));\n\tswitch (af) {\n\tcase AF_INET:\n\t\tn->af = AF_INET;\n\t\tif (l == 0)\n\t\t\treturn 0;\n\t\tn->v4.s_addr = htonl((0xffffffff << (32 - l)) & 0xffffffff);\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tn->af = AF_INET6;\n\t\tfor (i = 0; i < 4 && l >= 32; i++, l -= 32)\n\t\t\tn->addr32[i] = 0xffffffffU;\n\t\tif (i < 4 && l != 0)\n\t\t\tn->addr32[i] = htonl((0xffffffff << (32 - l)) &\n\t\t\t    0xffffffff);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define addr32\txa.addr32",
      "#define v4\txa.v4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(0xffffffff << (32 - l)) &\n\t\t\t    0xffffffff"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(0xffffffff << (32 - l)) & 0xffffffff"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "n",
            "'\\0'",
            "sizeof(*n)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "masklen_valid",
          "args": [
            "af",
            "l"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "masklen_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "63-74",
          "snippet": "static inline int\nmasklen_valid(int af, u_int masklen)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn masklen <= 32 ? 0 : -1;\n\tcase AF_INET6:\n\t\treturn masklen <= 128 ? 0 : -1;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nmasklen_valid(int af, u_int masklen)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn masklen <= 32 ? 0 : -1;\n\tcase AF_INET6:\n\t\treturn masklen <= 128 ? 0 : -1;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define addr32\txa.addr32\n#define v4\txa.v4\n\nstatic int\naddr_netmask(int af, u_int l, struct xaddr *n)\n{\n\tint i;\n\n\tif (masklen_valid(af, l) != 0 || n == NULL)\n\t\treturn -1;\n\n\tmemset(n, '\\0', sizeof(*n));\n\tswitch (af) {\n\tcase AF_INET:\n\t\tn->af = AF_INET;\n\t\tif (l == 0)\n\t\t\treturn 0;\n\t\tn->v4.s_addr = htonl((0xffffffff << (32 - l)) & 0xffffffff);\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tn->af = AF_INET6;\n\t\tfor (i = 0; i < 4 && l >= 32; i++, l -= 32)\n\t\t\tn->addr32[i] = 0xffffffffU;\n\t\tif (i < 4 && l != 0)\n\t\t\tn->addr32[i] = htonl((0xffffffff << (32 - l)) &\n\t\t\t    0xffffffff);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "addr_sa_to_xaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "80-109",
    "snippet": "static int\naddr_sa_to_xaddr(struct sockaddr *sa, socklen_t slen, struct xaddr *xa)\n{\n\tstruct sockaddr_in *in4 = (struct sockaddr_in *)sa;\n\tstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *)sa;\n\n\tmemset(xa, '\\0', sizeof(*xa));\n\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\t\tif (slen < (socklen_t)sizeof(*in4))\n\t\t\treturn -1;\n\t\txa->af = AF_INET;\n\t\tmemcpy(&xa->v4, &in4->sin_addr, sizeof(xa->v4));\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (slen < (socklen_t)sizeof(*in6))\n\t\t\treturn -1;\n\t\txa->af = AF_INET6;\n\t\tmemcpy(&xa->v6, &in6->sin6_addr, sizeof(xa->v6));\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n\t\txa->scope_id = in6->sin6_scope_id;\n#endif\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define v6\txa.v6",
      "#define v4\txa.v4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&xa->v6",
            "&in6->sin6_addr",
            "sizeof(xa->v6)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&xa->v4",
            "&in4->sin_addr",
            "sizeof(xa->v4)"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xa",
            "'\\0'",
            "sizeof(*xa)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define v6\txa.v6\n#define v4\txa.v4\n\nstatic int\naddr_sa_to_xaddr(struct sockaddr *sa, socklen_t slen, struct xaddr *xa)\n{\n\tstruct sockaddr_in *in4 = (struct sockaddr_in *)sa;\n\tstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *)sa;\n\n\tmemset(xa, '\\0', sizeof(*xa));\n\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\t\tif (slen < (socklen_t)sizeof(*in4))\n\t\t\treturn -1;\n\t\txa->af = AF_INET;\n\t\tmemcpy(&xa->v4, &in4->sin_addr, sizeof(xa->v4));\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (slen < (socklen_t)sizeof(*in6))\n\t\t\treturn -1;\n\t\txa->af = AF_INET6;\n\t\tmemcpy(&xa->v6, &in6->sin6_addr, sizeof(xa->v6));\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n\t\txa->scope_id = in6->sin6_scope_id;\n#endif\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "masklen_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "63-74",
    "snippet": "static inline int\nmasklen_valid(int af, u_int masklen)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn masklen <= 32 ? 0 : -1;\n\tcase AF_INET6:\n\t\treturn masklen <= 128 ? 0 : -1;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nmasklen_valid(int af, u_int masklen)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn masklen <= 32 ? 0 : -1;\n\tcase AF_INET6:\n\t\treturn masklen <= 128 ? 0 : -1;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "addr_unicast_masklen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
    "lines": "50-61",
    "snippet": "static int\naddr_unicast_masklen(int af)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn 32;\n\tcase AF_INET6:\n\t\treturn 128;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naddr_unicast_masklen(int af)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn 32;\n\tcase AF_INET6:\n\t\treturn 128;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
  }
]