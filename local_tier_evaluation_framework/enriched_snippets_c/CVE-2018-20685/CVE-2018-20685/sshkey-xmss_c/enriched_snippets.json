[
  {
    "function_name": "sshkey_xmss_enable_maxsign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "1041-1054",
    "snippet": "int\nsshkey_xmss_enable_maxsign(struct sshkey *k, u_int32_t maxsign)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\n\tif (sshkey_type_plain(k->type) != KEY_XMSS)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (maxsign == 0)\n\t\treturn 0;\n\tif (state->idx + maxsign < state->idx)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tstate->maxidx = state->idx + maxsign;\n\treturn 0;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "k->type"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_enable_maxsign(struct sshkey *k, u_int32_t maxsign)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\n\tif (sshkey_type_plain(k->type) != KEY_XMSS)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (maxsign == 0)\n\t\treturn 0;\n\tif (state->idx + maxsign < state->idx)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tstate->maxidx = state->idx + maxsign;\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_xmss_signatures_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "1026-1039",
    "snippet": "u_int32_t\nsshkey_xmss_signatures_left(const struct sshkey *k)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_int32_t idx;\n\n\tif (sshkey_type_plain(k->type) == KEY_XMSS && state &&\n\t    state->maxidx) {\n\t\tidx = k->xmss_sk ? PEEK_U32(k->xmss_sk) : state->idx;\n\t\tif (idx < state->maxidx)\n\t\t\treturn state->maxidx - idx;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "k->xmss_sk"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "k->type"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\nsshkey_xmss_signatures_left(const struct sshkey *k)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_int32_t idx;\n\n\tif (sshkey_type_plain(k->type) == KEY_XMSS && state &&\n\t    state->maxidx) {\n\t\tidx = k->xmss_sk ? PEEK_U32(k->xmss_sk) : state->idx;\n\t\tif (idx < state->maxidx)\n\t\t\treturn state->maxidx - idx;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_xmss_decrypt_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "922-1024",
    "snippet": "int\nsshkey_xmss_decrypt_state(const struct sshkey *k, struct sshbuf *encoded,\n   struct sshbuf **retp)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *copy = NULL, *decrypted = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher = NULL;\n\tu_char *key, *iv = NULL, *dp;\n\tsize_t keylen, ivlen, authlen, aadlen;\n\tu_int blocksize, encrypted_len, index;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (state == NULL ||\n\t    state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((cipher = cipher_by_name(state->enc_ciphername)) == NULL) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif (state->enc_keyiv_len != keylen + ivlen) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tkey = state->enc_keyiv;\n\n\tif ((copy = sshbuf_fromb(encoded)) == NULL ||\n\t    (decrypted = sshbuf_new()) == NULL ||\n\t    (iv = malloc(ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* check magic */\n\tif (sshbuf_len(encoded) < sizeof(XMSS_MAGIC) ||\n\t    memcmp(sshbuf_ptr(encoded), XMSS_MAGIC, sizeof(XMSS_MAGIC))) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* parse public portion */\n\tif ((r = sshbuf_consume(encoded, sizeof(XMSS_MAGIC))) != 0 ||\n\t    (r = sshbuf_get_u32(encoded, &index)) != 0 ||\n\t    (r = sshbuf_get_u32(encoded, &encrypted_len)) != 0)\n\t\tgoto out;\n\n\t/* check size of encrypted key blob */\n\tif (encrypted_len < blocksize || (encrypted_len % blocksize) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* check that an appropriate amount of auth data is present */\n\tif (sshbuf_len(encoded) < encrypted_len + authlen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\taadlen = sshbuf_len(copy) - sshbuf_len(encoded);\n\n\t/* replace first 4 bytes of IV with index to ensure uniqueness */\n\tmemcpy(iv, key + keylen, ivlen);\n\tPOKE_U32(iv, index);\n\n\t/* decrypt private state of key */\n\tif ((r = sshbuf_reserve(decrypted, aadlen + encrypted_len, &dp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    iv, ivlen, 0)) != 0 ||\n\t    (r = cipher_crypt(ciphercontext, 0, dp, sshbuf_ptr(copy),\n\t    encrypted_len, aadlen, authlen)) != 0)\n\t\tgoto out;\n\n\t/* there should be no trailing data */\n\tif ((r = sshbuf_consume(encoded, encrypted_len + authlen)) != 0)\n\t\tgoto out;\n\tif (sshbuf_len(encoded) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* remove AAD */\n\tif ((r = sshbuf_consume(decrypted, aadlen)) != 0)\n\t\tgoto out;\n\t/* XXX encrypted includes unchecked padding */\n\n\t/* success */\n\tr = 0;\n\tif (retp != NULL) {\n\t\t*retp = decrypted;\n\t\tdecrypted = NULL;\n\t}\n out:\n\tcipher_free(ciphercontext);\n\tsshbuf_free(copy);\n\tsshbuf_free(decrypted);\n\tfree(iv);\n\treturn r;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define XMSS_MAGIC\t\t\"xmss-state-v1\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "iv"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_free_bds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "187-208",
          "snippet": "void\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "decrypted"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_free",
          "args": [
            "ciphercontext"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "410-425",
          "snippet": "void\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nvoid\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "decrypted",
            "aadlen"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "encoded"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_crypt",
          "args": [
            "ciphercontext",
            "0",
            "dp",
            "sshbuf_ptr(copy)",
            "encrypted_len",
            "aadlen",
            "authlen"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_crypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "334-394",
          "snippet": "int\ncipher_crypt(struct sshcipher_ctx *cc, u_int seqnr, u_char *dest,\n   const u_char *src, u_int len, u_int aadlen, u_int authlen)\n{\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\treturn chachapoly_crypt(&cc->cp_ctx, seqnr, dest, src,\n\t\t    len, aadlen, authlen, cc->encrypt);\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tmemcpy(dest, src, aadlen + len);\n\t\treturn 0;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\tif (aadlen)\n\t\t\tmemcpy(dest, src, aadlen);\n\t\taesctr_encrypt_bytes(&cc->ac_ctx, src + aadlen,\n\t\t    dest + aadlen, len);\n\t\treturn 0;\n\t}\n\treturn SSH_ERR_INVALID_ARGUMENT;\n#else\n\tif (authlen) {\n\t\tu_char lastiv[1];\n\n\t\tif (authlen != cipher_authlen(cc->cipher))\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t/* increment IV */\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,\n\t\t    1, lastiv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t/* set tag on decyption */\n\t\tif (!cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_TAG,\n\t\t    authlen, (u_char *)src + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\tif (aadlen) {\n\t\tif (authlen &&\n\t\t    EVP_Cipher(cc->evp, NULL, (u_char *)src, aadlen) < 0)\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\tmemcpy(dest, src, aadlen);\n\t}\n\tif (len % cc->cipher->block_size)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (EVP_Cipher(cc->evp, dest + aadlen, (u_char *)src + aadlen,\n\t    len) < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif (authlen) {\n\t\t/* compute tag (on encrypt) or verify tag (on decrypt) */\n\t\tif (EVP_Cipher(cc->evp, NULL, NULL, 0) < 0)\n\t\t\treturn cc->encrypt ?\n\t\t\t    SSH_ERR_LIBCRYPTO_ERROR : SSH_ERR_MAC_INVALID;\n\t\tif (cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_GET_TAG,\n\t\t    authlen, dest + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_NONE\t\t(1<<3)",
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_NONE\t\t(1<<3)\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nint\ncipher_crypt(struct sshcipher_ctx *cc, u_int seqnr, u_char *dest,\n   const u_char *src, u_int len, u_int aadlen, u_int authlen)\n{\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\treturn chachapoly_crypt(&cc->cp_ctx, seqnr, dest, src,\n\t\t    len, aadlen, authlen, cc->encrypt);\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tmemcpy(dest, src, aadlen + len);\n\t\treturn 0;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\tif (aadlen)\n\t\t\tmemcpy(dest, src, aadlen);\n\t\taesctr_encrypt_bytes(&cc->ac_ctx, src + aadlen,\n\t\t    dest + aadlen, len);\n\t\treturn 0;\n\t}\n\treturn SSH_ERR_INVALID_ARGUMENT;\n#else\n\tif (authlen) {\n\t\tu_char lastiv[1];\n\n\t\tif (authlen != cipher_authlen(cc->cipher))\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t/* increment IV */\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,\n\t\t    1, lastiv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t/* set tag on decyption */\n\t\tif (!cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_TAG,\n\t\t    authlen, (u_char *)src + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\tif (aadlen) {\n\t\tif (authlen &&\n\t\t    EVP_Cipher(cc->evp, NULL, (u_char *)src, aadlen) < 0)\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\tmemcpy(dest, src, aadlen);\n\t}\n\tif (len % cc->cipher->block_size)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (EVP_Cipher(cc->evp, dest + aadlen, (u_char *)src + aadlen,\n\t    len) < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif (authlen) {\n\t\t/* compute tag (on encrypt) or verify tag (on decrypt) */\n\t\tif (EVP_Cipher(cc->evp, NULL, NULL, 0) < 0)\n\t\t\treturn cc->encrypt ?\n\t\t\t    SSH_ERR_LIBCRYPTO_ERROR : SSH_ERR_MAC_INVALID;\n\t\tif (cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_GET_TAG,\n\t\t    authlen, dest + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "copy"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_init",
          "args": [
            "&ciphercontext",
            "cipher",
            "key",
            "keylen",
            "iv",
            "ivlen",
            "0"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "235-322",
          "snippet": "int\ncipher_init(struct sshcipher_ctx **ccp, const struct sshcipher *cipher,\n    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,\n    int do_encrypt)\n{\n\tstruct sshcipher_ctx *cc = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst EVP_CIPHER *type;\n\tint klen;\n#endif\n\n\t*ccp = NULL;\n\tif ((cc = calloc(sizeof(*cc), 1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tcc->plaintext = (cipher->flags & CFLAG_NONE) != 0;\n\tcc->encrypt = do_encrypt;\n\n\tif (keylen < cipher->key_len ||\n\t    (iv != NULL && ivlen < cipher_ivlen(cipher))) {\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tcc->cipher = cipher;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tret = chachapoly_init(&cc->cp_ctx, key, keylen);\n\t\tgoto out;\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\taesctr_keysetup(&cc->ac_ctx, key, 8 * keylen, 8 * ivlen);\n\t\taesctr_ivsetup(&cc->ac_ctx, iv);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tret = SSH_ERR_INVALID_ARGUMENT;\n\tgoto out;\n#else /* WITH_OPENSSL */\n\ttype = (*cipher->evptype)();\n\tif ((cc->evp = EVP_CIPHER_CTX_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EVP_CipherInit(cc->evp, type, NULL, (u_char *)iv,\n\t    (do_encrypt == CIPHER_ENCRYPT)) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (cipher_authlen(cipher) &&\n\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,\n\t    -1, (u_char *)iv)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tklen = EVP_CIPHER_CTX_key_length(cc->evp);\n\tif (klen > 0 && keylen != (u_int)klen) {\n\t\tif (EVP_CIPHER_CTX_set_key_length(cc->evp, keylen) == 0) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tret = 0;\n#endif /* WITH_OPENSSL */\n out:\n\tif (ret == 0) {\n\t\t/* success */\n\t\t*ccp = cc;\n\t} else {\n\t\tif (cc != NULL) {\n#ifdef WITH_OPENSSL\n\t\t\tEVP_CIPHER_CTX_free(cc->evp);\n#endif /* WITH_OPENSSL */\n\t\t\texplicit_bzero(cc, sizeof(*cc));\n\t\t\tfree(cc);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_NONE\t\t(1<<3)",
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_NONE\t\t(1<<3)\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nint\ncipher_init(struct sshcipher_ctx **ccp, const struct sshcipher *cipher,\n    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,\n    int do_encrypt)\n{\n\tstruct sshcipher_ctx *cc = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst EVP_CIPHER *type;\n\tint klen;\n#endif\n\n\t*ccp = NULL;\n\tif ((cc = calloc(sizeof(*cc), 1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tcc->plaintext = (cipher->flags & CFLAG_NONE) != 0;\n\tcc->encrypt = do_encrypt;\n\n\tif (keylen < cipher->key_len ||\n\t    (iv != NULL && ivlen < cipher_ivlen(cipher))) {\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tcc->cipher = cipher;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tret = chachapoly_init(&cc->cp_ctx, key, keylen);\n\t\tgoto out;\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\taesctr_keysetup(&cc->ac_ctx, key, 8 * keylen, 8 * ivlen);\n\t\taesctr_ivsetup(&cc->ac_ctx, iv);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tret = SSH_ERR_INVALID_ARGUMENT;\n\tgoto out;\n#else /* WITH_OPENSSL */\n\ttype = (*cipher->evptype)();\n\tif ((cc->evp = EVP_CIPHER_CTX_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EVP_CipherInit(cc->evp, type, NULL, (u_char *)iv,\n\t    (do_encrypt == CIPHER_ENCRYPT)) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (cipher_authlen(cipher) &&\n\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,\n\t    -1, (u_char *)iv)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tklen = EVP_CIPHER_CTX_key_length(cc->evp);\n\tif (klen > 0 && keylen != (u_int)klen) {\n\t\tif (EVP_CIPHER_CTX_set_key_length(cc->evp, keylen) == 0) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tret = 0;\n#endif /* WITH_OPENSSL */\n out:\n\tif (ret == 0) {\n\t\t/* success */\n\t\t*ccp = cc;\n\t} else {\n\t\tif (cc != NULL) {\n#ifdef WITH_OPENSSL\n\t\t\tEVP_CIPHER_CTX_free(cc->evp);\n#endif /* WITH_OPENSSL */\n\t\t\texplicit_bzero(cc, sizeof(*cc));\n\t\t\tfree(cc);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reserve",
          "args": [
            "decrypted",
            "aadlen + encrypted_len",
            "&dp"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "343-361",
          "snippet": "int\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "POKE_U32",
          "args": [
            "iv",
            "index"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iv",
            "key + keylen",
            "ivlen"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "encoded",
            "&encrypted_len"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sshbuf_ptr(encoded)",
            "XMSS_MAGIC",
            "sizeof(XMSS_MAGIC)"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "ivlen"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_fromb",
          "args": [
            "encoded"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_fromb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "117-131",
          "snippet": "struct sshbuf *\nsshbuf_fromb(struct sshbuf *buf)\n{\n\tstruct sshbuf *ret;\n\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\tif ((ret = sshbuf_from(sshbuf_ptr(buf), sshbuf_len(buf))) == NULL)\n\t\treturn NULL;\n\tif (sshbuf_set_parent(ret, buf) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_fromb(struct sshbuf *buf)\n{\n\tstruct sshbuf *ret;\n\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\tif ((ret = sshbuf_from(sshbuf_ptr(buf), sshbuf_len(buf))) == NULL)\n\t\treturn NULL;\n\tif (sshbuf_set_parent(ret, buf) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_authlen",
          "args": [
            "cipher"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_authlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "163-167",
          "snippet": "u_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_ivlen",
          "args": [
            "cipher"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_ivlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "169-178",
          "snippet": "u_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t/*\n\t * Default is cipher block size, except for chacha20+poly1305 that\n\t * needs no IV. XXX make iv_len == -1 default?\n\t */\n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nu_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t/*\n\t * Default is cipher block size, except for chacha20+poly1305 that\n\t * needs no IV. XXX make iv_len == -1 default?\n\t */\n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_keylen",
          "args": [
            "cipher"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_keylen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "149-153",
          "snippet": "u_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_blocksize",
          "args": [
            "cipher"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "143-147",
          "snippet": "u_int\ncipher_blocksize(const struct sshcipher *c)\n{\n\treturn (c->block_size);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_blocksize(const struct sshcipher *c)\n{\n\treturn (c->block_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_by_name",
          "args": [
            "state->enc_ciphername"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "192-200",
          "snippet": "const struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};\n\nconst struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define XMSS_MAGIC\t\t\"xmss-state-v1\"\n\nint\nsshkey_xmss_decrypt_state(const struct sshkey *k, struct sshbuf *encoded,\n   struct sshbuf **retp)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *copy = NULL, *decrypted = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher = NULL;\n\tu_char *key, *iv = NULL, *dp;\n\tsize_t keylen, ivlen, authlen, aadlen;\n\tu_int blocksize, encrypted_len, index;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (state == NULL ||\n\t    state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((cipher = cipher_by_name(state->enc_ciphername)) == NULL) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif (state->enc_keyiv_len != keylen + ivlen) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tkey = state->enc_keyiv;\n\n\tif ((copy = sshbuf_fromb(encoded)) == NULL ||\n\t    (decrypted = sshbuf_new()) == NULL ||\n\t    (iv = malloc(ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* check magic */\n\tif (sshbuf_len(encoded) < sizeof(XMSS_MAGIC) ||\n\t    memcmp(sshbuf_ptr(encoded), XMSS_MAGIC, sizeof(XMSS_MAGIC))) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* parse public portion */\n\tif ((r = sshbuf_consume(encoded, sizeof(XMSS_MAGIC))) != 0 ||\n\t    (r = sshbuf_get_u32(encoded, &index)) != 0 ||\n\t    (r = sshbuf_get_u32(encoded, &encrypted_len)) != 0)\n\t\tgoto out;\n\n\t/* check size of encrypted key blob */\n\tif (encrypted_len < blocksize || (encrypted_len % blocksize) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* check that an appropriate amount of auth data is present */\n\tif (sshbuf_len(encoded) < encrypted_len + authlen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\taadlen = sshbuf_len(copy) - sshbuf_len(encoded);\n\n\t/* replace first 4 bytes of IV with index to ensure uniqueness */\n\tmemcpy(iv, key + keylen, ivlen);\n\tPOKE_U32(iv, index);\n\n\t/* decrypt private state of key */\n\tif ((r = sshbuf_reserve(decrypted, aadlen + encrypted_len, &dp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    iv, ivlen, 0)) != 0 ||\n\t    (r = cipher_crypt(ciphercontext, 0, dp, sshbuf_ptr(copy),\n\t    encrypted_len, aadlen, authlen)) != 0)\n\t\tgoto out;\n\n\t/* there should be no trailing data */\n\tif ((r = sshbuf_consume(encoded, encrypted_len + authlen)) != 0)\n\t\tgoto out;\n\tif (sshbuf_len(encoded) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* remove AAD */\n\tif ((r = sshbuf_consume(decrypted, aadlen)) != 0)\n\t\tgoto out;\n\t/* XXX encrypted includes unchecked padding */\n\n\t/* success */\n\tr = 0;\n\tif (retp != NULL) {\n\t\t*retp = decrypted;\n\t\tdecrypted = NULL;\n\t}\n out:\n\tcipher_free(ciphercontext);\n\tsshbuf_free(copy);\n\tsshbuf_free(decrypted);\n\tfree(iv);\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_xmss_encrypt_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "831-920",
    "snippet": "int\nsshkey_xmss_encrypt_state(const struct sshkey *k, struct sshbuf *b,\n   struct sshbuf **retp)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *encrypted = NULL, *encoded = NULL, *padded = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher;\n\tu_char *cp, *key, *iv = NULL;\n\tsize_t i, keylen, ivlen, blocksize, authlen, encrypted_len, aadlen;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (state == NULL ||\n\t    state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((cipher = cipher_by_name(state->enc_ciphername)) == NULL) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif (state->enc_keyiv_len != keylen + ivlen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tkey = state->enc_keyiv;\n\tif ((encrypted = sshbuf_new()) == NULL ||\n\t    (encoded = sshbuf_new()) == NULL ||\n\t    (padded = sshbuf_new()) == NULL ||\n\t    (iv = malloc(ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* replace first 4 bytes of IV with index to ensure uniqueness */\n\tmemcpy(iv, key + keylen, ivlen);\n\tPOKE_U32(iv, state->idx);\n\n\tif ((r = sshbuf_put(encoded, XMSS_MAGIC, sizeof(XMSS_MAGIC))) != 0 ||\n\t    (r = sshbuf_put_u32(encoded, state->idx)) != 0)\n\t\tgoto out;\n\n\t/* padded state will be encrypted */\n\tif ((r = sshbuf_putb(padded, b)) != 0)\n\t\tgoto out;\n\ti = 0;\n\twhile (sshbuf_len(padded) % blocksize) {\n\t\tif ((r = sshbuf_put_u8(padded, ++i & 0xff)) != 0)\n\t\t\tgoto out;\n\t}\n\tencrypted_len = sshbuf_len(padded);\n\n\t/* header including the length of state is used as AAD */\n\tif ((r = sshbuf_put_u32(encoded, encrypted_len)) != 0)\n\t\tgoto out;\n\taadlen = sshbuf_len(encoded);\n\n\t/* concat header and state */\n\tif ((r = sshbuf_putb(encoded, padded)) != 0)\n\t\tgoto out;\n\n\t/* reserve space for encryption of encoded data plus auth tag */\n\t/* encrypt at offset addlen */\n\tif ((r = sshbuf_reserve(encrypted,\n\t    encrypted_len + aadlen + authlen, &cp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    iv, ivlen, 1)) != 0 ||\n\t    (r = cipher_crypt(ciphercontext, 0, cp, sshbuf_ptr(encoded),\n\t    encrypted_len, aadlen, authlen)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n out:\n\tif (retp != NULL) {\n\t\t*retp = encrypted;\n\t\tencrypted = NULL;\n\t}\n\tsshbuf_free(padded);\n\tsshbuf_free(encoded);\n\tsshbuf_free(encrypted);\n\tcipher_free(ciphercontext);\n\tfree(iv);\n\treturn r;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define XMSS_MAGIC\t\t\"xmss-state-v1\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "iv"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_free_bds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "187-208",
          "snippet": "void\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_free",
          "args": [
            "ciphercontext"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "410-425",
          "snippet": "void\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nvoid\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "encrypted"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_crypt",
          "args": [
            "ciphercontext",
            "0",
            "cp",
            "sshbuf_ptr(encoded)",
            "encrypted_len",
            "aadlen",
            "authlen"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_crypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "334-394",
          "snippet": "int\ncipher_crypt(struct sshcipher_ctx *cc, u_int seqnr, u_char *dest,\n   const u_char *src, u_int len, u_int aadlen, u_int authlen)\n{\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\treturn chachapoly_crypt(&cc->cp_ctx, seqnr, dest, src,\n\t\t    len, aadlen, authlen, cc->encrypt);\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tmemcpy(dest, src, aadlen + len);\n\t\treturn 0;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\tif (aadlen)\n\t\t\tmemcpy(dest, src, aadlen);\n\t\taesctr_encrypt_bytes(&cc->ac_ctx, src + aadlen,\n\t\t    dest + aadlen, len);\n\t\treturn 0;\n\t}\n\treturn SSH_ERR_INVALID_ARGUMENT;\n#else\n\tif (authlen) {\n\t\tu_char lastiv[1];\n\n\t\tif (authlen != cipher_authlen(cc->cipher))\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t/* increment IV */\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,\n\t\t    1, lastiv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t/* set tag on decyption */\n\t\tif (!cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_TAG,\n\t\t    authlen, (u_char *)src + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\tif (aadlen) {\n\t\tif (authlen &&\n\t\t    EVP_Cipher(cc->evp, NULL, (u_char *)src, aadlen) < 0)\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\tmemcpy(dest, src, aadlen);\n\t}\n\tif (len % cc->cipher->block_size)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (EVP_Cipher(cc->evp, dest + aadlen, (u_char *)src + aadlen,\n\t    len) < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif (authlen) {\n\t\t/* compute tag (on encrypt) or verify tag (on decrypt) */\n\t\tif (EVP_Cipher(cc->evp, NULL, NULL, 0) < 0)\n\t\t\treturn cc->encrypt ?\n\t\t\t    SSH_ERR_LIBCRYPTO_ERROR : SSH_ERR_MAC_INVALID;\n\t\tif (cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_GET_TAG,\n\t\t    authlen, dest + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_NONE\t\t(1<<3)",
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_NONE\t\t(1<<3)\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nint\ncipher_crypt(struct sshcipher_ctx *cc, u_int seqnr, u_char *dest,\n   const u_char *src, u_int len, u_int aadlen, u_int authlen)\n{\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\treturn chachapoly_crypt(&cc->cp_ctx, seqnr, dest, src,\n\t\t    len, aadlen, authlen, cc->encrypt);\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tmemcpy(dest, src, aadlen + len);\n\t\treturn 0;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\tif (aadlen)\n\t\t\tmemcpy(dest, src, aadlen);\n\t\taesctr_encrypt_bytes(&cc->ac_ctx, src + aadlen,\n\t\t    dest + aadlen, len);\n\t\treturn 0;\n\t}\n\treturn SSH_ERR_INVALID_ARGUMENT;\n#else\n\tif (authlen) {\n\t\tu_char lastiv[1];\n\n\t\tif (authlen != cipher_authlen(cc->cipher))\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t/* increment IV */\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,\n\t\t    1, lastiv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t/* set tag on decyption */\n\t\tif (!cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_TAG,\n\t\t    authlen, (u_char *)src + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\tif (aadlen) {\n\t\tif (authlen &&\n\t\t    EVP_Cipher(cc->evp, NULL, (u_char *)src, aadlen) < 0)\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\tmemcpy(dest, src, aadlen);\n\t}\n\tif (len % cc->cipher->block_size)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (EVP_Cipher(cc->evp, dest + aadlen, (u_char *)src + aadlen,\n\t    len) < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif (authlen) {\n\t\t/* compute tag (on encrypt) or verify tag (on decrypt) */\n\t\tif (EVP_Cipher(cc->evp, NULL, NULL, 0) < 0)\n\t\t\treturn cc->encrypt ?\n\t\t\t    SSH_ERR_LIBCRYPTO_ERROR : SSH_ERR_MAC_INVALID;\n\t\tif (cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_GET_TAG,\n\t\t    authlen, dest + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "encoded"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_init",
          "args": [
            "&ciphercontext",
            "cipher",
            "key",
            "keylen",
            "iv",
            "ivlen",
            "1"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "235-322",
          "snippet": "int\ncipher_init(struct sshcipher_ctx **ccp, const struct sshcipher *cipher,\n    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,\n    int do_encrypt)\n{\n\tstruct sshcipher_ctx *cc = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst EVP_CIPHER *type;\n\tint klen;\n#endif\n\n\t*ccp = NULL;\n\tif ((cc = calloc(sizeof(*cc), 1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tcc->plaintext = (cipher->flags & CFLAG_NONE) != 0;\n\tcc->encrypt = do_encrypt;\n\n\tif (keylen < cipher->key_len ||\n\t    (iv != NULL && ivlen < cipher_ivlen(cipher))) {\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tcc->cipher = cipher;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tret = chachapoly_init(&cc->cp_ctx, key, keylen);\n\t\tgoto out;\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\taesctr_keysetup(&cc->ac_ctx, key, 8 * keylen, 8 * ivlen);\n\t\taesctr_ivsetup(&cc->ac_ctx, iv);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tret = SSH_ERR_INVALID_ARGUMENT;\n\tgoto out;\n#else /* WITH_OPENSSL */\n\ttype = (*cipher->evptype)();\n\tif ((cc->evp = EVP_CIPHER_CTX_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EVP_CipherInit(cc->evp, type, NULL, (u_char *)iv,\n\t    (do_encrypt == CIPHER_ENCRYPT)) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (cipher_authlen(cipher) &&\n\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,\n\t    -1, (u_char *)iv)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tklen = EVP_CIPHER_CTX_key_length(cc->evp);\n\tif (klen > 0 && keylen != (u_int)klen) {\n\t\tif (EVP_CIPHER_CTX_set_key_length(cc->evp, keylen) == 0) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tret = 0;\n#endif /* WITH_OPENSSL */\n out:\n\tif (ret == 0) {\n\t\t/* success */\n\t\t*ccp = cc;\n\t} else {\n\t\tif (cc != NULL) {\n#ifdef WITH_OPENSSL\n\t\t\tEVP_CIPHER_CTX_free(cc->evp);\n#endif /* WITH_OPENSSL */\n\t\t\texplicit_bzero(cc, sizeof(*cc));\n\t\t\tfree(cc);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_NONE\t\t(1<<3)",
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_NONE\t\t(1<<3)\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nint\ncipher_init(struct sshcipher_ctx **ccp, const struct sshcipher *cipher,\n    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,\n    int do_encrypt)\n{\n\tstruct sshcipher_ctx *cc = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst EVP_CIPHER *type;\n\tint klen;\n#endif\n\n\t*ccp = NULL;\n\tif ((cc = calloc(sizeof(*cc), 1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tcc->plaintext = (cipher->flags & CFLAG_NONE) != 0;\n\tcc->encrypt = do_encrypt;\n\n\tif (keylen < cipher->key_len ||\n\t    (iv != NULL && ivlen < cipher_ivlen(cipher))) {\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tcc->cipher = cipher;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tret = chachapoly_init(&cc->cp_ctx, key, keylen);\n\t\tgoto out;\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\taesctr_keysetup(&cc->ac_ctx, key, 8 * keylen, 8 * ivlen);\n\t\taesctr_ivsetup(&cc->ac_ctx, iv);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tret = SSH_ERR_INVALID_ARGUMENT;\n\tgoto out;\n#else /* WITH_OPENSSL */\n\ttype = (*cipher->evptype)();\n\tif ((cc->evp = EVP_CIPHER_CTX_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EVP_CipherInit(cc->evp, type, NULL, (u_char *)iv,\n\t    (do_encrypt == CIPHER_ENCRYPT)) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (cipher_authlen(cipher) &&\n\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,\n\t    -1, (u_char *)iv)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tklen = EVP_CIPHER_CTX_key_length(cc->evp);\n\tif (klen > 0 && keylen != (u_int)klen) {\n\t\tif (EVP_CIPHER_CTX_set_key_length(cc->evp, keylen) == 0) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tret = 0;\n#endif /* WITH_OPENSSL */\n out:\n\tif (ret == 0) {\n\t\t/* success */\n\t\t*ccp = cc;\n\t} else {\n\t\tif (cc != NULL) {\n#ifdef WITH_OPENSSL\n\t\t\tEVP_CIPHER_CTX_free(cc->evp);\n#endif /* WITH_OPENSSL */\n\t\t\texplicit_bzero(cc, sizeof(*cc));\n\t\t\tfree(cc);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reserve",
          "args": [
            "encrypted",
            "encrypted_len + aadlen + authlen",
            "&cp"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "343-361",
          "snippet": "int\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putb",
          "args": [
            "encoded",
            "padded"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "248-252",
          "snippet": "int\nsshbuf_putb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "encoded"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "encoded",
            "encrypted_len"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "padded",
            "++i & 0xff"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "encoded",
            "XMSS_MAGIC",
            "sizeof(XMSS_MAGIC)"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "POKE_U32",
          "args": [
            "iv",
            "state->idx"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iv",
            "key + keylen",
            "ivlen"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "ivlen"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_authlen",
          "args": [
            "cipher"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_authlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "163-167",
          "snippet": "u_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_ivlen",
          "args": [
            "cipher"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_ivlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "169-178",
          "snippet": "u_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t/*\n\t * Default is cipher block size, except for chacha20+poly1305 that\n\t * needs no IV. XXX make iv_len == -1 default?\n\t */\n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nu_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t/*\n\t * Default is cipher block size, except for chacha20+poly1305 that\n\t * needs no IV. XXX make iv_len == -1 default?\n\t */\n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_keylen",
          "args": [
            "cipher"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_keylen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "149-153",
          "snippet": "u_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_blocksize",
          "args": [
            "cipher"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "143-147",
          "snippet": "u_int\ncipher_blocksize(const struct sshcipher *c)\n{\n\treturn (c->block_size);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_blocksize(const struct sshcipher *c)\n{\n\treturn (c->block_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_by_name",
          "args": [
            "state->enc_ciphername"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "192-200",
          "snippet": "const struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};\n\nconst struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define XMSS_MAGIC\t\t\"xmss-state-v1\"\n\nint\nsshkey_xmss_encrypt_state(const struct sshkey *k, struct sshbuf *b,\n   struct sshbuf **retp)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *encrypted = NULL, *encoded = NULL, *padded = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher;\n\tu_char *cp, *key, *iv = NULL;\n\tsize_t i, keylen, ivlen, blocksize, authlen, encrypted_len, aadlen;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (state == NULL ||\n\t    state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((cipher = cipher_by_name(state->enc_ciphername)) == NULL) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif (state->enc_keyiv_len != keylen + ivlen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tkey = state->enc_keyiv;\n\tif ((encrypted = sshbuf_new()) == NULL ||\n\t    (encoded = sshbuf_new()) == NULL ||\n\t    (padded = sshbuf_new()) == NULL ||\n\t    (iv = malloc(ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* replace first 4 bytes of IV with index to ensure uniqueness */\n\tmemcpy(iv, key + keylen, ivlen);\n\tPOKE_U32(iv, state->idx);\n\n\tif ((r = sshbuf_put(encoded, XMSS_MAGIC, sizeof(XMSS_MAGIC))) != 0 ||\n\t    (r = sshbuf_put_u32(encoded, state->idx)) != 0)\n\t\tgoto out;\n\n\t/* padded state will be encrypted */\n\tif ((r = sshbuf_putb(padded, b)) != 0)\n\t\tgoto out;\n\ti = 0;\n\twhile (sshbuf_len(padded) % blocksize) {\n\t\tif ((r = sshbuf_put_u8(padded, ++i & 0xff)) != 0)\n\t\t\tgoto out;\n\t}\n\tencrypted_len = sshbuf_len(padded);\n\n\t/* header including the length of state is used as AAD */\n\tif ((r = sshbuf_put_u32(encoded, encrypted_len)) != 0)\n\t\tgoto out;\n\taadlen = sshbuf_len(encoded);\n\n\t/* concat header and state */\n\tif ((r = sshbuf_putb(encoded, padded)) != 0)\n\t\tgoto out;\n\n\t/* reserve space for encryption of encoded data plus auth tag */\n\t/* encrypt at offset addlen */\n\tif ((r = sshbuf_reserve(encrypted,\n\t    encrypted_len + aadlen + authlen, &cp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    iv, ivlen, 1)) != 0 ||\n\t    (r = cipher_crypt(ciphercontext, 0, cp, sshbuf_ptr(encoded),\n\t    encrypted_len, aadlen, authlen)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n out:\n\tif (retp != NULL) {\n\t\t*retp = encrypted;\n\t\tencrypted = NULL;\n\t}\n\tsshbuf_free(padded);\n\tsshbuf_free(encoded);\n\tsshbuf_free(encrypted);\n\tcipher_free(ciphercontext);\n\tfree(iv);\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_xmss_deserialize_state_opt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "800-829",
    "snippet": "int\nsshkey_xmss_deserialize_state_opt(struct sshkey *k, struct sshbuf *b)\n{\n\tenum sshkey_serialize_rep opts;\n\tu_char have_state;\n\tint r;\n\n\tif ((r = sshbuf_get_u8(b, &have_state)) != 0)\n\t\treturn r;\n\n\topts = have_state;\n\tswitch (opts) {\n\tcase SSHKEY_SERIALIZE_DEFAULT:\n\t\tr = 0;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_STATE:\n\t\tif ((r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_FULL:\n\t\tif ((r = sshkey_xmss_deserialize_enc_key(k, b)) != 0 ||\n\t\t    (r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tbreak;\n\t}\n\treturn r;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_xmss_deserialize_state",
          "args": [
            "k",
            "b"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_deserialize_state_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "800-829",
          "snippet": "int\nsshkey_xmss_deserialize_state_opt(struct sshkey *k, struct sshbuf *b)\n{\n\tenum sshkey_serialize_rep opts;\n\tu_char have_state;\n\tint r;\n\n\tif ((r = sshbuf_get_u8(b, &have_state)) != 0)\n\t\treturn r;\n\n\topts = have_state;\n\tswitch (opts) {\n\tcase SSHKEY_SERIALIZE_DEFAULT:\n\t\tr = 0;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_STATE:\n\t\tif ((r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_FULL:\n\t\tif ((r = sshkey_xmss_deserialize_enc_key(k, b)) != 0 ||\n\t\t    (r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tbreak;\n\t}\n\treturn r;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_deserialize_enc_key",
          "args": [
            "k",
            "b"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_deserialize_enc_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "306-320",
          "snippet": "int\nsshkey_xmss_deserialize_enc_key(struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tsize_t len;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_get_cstring(b, &state->enc_ciphername, NULL)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->enc_keyiv, &len)) != 0)\n\t\treturn r;\n\tstate->enc_keyiv_len = len;\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_deserialize_enc_key(struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tsize_t len;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_get_cstring(b, &state->enc_ciphername, NULL)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->enc_keyiv, &len)) != 0)\n\t\treturn r;\n\tstate->enc_keyiv_len = len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "b",
            "&have_state"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_deserialize_state_opt(struct sshkey *k, struct sshbuf *b)\n{\n\tenum sshkey_serialize_rep opts;\n\tu_char have_state;\n\tint r;\n\n\tif ((r = sshbuf_get_u8(b, &have_state)) != 0)\n\t\treturn r;\n\n\topts = have_state;\n\tswitch (opts) {\n\tcase SSHKEY_SERIALIZE_DEFAULT:\n\t\tr = 0;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_STATE:\n\t\tif ((r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_FULL:\n\t\tif ((r = sshkey_xmss_deserialize_enc_key(k, b)) != 0 ||\n\t\t    (r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tbreak;\n\t}\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_xmss_deserialize_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "743-798",
    "snippet": "int\nsshkey_xmss_deserialize_state(struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\ttreehash_inst *th;\n\tu_int32_t i, lh, node;\n\tsize_t ls, lsl, la, lk, ln, lr;\n\tchar *magic;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (k->xmss_sk == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((state->treehash = calloc(num_treehash(state),\n\t    sizeof(treehash_inst))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &magic, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &state->idx)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->stack, &ls)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &state->stackoffset)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->stacklevels, &lsl)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->auth, &la)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->keep, &lk)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->th_nodes, &ln)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->retain, &lr)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &lh)) != 0)\n\t\treturn r;\n\tif (strcmp(magic, SSH_XMSS_K2_MAGIC) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t/* XXX check stackoffset */\n\tif (ls != num_stack(state) ||\n\t    lsl != num_stacklevels(state) ||\n\t    la != num_auth(state) ||\n\t    lk != num_keep(state) ||\n\t    ln != num_th_nodes(state) ||\n\t    lr != num_retain(state) ||\n\t    lh != num_treehash(state))\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tfor (i = 0; i < num_treehash(state); i++) {\n\t\tth = &state->treehash[i];\n\t\tif ((r = sshbuf_get_u32(b, &th->h)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &th->next_idx)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &th->stackusage)) != 0 ||\n\t\t    (r = sshbuf_get_u8(b, &th->completed)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &node)) != 0)\n\t\t\treturn r;\n\t\tif (node < num_th_nodes(state))\n\t\t\tth->node = &state->th_nodes[node];\n\t}\n\tPOKE_U32(k->xmss_sk, state->idx);\n\txmss_set_bds_state(&state->bds, state->stack, state->stackoffset,\n\t    state->stacklevels, state->auth, state->keep, state->treehash,\n\t    state->retain, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SSH_XMSS_K2_MAGIC\t\"k=2\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmss_set_bds_state",
          "args": [
            "&state->bds",
            "state->stack",
            "state->stackoffset",
            "state->stacklevels",
            "state->auth",
            "state->keep",
            "state->treehash",
            "state->retain",
            "0"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "xmss_set_bds_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "72-82",
          "snippet": "void xmss_set_bds_state(bds_state *state, unsigned char *stack, int stackoffset, unsigned char *stacklevels, unsigned char *auth, unsigned char *keep, treehash_inst *treehash, unsigned char *retain, int next_leaf)\n{\n  state->stack = stack;\n  state->stackoffset = stackoffset;\n  state->stacklevels = stacklevels;\n  state->auth = auth;\n  state->keep = keep;\n  state->treehash = treehash;\n  state->retain = retain;\n  state->next_leaf = next_leaf;\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid xmss_set_bds_state(bds_state *state, unsigned char *stack, int stackoffset, unsigned char *stacklevels, unsigned char *auth, unsigned char *keep, treehash_inst *treehash, unsigned char *retain, int next_leaf)\n{\n  state->stack = stack;\n  state->stackoffset = stackoffset;\n  state->stacklevels = stacklevels;\n  state->auth = auth;\n  state->keep = keep;\n  state->treehash = treehash;\n  state->retain = retain;\n  state->next_leaf = next_leaf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "POKE_U32",
          "args": [
            "k->xmss_sk",
            "state->idx"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_th_nodes",
          "args": [
            "state"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "b",
            "&node"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "b",
            "&th->completed"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_treehash",
          "args": [
            "state"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_treehash",
          "args": [
            "state"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_retain",
          "args": [
            "state"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_th_nodes",
          "args": [
            "state"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_keep",
          "args": [
            "state"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_auth",
          "args": [
            "state"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_stacklevels",
          "args": [
            "state"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_stack",
          "args": [
            "state"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "magic",
            "SSH_XMSS_K2_MAGIC"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "b",
            "&state->retain",
            "&lr"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "b",
            "&magic",
            "NULL"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "num_treehash(state)",
            "sizeof(treehash_inst)"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_treehash",
          "args": [
            "state"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_XMSS_K2_MAGIC\t\"k=2\"\n\nint\nsshkey_xmss_deserialize_state(struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\ttreehash_inst *th;\n\tu_int32_t i, lh, node;\n\tsize_t ls, lsl, la, lk, ln, lr;\n\tchar *magic;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (k->xmss_sk == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((state->treehash = calloc(num_treehash(state),\n\t    sizeof(treehash_inst))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &magic, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &state->idx)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->stack, &ls)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &state->stackoffset)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->stacklevels, &lsl)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->auth, &la)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->keep, &lk)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->th_nodes, &ln)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->retain, &lr)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &lh)) != 0)\n\t\treturn r;\n\tif (strcmp(magic, SSH_XMSS_K2_MAGIC) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t/* XXX check stackoffset */\n\tif (ls != num_stack(state) ||\n\t    lsl != num_stacklevels(state) ||\n\t    la != num_auth(state) ||\n\t    lk != num_keep(state) ||\n\t    ln != num_th_nodes(state) ||\n\t    lr != num_retain(state) ||\n\t    lh != num_treehash(state))\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tfor (i = 0; i < num_treehash(state); i++) {\n\t\tth = &state->treehash[i];\n\t\tif ((r = sshbuf_get_u32(b, &th->h)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &th->next_idx)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &th->stackusage)) != 0 ||\n\t\t    (r = sshbuf_get_u8(b, &th->completed)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &node)) != 0)\n\t\t\treturn r;\n\t\tif (node < num_th_nodes(state))\n\t\t\tth->node = &state->th_nodes[node];\n\t}\n\tPOKE_U32(k->xmss_sk, state->idx);\n\txmss_set_bds_state(&state->bds, state->stack, state->stackoffset,\n\t    state->stacklevels, state->auth, state->keep, state->treehash,\n\t    state->retain, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_xmss_serialize_state_opt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "713-741",
    "snippet": "int\nsshkey_xmss_serialize_state_opt(const struct sshkey *k, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tint r = SSH_ERR_INVALID_ARGUMENT;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_put_u8(b, opts)) != 0)\n\t\treturn r;\n\tswitch (opts) {\n\tcase SSHKEY_SERIALIZE_STATE:\n\t\tr = sshkey_xmss_serialize_state(k, b);\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_FULL:\n\t\tif ((r = sshkey_xmss_serialize_enc_key(k, b)) != 0)\n\t\t\tbreak;\n\t\tr = sshkey_xmss_serialize_state(k, b);\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_DEFAULT:\n\t\tr = 0;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tbreak;\n\t}\n\treturn r;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_xmss_serialize_state",
          "args": [
            "k",
            "b"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_serialize_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "676-711",
          "snippet": "int\nsshkey_xmss_serialize_state(const struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\ttreehash_inst *th;\n\tu_int32_t i, node;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state->stack == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tstate->stackoffset = state->bds.stackoffset;\t/* copy back */\n\tif ((r = sshbuf_put_cstring(b, SSH_XMSS_K2_MAGIC)) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->idx)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->stack, num_stack(state))) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->stackoffset)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->stacklevels, num_stacklevels(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->auth, num_auth(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->keep, num_keep(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->th_nodes, num_th_nodes(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->retain, num_retain(state))) != 0 ||\n\t    (r = sshbuf_put_u32(b, num_treehash(state))) != 0)\n\t\treturn r;\n\tfor (i = 0; i < num_treehash(state); i++) {\n\t\tth = &state->treehash[i];\n\t\tnode = th->node - state->th_nodes;\n\t\tif ((r = sshbuf_put_u32(b, th->h)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, th->next_idx)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, th->stackusage)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, th->completed)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, node)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SSH_XMSS_K2_MAGIC\t\"k=2\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_XMSS_K2_MAGIC\t\"k=2\"\n\nint\nsshkey_xmss_serialize_state(const struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\ttreehash_inst *th;\n\tu_int32_t i, node;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state->stack == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tstate->stackoffset = state->bds.stackoffset;\t/* copy back */\n\tif ((r = sshbuf_put_cstring(b, SSH_XMSS_K2_MAGIC)) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->idx)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->stack, num_stack(state))) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->stackoffset)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->stacklevels, num_stacklevels(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->auth, num_auth(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->keep, num_keep(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->th_nodes, num_th_nodes(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->retain, num_retain(state))) != 0 ||\n\t    (r = sshbuf_put_u32(b, num_treehash(state))) != 0)\n\t\treturn r;\n\tfor (i = 0; i < num_treehash(state); i++) {\n\t\tth = &state->treehash[i];\n\t\tnode = th->node - state->th_nodes;\n\t\tif ((r = sshbuf_put_u32(b, th->h)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, th->next_idx)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, th->stackusage)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, th->completed)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, node)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_serialize_enc_key",
          "args": [
            "k",
            "b"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_serialize_enc_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "290-304",
          "snippet": "int\nsshkey_xmss_serialize_enc_key(const struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tint r;\n\n\tif (state == NULL || state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_put_cstring(b, state->enc_ciphername)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->enc_keyiv,\n\t    state->enc_keyiv_len)) != 0)\n\t\treturn r;\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_serialize_enc_key(const struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tint r;\n\n\tif (state == NULL || state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_put_cstring(b, state->enc_ciphername)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->enc_keyiv,\n\t    state->enc_keyiv_len)) != 0)\n\t\treturn r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "b",
            "opts"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_serialize_state_opt(const struct sshkey *k, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tint r = SSH_ERR_INVALID_ARGUMENT;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_put_u8(b, opts)) != 0)\n\t\treturn r;\n\tswitch (opts) {\n\tcase SSHKEY_SERIALIZE_STATE:\n\t\tr = sshkey_xmss_serialize_state(k, b);\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_FULL:\n\t\tif ((r = sshkey_xmss_serialize_enc_key(k, b)) != 0)\n\t\t\tbreak;\n\t\tr = sshkey_xmss_serialize_state(k, b);\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_DEFAULT:\n\t\tr = 0;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tbreak;\n\t}\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_xmss_serialize_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "676-711",
    "snippet": "int\nsshkey_xmss_serialize_state(const struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\ttreehash_inst *th;\n\tu_int32_t i, node;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state->stack == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tstate->stackoffset = state->bds.stackoffset;\t/* copy back */\n\tif ((r = sshbuf_put_cstring(b, SSH_XMSS_K2_MAGIC)) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->idx)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->stack, num_stack(state))) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->stackoffset)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->stacklevels, num_stacklevels(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->auth, num_auth(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->keep, num_keep(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->th_nodes, num_th_nodes(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->retain, num_retain(state))) != 0 ||\n\t    (r = sshbuf_put_u32(b, num_treehash(state))) != 0)\n\t\treturn r;\n\tfor (i = 0; i < num_treehash(state); i++) {\n\t\tth = &state->treehash[i];\n\t\tnode = th->node - state->th_nodes;\n\t\tif ((r = sshbuf_put_u32(b, th->h)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, th->next_idx)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, th->stackusage)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, th->completed)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, node)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SSH_XMSS_K2_MAGIC\t\"k=2\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "b",
            "node"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "b",
            "th->completed"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_treehash",
          "args": [
            "state"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_treehash",
          "args": [
            "state"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "b",
            "state->retain",
            "num_retain(state)"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_retain",
          "args": [
            "state"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_th_nodes",
          "args": [
            "state"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_keep",
          "args": [
            "state"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_auth",
          "args": [
            "state"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_stacklevels",
          "args": [
            "state"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_stack",
          "args": [
            "state"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "b",
            "SSH_XMSS_K2_MAGIC"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_XMSS_K2_MAGIC\t\"k=2\"\n\nint\nsshkey_xmss_serialize_state(const struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\ttreehash_inst *th;\n\tu_int32_t i, node;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state->stack == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tstate->stackoffset = state->bds.stackoffset;\t/* copy back */\n\tif ((r = sshbuf_put_cstring(b, SSH_XMSS_K2_MAGIC)) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->idx)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->stack, num_stack(state))) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->stackoffset)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->stacklevels, num_stacklevels(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->auth, num_auth(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->keep, num_keep(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->th_nodes, num_th_nodes(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->retain, num_retain(state))) != 0 ||\n\t    (r = sshbuf_put_u32(b, num_treehash(state))) != 0)\n\t\treturn r;\n\tfor (i = 0; i < num_treehash(state); i++) {\n\t\tth = &state->treehash[i];\n\t\tnode = th->node - state->th_nodes;\n\t\tif ((r = sshbuf_put_u32(b, th->h)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, th->next_idx)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, th->stackusage)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, th->completed)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, node)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_xmss_update_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "565-674",
    "snippet": "int\nsshkey_xmss_update_state(const struct sshkey *k, sshkey_printfn *pr)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *b = NULL, *enc = NULL;\n\tu_int32_t idx = 0;\n\tunsigned char buf[4];\n\tchar *filename = NULL;\n\tchar *statefile = NULL, *ostatefile = NULL, *nstatefile = NULL;\n\tint fd = -1;\n\tint ret = SSH_ERR_INVALID_ARGUMENT;\n\n\tif (state == NULL || !state->allow_update)\n\t\treturn ret;\n\tif (state->maxidx) {\n\t\t/* no update since the number of signatures is limited */\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\tidx = PEEK_U32(k->xmss_sk);\n\tif (idx == state->idx) {\n\t\t/* no signature happened, no need to update */\n\t\tret = 0;\n\t\tgoto done;\n\t} else if (idx != state->idx + 1) {\n\t\tPRINT(\"%s: more than one signature happened: idx %u state %u\",\n\t\t     __func__, idx, state->idx);\n\t\tgoto done;\n\t}\n\tstate->idx = idx;\n\tif ((filename = k->xmss_filename) == NULL)\n\t\tgoto done;\n\tif (asprintf(&statefile, \"%s.state\", filename) < 0 ||\n\t    asprintf(&ostatefile, \"%s.ostate\", filename) < 0 ||\n\t    asprintf(&nstatefile, \"%s.nstate\", filename) < 0) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tunlink(nstatefile);\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((ret = sshkey_xmss_serialize_state(k, b)) != 0) {\n\t\tPRINT(\"%s: SERLIALIZE FAILED: %d\", __func__, ret);\n\t\tgoto done;\n\t}\n\tif ((ret = sshkey_xmss_encrypt_state(k, b, &enc)) != 0) {\n\t\tPRINT(\"%s: ENCRYPT FAILED: %d\", __func__, ret);\n\t\tgoto done;\n\t}\n\tif ((fd = open(nstatefile, O_CREAT|O_WRONLY|O_EXCL, 0600)) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: open new state file: %s\", __func__, nstatefile);\n\t\tgoto done;\n\t}\n\tPOKE_U32(buf, sshbuf_len(enc));\n\tif (atomicio(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: write new state file hdr: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(enc), sshbuf_len(enc)) !=\n\t    sshbuf_len(enc)) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: write new state file data: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (fsync(fd) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: sync new state file: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (close(fd) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: close new state file: %s\", __func__, nstatefile);\n\t\tgoto done;\n\t}\n\tif (state->have_state) {\n\t\tunlink(ostatefile);\n\t\tif (link(statefile, ostatefile)) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: backup state %s to %s\", __func__, statefile,\n\t\t\t    ostatefile);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (rename(nstatefile, statefile) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: rename %s to %s\", __func__, nstatefile, statefile);\n\t\tgoto done;\n\t}\n\tret = 0;\ndone:\n\tif (state->lockfd != -1) {\n\t\tclose(state->lockfd);\n\t\tstate->lockfd = -1;\n\t}\n\tif (nstatefile)\n\t\tunlink(nstatefile);\n\tfree(statefile);\n\tfree(ostatefile);\n\tfree(nstatefile);\n\tsshbuf_free(b);\n\tsshbuf_free(enc);\n\treturn ret;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "enc"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "nstatefile"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_free_bds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "187-208",
          "snippet": "void\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "nstatefile"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "state->lockfd"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: rename %s to %s\"",
            "__func__",
            "nstatefile",
            "statefile"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "nstatefile",
            "statefile"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: backup state %s to %s\"",
            "__func__",
            "statefile",
            "ostatefile"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link",
          "args": [
            "statefile",
            "ostatefile"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "do_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1026-1079",
          "snippet": "char *\ndo_readlink(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_READLINK, path, strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't readlink: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_READLINK\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_READLINK %s -> %s\", path, filename);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn filename;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ndo_readlink(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_READLINK, path, strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't readlink: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_READLINK\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_READLINK %s -> %s\", path, filename);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "ostatefile"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: close new state file: %s\"",
            "__func__",
            "nstatefile"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: sync new state file: %s\"",
            "__func__",
            "nstatefile"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsync",
          "args": [
            "fd"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "process_extended_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1354-1370",
          "snippet": "static void\nprocess_extended_fsync(u_int32_t id)\n{\n\tint handle, fd, r, status = SSH2_FX_OP_UNSUPPORTED;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"request %u: fsync (handle %u)\", id, handle);\n\tverbose(\"fsync \\\"%s\\\"\", handle_to_name(handle));\n\tif ((fd = handle_to_fd(handle)) < 0)\n\t\tstatus = SSH2_FX_NO_SUCH_FILE;\n\telse if (handle_is_ok(handle, HANDLE_FILE)) {\n\t\tr = fsync(fd);\n\t\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\t}\n\tsend_status(id, status);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct sshbuf *iqueue;",
            "static void process_open(u_int32_t id);",
            "static void process_close(u_int32_t id);",
            "static void process_read(u_int32_t id);",
            "static void process_write(u_int32_t id);",
            "static void process_stat(u_int32_t id);",
            "static void process_lstat(u_int32_t id);",
            "static void process_fstat(u_int32_t id);",
            "static void process_setstat(u_int32_t id);",
            "static void process_fsetstat(u_int32_t id);",
            "static void process_opendir(u_int32_t id);",
            "static void process_readdir(u_int32_t id);",
            "static void process_remove(u_int32_t id);",
            "static void process_mkdir(u_int32_t id);",
            "static void process_rmdir(u_int32_t id);",
            "static void process_realpath(u_int32_t id);",
            "static void process_rename(u_int32_t id);",
            "static void process_readlink(u_int32_t id);",
            "static void process_symlink(u_int32_t id);",
            "static void process_extended_posix_rename(u_int32_t id);",
            "static void process_extended_statvfs(u_int32_t id);",
            "static void process_extended_fstatvfs(u_int32_t id);",
            "static void process_extended_hardlink(u_int32_t id);",
            "static void process_extended_fsync(u_int32_t id);",
            "static void process_extended(u_int32_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *iqueue;\nstatic void process_open(u_int32_t id);\nstatic void process_close(u_int32_t id);\nstatic void process_read(u_int32_t id);\nstatic void process_write(u_int32_t id);\nstatic void process_stat(u_int32_t id);\nstatic void process_lstat(u_int32_t id);\nstatic void process_fstat(u_int32_t id);\nstatic void process_setstat(u_int32_t id);\nstatic void process_fsetstat(u_int32_t id);\nstatic void process_opendir(u_int32_t id);\nstatic void process_readdir(u_int32_t id);\nstatic void process_remove(u_int32_t id);\nstatic void process_mkdir(u_int32_t id);\nstatic void process_rmdir(u_int32_t id);\nstatic void process_realpath(u_int32_t id);\nstatic void process_rename(u_int32_t id);\nstatic void process_readlink(u_int32_t id);\nstatic void process_symlink(u_int32_t id);\nstatic void process_extended_posix_rename(u_int32_t id);\nstatic void process_extended_statvfs(u_int32_t id);\nstatic void process_extended_fstatvfs(u_int32_t id);\nstatic void process_extended_hardlink(u_int32_t id);\nstatic void process_extended_fsync(u_int32_t id);\nstatic void process_extended(u_int32_t id);\n\nstatic void\nprocess_extended_fsync(u_int32_t id)\n{\n\tint handle, fd, r, status = SSH2_FX_OP_UNSUPPORTED;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"request %u: fsync (handle %u)\", id, handle);\n\tverbose(\"fsync \\\"%s\\\"\", handle_to_name(handle));\n\tif ((fd = handle_to_fd(handle)) < 0)\n\t\tstatus = SSH2_FX_NO_SUCH_FILE;\n\telse if (handle_is_ok(handle, HANDLE_FILE)) {\n\t\tr = fsync(fd);\n\t\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\t}\n\tsend_status(id, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: write new state file data: %s\"",
            "__func__",
            "nstatefile"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "enc"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "fd",
            "sshbuf_mutable_ptr(enc)",
            "sshbuf_len(enc)"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_mutable_ptr",
          "args": [
            "enc"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_mutable_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "276-282",
          "snippet": "u_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: write new state file hdr: %s\"",
            "__func__",
            "nstatefile"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POKE_U32",
          "args": [
            "buf",
            "sshbuf_len(enc)"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: open new state file: %s\"",
            "__func__",
            "nstatefile"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "nstatefile",
            "O_CREAT|O_WRONLY|O_EXCL",
            "0600"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "lastlog_openseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/loginrec.c",
          "lines": "1471-1514",
          "snippet": "static int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "# include <util.h>",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"canohost.h\"",
            "#include \"packet.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int utmp_write_entry(struct logininfo *li);",
            "int utmpx_write_entry(struct logininfo *li);",
            "int wtmp_write_entry(struct logininfo *li);",
            "int wtmpx_write_entry(struct logininfo *li);",
            "int lastlog_write_entry(struct logininfo *li);",
            "int syslogin_write_entry(struct logininfo *li);",
            "int getlast_entry(struct logininfo *li);",
            "int lastlog_get_entry(struct logininfo *li);",
            "int utmpx_get_entry(struct logininfo *li);",
            "int wtmp_get_entry(struct logininfo *li);",
            "int wtmpx_get_entry(struct logininfo *li);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <util.h>\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint utmp_write_entry(struct logininfo *li);\nint utmpx_write_entry(struct logininfo *li);\nint wtmp_write_entry(struct logininfo *li);\nint wtmpx_write_entry(struct logininfo *li);\nint lastlog_write_entry(struct logininfo *li);\nint syslogin_write_entry(struct logininfo *li);\nint getlast_entry(struct logininfo *li);\nint lastlog_get_entry(struct logininfo *li);\nint utmpx_get_entry(struct logininfo *li);\nint wtmp_get_entry(struct logininfo *li);\nint wtmpx_get_entry(struct logininfo *li);\n\nstatic int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: ENCRYPT FAILED: %d\"",
            "__func__",
            "ret"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_encrypt_state",
          "args": [
            "k",
            "b",
            "&enc"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_encrypt_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "831-920",
          "snippet": "int\nsshkey_xmss_encrypt_state(const struct sshkey *k, struct sshbuf *b,\n   struct sshbuf **retp)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *encrypted = NULL, *encoded = NULL, *padded = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher;\n\tu_char *cp, *key, *iv = NULL;\n\tsize_t i, keylen, ivlen, blocksize, authlen, encrypted_len, aadlen;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (state == NULL ||\n\t    state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((cipher = cipher_by_name(state->enc_ciphername)) == NULL) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif (state->enc_keyiv_len != keylen + ivlen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tkey = state->enc_keyiv;\n\tif ((encrypted = sshbuf_new()) == NULL ||\n\t    (encoded = sshbuf_new()) == NULL ||\n\t    (padded = sshbuf_new()) == NULL ||\n\t    (iv = malloc(ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* replace first 4 bytes of IV with index to ensure uniqueness */\n\tmemcpy(iv, key + keylen, ivlen);\n\tPOKE_U32(iv, state->idx);\n\n\tif ((r = sshbuf_put(encoded, XMSS_MAGIC, sizeof(XMSS_MAGIC))) != 0 ||\n\t    (r = sshbuf_put_u32(encoded, state->idx)) != 0)\n\t\tgoto out;\n\n\t/* padded state will be encrypted */\n\tif ((r = sshbuf_putb(padded, b)) != 0)\n\t\tgoto out;\n\ti = 0;\n\twhile (sshbuf_len(padded) % blocksize) {\n\t\tif ((r = sshbuf_put_u8(padded, ++i & 0xff)) != 0)\n\t\t\tgoto out;\n\t}\n\tencrypted_len = sshbuf_len(padded);\n\n\t/* header including the length of state is used as AAD */\n\tif ((r = sshbuf_put_u32(encoded, encrypted_len)) != 0)\n\t\tgoto out;\n\taadlen = sshbuf_len(encoded);\n\n\t/* concat header and state */\n\tif ((r = sshbuf_putb(encoded, padded)) != 0)\n\t\tgoto out;\n\n\t/* reserve space for encryption of encoded data plus auth tag */\n\t/* encrypt at offset addlen */\n\tif ((r = sshbuf_reserve(encrypted,\n\t    encrypted_len + aadlen + authlen, &cp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    iv, ivlen, 1)) != 0 ||\n\t    (r = cipher_crypt(ciphercontext, 0, cp, sshbuf_ptr(encoded),\n\t    encrypted_len, aadlen, authlen)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n out:\n\tif (retp != NULL) {\n\t\t*retp = encrypted;\n\t\tencrypted = NULL;\n\t}\n\tsshbuf_free(padded);\n\tsshbuf_free(encoded);\n\tsshbuf_free(encrypted);\n\tcipher_free(ciphercontext);\n\tfree(iv);\n\treturn r;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define XMSS_MAGIC\t\t\"xmss-state-v1\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define XMSS_MAGIC\t\t\"xmss-state-v1\"\n\nint\nsshkey_xmss_encrypt_state(const struct sshkey *k, struct sshbuf *b,\n   struct sshbuf **retp)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *encrypted = NULL, *encoded = NULL, *padded = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher;\n\tu_char *cp, *key, *iv = NULL;\n\tsize_t i, keylen, ivlen, blocksize, authlen, encrypted_len, aadlen;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (state == NULL ||\n\t    state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((cipher = cipher_by_name(state->enc_ciphername)) == NULL) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif (state->enc_keyiv_len != keylen + ivlen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tkey = state->enc_keyiv;\n\tif ((encrypted = sshbuf_new()) == NULL ||\n\t    (encoded = sshbuf_new()) == NULL ||\n\t    (padded = sshbuf_new()) == NULL ||\n\t    (iv = malloc(ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* replace first 4 bytes of IV with index to ensure uniqueness */\n\tmemcpy(iv, key + keylen, ivlen);\n\tPOKE_U32(iv, state->idx);\n\n\tif ((r = sshbuf_put(encoded, XMSS_MAGIC, sizeof(XMSS_MAGIC))) != 0 ||\n\t    (r = sshbuf_put_u32(encoded, state->idx)) != 0)\n\t\tgoto out;\n\n\t/* padded state will be encrypted */\n\tif ((r = sshbuf_putb(padded, b)) != 0)\n\t\tgoto out;\n\ti = 0;\n\twhile (sshbuf_len(padded) % blocksize) {\n\t\tif ((r = sshbuf_put_u8(padded, ++i & 0xff)) != 0)\n\t\t\tgoto out;\n\t}\n\tencrypted_len = sshbuf_len(padded);\n\n\t/* header including the length of state is used as AAD */\n\tif ((r = sshbuf_put_u32(encoded, encrypted_len)) != 0)\n\t\tgoto out;\n\taadlen = sshbuf_len(encoded);\n\n\t/* concat header and state */\n\tif ((r = sshbuf_putb(encoded, padded)) != 0)\n\t\tgoto out;\n\n\t/* reserve space for encryption of encoded data plus auth tag */\n\t/* encrypt at offset addlen */\n\tif ((r = sshbuf_reserve(encrypted,\n\t    encrypted_len + aadlen + authlen, &cp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    iv, ivlen, 1)) != 0 ||\n\t    (r = cipher_crypt(ciphercontext, 0, cp, sshbuf_ptr(encoded),\n\t    encrypted_len, aadlen, authlen)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n out:\n\tif (retp != NULL) {\n\t\t*retp = encrypted;\n\t\tencrypted = NULL;\n\t}\n\tsshbuf_free(padded);\n\tsshbuf_free(encoded);\n\tsshbuf_free(encrypted);\n\tcipher_free(ciphercontext);\n\tfree(iv);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: SERLIALIZE FAILED: %d\"",
            "__func__",
            "ret"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_serialize_state",
          "args": [
            "k",
            "b"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_serialize_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "676-711",
          "snippet": "int\nsshkey_xmss_serialize_state(const struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\ttreehash_inst *th;\n\tu_int32_t i, node;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state->stack == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tstate->stackoffset = state->bds.stackoffset;\t/* copy back */\n\tif ((r = sshbuf_put_cstring(b, SSH_XMSS_K2_MAGIC)) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->idx)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->stack, num_stack(state))) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->stackoffset)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->stacklevels, num_stacklevels(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->auth, num_auth(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->keep, num_keep(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->th_nodes, num_th_nodes(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->retain, num_retain(state))) != 0 ||\n\t    (r = sshbuf_put_u32(b, num_treehash(state))) != 0)\n\t\treturn r;\n\tfor (i = 0; i < num_treehash(state); i++) {\n\t\tth = &state->treehash[i];\n\t\tnode = th->node - state->th_nodes;\n\t\tif ((r = sshbuf_put_u32(b, th->h)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, th->next_idx)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, th->stackusage)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, th->completed)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, node)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SSH_XMSS_K2_MAGIC\t\"k=2\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_XMSS_K2_MAGIC\t\"k=2\"\n\nint\nsshkey_xmss_serialize_state(const struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\ttreehash_inst *th;\n\tu_int32_t i, node;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state->stack == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tstate->stackoffset = state->bds.stackoffset;\t/* copy back */\n\tif ((r = sshbuf_put_cstring(b, SSH_XMSS_K2_MAGIC)) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->idx)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->stack, num_stack(state))) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->stackoffset)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->stacklevels, num_stacklevels(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->auth, num_auth(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->keep, num_keep(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->th_nodes, num_th_nodes(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->retain, num_retain(state))) != 0 ||\n\t    (r = sshbuf_put_u32(b, num_treehash(state))) != 0)\n\t\treturn r;\n\tfor (i = 0; i < num_treehash(state); i++) {\n\t\tth = &state->treehash[i];\n\t\tnode = th->node - state->th_nodes;\n\t\tif ((r = sshbuf_put_u32(b, th->h)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, th->next_idx)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, th->stackusage)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, th->completed)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, node)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "nstatefile"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&nstatefile",
            "\"%s.nstate\"",
            "filename"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: more than one signature happened: idx %u state %u\"",
            "__func__",
            "idx",
            "state->idx"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "k->xmss_sk"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_update_state(const struct sshkey *k, sshkey_printfn *pr)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *b = NULL, *enc = NULL;\n\tu_int32_t idx = 0;\n\tunsigned char buf[4];\n\tchar *filename = NULL;\n\tchar *statefile = NULL, *ostatefile = NULL, *nstatefile = NULL;\n\tint fd = -1;\n\tint ret = SSH_ERR_INVALID_ARGUMENT;\n\n\tif (state == NULL || !state->allow_update)\n\t\treturn ret;\n\tif (state->maxidx) {\n\t\t/* no update since the number of signatures is limited */\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\tidx = PEEK_U32(k->xmss_sk);\n\tif (idx == state->idx) {\n\t\t/* no signature happened, no need to update */\n\t\tret = 0;\n\t\tgoto done;\n\t} else if (idx != state->idx + 1) {\n\t\tPRINT(\"%s: more than one signature happened: idx %u state %u\",\n\t\t     __func__, idx, state->idx);\n\t\tgoto done;\n\t}\n\tstate->idx = idx;\n\tif ((filename = k->xmss_filename) == NULL)\n\t\tgoto done;\n\tif (asprintf(&statefile, \"%s.state\", filename) < 0 ||\n\t    asprintf(&ostatefile, \"%s.ostate\", filename) < 0 ||\n\t    asprintf(&nstatefile, \"%s.nstate\", filename) < 0) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tunlink(nstatefile);\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((ret = sshkey_xmss_serialize_state(k, b)) != 0) {\n\t\tPRINT(\"%s: SERLIALIZE FAILED: %d\", __func__, ret);\n\t\tgoto done;\n\t}\n\tif ((ret = sshkey_xmss_encrypt_state(k, b, &enc)) != 0) {\n\t\tPRINT(\"%s: ENCRYPT FAILED: %d\", __func__, ret);\n\t\tgoto done;\n\t}\n\tif ((fd = open(nstatefile, O_CREAT|O_WRONLY|O_EXCL, 0600)) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: open new state file: %s\", __func__, nstatefile);\n\t\tgoto done;\n\t}\n\tPOKE_U32(buf, sshbuf_len(enc));\n\tif (atomicio(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: write new state file hdr: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(enc), sshbuf_len(enc)) !=\n\t    sshbuf_len(enc)) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: write new state file data: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (fsync(fd) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: sync new state file: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (close(fd) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: close new state file: %s\", __func__, nstatefile);\n\t\tgoto done;\n\t}\n\tif (state->have_state) {\n\t\tunlink(ostatefile);\n\t\tif (link(statefile, ostatefile)) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: backup state %s to %s\", __func__, statefile,\n\t\t\t    ostatefile);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (rename(nstatefile, statefile) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: rename %s to %s\", __func__, nstatefile, statefile);\n\t\tgoto done;\n\t}\n\tret = 0;\ndone:\n\tif (state->lockfd != -1) {\n\t\tclose(state->lockfd);\n\t\tstate->lockfd = -1;\n\t}\n\tif (nstatefile)\n\t\tunlink(nstatefile);\n\tfree(statefile);\n\tfree(ostatefile);\n\tfree(nstatefile);\n\tsshbuf_free(b);\n\tsshbuf_free(enc);\n\treturn ret;\n}"
  },
  {
    "function_name": "sshkey_xmss_forward_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "532-563",
    "snippet": "int\nsshkey_xmss_forward_state(const struct sshkey *k, u_int32_t reserve)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char *sig = NULL;\n\tsize_t required_siglen;\n\tunsigned long long smlen;\n\tu_char data;\n\tint ret, r;\n\n\tif (state == NULL || !state->allow_update)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (reserve == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state->idx + reserve <= state->idx)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(k, &required_siglen)) != 0)\n\t\treturn r;\n\tif ((sig = malloc(required_siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\twhile (reserve-- > 0) {\n\t\tstate->idx = PEEK_U32(k->xmss_sk);\n\t\tsmlen = required_siglen;\n\t\tif ((ret = xmss_sign(k->xmss_sk, sshkey_xmss_bds_state(k),\n\t\t    sig, &smlen, &data, 0, sshkey_xmss_params(k))) != 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(sig);\n\treturn r;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sig"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_free_bds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "187-208",
          "snippet": "void\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmss_sign",
          "args": [
            "k->xmss_sk",
            "sshkey_xmss_bds_state(k)",
            "sig",
            "&smlen",
            "&data",
            "0",
            "sshkey_xmss_params(k)"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "xmss_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "551-658",
          "snippet": "int xmss_sign(unsigned char *sk, bds_state *state, unsigned char *sig_msg, unsigned long long *sig_msg_len, const unsigned char *msg, unsigned long long msglen, const xmss_params *params)\n{\n  unsigned int h = params->h;\n  unsigned int n = params->n;\n  unsigned int k = params->k;\n  uint16_t i = 0;\n\n  // Extract SK\n  unsigned long idx = ((unsigned long)sk[0] << 24) | ((unsigned long)sk[1] << 16) | ((unsigned long)sk[2] << 8) | sk[3];\n  unsigned char sk_seed[n];\n  memcpy(sk_seed, sk+4, n);\n  unsigned char sk_prf[n];\n  memcpy(sk_prf, sk+4+n, n);\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, sk+4+2*n, n);\n  \n  // index as 32 bytes string\n  unsigned char idx_bytes_32[32];\n  to_byte(idx_bytes_32, idx, 32);\n  \n  unsigned char hash_key[3*n]; \n  \n  // Update SK\n  sk[0] = ((idx + 1) >> 24) & 255;\n  sk[1] = ((idx + 1) >> 16) & 255;\n  sk[2] = ((idx + 1) >> 8) & 255;\n  sk[3] = (idx + 1) & 255;\n  // -- Secret key for this non-forward-secure version is now updated.\n  // -- A productive implementation should use a file handle instead and write the updated secret key at this point!\n\n  // Init working params\n  unsigned char R[n];\n  unsigned char msg_h[n];\n  unsigned char ots_seed[n];\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  // ---------------------------------\n  // Message Hashing\n  // ---------------------------------\n\n  // Message Hash:\n  // First compute pseudorandom value\n  prf(R, idx_bytes_32, sk_prf, n);\n  // Generate hash key (R || root || idx)\n  memcpy(hash_key, R, n);\n  memcpy(hash_key+n, sk+4+3*n, n);\n  to_byte(hash_key+2*n, idx, n);\n  // Then use it for message digest\n  h_msg(msg_h, msg, msglen, hash_key, 3*n, n);\n\n  // Start collecting signature\n  *sig_msg_len = 0;\n\n  // Copy index to signature\n  sig_msg[0] = (idx >> 24) & 255;\n  sig_msg[1] = (idx >> 16) & 255;\n  sig_msg[2] = (idx >> 8) & 255;\n  sig_msg[3] = idx & 255;\n\n  sig_msg += 4;\n  *sig_msg_len += 4;\n\n  // Copy R to signature\n  for (i = 0; i < n; i++)\n    sig_msg[i] = R[i];\n\n  sig_msg += n;\n  *sig_msg_len += n;\n\n  // ----------------------------------\n  // Now we start to \"really sign\"\n  // ----------------------------------\n\n  // Prepare Address\n  setType(ots_addr, 0);\n  setOTSADRS(ots_addr, idx);\n\n  // Compute seed for OTS key pair\n  get_seed(ots_seed, sk_seed, n, ots_addr);\n\n  // Compute WOTS signature\n  wots_sign(sig_msg, msg_h, ots_seed, &(params->wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->wots_par.keysize;\n  *sig_msg_len += params->wots_par.keysize;\n\n  // the auth path was already computed during the previous round\n  memcpy(sig_msg, state->auth, h*n);\n\n  if (idx < (1U << h) - 1) {\n    bds_round(state, idx, sk_seed, params, pub_seed, ots_addr);\n    bds_treehash_update(state, (h - k) >> 1, sk_seed, params, pub_seed, ots_addr);\n  }\n\n/* TODO: save key/bds state here! */\n\n  sig_msg += params->h*n;\n  *sig_msg_len += params->h*n;\n\n  //Whipe secret elements?\n  //zerobytes(tsk, CRYPTO_SECRETKEYBYTES);\n\n\n  memcpy(sig_msg, msg, msglen);\n  *sig_msg_len += msglen;\n\n  return 0;\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint xmss_sign(unsigned char *sk, bds_state *state, unsigned char *sig_msg, unsigned long long *sig_msg_len, const unsigned char *msg, unsigned long long msglen, const xmss_params *params)\n{\n  unsigned int h = params->h;\n  unsigned int n = params->n;\n  unsigned int k = params->k;\n  uint16_t i = 0;\n\n  // Extract SK\n  unsigned long idx = ((unsigned long)sk[0] << 24) | ((unsigned long)sk[1] << 16) | ((unsigned long)sk[2] << 8) | sk[3];\n  unsigned char sk_seed[n];\n  memcpy(sk_seed, sk+4, n);\n  unsigned char sk_prf[n];\n  memcpy(sk_prf, sk+4+n, n);\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, sk+4+2*n, n);\n  \n  // index as 32 bytes string\n  unsigned char idx_bytes_32[32];\n  to_byte(idx_bytes_32, idx, 32);\n  \n  unsigned char hash_key[3*n]; \n  \n  // Update SK\n  sk[0] = ((idx + 1) >> 24) & 255;\n  sk[1] = ((idx + 1) >> 16) & 255;\n  sk[2] = ((idx + 1) >> 8) & 255;\n  sk[3] = (idx + 1) & 255;\n  // -- Secret key for this non-forward-secure version is now updated.\n  // -- A productive implementation should use a file handle instead and write the updated secret key at this point!\n\n  // Init working params\n  unsigned char R[n];\n  unsigned char msg_h[n];\n  unsigned char ots_seed[n];\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  // ---------------------------------\n  // Message Hashing\n  // ---------------------------------\n\n  // Message Hash:\n  // First compute pseudorandom value\n  prf(R, idx_bytes_32, sk_prf, n);\n  // Generate hash key (R || root || idx)\n  memcpy(hash_key, R, n);\n  memcpy(hash_key+n, sk+4+3*n, n);\n  to_byte(hash_key+2*n, idx, n);\n  // Then use it for message digest\n  h_msg(msg_h, msg, msglen, hash_key, 3*n, n);\n\n  // Start collecting signature\n  *sig_msg_len = 0;\n\n  // Copy index to signature\n  sig_msg[0] = (idx >> 24) & 255;\n  sig_msg[1] = (idx >> 16) & 255;\n  sig_msg[2] = (idx >> 8) & 255;\n  sig_msg[3] = idx & 255;\n\n  sig_msg += 4;\n  *sig_msg_len += 4;\n\n  // Copy R to signature\n  for (i = 0; i < n; i++)\n    sig_msg[i] = R[i];\n\n  sig_msg += n;\n  *sig_msg_len += n;\n\n  // ----------------------------------\n  // Now we start to \"really sign\"\n  // ----------------------------------\n\n  // Prepare Address\n  setType(ots_addr, 0);\n  setOTSADRS(ots_addr, idx);\n\n  // Compute seed for OTS key pair\n  get_seed(ots_seed, sk_seed, n, ots_addr);\n\n  // Compute WOTS signature\n  wots_sign(sig_msg, msg_h, ots_seed, &(params->wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->wots_par.keysize;\n  *sig_msg_len += params->wots_par.keysize;\n\n  // the auth path was already computed during the previous round\n  memcpy(sig_msg, state->auth, h*n);\n\n  if (idx < (1U << h) - 1) {\n    bds_round(state, idx, sk_seed, params, pub_seed, ots_addr);\n    bds_treehash_update(state, (h - k) >> 1, sk_seed, params, pub_seed, ots_addr);\n  }\n\n/* TODO: save key/bds state here! */\n\n  sig_msg += params->h*n;\n  *sig_msg_len += params->h*n;\n\n  //Whipe secret elements?\n  //zerobytes(tsk, CRYPTO_SECRETKEYBYTES);\n\n\n  memcpy(sig_msg, msg, msglen);\n  *sig_msg_len += msglen;\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_params",
          "args": [
            "k"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "210-218",
          "snippet": "void *\nsshkey_xmss_params(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->params;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nsshkey_xmss_params(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->params;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_bds_state",
          "args": [
            "k"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_bds_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "220-228",
          "snippet": "void *\nsshkey_xmss_bds_state(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->bds;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nsshkey_xmss_bds_state(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->bds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "k->xmss_sk"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "required_siglen"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_siglen",
          "args": [
            "k",
            "&required_siglen"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_siglen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "230-243",
          "snippet": "int\nsshkey_xmss_siglen(const struct sshkey *key, size_t *lenp)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (lenp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t*lenp = 4 + state->n +\n\t    state->params.wots_par.keysize +\n\t    state->h * state->n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_siglen(const struct sshkey *key, size_t *lenp)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (lenp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t*lenp = 4 + state->n +\n\t    state->params.wots_par.keysize +\n\t    state->h * state->n;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_forward_state(const struct sshkey *k, u_int32_t reserve)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char *sig = NULL;\n\tsize_t required_siglen;\n\tunsigned long long smlen;\n\tu_char data;\n\tint ret, r;\n\n\tif (state == NULL || !state->allow_update)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (reserve == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state->idx + reserve <= state->idx)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(k, &required_siglen)) != 0)\n\t\treturn r;\n\tif ((sig = malloc(required_siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\twhile (reserve-- > 0) {\n\t\tstate->idx = PEEK_U32(k->xmss_sk);\n\t\tsmlen = required_siglen;\n\t\tif ((ret = xmss_sign(k->xmss_sk, sshkey_xmss_bds_state(k),\n\t\t    sig, &smlen, &data, 0, sshkey_xmss_params(k))) != 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(sig);\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_xmss_get_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "442-530",
    "snippet": "int\nsshkey_xmss_get_state(const struct sshkey *k, sshkey_printfn *pr)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_int32_t idx = 0;\n\tchar *filename = NULL;\n\tchar *statefile = NULL, *ostatefile = NULL, *lockfile = NULL;\n\tint lockfd = -1, have_state = 0, have_ostate, tries = 0;\n\tint ret = SSH_ERR_INVALID_ARGUMENT, r;\n\n\tif (state == NULL)\n\t\tgoto done;\n\t/*\n\t * If maxidx is set, then we are allowed a limited number\n\t * of signatures, but don't need to access the disk.\n\t * Otherwise we need to deal with the on-disk state.\n\t */\n\tif (state->maxidx) {\n\t\t/* xmss_sk always contains the current state */\n\t\tidx = PEEK_U32(k->xmss_sk);\n\t\tif (idx < state->maxidx) {\n\t\t\tstate->allow_update = 1;\n\t\t\treturn 0;\n\t\t}\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif ((filename = k->xmss_filename) == NULL)\n\t\tgoto done;\n\tif (asprintf(&lockfile, \"%s.lock\", filename) < 0 ||\n\t    asprintf(&statefile, \"%s.state\", filename) < 0 ||\n\t    asprintf(&ostatefile, \"%s.ostate\", filename) < 0) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((lockfd = open(lockfile, O_CREAT|O_RDONLY, 0600)) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: cannot open/create: %s\", __func__, lockfile);\n\t\tgoto done;\n\t}\n\twhile (flock(lockfd, LOCK_EX|LOCK_NB) < 0) {\n\t\tif (errno != EWOULDBLOCK) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: cannot lock: %s\", __func__, lockfile);\n\t\t\tgoto done;\n\t\t}\n\t\tif (++tries > 10) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: giving up on: %s\", __func__, lockfile);\n\t\t\tgoto done;\n\t\t}\n\t\tusleep(1000*100*tries);\n\t}\n\t/* XXX no longer const */\n\tif ((r = sshkey_xmss_get_state_from_file((struct sshkey *)k,\n\t    statefile, &have_state, pr)) != 0) {\n\t\tif ((r = sshkey_xmss_get_state_from_file((struct sshkey *)k,\n\t\t    ostatefile, &have_ostate, pr)) == 0) {\n\t\t\tstate->allow_update = 1;\n\t\t\tr = sshkey_xmss_forward_state(k, 1);\n\t\t\tstate->idx = PEEK_U32(k->xmss_sk);\n\t\t\tstate->allow_update = 0;\n\t\t}\n\t}\n\tif (!have_state && !have_ostate) {\n\t\t/* check that bds state is initialized */\n\t\tif (state->bds.auth == NULL)\n\t\t\tgoto done;\n\t\tPRINT(\"%s: start from scratch idx 0: %u\", __func__, state->idx);\n\t} else if (r != 0) {\n\t\tret = r;\n\t\tgoto done;\n\t}\n\tif (state->idx + 1 < state->idx) {\n\t\tPRINT(\"%s: state wrap: %u\", __func__, state->idx);\n\t\tgoto done;\n\t}\n\tstate->have_state = have_state;\n\tstate->lockfd = lockfd;\n\tstate->allow_update = 1;\n\tlockfd = -1;\n\tret = 0;\ndone:\n\tif (lockfd != -1)\n\t\tclose(lockfd);\n\tfree(lockfile);\n\tfree(statefile);\n\tfree(ostatefile);\n\treturn ret;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ostatefile"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_free_bds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "187-208",
          "snippet": "void\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "lockfd"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: state wrap: %u\"",
            "__func__",
            "state->idx"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: start from scratch idx 0: %u\"",
            "__func__",
            "state->idx"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "k->xmss_sk"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_forward_state",
          "args": [
            "k",
            "1"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_forward_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "532-563",
          "snippet": "int\nsshkey_xmss_forward_state(const struct sshkey *k, u_int32_t reserve)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char *sig = NULL;\n\tsize_t required_siglen;\n\tunsigned long long smlen;\n\tu_char data;\n\tint ret, r;\n\n\tif (state == NULL || !state->allow_update)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (reserve == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state->idx + reserve <= state->idx)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(k, &required_siglen)) != 0)\n\t\treturn r;\n\tif ((sig = malloc(required_siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\twhile (reserve-- > 0) {\n\t\tstate->idx = PEEK_U32(k->xmss_sk);\n\t\tsmlen = required_siglen;\n\t\tif ((ret = xmss_sign(k->xmss_sk, sshkey_xmss_bds_state(k),\n\t\t    sig, &smlen, &data, 0, sshkey_xmss_params(k))) != 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(sig);\n\treturn r;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_forward_state(const struct sshkey *k, u_int32_t reserve)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char *sig = NULL;\n\tsize_t required_siglen;\n\tunsigned long long smlen;\n\tu_char data;\n\tint ret, r;\n\n\tif (state == NULL || !state->allow_update)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (reserve == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state->idx + reserve <= state->idx)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(k, &required_siglen)) != 0)\n\t\treturn r;\n\tif ((sig = malloc(required_siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\twhile (reserve-- > 0) {\n\t\tstate->idx = PEEK_U32(k->xmss_sk);\n\t\tsmlen = required_siglen;\n\t\tif ((ret = xmss_sign(k->xmss_sk, sshkey_xmss_bds_state(k),\n\t\t    sig, &smlen, &data, 0, sshkey_xmss_params(k))) != 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(sig);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_get_state_from_file",
          "args": [
            "(struct sshkey *)k",
            "ostatefile",
            "&have_ostate",
            "pr"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_get_state_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "393-440",
          "snippet": "int\nsshkey_xmss_get_state_from_file(struct sshkey *k, const char *filename,\n    int *have_file, sshkey_printfn *pr)\n{\n\tstruct sshbuf *b = NULL, *enc = NULL;\n\tint ret = SSH_ERR_SYSTEM_ERROR, r, fd = -1;\n\tu_int32_t len;\n\tunsigned char buf[4], *data = NULL;\n\n\t*have_file = 0;\n\tif ((fd = open(filename, O_RDONLY)) >= 0) {\n\t\t*have_file = 1;\n\t\tif (atomicio(read, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\t\tPRINT(\"%s: corrupt state file: %s\", __func__, filename);\n\t\t\tgoto done;\n\t\t}\n\t\tlen = PEEK_U32(buf);\n\t\tif ((data = calloc(len, 1)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (atomicio(read, fd, data, len) != len) {\n\t\t\tPRINT(\"%s: cannot read blob: %s\", __func__, filename);\n\t\t\tgoto done;\n\t\t}\n\t\tif ((enc = sshbuf_from(data, len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto done;\n\t\t}\n\t\tsshkey_xmss_free_bds(k);\n\t\tif ((r = sshkey_xmss_decrypt_state(k, enc, &b)) != 0) {\n\t\t\tret = r;\n\t\t\tgoto done;\n\t\t}\n\t\tif ((r = sshkey_xmss_deserialize_state(k, b)) != 0) {\n\t\t\tret = r;\n\t\t\tgoto done;\n\t\t}\n\t\tret = 0;\n\t}\ndone:\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(data);\n\tsshbuf_free(enc);\n\tsshbuf_free(b);\n\treturn ret;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_get_state_from_file(struct sshkey *k, const char *filename,\n    int *have_file, sshkey_printfn *pr)\n{\n\tstruct sshbuf *b = NULL, *enc = NULL;\n\tint ret = SSH_ERR_SYSTEM_ERROR, r, fd = -1;\n\tu_int32_t len;\n\tunsigned char buf[4], *data = NULL;\n\n\t*have_file = 0;\n\tif ((fd = open(filename, O_RDONLY)) >= 0) {\n\t\t*have_file = 1;\n\t\tif (atomicio(read, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\t\tPRINT(\"%s: corrupt state file: %s\", __func__, filename);\n\t\t\tgoto done;\n\t\t}\n\t\tlen = PEEK_U32(buf);\n\t\tif ((data = calloc(len, 1)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (atomicio(read, fd, data, len) != len) {\n\t\t\tPRINT(\"%s: cannot read blob: %s\", __func__, filename);\n\t\t\tgoto done;\n\t\t}\n\t\tif ((enc = sshbuf_from(data, len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto done;\n\t\t}\n\t\tsshkey_xmss_free_bds(k);\n\t\tif ((r = sshkey_xmss_decrypt_state(k, enc, &b)) != 0) {\n\t\t\tret = r;\n\t\t\tgoto done;\n\t\t}\n\t\tif ((r = sshkey_xmss_deserialize_state(k, b)) != 0) {\n\t\t\tret = r;\n\t\t\tgoto done;\n\t\t}\n\t\tret = 0;\n\t}\ndone:\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(data);\n\tsshbuf_free(enc);\n\tsshbuf_free(b);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000*100*tries"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "usleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "171-178",
          "snippet": "int usleep(unsigned int useconds)\n{\n\tstruct timespec ts;\n\n\tts.tv_sec = useconds / 1000000;\n\tts.tv_nsec = (useconds % 1000000) * 1000;\n\treturn nanosleep(&ts, NULL);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint usleep(unsigned int useconds)\n{\n\tstruct timespec ts;\n\n\tts.tv_sec = useconds / 1000000;\n\tts.tv_nsec = (useconds % 1000000) * 1000;\n\treturn nanosleep(&ts, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: giving up on: %s\"",
            "__func__",
            "lockfile"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: cannot lock: %s\"",
            "__func__",
            "lockfile"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock",
          "args": [
            "lockfd",
            "LOCK_EX|LOCK_NB"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "flock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-flock.c",
          "lines": "43-80",
          "snippet": "int\nflock(int fd, int op)\n{\n\tint rc = 0;\n\n#if defined(F_SETLK) && defined(F_SETLKW)\n\tstruct flock fl = {0};\n\n\tswitch (op & (LOCK_EX|LOCK_SH|LOCK_UN)) {\n\tcase LOCK_EX:\n\t\tfl.l_type = F_WRLCK;\n\t\tbreak;\n\n\tcase LOCK_SH:\n\t\tfl.l_type = F_RDLCK;\n\t\tbreak;\n\n\tcase LOCK_UN:\n\t\tfl.l_type = F_UNLCK;\n\t\tbreak;\n\n\tdefault:\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tfl.l_whence = SEEK_SET;\n\trc = fcntl(fd, op & LOCK_NB ? F_SETLK : F_SETLKW, &fl);\n\n\tif (rc && (errno == EAGAIN))\n\t\terrno = EWOULDBLOCK;\n#else\n\trc = -1;\n\terrno = ENOSYS;\n#endif\n\n\treturn rc;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\nflock(int fd, int op)\n{\n\tint rc = 0;\n\n#if defined(F_SETLK) && defined(F_SETLKW)\n\tstruct flock fl = {0};\n\n\tswitch (op & (LOCK_EX|LOCK_SH|LOCK_UN)) {\n\tcase LOCK_EX:\n\t\tfl.l_type = F_WRLCK;\n\t\tbreak;\n\n\tcase LOCK_SH:\n\t\tfl.l_type = F_RDLCK;\n\t\tbreak;\n\n\tcase LOCK_UN:\n\t\tfl.l_type = F_UNLCK;\n\t\tbreak;\n\n\tdefault:\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tfl.l_whence = SEEK_SET;\n\trc = fcntl(fd, op & LOCK_NB ? F_SETLK : F_SETLKW, &fl);\n\n\tif (rc && (errno == EAGAIN))\n\t\terrno = EWOULDBLOCK;\n#else\n\trc = -1;\n\terrno = ENOSYS;\n#endif\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: cannot open/create: %s\"",
            "__func__",
            "lockfile"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "lockfile",
            "O_CREAT|O_RDONLY",
            "0600"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "lastlog_openseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/loginrec.c",
          "lines": "1471-1514",
          "snippet": "static int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "# include <util.h>",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"canohost.h\"",
            "#include \"packet.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int utmp_write_entry(struct logininfo *li);",
            "int utmpx_write_entry(struct logininfo *li);",
            "int wtmp_write_entry(struct logininfo *li);",
            "int wtmpx_write_entry(struct logininfo *li);",
            "int lastlog_write_entry(struct logininfo *li);",
            "int syslogin_write_entry(struct logininfo *li);",
            "int getlast_entry(struct logininfo *li);",
            "int lastlog_get_entry(struct logininfo *li);",
            "int utmpx_get_entry(struct logininfo *li);",
            "int wtmp_get_entry(struct logininfo *li);",
            "int wtmpx_get_entry(struct logininfo *li);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <util.h>\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint utmp_write_entry(struct logininfo *li);\nint utmpx_write_entry(struct logininfo *li);\nint wtmp_write_entry(struct logininfo *li);\nint wtmpx_write_entry(struct logininfo *li);\nint lastlog_write_entry(struct logininfo *li);\nint syslogin_write_entry(struct logininfo *li);\nint getlast_entry(struct logininfo *li);\nint lastlog_get_entry(struct logininfo *li);\nint utmpx_get_entry(struct logininfo *li);\nint wtmp_get_entry(struct logininfo *li);\nint wtmpx_get_entry(struct logininfo *li);\n\nstatic int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&ostatefile",
            "\"%s.ostate\"",
            "filename"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "k->xmss_sk"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_get_state(const struct sshkey *k, sshkey_printfn *pr)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_int32_t idx = 0;\n\tchar *filename = NULL;\n\tchar *statefile = NULL, *ostatefile = NULL, *lockfile = NULL;\n\tint lockfd = -1, have_state = 0, have_ostate, tries = 0;\n\tint ret = SSH_ERR_INVALID_ARGUMENT, r;\n\n\tif (state == NULL)\n\t\tgoto done;\n\t/*\n\t * If maxidx is set, then we are allowed a limited number\n\t * of signatures, but don't need to access the disk.\n\t * Otherwise we need to deal with the on-disk state.\n\t */\n\tif (state->maxidx) {\n\t\t/* xmss_sk always contains the current state */\n\t\tidx = PEEK_U32(k->xmss_sk);\n\t\tif (idx < state->maxidx) {\n\t\t\tstate->allow_update = 1;\n\t\t\treturn 0;\n\t\t}\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif ((filename = k->xmss_filename) == NULL)\n\t\tgoto done;\n\tif (asprintf(&lockfile, \"%s.lock\", filename) < 0 ||\n\t    asprintf(&statefile, \"%s.state\", filename) < 0 ||\n\t    asprintf(&ostatefile, \"%s.ostate\", filename) < 0) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((lockfd = open(lockfile, O_CREAT|O_RDONLY, 0600)) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: cannot open/create: %s\", __func__, lockfile);\n\t\tgoto done;\n\t}\n\twhile (flock(lockfd, LOCK_EX|LOCK_NB) < 0) {\n\t\tif (errno != EWOULDBLOCK) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: cannot lock: %s\", __func__, lockfile);\n\t\t\tgoto done;\n\t\t}\n\t\tif (++tries > 10) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: giving up on: %s\", __func__, lockfile);\n\t\t\tgoto done;\n\t\t}\n\t\tusleep(1000*100*tries);\n\t}\n\t/* XXX no longer const */\n\tif ((r = sshkey_xmss_get_state_from_file((struct sshkey *)k,\n\t    statefile, &have_state, pr)) != 0) {\n\t\tif ((r = sshkey_xmss_get_state_from_file((struct sshkey *)k,\n\t\t    ostatefile, &have_ostate, pr)) == 0) {\n\t\t\tstate->allow_update = 1;\n\t\t\tr = sshkey_xmss_forward_state(k, 1);\n\t\t\tstate->idx = PEEK_U32(k->xmss_sk);\n\t\t\tstate->allow_update = 0;\n\t\t}\n\t}\n\tif (!have_state && !have_ostate) {\n\t\t/* check that bds state is initialized */\n\t\tif (state->bds.auth == NULL)\n\t\t\tgoto done;\n\t\tPRINT(\"%s: start from scratch idx 0: %u\", __func__, state->idx);\n\t} else if (r != 0) {\n\t\tret = r;\n\t\tgoto done;\n\t}\n\tif (state->idx + 1 < state->idx) {\n\t\tPRINT(\"%s: state wrap: %u\", __func__, state->idx);\n\t\tgoto done;\n\t}\n\tstate->have_state = have_state;\n\tstate->lockfd = lockfd;\n\tstate->allow_update = 1;\n\tlockfd = -1;\n\tret = 0;\ndone:\n\tif (lockfd != -1)\n\t\tclose(lockfd);\n\tfree(lockfile);\n\tfree(statefile);\n\tfree(ostatefile);\n\treturn ret;\n}"
  },
  {
    "function_name": "sshkey_xmss_get_state_from_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "393-440",
    "snippet": "int\nsshkey_xmss_get_state_from_file(struct sshkey *k, const char *filename,\n    int *have_file, sshkey_printfn *pr)\n{\n\tstruct sshbuf *b = NULL, *enc = NULL;\n\tint ret = SSH_ERR_SYSTEM_ERROR, r, fd = -1;\n\tu_int32_t len;\n\tunsigned char buf[4], *data = NULL;\n\n\t*have_file = 0;\n\tif ((fd = open(filename, O_RDONLY)) >= 0) {\n\t\t*have_file = 1;\n\t\tif (atomicio(read, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\t\tPRINT(\"%s: corrupt state file: %s\", __func__, filename);\n\t\t\tgoto done;\n\t\t}\n\t\tlen = PEEK_U32(buf);\n\t\tif ((data = calloc(len, 1)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (atomicio(read, fd, data, len) != len) {\n\t\t\tPRINT(\"%s: cannot read blob: %s\", __func__, filename);\n\t\t\tgoto done;\n\t\t}\n\t\tif ((enc = sshbuf_from(data, len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto done;\n\t\t}\n\t\tsshkey_xmss_free_bds(k);\n\t\tif ((r = sshkey_xmss_decrypt_state(k, enc, &b)) != 0) {\n\t\t\tret = r;\n\t\t\tgoto done;\n\t\t}\n\t\tif ((r = sshkey_xmss_deserialize_state(k, b)) != 0) {\n\t\t\tret = r;\n\t\t\tgoto done;\n\t\t}\n\t\tret = 0;\n\t}\ndone:\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(data);\n\tsshbuf_free(enc);\n\tsshbuf_free(b);\n\treturn ret;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_free_bds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "187-208",
          "snippet": "void\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_deserialize_state",
          "args": [
            "k",
            "b"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_deserialize_state_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "800-829",
          "snippet": "int\nsshkey_xmss_deserialize_state_opt(struct sshkey *k, struct sshbuf *b)\n{\n\tenum sshkey_serialize_rep opts;\n\tu_char have_state;\n\tint r;\n\n\tif ((r = sshbuf_get_u8(b, &have_state)) != 0)\n\t\treturn r;\n\n\topts = have_state;\n\tswitch (opts) {\n\tcase SSHKEY_SERIALIZE_DEFAULT:\n\t\tr = 0;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_STATE:\n\t\tif ((r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_FULL:\n\t\tif ((r = sshkey_xmss_deserialize_enc_key(k, b)) != 0 ||\n\t\t    (r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tbreak;\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_deserialize_state_opt(struct sshkey *k, struct sshbuf *b)\n{\n\tenum sshkey_serialize_rep opts;\n\tu_char have_state;\n\tint r;\n\n\tif ((r = sshbuf_get_u8(b, &have_state)) != 0)\n\t\treturn r;\n\n\topts = have_state;\n\tswitch (opts) {\n\tcase SSHKEY_SERIALIZE_DEFAULT:\n\t\tr = 0;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_STATE:\n\t\tif ((r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_FULL:\n\t\tif ((r = sshkey_xmss_deserialize_enc_key(k, b)) != 0 ||\n\t\t    (r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tbreak;\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_decrypt_state",
          "args": [
            "k",
            "enc",
            "&b"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_decrypt_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "922-1024",
          "snippet": "int\nsshkey_xmss_decrypt_state(const struct sshkey *k, struct sshbuf *encoded,\n   struct sshbuf **retp)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *copy = NULL, *decrypted = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher = NULL;\n\tu_char *key, *iv = NULL, *dp;\n\tsize_t keylen, ivlen, authlen, aadlen;\n\tu_int blocksize, encrypted_len, index;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (state == NULL ||\n\t    state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((cipher = cipher_by_name(state->enc_ciphername)) == NULL) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif (state->enc_keyiv_len != keylen + ivlen) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tkey = state->enc_keyiv;\n\n\tif ((copy = sshbuf_fromb(encoded)) == NULL ||\n\t    (decrypted = sshbuf_new()) == NULL ||\n\t    (iv = malloc(ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* check magic */\n\tif (sshbuf_len(encoded) < sizeof(XMSS_MAGIC) ||\n\t    memcmp(sshbuf_ptr(encoded), XMSS_MAGIC, sizeof(XMSS_MAGIC))) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* parse public portion */\n\tif ((r = sshbuf_consume(encoded, sizeof(XMSS_MAGIC))) != 0 ||\n\t    (r = sshbuf_get_u32(encoded, &index)) != 0 ||\n\t    (r = sshbuf_get_u32(encoded, &encrypted_len)) != 0)\n\t\tgoto out;\n\n\t/* check size of encrypted key blob */\n\tif (encrypted_len < blocksize || (encrypted_len % blocksize) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* check that an appropriate amount of auth data is present */\n\tif (sshbuf_len(encoded) < encrypted_len + authlen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\taadlen = sshbuf_len(copy) - sshbuf_len(encoded);\n\n\t/* replace first 4 bytes of IV with index to ensure uniqueness */\n\tmemcpy(iv, key + keylen, ivlen);\n\tPOKE_U32(iv, index);\n\n\t/* decrypt private state of key */\n\tif ((r = sshbuf_reserve(decrypted, aadlen + encrypted_len, &dp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    iv, ivlen, 0)) != 0 ||\n\t    (r = cipher_crypt(ciphercontext, 0, dp, sshbuf_ptr(copy),\n\t    encrypted_len, aadlen, authlen)) != 0)\n\t\tgoto out;\n\n\t/* there should be no trailing data */\n\tif ((r = sshbuf_consume(encoded, encrypted_len + authlen)) != 0)\n\t\tgoto out;\n\tif (sshbuf_len(encoded) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* remove AAD */\n\tif ((r = sshbuf_consume(decrypted, aadlen)) != 0)\n\t\tgoto out;\n\t/* XXX encrypted includes unchecked padding */\n\n\t/* success */\n\tr = 0;\n\tif (retp != NULL) {\n\t\t*retp = decrypted;\n\t\tdecrypted = NULL;\n\t}\n out:\n\tcipher_free(ciphercontext);\n\tsshbuf_free(copy);\n\tsshbuf_free(decrypted);\n\tfree(iv);\n\treturn r;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define XMSS_MAGIC\t\t\"xmss-state-v1\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define XMSS_MAGIC\t\t\"xmss-state-v1\"\n\nint\nsshkey_xmss_decrypt_state(const struct sshkey *k, struct sshbuf *encoded,\n   struct sshbuf **retp)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *copy = NULL, *decrypted = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher = NULL;\n\tu_char *key, *iv = NULL, *dp;\n\tsize_t keylen, ivlen, authlen, aadlen;\n\tu_int blocksize, encrypted_len, index;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (state == NULL ||\n\t    state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((cipher = cipher_by_name(state->enc_ciphername)) == NULL) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif (state->enc_keyiv_len != keylen + ivlen) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tkey = state->enc_keyiv;\n\n\tif ((copy = sshbuf_fromb(encoded)) == NULL ||\n\t    (decrypted = sshbuf_new()) == NULL ||\n\t    (iv = malloc(ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* check magic */\n\tif (sshbuf_len(encoded) < sizeof(XMSS_MAGIC) ||\n\t    memcmp(sshbuf_ptr(encoded), XMSS_MAGIC, sizeof(XMSS_MAGIC))) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* parse public portion */\n\tif ((r = sshbuf_consume(encoded, sizeof(XMSS_MAGIC))) != 0 ||\n\t    (r = sshbuf_get_u32(encoded, &index)) != 0 ||\n\t    (r = sshbuf_get_u32(encoded, &encrypted_len)) != 0)\n\t\tgoto out;\n\n\t/* check size of encrypted key blob */\n\tif (encrypted_len < blocksize || (encrypted_len % blocksize) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* check that an appropriate amount of auth data is present */\n\tif (sshbuf_len(encoded) < encrypted_len + authlen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\taadlen = sshbuf_len(copy) - sshbuf_len(encoded);\n\n\t/* replace first 4 bytes of IV with index to ensure uniqueness */\n\tmemcpy(iv, key + keylen, ivlen);\n\tPOKE_U32(iv, index);\n\n\t/* decrypt private state of key */\n\tif ((r = sshbuf_reserve(decrypted, aadlen + encrypted_len, &dp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    iv, ivlen, 0)) != 0 ||\n\t    (r = cipher_crypt(ciphercontext, 0, dp, sshbuf_ptr(copy),\n\t    encrypted_len, aadlen, authlen)) != 0)\n\t\tgoto out;\n\n\t/* there should be no trailing data */\n\tif ((r = sshbuf_consume(encoded, encrypted_len + authlen)) != 0)\n\t\tgoto out;\n\tif (sshbuf_len(encoded) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* remove AAD */\n\tif ((r = sshbuf_consume(decrypted, aadlen)) != 0)\n\t\tgoto out;\n\t/* XXX encrypted includes unchecked padding */\n\n\t/* success */\n\tr = 0;\n\tif (retp != NULL) {\n\t\t*retp = decrypted;\n\t\tdecrypted = NULL;\n\t}\n out:\n\tcipher_free(ciphercontext);\n\tsshbuf_free(copy);\n\tsshbuf_free(decrypted);\n\tfree(iv);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_from",
          "args": [
            "data",
            "len"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "87-102",
          "snippet": "struct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: cannot read blob: %s\"",
            "__func__",
            "filename"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "read",
            "fd",
            "data",
            "len"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "len",
            "1"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "buf"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT",
          "args": [
            "\"%s: corrupt state file: %s\"",
            "__func__",
            "filename"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename",
            "O_RDONLY"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_get_state_from_file(struct sshkey *k, const char *filename,\n    int *have_file, sshkey_printfn *pr)\n{\n\tstruct sshbuf *b = NULL, *enc = NULL;\n\tint ret = SSH_ERR_SYSTEM_ERROR, r, fd = -1;\n\tu_int32_t len;\n\tunsigned char buf[4], *data = NULL;\n\n\t*have_file = 0;\n\tif ((fd = open(filename, O_RDONLY)) >= 0) {\n\t\t*have_file = 1;\n\t\tif (atomicio(read, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\t\tPRINT(\"%s: corrupt state file: %s\", __func__, filename);\n\t\t\tgoto done;\n\t\t}\n\t\tlen = PEEK_U32(buf);\n\t\tif ((data = calloc(len, 1)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (atomicio(read, fd, data, len) != len) {\n\t\t\tPRINT(\"%s: cannot read blob: %s\", __func__, filename);\n\t\t\tgoto done;\n\t\t}\n\t\tif ((enc = sshbuf_from(data, len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto done;\n\t\t}\n\t\tsshkey_xmss_free_bds(k);\n\t\tif ((r = sshkey_xmss_decrypt_state(k, enc, &b)) != 0) {\n\t\t\tret = r;\n\t\t\tgoto done;\n\t\t}\n\t\tif ((r = sshkey_xmss_deserialize_state(k, b)) != 0) {\n\t\t\tret = r;\n\t\t\tgoto done;\n\t\t}\n\t\tret = 0;\n\t}\ndone:\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(data);\n\tsshbuf_free(enc);\n\tsshbuf_free(b);\n\treturn ret;\n}"
  },
  {
    "function_name": "sshkey_xmss_generate_private_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "365-391",
    "snippet": "int\nsshkey_xmss_generate_private_key(struct sshkey *k, u_int bits)\n{\n\tint r;\n\tconst char *name;\n\n\tif (bits == 10) {\n\t\tname = XMSS_SHA2_256_W16_H10_NAME;\n\t} else if (bits == 16) {\n\t\tname = XMSS_SHA2_256_W16_H16_NAME;\n\t} else if (bits == 20) {\n\t\tname = XMSS_SHA2_256_W16_H20_NAME;\n\t} else {\n\t\tname = XMSS_DEFAULT_NAME;\n\t}\n\tif ((r = sshkey_xmss_init(k, name)) != 0 ||\n\t    (r = sshkey_xmss_init_bds_state(k)) != 0 ||\n\t    (r = sshkey_xmss_init_enc_key(k, XMSS_CIPHERNAME)) != 0)\n\t\treturn r;\n\tif ((k->xmss_pk = malloc(sshkey_xmss_pklen(k))) == NULL ||\n\t    (k->xmss_sk = malloc(sshkey_xmss_sklen(k))) == NULL) {\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\txmss_keypair(k->xmss_pk, k->xmss_sk, sshkey_xmss_bds_state(k),\n\t    sshkey_xmss_params(k));\n\treturn 0;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define XMSS_CIPHERNAME\t\t\"aes256-gcm@openssh.com\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmss_keypair",
          "args": [
            "k->xmss_pk",
            "k->xmss_sk",
            "sshkey_xmss_bds_state(k)",
            "sshkey_xmss_params(k)"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "xmss_keypair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "522-542",
          "snippet": "int xmss_keypair(unsigned char *pk, unsigned char *sk, bds_state *state, xmss_params *params)\n{\n  unsigned int n = params->n;\n  // Set idx = 0\n  sk[0] = 0;\n  sk[1] = 0;\n  sk[2] = 0;\n  sk[3] = 0;\n  // Init SK_SEED (n byte), SK_PRF (n byte), and PUB_SEED (n byte)\n  randombytes(sk+4, 3*n);\n  // Copy PUB_SEED to public key\n  memcpy(pk+n, sk+4+2*n, n);\n\n  uint32_t addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  // Compute root\n  treehash_setup(pk, params->h, 0, state, sk+4, params, sk+4+2*n, addr);\n  // copy root to sk\n  memcpy(sk+4+3*n, pk, n);\n  return 0;\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint xmss_keypair(unsigned char *pk, unsigned char *sk, bds_state *state, xmss_params *params)\n{\n  unsigned int n = params->n;\n  // Set idx = 0\n  sk[0] = 0;\n  sk[1] = 0;\n  sk[2] = 0;\n  sk[3] = 0;\n  // Init SK_SEED (n byte), SK_PRF (n byte), and PUB_SEED (n byte)\n  randombytes(sk+4, 3*n);\n  // Copy PUB_SEED to public key\n  memcpy(pk+n, sk+4+2*n, n);\n\n  uint32_t addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  // Compute root\n  treehash_setup(pk, params->h, 0, state, sk+4, params, sk+4+2*n, addr);\n  // copy root to sk\n  memcpy(sk+4+3*n, pk, n);\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_params",
          "args": [
            "k"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "210-218",
          "snippet": "void *\nsshkey_xmss_params(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->params;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nsshkey_xmss_params(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->params;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_bds_state",
          "args": [
            "k"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_bds_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "220-228",
          "snippet": "void *\nsshkey_xmss_bds_state(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->bds;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nsshkey_xmss_bds_state(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->bds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sshkey_xmss_sklen(k)"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_sklen",
          "args": [
            "k"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_sklen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "255-263",
          "snippet": "size_t\nsshkey_xmss_sklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 4 + 4;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_sklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 4 + 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_pklen",
          "args": [
            "k"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_pklen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "245-253",
          "snippet": "size_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_init_enc_key",
          "args": [
            "k",
            "XMSS_CIPHERNAME"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_init_enc_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "265-288",
          "snippet": "int\nsshkey_xmss_init_enc_key(struct sshkey *k, const char *ciphername)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tconst struct sshcipher *cipher;\n\tsize_t keylen = 0, ivlen = 0;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((state->enc_ciphername = strdup(ciphername)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tstate->enc_keyiv_len = keylen + ivlen;\n\tif ((state->enc_keyiv = calloc(state->enc_keyiv_len, 1)) == NULL) {\n\t\tfree(state->enc_ciphername);\n\t\tstate->enc_ciphername = NULL;\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tarc4random_buf(state->enc_keyiv, state->enc_keyiv_len);\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_init_enc_key(struct sshkey *k, const char *ciphername)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tconst struct sshcipher *cipher;\n\tsize_t keylen = 0, ivlen = 0;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((state->enc_ciphername = strdup(ciphername)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tstate->enc_keyiv_len = keylen + ivlen;\n\tif ((state->enc_keyiv = calloc(state->enc_keyiv_len, 1)) == NULL) {\n\t\tfree(state->enc_ciphername);\n\t\tstate->enc_ciphername = NULL;\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tarc4random_buf(state->enc_keyiv, state->enc_keyiv_len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_init_bds_state",
          "args": [
            "k"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_init_bds_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "161-185",
          "snippet": "int\nsshkey_xmss_init_bds_state(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\tu_int32_t i;\n\n\tstate->stackoffset = 0;\n\tif ((state->stack = calloc(num_stack(state), 1)) == NULL ||\n\t    (state->stacklevels = calloc(num_stacklevels(state), 1))== NULL ||\n\t    (state->auth = calloc(num_auth(state), 1)) == NULL ||\n\t    (state->keep = calloc(num_keep(state), 1)) == NULL ||\n\t    (state->th_nodes = calloc(num_th_nodes(state), 1)) == NULL ||\n\t    (state->retain = calloc(num_retain(state), 1)) == NULL ||\n\t    (state->treehash = calloc(num_treehash(state),\n\t    sizeof(treehash_inst))) == NULL) {\n\t\tsshkey_xmss_free_bds(key);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tfor (i = 0; i < state->h - state->k; i++)\n\t\tstate->treehash[i].node = &state->th_nodes[state->n*i];\n\txmss_set_bds_state(&state->bds, state->stack, state->stackoffset,\n\t    state->stacklevels, state->auth, state->keep, state->treehash,\n\t    state->retain, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_init_bds_state(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\tu_int32_t i;\n\n\tstate->stackoffset = 0;\n\tif ((state->stack = calloc(num_stack(state), 1)) == NULL ||\n\t    (state->stacklevels = calloc(num_stacklevels(state), 1))== NULL ||\n\t    (state->auth = calloc(num_auth(state), 1)) == NULL ||\n\t    (state->keep = calloc(num_keep(state), 1)) == NULL ||\n\t    (state->th_nodes = calloc(num_th_nodes(state), 1)) == NULL ||\n\t    (state->retain = calloc(num_retain(state), 1)) == NULL ||\n\t    (state->treehash = calloc(num_treehash(state),\n\t    sizeof(treehash_inst))) == NULL) {\n\t\tsshkey_xmss_free_bds(key);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tfor (i = 0; i < state->h - state->k; i++)\n\t\tstate->treehash[i].node = &state->th_nodes[state->n*i];\n\txmss_set_bds_state(&state->bds, state->stack, state->stackoffset,\n\t    state->stacklevels, state->auth, state->keep, state->treehash,\n\t    state->retain, 0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define XMSS_CIPHERNAME\t\t\"aes256-gcm@openssh.com\"\n\nint\nsshkey_xmss_generate_private_key(struct sshkey *k, u_int bits)\n{\n\tint r;\n\tconst char *name;\n\n\tif (bits == 10) {\n\t\tname = XMSS_SHA2_256_W16_H10_NAME;\n\t} else if (bits == 16) {\n\t\tname = XMSS_SHA2_256_W16_H16_NAME;\n\t} else if (bits == 20) {\n\t\tname = XMSS_SHA2_256_W16_H20_NAME;\n\t} else {\n\t\tname = XMSS_DEFAULT_NAME;\n\t}\n\tif ((r = sshkey_xmss_init(k, name)) != 0 ||\n\t    (r = sshkey_xmss_init_bds_state(k)) != 0 ||\n\t    (r = sshkey_xmss_init_enc_key(k, XMSS_CIPHERNAME)) != 0)\n\t\treturn r;\n\tif ((k->xmss_pk = malloc(sshkey_xmss_pklen(k))) == NULL ||\n\t    (k->xmss_sk = malloc(sshkey_xmss_sklen(k))) == NULL) {\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\txmss_keypair(k->xmss_pk, k->xmss_sk, sshkey_xmss_bds_state(k),\n\t    sshkey_xmss_params(k));\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_xmss_deserialize_pk_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "343-363",
    "snippet": "int\nsshkey_xmss_deserialize_pk_info(struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char have_info;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t/* optional */\n\tif (sshbuf_len(b) == 0)\n\t\treturn 0;\n\tif ((r = sshbuf_get_u8(b, &have_info)) != 0)\n\t\treturn r;\n\tif (have_info != 1)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_get_u32(b, &state->idx)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &state->maxidx)) != 0)\n\t\treturn r;\n\treturn 0;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "b",
            "&state->maxidx"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "b",
            "&have_info"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_deserialize_pk_info(struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char have_info;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t/* optional */\n\tif (sshbuf_len(b) == 0)\n\t\treturn 0;\n\tif ((r = sshbuf_get_u8(b, &have_info)) != 0)\n\t\treturn r;\n\tif (have_info != 1)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_get_u32(b, &state->idx)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &state->maxidx)) != 0)\n\t\treturn r;\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_xmss_serialize_pk_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "322-341",
    "snippet": "int\nsshkey_xmss_serialize_pk_info(const struct sshkey *k, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char have_info = 1;\n\tu_int32_t idx;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (opts != SSHKEY_SERIALIZE_INFO)\n\t\treturn 0;\n\tidx = k->xmss_sk ? PEEK_U32(k->xmss_sk) : state->idx;\n\tif ((r = sshbuf_put_u8(b, have_info)) != 0 ||\n\t    (r = sshbuf_put_u32(b, idx)) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->maxidx)) != 0)\n\t\treturn r;\n\treturn 0;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "b",
            "state->maxidx"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "b",
            "have_info"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "k->xmss_sk"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_serialize_pk_info(const struct sshkey *k, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char have_info = 1;\n\tu_int32_t idx;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (opts != SSHKEY_SERIALIZE_INFO)\n\t\treturn 0;\n\tidx = k->xmss_sk ? PEEK_U32(k->xmss_sk) : state->idx;\n\tif ((r = sshbuf_put_u8(b, have_info)) != 0 ||\n\t    (r = sshbuf_put_u32(b, idx)) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->maxidx)) != 0)\n\t\treturn r;\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_xmss_deserialize_enc_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "306-320",
    "snippet": "int\nsshkey_xmss_deserialize_enc_key(struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tsize_t len;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_get_cstring(b, &state->enc_ciphername, NULL)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->enc_keyiv, &len)) != 0)\n\t\treturn r;\n\tstate->enc_keyiv_len = len;\n\treturn 0;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "b",
            "&state->enc_keyiv",
            "&len"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "b",
            "&state->enc_ciphername",
            "NULL"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_deserialize_enc_key(struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tsize_t len;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_get_cstring(b, &state->enc_ciphername, NULL)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->enc_keyiv, &len)) != 0)\n\t\treturn r;\n\tstate->enc_keyiv_len = len;\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_xmss_serialize_enc_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "290-304",
    "snippet": "int\nsshkey_xmss_serialize_enc_key(const struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tint r;\n\n\tif (state == NULL || state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_put_cstring(b, state->enc_ciphername)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->enc_keyiv,\n\t    state->enc_keyiv_len)) != 0)\n\t\treturn r;\n\treturn 0;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "b",
            "state->enc_keyiv",
            "state->enc_keyiv_len"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "b",
            "state->enc_ciphername"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_serialize_enc_key(const struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tint r;\n\n\tif (state == NULL || state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_put_cstring(b, state->enc_ciphername)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->enc_keyiv,\n\t    state->enc_keyiv_len)) != 0)\n\t\treturn r;\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_xmss_init_enc_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "265-288",
    "snippet": "int\nsshkey_xmss_init_enc_key(struct sshkey *k, const char *ciphername)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tconst struct sshcipher *cipher;\n\tsize_t keylen = 0, ivlen = 0;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((state->enc_ciphername = strdup(ciphername)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tstate->enc_keyiv_len = keylen + ivlen;\n\tif ((state->enc_keyiv = calloc(state->enc_keyiv_len, 1)) == NULL) {\n\t\tfree(state->enc_ciphername);\n\t\tstate->enc_ciphername = NULL;\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tarc4random_buf(state->enc_keyiv, state->enc_keyiv_len);\n\treturn 0;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arc4random_buf",
          "args": [
            "state->enc_keyiv",
            "state->enc_keyiv_len"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "263-277",
          "snippet": "void\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "state->enc_ciphername"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_free_bds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "187-208",
          "snippet": "void\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "state->enc_keyiv_len",
            "1"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_ivlen",
          "args": [
            "cipher"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_ivlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "169-178",
          "snippet": "u_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t/*\n\t * Default is cipher block size, except for chacha20+poly1305 that\n\t * needs no IV. XXX make iv_len == -1 default?\n\t */\n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nu_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t/*\n\t * Default is cipher block size, except for chacha20+poly1305 that\n\t * needs no IV. XXX make iv_len == -1 default?\n\t */\n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_keylen",
          "args": [
            "cipher"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_keylen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "149-153",
          "snippet": "u_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ciphername"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_by_name",
          "args": [
            "ciphername"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "192-200",
          "snippet": "const struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};\n\nconst struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_init_enc_key(struct sshkey *k, const char *ciphername)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tconst struct sshcipher *cipher;\n\tsize_t keylen = 0, ivlen = 0;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((state->enc_ciphername = strdup(ciphername)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tstate->enc_keyiv_len = keylen + ivlen;\n\tif ((state->enc_keyiv = calloc(state->enc_keyiv_len, 1)) == NULL) {\n\t\tfree(state->enc_ciphername);\n\t\tstate->enc_ciphername = NULL;\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tarc4random_buf(state->enc_keyiv, state->enc_keyiv_len);\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_xmss_sklen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "255-263",
    "snippet": "size_t\nsshkey_xmss_sklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 4 + 4;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_sklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 4 + 4;\n}"
  },
  {
    "function_name": "sshkey_xmss_pklen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "245-253",
    "snippet": "size_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}"
  },
  {
    "function_name": "sshkey_xmss_siglen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "230-243",
    "snippet": "int\nsshkey_xmss_siglen(const struct sshkey *key, size_t *lenp)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (lenp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t*lenp = 4 + state->n +\n\t    state->params.wots_par.keysize +\n\t    state->h * state->n;\n\treturn 0;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_siglen(const struct sshkey *key, size_t *lenp)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (lenp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t*lenp = 4 + state->n +\n\t    state->params.wots_par.keysize +\n\t    state->h * state->n;\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_xmss_bds_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "220-228",
    "snippet": "void *\nsshkey_xmss_bds_state(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->bds;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nsshkey_xmss_bds_state(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->bds;\n}"
  },
  {
    "function_name": "sshkey_xmss_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "210-218",
    "snippet": "void *\nsshkey_xmss_params(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->params;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nsshkey_xmss_params(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->params;\n}"
  },
  {
    "function_name": "sshkey_xmss_free_bds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "187-208",
    "snippet": "void\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "state->treehash"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_free_bds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "187-208",
          "snippet": "void\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}"
  },
  {
    "function_name": "sshkey_xmss_init_bds_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "161-185",
    "snippet": "int\nsshkey_xmss_init_bds_state(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\tu_int32_t i;\n\n\tstate->stackoffset = 0;\n\tif ((state->stack = calloc(num_stack(state), 1)) == NULL ||\n\t    (state->stacklevels = calloc(num_stacklevels(state), 1))== NULL ||\n\t    (state->auth = calloc(num_auth(state), 1)) == NULL ||\n\t    (state->keep = calloc(num_keep(state), 1)) == NULL ||\n\t    (state->th_nodes = calloc(num_th_nodes(state), 1)) == NULL ||\n\t    (state->retain = calloc(num_retain(state), 1)) == NULL ||\n\t    (state->treehash = calloc(num_treehash(state),\n\t    sizeof(treehash_inst))) == NULL) {\n\t\tsshkey_xmss_free_bds(key);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tfor (i = 0; i < state->h - state->k; i++)\n\t\tstate->treehash[i].node = &state->th_nodes[state->n*i];\n\txmss_set_bds_state(&state->bds, state->stack, state->stackoffset,\n\t    state->stacklevels, state->auth, state->keep, state->treehash,\n\t    state->retain, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmss_set_bds_state",
          "args": [
            "&state->bds",
            "state->stack",
            "state->stackoffset",
            "state->stacklevels",
            "state->auth",
            "state->keep",
            "state->treehash",
            "state->retain",
            "0"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "xmss_set_bds_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "72-82",
          "snippet": "void xmss_set_bds_state(bds_state *state, unsigned char *stack, int stackoffset, unsigned char *stacklevels, unsigned char *auth, unsigned char *keep, treehash_inst *treehash, unsigned char *retain, int next_leaf)\n{\n  state->stack = stack;\n  state->stackoffset = stackoffset;\n  state->stacklevels = stacklevels;\n  state->auth = auth;\n  state->keep = keep;\n  state->treehash = treehash;\n  state->retain = retain;\n  state->next_leaf = next_leaf;\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid xmss_set_bds_state(bds_state *state, unsigned char *stack, int stackoffset, unsigned char *stacklevels, unsigned char *auth, unsigned char *keep, treehash_inst *treehash, unsigned char *retain, int next_leaf)\n{\n  state->stack = stack;\n  state->stackoffset = stackoffset;\n  state->stacklevels = stacklevels;\n  state->auth = auth;\n  state->keep = keep;\n  state->treehash = treehash;\n  state->retain = retain;\n  state->next_leaf = next_leaf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_free_bds",
          "args": [
            "key"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_free_bds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "187-208",
          "snippet": "void\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "num_treehash(state)",
            "sizeof(treehash_inst)"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_treehash",
          "args": [
            "state"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_retain",
          "args": [
            "state"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_th_nodes",
          "args": [
            "state"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_keep",
          "args": [
            "state"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_auth",
          "args": [
            "state"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_stacklevels",
          "args": [
            "state"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_stack",
          "args": [
            "state"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_init_bds_state(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\tu_int32_t i;\n\n\tstate->stackoffset = 0;\n\tif ((state->stack = calloc(num_stack(state), 1)) == NULL ||\n\t    (state->stacklevels = calloc(num_stacklevels(state), 1))== NULL ||\n\t    (state->auth = calloc(num_auth(state), 1)) == NULL ||\n\t    (state->keep = calloc(num_keep(state), 1)) == NULL ||\n\t    (state->th_nodes = calloc(num_th_nodes(state), 1)) == NULL ||\n\t    (state->retain = calloc(num_retain(state), 1)) == NULL ||\n\t    (state->treehash = calloc(num_treehash(state),\n\t    sizeof(treehash_inst))) == NULL) {\n\t\tsshkey_xmss_free_bds(key);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tfor (i = 0; i < state->h - state->k; i++)\n\t\tstate->treehash[i].node = &state->th_nodes[state->n*i];\n\txmss_set_bds_state(&state->bds, state->stack, state->stackoffset,\n\t    state->stacklevels, state->auth, state->keep, state->treehash,\n\t    state->retain, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_xmss_free_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "135-150",
    "snippet": "void\nsshkey_xmss_free_state(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tsshkey_xmss_free_bds(key);\n\tif (state) {\n\t\tif (state->enc_keyiv) {\n\t\t\texplicit_bzero(state->enc_keyiv, state->enc_keyiv_len);\n\t\t\tfree(state->enc_keyiv);\n\t\t}\n\t\tfree(state->enc_ciphername);\n\t\tfree(state);\n\t}\n\tkey->xmss_state = NULL;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "state"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_free_bds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "187-208",
          "snippet": "void\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "state->enc_keyiv",
            "state->enc_keyiv_len"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_xmss_free_state(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tsshkey_xmss_free_bds(key);\n\tif (state) {\n\t\tif (state->enc_keyiv) {\n\t\t\texplicit_bzero(state->enc_keyiv, state->enc_keyiv_len);\n\t\t\tfree(state->enc_keyiv);\n\t\t}\n\t\tfree(state->enc_ciphername);\n\t\tfree(state);\n\t}\n\tkey->xmss_state = NULL;\n}"
  },
  {
    "function_name": "sshkey_xmss_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
    "lines": "92-133",
    "snippet": "int\nsshkey_xmss_init(struct sshkey *key, const char *name)\n{\n\tstruct ssh_xmss_state *state;\n\n\tif (key->xmss_state != NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (name == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tstate = calloc(sizeof(struct ssh_xmss_state), 1);\n\tif (state == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (strcmp(name, XMSS_SHA2_256_W16_H10_NAME) == 0) {\n\t\tstate->n = 32;\n\t\tstate->w = 16;\n\t\tstate->h = 10;\n\t} else if (strcmp(name, XMSS_SHA2_256_W16_H16_NAME) == 0) {\n\t\tstate->n = 32;\n\t\tstate->w = 16;\n\t\tstate->h = 16;\n\t} else if (strcmp(name, XMSS_SHA2_256_W16_H20_NAME) == 0) {\n\t\tstate->n = 32;\n\t\tstate->w = 16;\n\t\tstate->h = 20;\n\t} else {\n\t\tfree(state);\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\tif ((key->xmss_name = strdup(name)) == NULL) {\n\t\tfree(state);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tstate->k = 2;\t/* XXX hardcoded */\n\tstate->lockfd = -1;\n\tif (xmss_set_params(&state->params, state->n, state->h, state->w,\n\t    state->k) != 0) {\n\t\tfree(state);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tkey->xmss_state = state;\n\treturn 0;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"atomicio.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "# include <sys/file.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "state"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_free_bds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "187-208",
          "snippet": "void\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmss_set_params",
          "args": [
            "&state->params",
            "state->n",
            "state->h",
            "state->w",
            "state->k"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "xmss_set_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "53-66",
          "snippet": "int xmss_set_params(xmss_params *params, int n, int h, int w, int k)\n{\n  if (k >= h || k < 2 || (h - k) % 2) {\n    fprintf(stderr, \"For BDS traversal, H - K must be even, with H > K >= 2!\\n\");\n    return 1;\n  }\n  params->h = h;\n  params->n = n;\n  params->k = k;\n  wots_params wots_par;\n  wots_set_params(&wots_par, n, w);\n  params->wots_par = wots_par;\n  return 0;\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint xmss_set_params(xmss_params *params, int n, int h, int w, int k)\n{\n  if (k >= h || k < 2 || (h - k) % 2) {\n    fprintf(stderr, \"For BDS traversal, H - K must be even, with H > K >= 2!\\n\");\n    return 1;\n  }\n  params->h = h;\n  params->n = n;\n  params->k = k;\n  wots_params wots_par;\n  wots_set_params(&wots_par, n, w);\n  params->wots_par = wots_par;\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XMSS_SHA2_256_W16_H20_NAME"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "sizeof(struct ssh_xmss_state)",
            "1"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_init(struct sshkey *key, const char *name)\n{\n\tstruct ssh_xmss_state *state;\n\n\tif (key->xmss_state != NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (name == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tstate = calloc(sizeof(struct ssh_xmss_state), 1);\n\tif (state == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (strcmp(name, XMSS_SHA2_256_W16_H10_NAME) == 0) {\n\t\tstate->n = 32;\n\t\tstate->w = 16;\n\t\tstate->h = 10;\n\t} else if (strcmp(name, XMSS_SHA2_256_W16_H16_NAME) == 0) {\n\t\tstate->n = 32;\n\t\tstate->w = 16;\n\t\tstate->h = 16;\n\t} else if (strcmp(name, XMSS_SHA2_256_W16_H20_NAME) == 0) {\n\t\tstate->n = 32;\n\t\tstate->w = 16;\n\t\tstate->h = 20;\n\t} else {\n\t\tfree(state);\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\tif ((key->xmss_name = strdup(name)) == NULL) {\n\t\tfree(state);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tstate->k = 2;\t/* XXX hardcoded */\n\tstate->lockfd = -1;\n\tif (xmss_set_params(&state->params, state->n, state->h, state->w,\n\t    state->k) != 0) {\n\t\tfree(state);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tkey->xmss_state = state;\n\treturn 0;\n}"
  }
]