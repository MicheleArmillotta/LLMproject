[
  {
    "function_name": "getopt_long_only",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
    "lines": "522-529",
    "snippet": "int\ngetopt_long_only(int nargc, char * const *nargv, const char *options,\n    const struct option *long_options, int *idx)\n{\n\n\treturn (getopt_internal(nargc, nargv, options, long_options, idx,\n\t    FLAG_PERMUTE|FLAG_LONGONLY));\n}",
    "includes": [
      "#include \"log.h\"",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <getopt.h>",
      "#include <err.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define FLAG_LONGONLY\t0x04\t/* operate as getopt_long_only */",
      "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getopt_internal",
          "args": [
            "nargc",
            "nargv",
            "options",
            "long_options",
            "idx",
            "FLAG_PERMUTE|FLAG_LONGONLY"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "getopt_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "293-481",
          "snippet": "static int\ngetopt_internal(int nargc, char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int flags)\n{\n\tchar *oli;\t\t\t\t/* option letter list index */\n\tint optchar, short_too;\n\tstatic int posixly_correct = -1;\n\n\tif (options == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * XXX Some GNU programs (like cvs) set optind to 0 instead of\n\t * XXX using optreset.  Work around this braindamage.\n\t */\n\tif (optind == 0)\n\t\toptind = optreset = 1;\n\n\t/*\n\t * Disable GNU extensions if POSIXLY_CORRECT is set or options\n\t * string begins with a '+'.\n\t */\n\tif (posixly_correct == -1 || optreset)\n\t\tposixly_correct = (getenv(\"POSIXLY_CORRECT\") != NULL);\n\tif (*options == '-')\n\t\tflags |= FLAG_ALLARGS;\n\telse if (posixly_correct || *options == '+')\n\t\tflags &= ~FLAG_PERMUTE;\n\tif (*options == '+' || *options == '-')\n\t\toptions++;\n\n\toptarg = NULL;\n\tif (optreset)\n\t\tnonopt_start = nonopt_end = -1;\nstart:\n\tif (optreset || !*place) {\t\t/* update scanning pointer */\n\t\toptreset = 0;\n\t\tif (optind >= nargc) {          /* end of argument vector */\n\t\t\tplace = EMSG;\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\t/* do permutation, if we have to */\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\telse if (nonopt_start != -1) {\n\t\t\t\t/*\n\t\t\t\t * If we skipped non-options, set optind\n\t\t\t\t * to the first of them.\n\t\t\t\t */\n\t\t\t\toptind = nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (*(place = nargv[optind]) != '-' ||\n\t\t    (place[1] == '\\0' && strchr(options, '-') == NULL)) {\n\t\t\tplace = EMSG;\t\t/* found non-option */\n\t\t\tif (flags & FLAG_ALLARGS) {\n\t\t\t\t/*\n\t\t\t\t * GNU extension:\n\t\t\t\t * return non-option as argument to option 1\n\t\t\t\t */\n\t\t\t\toptarg = nargv[optind++];\n\t\t\t\treturn (INORDER);\n\t\t\t}\n\t\t\tif (!(flags & FLAG_PERMUTE)) {\n\t\t\t\t/*\n\t\t\t\t * If no permutation wanted, stop parsing\n\t\t\t\t * at first non-option.\n\t\t\t\t */\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t/* do permutation */\n\t\t\tif (nonopt_start == -1)\n\t\t\t\tnonopt_start = optind;\n\t\t\telse if (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\tnonopt_start = optind -\n\t\t\t\t    (nonopt_end - nonopt_start);\n\t\t\t\tnonopt_end = -1;\n\t\t\t}\n\t\t\toptind++;\n\t\t\t/* process next argument */\n\t\t\tgoto start;\n\t\t}\n\t\tif (nonopt_start != -1 && nonopt_end == -1)\n\t\t\tnonopt_end = optind;\n\n\t\t/*\n\t\t * If we have \"-\" do nothing, if \"--\" we are done.\n\t\t */\n\t\tif (place[1] != '\\0' && *++place == '-' && place[1] == '\\0') {\n\t\t\toptind++;\n\t\t\tplace = EMSG;\n\t\t\t/*\n\t\t\t * We found an option (--), so if we skipped\n\t\t\t * non-options, we have to permute.\n\t\t\t */\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t/*\n\t * Check long options if:\n\t *  1) we were passed some\n\t *  2) the arg is not just \"-\"\n\t *  3) either the arg starts with -- we are getopt_long_only()\n\t */\n\tif (long_options != NULL && place != nargv[optind] &&\n\t    (*place == '-' || (flags & FLAG_LONGONLY))) {\n\t\tshort_too = 0;\n\t\tif (*place == '-')\n\t\t\tplace++;\t\t/* --foo long option */\n\t\telse if (*place != ':' && strchr(options, *place) != NULL)\n\t\t\tshort_too = 1;\t\t/* could be short option too */\n\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, short_too);\n\t\tif (optchar != -1) {\n\t\t\tplace = EMSG;\n\t\t\treturn (optchar);\n\t\t}\n\t}\n\n\tif ((optchar = (int)*place++) == (int)':' ||\n\t    (optchar == (int)'-' && *place != '\\0') ||\n\t    (oli = strchr(options, optchar)) == NULL) {\n\t\t/*\n\t\t * If the user specified \"-\" and  '-' isn't listed in\n\t\t * options, return -1 (non-option) as per POSIX.\n\t\t * Otherwise, it is an unknown option character (or ':').\n\t\t */\n\t\tif (optchar == (int)'-' && *place == '\\0')\n\t\t\treturn (-1);\n\t\tif (!*place)\n\t\t\t++optind;\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptchar, optchar);\n\t\toptopt = optchar;\n\t\treturn (BADCH);\n\t}\n\tif (long_options != NULL && optchar == 'W' && oli[1] == ';') {\n\t\t/* -W long-option */\n\t\tif (*place)\t\t\t/* no space */\n\t\t\t/* NOTHING */;\n\t\telse if (++optind >= nargc) {\t/* no arg */\n\t\t\tplace = EMSG;\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargchar, optchar);\n\t\t\toptopt = optchar;\n\t\t\treturn (BADARG);\n\t\t} else\t\t\t\t/* white space */\n\t\t\tplace = nargv[optind];\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, 0);\n\t\tplace = EMSG;\n\t\treturn (optchar);\n\t}\n\tif (*++oli != ':') {\t\t\t/* doesn't take argument */\n\t\tif (!*place)\n\t\t\t++optind;\n\t} else {\t\t\t\t/* takes (optional) argument */\n\t\toptarg = NULL;\n\t\tif (*place)\t\t\t/* no white space */\n\t\t\toptarg = place;\n\t\telse if (oli[1] != ':') {\t/* arg not optional */\n\t\t\tif (++optind >= nargc) {\t/* no arg */\n\t\t\t\tplace = EMSG;\n\t\t\t\tif (PRINT_ERROR)\n\t\t\t\t\twarnx(recargchar, optchar);\n\t\t\t\toptopt = optchar;\n\t\t\t\treturn (BADARG);\n\t\t\t} else\n\t\t\t\toptarg = nargv[optind];\n\t\t}\n\t\tplace = EMSG;\n\t\t++optind;\n\t}\n\t/* dump back option letter */\n\treturn (optchar);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tEMSG\t\t\"\"",
            "#define\tINORDER \t(int)1",
            "#define\tBADARG\t\t((*options == ':') ? (int)':' : (int)'?')",
            "#define\tBADCH\t\t(int)'?'",
            "#define FLAG_LONGONLY\t0x04\t/* operate as getopt_long_only */",
            "#define FLAG_ALLARGS\t0x02\t/* treat non-options as args to option \"-1\" */",
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */",
            "#define PRINT_ERROR\t((opterr) && (*options != ':'))",
            "#define warnx\t\tlogit"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define\tEMSG\t\t\"\"\n#define\tINORDER \t(int)1\n#define\tBADARG\t\t((*options == ':') ? (int)':' : (int)'?')\n#define\tBADCH\t\t(int)'?'\n#define FLAG_LONGONLY\t0x04\t/* operate as getopt_long_only */\n#define FLAG_ALLARGS\t0x02\t/* treat non-options as args to option \"-1\" */\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n#define PRINT_ERROR\t((opterr) && (*options != ':'))\n#define warnx\t\tlogit\n\nstatic int\ngetopt_internal(int nargc, char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int flags)\n{\n\tchar *oli;\t\t\t\t/* option letter list index */\n\tint optchar, short_too;\n\tstatic int posixly_correct = -1;\n\n\tif (options == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * XXX Some GNU programs (like cvs) set optind to 0 instead of\n\t * XXX using optreset.  Work around this braindamage.\n\t */\n\tif (optind == 0)\n\t\toptind = optreset = 1;\n\n\t/*\n\t * Disable GNU extensions if POSIXLY_CORRECT is set or options\n\t * string begins with a '+'.\n\t */\n\tif (posixly_correct == -1 || optreset)\n\t\tposixly_correct = (getenv(\"POSIXLY_CORRECT\") != NULL);\n\tif (*options == '-')\n\t\tflags |= FLAG_ALLARGS;\n\telse if (posixly_correct || *options == '+')\n\t\tflags &= ~FLAG_PERMUTE;\n\tif (*options == '+' || *options == '-')\n\t\toptions++;\n\n\toptarg = NULL;\n\tif (optreset)\n\t\tnonopt_start = nonopt_end = -1;\nstart:\n\tif (optreset || !*place) {\t\t/* update scanning pointer */\n\t\toptreset = 0;\n\t\tif (optind >= nargc) {          /* end of argument vector */\n\t\t\tplace = EMSG;\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\t/* do permutation, if we have to */\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\telse if (nonopt_start != -1) {\n\t\t\t\t/*\n\t\t\t\t * If we skipped non-options, set optind\n\t\t\t\t * to the first of them.\n\t\t\t\t */\n\t\t\t\toptind = nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (*(place = nargv[optind]) != '-' ||\n\t\t    (place[1] == '\\0' && strchr(options, '-') == NULL)) {\n\t\t\tplace = EMSG;\t\t/* found non-option */\n\t\t\tif (flags & FLAG_ALLARGS) {\n\t\t\t\t/*\n\t\t\t\t * GNU extension:\n\t\t\t\t * return non-option as argument to option 1\n\t\t\t\t */\n\t\t\t\toptarg = nargv[optind++];\n\t\t\t\treturn (INORDER);\n\t\t\t}\n\t\t\tif (!(flags & FLAG_PERMUTE)) {\n\t\t\t\t/*\n\t\t\t\t * If no permutation wanted, stop parsing\n\t\t\t\t * at first non-option.\n\t\t\t\t */\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t/* do permutation */\n\t\t\tif (nonopt_start == -1)\n\t\t\t\tnonopt_start = optind;\n\t\t\telse if (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\tnonopt_start = optind -\n\t\t\t\t    (nonopt_end - nonopt_start);\n\t\t\t\tnonopt_end = -1;\n\t\t\t}\n\t\t\toptind++;\n\t\t\t/* process next argument */\n\t\t\tgoto start;\n\t\t}\n\t\tif (nonopt_start != -1 && nonopt_end == -1)\n\t\t\tnonopt_end = optind;\n\n\t\t/*\n\t\t * If we have \"-\" do nothing, if \"--\" we are done.\n\t\t */\n\t\tif (place[1] != '\\0' && *++place == '-' && place[1] == '\\0') {\n\t\t\toptind++;\n\t\t\tplace = EMSG;\n\t\t\t/*\n\t\t\t * We found an option (--), so if we skipped\n\t\t\t * non-options, we have to permute.\n\t\t\t */\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t/*\n\t * Check long options if:\n\t *  1) we were passed some\n\t *  2) the arg is not just \"-\"\n\t *  3) either the arg starts with -- we are getopt_long_only()\n\t */\n\tif (long_options != NULL && place != nargv[optind] &&\n\t    (*place == '-' || (flags & FLAG_LONGONLY))) {\n\t\tshort_too = 0;\n\t\tif (*place == '-')\n\t\t\tplace++;\t\t/* --foo long option */\n\t\telse if (*place != ':' && strchr(options, *place) != NULL)\n\t\t\tshort_too = 1;\t\t/* could be short option too */\n\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, short_too);\n\t\tif (optchar != -1) {\n\t\t\tplace = EMSG;\n\t\t\treturn (optchar);\n\t\t}\n\t}\n\n\tif ((optchar = (int)*place++) == (int)':' ||\n\t    (optchar == (int)'-' && *place != '\\0') ||\n\t    (oli = strchr(options, optchar)) == NULL) {\n\t\t/*\n\t\t * If the user specified \"-\" and  '-' isn't listed in\n\t\t * options, return -1 (non-option) as per POSIX.\n\t\t * Otherwise, it is an unknown option character (or ':').\n\t\t */\n\t\tif (optchar == (int)'-' && *place == '\\0')\n\t\t\treturn (-1);\n\t\tif (!*place)\n\t\t\t++optind;\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptchar, optchar);\n\t\toptopt = optchar;\n\t\treturn (BADCH);\n\t}\n\tif (long_options != NULL && optchar == 'W' && oli[1] == ';') {\n\t\t/* -W long-option */\n\t\tif (*place)\t\t\t/* no space */\n\t\t\t/* NOTHING */;\n\t\telse if (++optind >= nargc) {\t/* no arg */\n\t\t\tplace = EMSG;\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargchar, optchar);\n\t\t\toptopt = optchar;\n\t\t\treturn (BADARG);\n\t\t} else\t\t\t\t/* white space */\n\t\t\tplace = nargv[optind];\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, 0);\n\t\tplace = EMSG;\n\t\treturn (optchar);\n\t}\n\tif (*++oli != ':') {\t\t\t/* doesn't take argument */\n\t\tif (!*place)\n\t\t\t++optind;\n\t} else {\t\t\t\t/* takes (optional) argument */\n\t\toptarg = NULL;\n\t\tif (*place)\t\t\t/* no white space */\n\t\t\toptarg = place;\n\t\telse if (oli[1] != ':') {\t/* arg not optional */\n\t\t\tif (++optind >= nargc) {\t/* no arg */\n\t\t\t\tplace = EMSG;\n\t\t\t\tif (PRINT_ERROR)\n\t\t\t\t\twarnx(recargchar, optchar);\n\t\t\t\toptopt = optchar;\n\t\t\t\treturn (BADARG);\n\t\t\t} else\n\t\t\t\toptarg = nargv[optind];\n\t\t}\n\t\tplace = EMSG;\n\t\t++optind;\n\t}\n\t/* dump back option letter */\n\treturn (optchar);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_LONGONLY\t0x04\t/* operate as getopt_long_only */\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt_long_only(int nargc, char * const *nargv, const char *options,\n    const struct option *long_options, int *idx)\n{\n\n\treturn (getopt_internal(nargc, nargv, options, long_options, idx,\n\t    FLAG_PERMUTE|FLAG_LONGONLY));\n}"
  },
  {
    "function_name": "getopt_long",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
    "lines": "509-516",
    "snippet": "int\ngetopt_long(int nargc, char * const *nargv, const char *options,\n    const struct option *long_options, int *idx)\n{\n\n\treturn (getopt_internal(nargc, nargv, options, long_options, idx,\n\t    FLAG_PERMUTE));\n}",
    "includes": [
      "#include \"log.h\"",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <getopt.h>",
      "#include <err.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getopt_internal",
          "args": [
            "nargc",
            "nargv",
            "options",
            "long_options",
            "idx",
            "FLAG_PERMUTE"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "getopt_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "293-481",
          "snippet": "static int\ngetopt_internal(int nargc, char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int flags)\n{\n\tchar *oli;\t\t\t\t/* option letter list index */\n\tint optchar, short_too;\n\tstatic int posixly_correct = -1;\n\n\tif (options == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * XXX Some GNU programs (like cvs) set optind to 0 instead of\n\t * XXX using optreset.  Work around this braindamage.\n\t */\n\tif (optind == 0)\n\t\toptind = optreset = 1;\n\n\t/*\n\t * Disable GNU extensions if POSIXLY_CORRECT is set or options\n\t * string begins with a '+'.\n\t */\n\tif (posixly_correct == -1 || optreset)\n\t\tposixly_correct = (getenv(\"POSIXLY_CORRECT\") != NULL);\n\tif (*options == '-')\n\t\tflags |= FLAG_ALLARGS;\n\telse if (posixly_correct || *options == '+')\n\t\tflags &= ~FLAG_PERMUTE;\n\tif (*options == '+' || *options == '-')\n\t\toptions++;\n\n\toptarg = NULL;\n\tif (optreset)\n\t\tnonopt_start = nonopt_end = -1;\nstart:\n\tif (optreset || !*place) {\t\t/* update scanning pointer */\n\t\toptreset = 0;\n\t\tif (optind >= nargc) {          /* end of argument vector */\n\t\t\tplace = EMSG;\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\t/* do permutation, if we have to */\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\telse if (nonopt_start != -1) {\n\t\t\t\t/*\n\t\t\t\t * If we skipped non-options, set optind\n\t\t\t\t * to the first of them.\n\t\t\t\t */\n\t\t\t\toptind = nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (*(place = nargv[optind]) != '-' ||\n\t\t    (place[1] == '\\0' && strchr(options, '-') == NULL)) {\n\t\t\tplace = EMSG;\t\t/* found non-option */\n\t\t\tif (flags & FLAG_ALLARGS) {\n\t\t\t\t/*\n\t\t\t\t * GNU extension:\n\t\t\t\t * return non-option as argument to option 1\n\t\t\t\t */\n\t\t\t\toptarg = nargv[optind++];\n\t\t\t\treturn (INORDER);\n\t\t\t}\n\t\t\tif (!(flags & FLAG_PERMUTE)) {\n\t\t\t\t/*\n\t\t\t\t * If no permutation wanted, stop parsing\n\t\t\t\t * at first non-option.\n\t\t\t\t */\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t/* do permutation */\n\t\t\tif (nonopt_start == -1)\n\t\t\t\tnonopt_start = optind;\n\t\t\telse if (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\tnonopt_start = optind -\n\t\t\t\t    (nonopt_end - nonopt_start);\n\t\t\t\tnonopt_end = -1;\n\t\t\t}\n\t\t\toptind++;\n\t\t\t/* process next argument */\n\t\t\tgoto start;\n\t\t}\n\t\tif (nonopt_start != -1 && nonopt_end == -1)\n\t\t\tnonopt_end = optind;\n\n\t\t/*\n\t\t * If we have \"-\" do nothing, if \"--\" we are done.\n\t\t */\n\t\tif (place[1] != '\\0' && *++place == '-' && place[1] == '\\0') {\n\t\t\toptind++;\n\t\t\tplace = EMSG;\n\t\t\t/*\n\t\t\t * We found an option (--), so if we skipped\n\t\t\t * non-options, we have to permute.\n\t\t\t */\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t/*\n\t * Check long options if:\n\t *  1) we were passed some\n\t *  2) the arg is not just \"-\"\n\t *  3) either the arg starts with -- we are getopt_long_only()\n\t */\n\tif (long_options != NULL && place != nargv[optind] &&\n\t    (*place == '-' || (flags & FLAG_LONGONLY))) {\n\t\tshort_too = 0;\n\t\tif (*place == '-')\n\t\t\tplace++;\t\t/* --foo long option */\n\t\telse if (*place != ':' && strchr(options, *place) != NULL)\n\t\t\tshort_too = 1;\t\t/* could be short option too */\n\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, short_too);\n\t\tif (optchar != -1) {\n\t\t\tplace = EMSG;\n\t\t\treturn (optchar);\n\t\t}\n\t}\n\n\tif ((optchar = (int)*place++) == (int)':' ||\n\t    (optchar == (int)'-' && *place != '\\0') ||\n\t    (oli = strchr(options, optchar)) == NULL) {\n\t\t/*\n\t\t * If the user specified \"-\" and  '-' isn't listed in\n\t\t * options, return -1 (non-option) as per POSIX.\n\t\t * Otherwise, it is an unknown option character (or ':').\n\t\t */\n\t\tif (optchar == (int)'-' && *place == '\\0')\n\t\t\treturn (-1);\n\t\tif (!*place)\n\t\t\t++optind;\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptchar, optchar);\n\t\toptopt = optchar;\n\t\treturn (BADCH);\n\t}\n\tif (long_options != NULL && optchar == 'W' && oli[1] == ';') {\n\t\t/* -W long-option */\n\t\tif (*place)\t\t\t/* no space */\n\t\t\t/* NOTHING */;\n\t\telse if (++optind >= nargc) {\t/* no arg */\n\t\t\tplace = EMSG;\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargchar, optchar);\n\t\t\toptopt = optchar;\n\t\t\treturn (BADARG);\n\t\t} else\t\t\t\t/* white space */\n\t\t\tplace = nargv[optind];\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, 0);\n\t\tplace = EMSG;\n\t\treturn (optchar);\n\t}\n\tif (*++oli != ':') {\t\t\t/* doesn't take argument */\n\t\tif (!*place)\n\t\t\t++optind;\n\t} else {\t\t\t\t/* takes (optional) argument */\n\t\toptarg = NULL;\n\t\tif (*place)\t\t\t/* no white space */\n\t\t\toptarg = place;\n\t\telse if (oli[1] != ':') {\t/* arg not optional */\n\t\t\tif (++optind >= nargc) {\t/* no arg */\n\t\t\t\tplace = EMSG;\n\t\t\t\tif (PRINT_ERROR)\n\t\t\t\t\twarnx(recargchar, optchar);\n\t\t\t\toptopt = optchar;\n\t\t\t\treturn (BADARG);\n\t\t\t} else\n\t\t\t\toptarg = nargv[optind];\n\t\t}\n\t\tplace = EMSG;\n\t\t++optind;\n\t}\n\t/* dump back option letter */\n\treturn (optchar);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tEMSG\t\t\"\"",
            "#define\tINORDER \t(int)1",
            "#define\tBADARG\t\t((*options == ':') ? (int)':' : (int)'?')",
            "#define\tBADCH\t\t(int)'?'",
            "#define FLAG_LONGONLY\t0x04\t/* operate as getopt_long_only */",
            "#define FLAG_ALLARGS\t0x02\t/* treat non-options as args to option \"-1\" */",
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */",
            "#define PRINT_ERROR\t((opterr) && (*options != ':'))",
            "#define warnx\t\tlogit"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define\tEMSG\t\t\"\"\n#define\tINORDER \t(int)1\n#define\tBADARG\t\t((*options == ':') ? (int)':' : (int)'?')\n#define\tBADCH\t\t(int)'?'\n#define FLAG_LONGONLY\t0x04\t/* operate as getopt_long_only */\n#define FLAG_ALLARGS\t0x02\t/* treat non-options as args to option \"-1\" */\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n#define PRINT_ERROR\t((opterr) && (*options != ':'))\n#define warnx\t\tlogit\n\nstatic int\ngetopt_internal(int nargc, char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int flags)\n{\n\tchar *oli;\t\t\t\t/* option letter list index */\n\tint optchar, short_too;\n\tstatic int posixly_correct = -1;\n\n\tif (options == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * XXX Some GNU programs (like cvs) set optind to 0 instead of\n\t * XXX using optreset.  Work around this braindamage.\n\t */\n\tif (optind == 0)\n\t\toptind = optreset = 1;\n\n\t/*\n\t * Disable GNU extensions if POSIXLY_CORRECT is set or options\n\t * string begins with a '+'.\n\t */\n\tif (posixly_correct == -1 || optreset)\n\t\tposixly_correct = (getenv(\"POSIXLY_CORRECT\") != NULL);\n\tif (*options == '-')\n\t\tflags |= FLAG_ALLARGS;\n\telse if (posixly_correct || *options == '+')\n\t\tflags &= ~FLAG_PERMUTE;\n\tif (*options == '+' || *options == '-')\n\t\toptions++;\n\n\toptarg = NULL;\n\tif (optreset)\n\t\tnonopt_start = nonopt_end = -1;\nstart:\n\tif (optreset || !*place) {\t\t/* update scanning pointer */\n\t\toptreset = 0;\n\t\tif (optind >= nargc) {          /* end of argument vector */\n\t\t\tplace = EMSG;\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\t/* do permutation, if we have to */\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\telse if (nonopt_start != -1) {\n\t\t\t\t/*\n\t\t\t\t * If we skipped non-options, set optind\n\t\t\t\t * to the first of them.\n\t\t\t\t */\n\t\t\t\toptind = nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (*(place = nargv[optind]) != '-' ||\n\t\t    (place[1] == '\\0' && strchr(options, '-') == NULL)) {\n\t\t\tplace = EMSG;\t\t/* found non-option */\n\t\t\tif (flags & FLAG_ALLARGS) {\n\t\t\t\t/*\n\t\t\t\t * GNU extension:\n\t\t\t\t * return non-option as argument to option 1\n\t\t\t\t */\n\t\t\t\toptarg = nargv[optind++];\n\t\t\t\treturn (INORDER);\n\t\t\t}\n\t\t\tif (!(flags & FLAG_PERMUTE)) {\n\t\t\t\t/*\n\t\t\t\t * If no permutation wanted, stop parsing\n\t\t\t\t * at first non-option.\n\t\t\t\t */\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t/* do permutation */\n\t\t\tif (nonopt_start == -1)\n\t\t\t\tnonopt_start = optind;\n\t\t\telse if (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\tnonopt_start = optind -\n\t\t\t\t    (nonopt_end - nonopt_start);\n\t\t\t\tnonopt_end = -1;\n\t\t\t}\n\t\t\toptind++;\n\t\t\t/* process next argument */\n\t\t\tgoto start;\n\t\t}\n\t\tif (nonopt_start != -1 && nonopt_end == -1)\n\t\t\tnonopt_end = optind;\n\n\t\t/*\n\t\t * If we have \"-\" do nothing, if \"--\" we are done.\n\t\t */\n\t\tif (place[1] != '\\0' && *++place == '-' && place[1] == '\\0') {\n\t\t\toptind++;\n\t\t\tplace = EMSG;\n\t\t\t/*\n\t\t\t * We found an option (--), so if we skipped\n\t\t\t * non-options, we have to permute.\n\t\t\t */\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t/*\n\t * Check long options if:\n\t *  1) we were passed some\n\t *  2) the arg is not just \"-\"\n\t *  3) either the arg starts with -- we are getopt_long_only()\n\t */\n\tif (long_options != NULL && place != nargv[optind] &&\n\t    (*place == '-' || (flags & FLAG_LONGONLY))) {\n\t\tshort_too = 0;\n\t\tif (*place == '-')\n\t\t\tplace++;\t\t/* --foo long option */\n\t\telse if (*place != ':' && strchr(options, *place) != NULL)\n\t\t\tshort_too = 1;\t\t/* could be short option too */\n\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, short_too);\n\t\tif (optchar != -1) {\n\t\t\tplace = EMSG;\n\t\t\treturn (optchar);\n\t\t}\n\t}\n\n\tif ((optchar = (int)*place++) == (int)':' ||\n\t    (optchar == (int)'-' && *place != '\\0') ||\n\t    (oli = strchr(options, optchar)) == NULL) {\n\t\t/*\n\t\t * If the user specified \"-\" and  '-' isn't listed in\n\t\t * options, return -1 (non-option) as per POSIX.\n\t\t * Otherwise, it is an unknown option character (or ':').\n\t\t */\n\t\tif (optchar == (int)'-' && *place == '\\0')\n\t\t\treturn (-1);\n\t\tif (!*place)\n\t\t\t++optind;\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptchar, optchar);\n\t\toptopt = optchar;\n\t\treturn (BADCH);\n\t}\n\tif (long_options != NULL && optchar == 'W' && oli[1] == ';') {\n\t\t/* -W long-option */\n\t\tif (*place)\t\t\t/* no space */\n\t\t\t/* NOTHING */;\n\t\telse if (++optind >= nargc) {\t/* no arg */\n\t\t\tplace = EMSG;\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargchar, optchar);\n\t\t\toptopt = optchar;\n\t\t\treturn (BADARG);\n\t\t} else\t\t\t\t/* white space */\n\t\t\tplace = nargv[optind];\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, 0);\n\t\tplace = EMSG;\n\t\treturn (optchar);\n\t}\n\tif (*++oli != ':') {\t\t\t/* doesn't take argument */\n\t\tif (!*place)\n\t\t\t++optind;\n\t} else {\t\t\t\t/* takes (optional) argument */\n\t\toptarg = NULL;\n\t\tif (*place)\t\t\t/* no white space */\n\t\t\toptarg = place;\n\t\telse if (oli[1] != ':') {\t/* arg not optional */\n\t\t\tif (++optind >= nargc) {\t/* no arg */\n\t\t\t\tplace = EMSG;\n\t\t\t\tif (PRINT_ERROR)\n\t\t\t\t\twarnx(recargchar, optchar);\n\t\t\t\toptopt = optchar;\n\t\t\t\treturn (BADARG);\n\t\t\t} else\n\t\t\t\toptarg = nargv[optind];\n\t\t}\n\t\tplace = EMSG;\n\t\t++optind;\n\t}\n\t/* dump back option letter */\n\treturn (optchar);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt_long(int nargc, char * const *nargv, const char *options,\n    const struct option *long_options, int *idx)\n{\n\n\treturn (getopt_internal(nargc, nargv, options, long_options, idx,\n\t    FLAG_PERMUTE));\n}"
  },
  {
    "function_name": "getopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
    "lines": "489-502",
    "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
    "includes": [
      "#include \"log.h\"",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <getopt.h>",
      "#include <err.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getopt_internal",
          "args": [
            "nargc",
            "nargv",
            "options",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "getopt_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "293-481",
          "snippet": "static int\ngetopt_internal(int nargc, char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int flags)\n{\n\tchar *oli;\t\t\t\t/* option letter list index */\n\tint optchar, short_too;\n\tstatic int posixly_correct = -1;\n\n\tif (options == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * XXX Some GNU programs (like cvs) set optind to 0 instead of\n\t * XXX using optreset.  Work around this braindamage.\n\t */\n\tif (optind == 0)\n\t\toptind = optreset = 1;\n\n\t/*\n\t * Disable GNU extensions if POSIXLY_CORRECT is set or options\n\t * string begins with a '+'.\n\t */\n\tif (posixly_correct == -1 || optreset)\n\t\tposixly_correct = (getenv(\"POSIXLY_CORRECT\") != NULL);\n\tif (*options == '-')\n\t\tflags |= FLAG_ALLARGS;\n\telse if (posixly_correct || *options == '+')\n\t\tflags &= ~FLAG_PERMUTE;\n\tif (*options == '+' || *options == '-')\n\t\toptions++;\n\n\toptarg = NULL;\n\tif (optreset)\n\t\tnonopt_start = nonopt_end = -1;\nstart:\n\tif (optreset || !*place) {\t\t/* update scanning pointer */\n\t\toptreset = 0;\n\t\tif (optind >= nargc) {          /* end of argument vector */\n\t\t\tplace = EMSG;\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\t/* do permutation, if we have to */\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\telse if (nonopt_start != -1) {\n\t\t\t\t/*\n\t\t\t\t * If we skipped non-options, set optind\n\t\t\t\t * to the first of them.\n\t\t\t\t */\n\t\t\t\toptind = nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (*(place = nargv[optind]) != '-' ||\n\t\t    (place[1] == '\\0' && strchr(options, '-') == NULL)) {\n\t\t\tplace = EMSG;\t\t/* found non-option */\n\t\t\tif (flags & FLAG_ALLARGS) {\n\t\t\t\t/*\n\t\t\t\t * GNU extension:\n\t\t\t\t * return non-option as argument to option 1\n\t\t\t\t */\n\t\t\t\toptarg = nargv[optind++];\n\t\t\t\treturn (INORDER);\n\t\t\t}\n\t\t\tif (!(flags & FLAG_PERMUTE)) {\n\t\t\t\t/*\n\t\t\t\t * If no permutation wanted, stop parsing\n\t\t\t\t * at first non-option.\n\t\t\t\t */\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t/* do permutation */\n\t\t\tif (nonopt_start == -1)\n\t\t\t\tnonopt_start = optind;\n\t\t\telse if (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\tnonopt_start = optind -\n\t\t\t\t    (nonopt_end - nonopt_start);\n\t\t\t\tnonopt_end = -1;\n\t\t\t}\n\t\t\toptind++;\n\t\t\t/* process next argument */\n\t\t\tgoto start;\n\t\t}\n\t\tif (nonopt_start != -1 && nonopt_end == -1)\n\t\t\tnonopt_end = optind;\n\n\t\t/*\n\t\t * If we have \"-\" do nothing, if \"--\" we are done.\n\t\t */\n\t\tif (place[1] != '\\0' && *++place == '-' && place[1] == '\\0') {\n\t\t\toptind++;\n\t\t\tplace = EMSG;\n\t\t\t/*\n\t\t\t * We found an option (--), so if we skipped\n\t\t\t * non-options, we have to permute.\n\t\t\t */\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t/*\n\t * Check long options if:\n\t *  1) we were passed some\n\t *  2) the arg is not just \"-\"\n\t *  3) either the arg starts with -- we are getopt_long_only()\n\t */\n\tif (long_options != NULL && place != nargv[optind] &&\n\t    (*place == '-' || (flags & FLAG_LONGONLY))) {\n\t\tshort_too = 0;\n\t\tif (*place == '-')\n\t\t\tplace++;\t\t/* --foo long option */\n\t\telse if (*place != ':' && strchr(options, *place) != NULL)\n\t\t\tshort_too = 1;\t\t/* could be short option too */\n\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, short_too);\n\t\tif (optchar != -1) {\n\t\t\tplace = EMSG;\n\t\t\treturn (optchar);\n\t\t}\n\t}\n\n\tif ((optchar = (int)*place++) == (int)':' ||\n\t    (optchar == (int)'-' && *place != '\\0') ||\n\t    (oli = strchr(options, optchar)) == NULL) {\n\t\t/*\n\t\t * If the user specified \"-\" and  '-' isn't listed in\n\t\t * options, return -1 (non-option) as per POSIX.\n\t\t * Otherwise, it is an unknown option character (or ':').\n\t\t */\n\t\tif (optchar == (int)'-' && *place == '\\0')\n\t\t\treturn (-1);\n\t\tif (!*place)\n\t\t\t++optind;\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptchar, optchar);\n\t\toptopt = optchar;\n\t\treturn (BADCH);\n\t}\n\tif (long_options != NULL && optchar == 'W' && oli[1] == ';') {\n\t\t/* -W long-option */\n\t\tif (*place)\t\t\t/* no space */\n\t\t\t/* NOTHING */;\n\t\telse if (++optind >= nargc) {\t/* no arg */\n\t\t\tplace = EMSG;\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargchar, optchar);\n\t\t\toptopt = optchar;\n\t\t\treturn (BADARG);\n\t\t} else\t\t\t\t/* white space */\n\t\t\tplace = nargv[optind];\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, 0);\n\t\tplace = EMSG;\n\t\treturn (optchar);\n\t}\n\tif (*++oli != ':') {\t\t\t/* doesn't take argument */\n\t\tif (!*place)\n\t\t\t++optind;\n\t} else {\t\t\t\t/* takes (optional) argument */\n\t\toptarg = NULL;\n\t\tif (*place)\t\t\t/* no white space */\n\t\t\toptarg = place;\n\t\telse if (oli[1] != ':') {\t/* arg not optional */\n\t\t\tif (++optind >= nargc) {\t/* no arg */\n\t\t\t\tplace = EMSG;\n\t\t\t\tif (PRINT_ERROR)\n\t\t\t\t\twarnx(recargchar, optchar);\n\t\t\t\toptopt = optchar;\n\t\t\t\treturn (BADARG);\n\t\t\t} else\n\t\t\t\toptarg = nargv[optind];\n\t\t}\n\t\tplace = EMSG;\n\t\t++optind;\n\t}\n\t/* dump back option letter */\n\treturn (optchar);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tEMSG\t\t\"\"",
            "#define\tINORDER \t(int)1",
            "#define\tBADARG\t\t((*options == ':') ? (int)':' : (int)'?')",
            "#define\tBADCH\t\t(int)'?'",
            "#define FLAG_LONGONLY\t0x04\t/* operate as getopt_long_only */",
            "#define FLAG_ALLARGS\t0x02\t/* treat non-options as args to option \"-1\" */",
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */",
            "#define PRINT_ERROR\t((opterr) && (*options != ':'))",
            "#define warnx\t\tlogit"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define\tEMSG\t\t\"\"\n#define\tINORDER \t(int)1\n#define\tBADARG\t\t((*options == ':') ? (int)':' : (int)'?')\n#define\tBADCH\t\t(int)'?'\n#define FLAG_LONGONLY\t0x04\t/* operate as getopt_long_only */\n#define FLAG_ALLARGS\t0x02\t/* treat non-options as args to option \"-1\" */\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n#define PRINT_ERROR\t((opterr) && (*options != ':'))\n#define warnx\t\tlogit\n\nstatic int\ngetopt_internal(int nargc, char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int flags)\n{\n\tchar *oli;\t\t\t\t/* option letter list index */\n\tint optchar, short_too;\n\tstatic int posixly_correct = -1;\n\n\tif (options == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * XXX Some GNU programs (like cvs) set optind to 0 instead of\n\t * XXX using optreset.  Work around this braindamage.\n\t */\n\tif (optind == 0)\n\t\toptind = optreset = 1;\n\n\t/*\n\t * Disable GNU extensions if POSIXLY_CORRECT is set or options\n\t * string begins with a '+'.\n\t */\n\tif (posixly_correct == -1 || optreset)\n\t\tposixly_correct = (getenv(\"POSIXLY_CORRECT\") != NULL);\n\tif (*options == '-')\n\t\tflags |= FLAG_ALLARGS;\n\telse if (posixly_correct || *options == '+')\n\t\tflags &= ~FLAG_PERMUTE;\n\tif (*options == '+' || *options == '-')\n\t\toptions++;\n\n\toptarg = NULL;\n\tif (optreset)\n\t\tnonopt_start = nonopt_end = -1;\nstart:\n\tif (optreset || !*place) {\t\t/* update scanning pointer */\n\t\toptreset = 0;\n\t\tif (optind >= nargc) {          /* end of argument vector */\n\t\t\tplace = EMSG;\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\t/* do permutation, if we have to */\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\telse if (nonopt_start != -1) {\n\t\t\t\t/*\n\t\t\t\t * If we skipped non-options, set optind\n\t\t\t\t * to the first of them.\n\t\t\t\t */\n\t\t\t\toptind = nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (*(place = nargv[optind]) != '-' ||\n\t\t    (place[1] == '\\0' && strchr(options, '-') == NULL)) {\n\t\t\tplace = EMSG;\t\t/* found non-option */\n\t\t\tif (flags & FLAG_ALLARGS) {\n\t\t\t\t/*\n\t\t\t\t * GNU extension:\n\t\t\t\t * return non-option as argument to option 1\n\t\t\t\t */\n\t\t\t\toptarg = nargv[optind++];\n\t\t\t\treturn (INORDER);\n\t\t\t}\n\t\t\tif (!(flags & FLAG_PERMUTE)) {\n\t\t\t\t/*\n\t\t\t\t * If no permutation wanted, stop parsing\n\t\t\t\t * at first non-option.\n\t\t\t\t */\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t/* do permutation */\n\t\t\tif (nonopt_start == -1)\n\t\t\t\tnonopt_start = optind;\n\t\t\telse if (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\tnonopt_start = optind -\n\t\t\t\t    (nonopt_end - nonopt_start);\n\t\t\t\tnonopt_end = -1;\n\t\t\t}\n\t\t\toptind++;\n\t\t\t/* process next argument */\n\t\t\tgoto start;\n\t\t}\n\t\tif (nonopt_start != -1 && nonopt_end == -1)\n\t\t\tnonopt_end = optind;\n\n\t\t/*\n\t\t * If we have \"-\" do nothing, if \"--\" we are done.\n\t\t */\n\t\tif (place[1] != '\\0' && *++place == '-' && place[1] == '\\0') {\n\t\t\toptind++;\n\t\t\tplace = EMSG;\n\t\t\t/*\n\t\t\t * We found an option (--), so if we skipped\n\t\t\t * non-options, we have to permute.\n\t\t\t */\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t/*\n\t * Check long options if:\n\t *  1) we were passed some\n\t *  2) the arg is not just \"-\"\n\t *  3) either the arg starts with -- we are getopt_long_only()\n\t */\n\tif (long_options != NULL && place != nargv[optind] &&\n\t    (*place == '-' || (flags & FLAG_LONGONLY))) {\n\t\tshort_too = 0;\n\t\tif (*place == '-')\n\t\t\tplace++;\t\t/* --foo long option */\n\t\telse if (*place != ':' && strchr(options, *place) != NULL)\n\t\t\tshort_too = 1;\t\t/* could be short option too */\n\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, short_too);\n\t\tif (optchar != -1) {\n\t\t\tplace = EMSG;\n\t\t\treturn (optchar);\n\t\t}\n\t}\n\n\tif ((optchar = (int)*place++) == (int)':' ||\n\t    (optchar == (int)'-' && *place != '\\0') ||\n\t    (oli = strchr(options, optchar)) == NULL) {\n\t\t/*\n\t\t * If the user specified \"-\" and  '-' isn't listed in\n\t\t * options, return -1 (non-option) as per POSIX.\n\t\t * Otherwise, it is an unknown option character (or ':').\n\t\t */\n\t\tif (optchar == (int)'-' && *place == '\\0')\n\t\t\treturn (-1);\n\t\tif (!*place)\n\t\t\t++optind;\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptchar, optchar);\n\t\toptopt = optchar;\n\t\treturn (BADCH);\n\t}\n\tif (long_options != NULL && optchar == 'W' && oli[1] == ';') {\n\t\t/* -W long-option */\n\t\tif (*place)\t\t\t/* no space */\n\t\t\t/* NOTHING */;\n\t\telse if (++optind >= nargc) {\t/* no arg */\n\t\t\tplace = EMSG;\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargchar, optchar);\n\t\t\toptopt = optchar;\n\t\t\treturn (BADARG);\n\t\t} else\t\t\t\t/* white space */\n\t\t\tplace = nargv[optind];\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, 0);\n\t\tplace = EMSG;\n\t\treturn (optchar);\n\t}\n\tif (*++oli != ':') {\t\t\t/* doesn't take argument */\n\t\tif (!*place)\n\t\t\t++optind;\n\t} else {\t\t\t\t/* takes (optional) argument */\n\t\toptarg = NULL;\n\t\tif (*place)\t\t\t/* no white space */\n\t\t\toptarg = place;\n\t\telse if (oli[1] != ':') {\t/* arg not optional */\n\t\t\tif (++optind >= nargc) {\t/* no arg */\n\t\t\t\tplace = EMSG;\n\t\t\t\tif (PRINT_ERROR)\n\t\t\t\t\twarnx(recargchar, optchar);\n\t\t\t\toptopt = optchar;\n\t\t\t\treturn (BADARG);\n\t\t\t} else\n\t\t\t\toptarg = nargv[optind];\n\t\t}\n\t\tplace = EMSG;\n\t\t++optind;\n\t}\n\t/* dump back option letter */\n\treturn (optchar);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
  },
  {
    "function_name": "getopt_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
    "lines": "293-481",
    "snippet": "static int\ngetopt_internal(int nargc, char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int flags)\n{\n\tchar *oli;\t\t\t\t/* option letter list index */\n\tint optchar, short_too;\n\tstatic int posixly_correct = -1;\n\n\tif (options == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * XXX Some GNU programs (like cvs) set optind to 0 instead of\n\t * XXX using optreset.  Work around this braindamage.\n\t */\n\tif (optind == 0)\n\t\toptind = optreset = 1;\n\n\t/*\n\t * Disable GNU extensions if POSIXLY_CORRECT is set or options\n\t * string begins with a '+'.\n\t */\n\tif (posixly_correct == -1 || optreset)\n\t\tposixly_correct = (getenv(\"POSIXLY_CORRECT\") != NULL);\n\tif (*options == '-')\n\t\tflags |= FLAG_ALLARGS;\n\telse if (posixly_correct || *options == '+')\n\t\tflags &= ~FLAG_PERMUTE;\n\tif (*options == '+' || *options == '-')\n\t\toptions++;\n\n\toptarg = NULL;\n\tif (optreset)\n\t\tnonopt_start = nonopt_end = -1;\nstart:\n\tif (optreset || !*place) {\t\t/* update scanning pointer */\n\t\toptreset = 0;\n\t\tif (optind >= nargc) {          /* end of argument vector */\n\t\t\tplace = EMSG;\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\t/* do permutation, if we have to */\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\telse if (nonopt_start != -1) {\n\t\t\t\t/*\n\t\t\t\t * If we skipped non-options, set optind\n\t\t\t\t * to the first of them.\n\t\t\t\t */\n\t\t\t\toptind = nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (*(place = nargv[optind]) != '-' ||\n\t\t    (place[1] == '\\0' && strchr(options, '-') == NULL)) {\n\t\t\tplace = EMSG;\t\t/* found non-option */\n\t\t\tif (flags & FLAG_ALLARGS) {\n\t\t\t\t/*\n\t\t\t\t * GNU extension:\n\t\t\t\t * return non-option as argument to option 1\n\t\t\t\t */\n\t\t\t\toptarg = nargv[optind++];\n\t\t\t\treturn (INORDER);\n\t\t\t}\n\t\t\tif (!(flags & FLAG_PERMUTE)) {\n\t\t\t\t/*\n\t\t\t\t * If no permutation wanted, stop parsing\n\t\t\t\t * at first non-option.\n\t\t\t\t */\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t/* do permutation */\n\t\t\tif (nonopt_start == -1)\n\t\t\t\tnonopt_start = optind;\n\t\t\telse if (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\tnonopt_start = optind -\n\t\t\t\t    (nonopt_end - nonopt_start);\n\t\t\t\tnonopt_end = -1;\n\t\t\t}\n\t\t\toptind++;\n\t\t\t/* process next argument */\n\t\t\tgoto start;\n\t\t}\n\t\tif (nonopt_start != -1 && nonopt_end == -1)\n\t\t\tnonopt_end = optind;\n\n\t\t/*\n\t\t * If we have \"-\" do nothing, if \"--\" we are done.\n\t\t */\n\t\tif (place[1] != '\\0' && *++place == '-' && place[1] == '\\0') {\n\t\t\toptind++;\n\t\t\tplace = EMSG;\n\t\t\t/*\n\t\t\t * We found an option (--), so if we skipped\n\t\t\t * non-options, we have to permute.\n\t\t\t */\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t/*\n\t * Check long options if:\n\t *  1) we were passed some\n\t *  2) the arg is not just \"-\"\n\t *  3) either the arg starts with -- we are getopt_long_only()\n\t */\n\tif (long_options != NULL && place != nargv[optind] &&\n\t    (*place == '-' || (flags & FLAG_LONGONLY))) {\n\t\tshort_too = 0;\n\t\tif (*place == '-')\n\t\t\tplace++;\t\t/* --foo long option */\n\t\telse if (*place != ':' && strchr(options, *place) != NULL)\n\t\t\tshort_too = 1;\t\t/* could be short option too */\n\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, short_too);\n\t\tif (optchar != -1) {\n\t\t\tplace = EMSG;\n\t\t\treturn (optchar);\n\t\t}\n\t}\n\n\tif ((optchar = (int)*place++) == (int)':' ||\n\t    (optchar == (int)'-' && *place != '\\0') ||\n\t    (oli = strchr(options, optchar)) == NULL) {\n\t\t/*\n\t\t * If the user specified \"-\" and  '-' isn't listed in\n\t\t * options, return -1 (non-option) as per POSIX.\n\t\t * Otherwise, it is an unknown option character (or ':').\n\t\t */\n\t\tif (optchar == (int)'-' && *place == '\\0')\n\t\t\treturn (-1);\n\t\tif (!*place)\n\t\t\t++optind;\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptchar, optchar);\n\t\toptopt = optchar;\n\t\treturn (BADCH);\n\t}\n\tif (long_options != NULL && optchar == 'W' && oli[1] == ';') {\n\t\t/* -W long-option */\n\t\tif (*place)\t\t\t/* no space */\n\t\t\t/* NOTHING */;\n\t\telse if (++optind >= nargc) {\t/* no arg */\n\t\t\tplace = EMSG;\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargchar, optchar);\n\t\t\toptopt = optchar;\n\t\t\treturn (BADARG);\n\t\t} else\t\t\t\t/* white space */\n\t\t\tplace = nargv[optind];\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, 0);\n\t\tplace = EMSG;\n\t\treturn (optchar);\n\t}\n\tif (*++oli != ':') {\t\t\t/* doesn't take argument */\n\t\tif (!*place)\n\t\t\t++optind;\n\t} else {\t\t\t\t/* takes (optional) argument */\n\t\toptarg = NULL;\n\t\tif (*place)\t\t\t/* no white space */\n\t\t\toptarg = place;\n\t\telse if (oli[1] != ':') {\t/* arg not optional */\n\t\t\tif (++optind >= nargc) {\t/* no arg */\n\t\t\t\tplace = EMSG;\n\t\t\t\tif (PRINT_ERROR)\n\t\t\t\t\twarnx(recargchar, optchar);\n\t\t\t\toptopt = optchar;\n\t\t\t\treturn (BADARG);\n\t\t\t} else\n\t\t\t\toptarg = nargv[optind];\n\t\t}\n\t\tplace = EMSG;\n\t\t++optind;\n\t}\n\t/* dump back option letter */\n\treturn (optchar);\n}",
    "includes": [
      "#include \"log.h\"",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <getopt.h>",
      "#include <err.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tEMSG\t\t\"\"",
      "#define\tINORDER \t(int)1",
      "#define\tBADARG\t\t((*options == ':') ? (int)':' : (int)'?')",
      "#define\tBADCH\t\t(int)'?'",
      "#define FLAG_LONGONLY\t0x04\t/* operate as getopt_long_only */",
      "#define FLAG_ALLARGS\t0x02\t/* treat non-options as args to option \"-1\" */",
      "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */",
      "#define PRINT_ERROR\t((opterr) && (*options != ':'))",
      "#define warnx\t\tlogit"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "warnx",
          "args": [
            "recargchar",
            "optchar"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_long_options",
          "args": [
            "nargv",
            "options",
            "long_options",
            "idx",
            "0"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "parse_long_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "175-287",
          "snippet": "static int\nparse_long_options(char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int short_too)\n{\n\tchar *current_argv, *has_equal;\n\tsize_t current_argv_len;\n\tint i, match;\n\n\tcurrent_argv = place;\n\tmatch = -1;\n\n\toptind++;\n\n\tif ((has_equal = strchr(current_argv, '=')) != NULL) {\n\t\t/* argument found (--option=arg) */\n\t\tcurrent_argv_len = has_equal - current_argv;\n\t\thas_equal++;\n\t} else\n\t\tcurrent_argv_len = strlen(current_argv);\n\n\tfor (i = 0; long_options[i].name; i++) {\n\t\t/* find matching long option */\n\t\tif (strncmp(current_argv, long_options[i].name,\n\t\t    current_argv_len))\n\t\t\tcontinue;\n\n\t\tif (strlen(long_options[i].name) == current_argv_len) {\n\t\t\t/* exact match */\n\t\t\tmatch = i;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If this is a known short option, don't allow\n\t\t * a partial match of a single character.\n\t\t */\n\t\tif (short_too && current_argv_len == 1)\n\t\t\tcontinue;\n\n\t\tif (match == -1)\t/* partial match */\n\t\t\tmatch = i;\n\t\telse {\n\t\t\t/* ambiguous abbreviation */\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(ambig, (int)current_argv_len,\n\t\t\t\t     current_argv);\n\t\t\toptopt = 0;\n\t\t\treturn (BADCH);\n\t\t}\n\t}\n\tif (match != -1) {\t\t/* option found */\n\t\tif (long_options[match].has_arg == no_argument\n\t\t    && has_equal) {\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(noarg, (int)current_argv_len,\n\t\t\t\t     current_argv);\n\t\t\t/*\n\t\t\t * XXX: GNU sets optopt to val regardless of flag\n\t\t\t */\n\t\t\tif (long_options[match].flag == NULL)\n\t\t\t\toptopt = long_options[match].val;\n\t\t\telse\n\t\t\t\toptopt = 0;\n\t\t\treturn (BADARG);\n\t\t}\n\t\tif (long_options[match].has_arg == required_argument ||\n\t\t    long_options[match].has_arg == optional_argument) {\n\t\t\tif (has_equal)\n\t\t\t\toptarg = has_equal;\n\t\t\telse if (long_options[match].has_arg ==\n\t\t\t    required_argument) {\n\t\t\t\t/*\n\t\t\t\t * optional argument doesn't use next nargv\n\t\t\t\t */\n\t\t\t\toptarg = nargv[optind++];\n\t\t\t}\n\t\t}\n\t\tif ((long_options[match].has_arg == required_argument)\n\t\t    && (optarg == NULL)) {\n\t\t\t/*\n\t\t\t * Missing argument; leading ':' indicates no error\n\t\t\t * should be generated.\n\t\t\t */\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargstring,\n\t\t\t\t    current_argv);\n\t\t\t/*\n\t\t\t * XXX: GNU sets optopt to val regardless of flag\n\t\t\t */\n\t\t\tif (long_options[match].flag == NULL)\n\t\t\t\toptopt = long_options[match].val;\n\t\t\telse\n\t\t\t\toptopt = 0;\n\t\t\t--optind;\n\t\t\treturn (BADARG);\n\t\t}\n\t} else {\t\t\t/* unknown option */\n\t\tif (short_too) {\n\t\t\t--optind;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptstring, current_argv);\n\t\toptopt = 0;\n\t\treturn (BADCH);\n\t}\n\tif (idx)\n\t\t*idx = match;\n\tif (long_options[match].flag) {\n\t\t*long_options[match].flag = long_options[match].val;\n\t\treturn (0);\n\t} else\n\t\treturn (long_options[match].val);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tBADARG\t\t((*options == ':') ? (int)':' : (int)'?')",
            "#define\tBADCH\t\t(int)'?'",
            "#define PRINT_ERROR\t((opterr) && (*options != ':'))",
            "#define warnx\t\tlogit"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define\tBADARG\t\t((*options == ':') ? (int)':' : (int)'?')\n#define\tBADCH\t\t(int)'?'\n#define PRINT_ERROR\t((opterr) && (*options != ':'))\n#define warnx\t\tlogit\n\nstatic int\nparse_long_options(char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int short_too)\n{\n\tchar *current_argv, *has_equal;\n\tsize_t current_argv_len;\n\tint i, match;\n\n\tcurrent_argv = place;\n\tmatch = -1;\n\n\toptind++;\n\n\tif ((has_equal = strchr(current_argv, '=')) != NULL) {\n\t\t/* argument found (--option=arg) */\n\t\tcurrent_argv_len = has_equal - current_argv;\n\t\thas_equal++;\n\t} else\n\t\tcurrent_argv_len = strlen(current_argv);\n\n\tfor (i = 0; long_options[i].name; i++) {\n\t\t/* find matching long option */\n\t\tif (strncmp(current_argv, long_options[i].name,\n\t\t    current_argv_len))\n\t\t\tcontinue;\n\n\t\tif (strlen(long_options[i].name) == current_argv_len) {\n\t\t\t/* exact match */\n\t\t\tmatch = i;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If this is a known short option, don't allow\n\t\t * a partial match of a single character.\n\t\t */\n\t\tif (short_too && current_argv_len == 1)\n\t\t\tcontinue;\n\n\t\tif (match == -1)\t/* partial match */\n\t\t\tmatch = i;\n\t\telse {\n\t\t\t/* ambiguous abbreviation */\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(ambig, (int)current_argv_len,\n\t\t\t\t     current_argv);\n\t\t\toptopt = 0;\n\t\t\treturn (BADCH);\n\t\t}\n\t}\n\tif (match != -1) {\t\t/* option found */\n\t\tif (long_options[match].has_arg == no_argument\n\t\t    && has_equal) {\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(noarg, (int)current_argv_len,\n\t\t\t\t     current_argv);\n\t\t\t/*\n\t\t\t * XXX: GNU sets optopt to val regardless of flag\n\t\t\t */\n\t\t\tif (long_options[match].flag == NULL)\n\t\t\t\toptopt = long_options[match].val;\n\t\t\telse\n\t\t\t\toptopt = 0;\n\t\t\treturn (BADARG);\n\t\t}\n\t\tif (long_options[match].has_arg == required_argument ||\n\t\t    long_options[match].has_arg == optional_argument) {\n\t\t\tif (has_equal)\n\t\t\t\toptarg = has_equal;\n\t\t\telse if (long_options[match].has_arg ==\n\t\t\t    required_argument) {\n\t\t\t\t/*\n\t\t\t\t * optional argument doesn't use next nargv\n\t\t\t\t */\n\t\t\t\toptarg = nargv[optind++];\n\t\t\t}\n\t\t}\n\t\tif ((long_options[match].has_arg == required_argument)\n\t\t    && (optarg == NULL)) {\n\t\t\t/*\n\t\t\t * Missing argument; leading ':' indicates no error\n\t\t\t * should be generated.\n\t\t\t */\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargstring,\n\t\t\t\t    current_argv);\n\t\t\t/*\n\t\t\t * XXX: GNU sets optopt to val regardless of flag\n\t\t\t */\n\t\t\tif (long_options[match].flag == NULL)\n\t\t\t\toptopt = long_options[match].val;\n\t\t\telse\n\t\t\t\toptopt = 0;\n\t\t\t--optind;\n\t\t\treturn (BADARG);\n\t\t}\n\t} else {\t\t\t/* unknown option */\n\t\tif (short_too) {\n\t\t\t--optind;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptstring, current_argv);\n\t\toptopt = 0;\n\t\treturn (BADCH);\n\t}\n\tif (idx)\n\t\t*idx = match;\n\tif (long_options[match].flag) {\n\t\t*long_options[match].flag = long_options[match].val;\n\t\treturn (0);\n\t} else\n\t\treturn (long_options[match].val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warnx",
          "args": [
            "recargchar",
            "optchar"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warnx",
          "args": [
            "illoptchar",
            "optchar"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "options",
            "optchar"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "permute_args",
          "args": [
            "nonopt_start",
            "nonopt_end",
            "optind",
            "nargv"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "permute_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "138-168",
          "snippet": "static void\npermute_args(int panonopt_start, int panonopt_end, int opt_end,\n\tchar * const *nargv)\n{\n\tint cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;\n\tchar *swap;\n\n\t/*\n\t * compute lengths of blocks and number and size of cycles\n\t */\n\tnnonopts = panonopt_end - panonopt_start;\n\tnopts = opt_end - panonopt_end;\n\tncycle = gcd(nnonopts, nopts);\n\tcyclelen = (opt_end - panonopt_start) / ncycle;\n\n\tfor (i = 0; i < ncycle; i++) {\n\t\tcstart = panonopt_end+i;\n\t\tpos = cstart;\n\t\tfor (j = 0; j < cyclelen; j++) {\n\t\t\tif (pos >= panonopt_end)\n\t\t\t\tpos -= nnonopts;\n\t\t\telse\n\t\t\t\tpos += nopts;\n\t\t\tswap = nargv[pos];\n\t\t\t/* LINTED const cast */\n\t\t\t((char **) nargv)[pos] = nargv[cstart];\n\t\t\t/* LINTED const cast */\n\t\t\t((char **)nargv)[cstart] = swap;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\nstatic void\npermute_args(int panonopt_start, int panonopt_end, int opt_end,\n\tchar * const *nargv)\n{\n\tint cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;\n\tchar *swap;\n\n\t/*\n\t * compute lengths of blocks and number and size of cycles\n\t */\n\tnnonopts = panonopt_end - panonopt_start;\n\tnopts = opt_end - panonopt_end;\n\tncycle = gcd(nnonopts, nopts);\n\tcyclelen = (opt_end - panonopt_start) / ncycle;\n\n\tfor (i = 0; i < ncycle; i++) {\n\t\tcstart = panonopt_end+i;\n\t\tpos = cstart;\n\t\tfor (j = 0; j < cyclelen; j++) {\n\t\t\tif (pos >= panonopt_end)\n\t\t\t\tpos -= nnonopts;\n\t\t\telse\n\t\t\t\tpos += nopts;\n\t\t\tswap = nargv[pos];\n\t\t\t/* LINTED const cast */\n\t\t\t((char **) nargv)[pos] = nargv[cstart];\n\t\t\t/* LINTED const cast */\n\t\t\t((char **)nargv)[cstart] = swap;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"POSIXLY_CORRECT\""
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define\tEMSG\t\t\"\"\n#define\tINORDER \t(int)1\n#define\tBADARG\t\t((*options == ':') ? (int)':' : (int)'?')\n#define\tBADCH\t\t(int)'?'\n#define FLAG_LONGONLY\t0x04\t/* operate as getopt_long_only */\n#define FLAG_ALLARGS\t0x02\t/* treat non-options as args to option \"-1\" */\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n#define PRINT_ERROR\t((opterr) && (*options != ':'))\n#define warnx\t\tlogit\n\nstatic int\ngetopt_internal(int nargc, char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int flags)\n{\n\tchar *oli;\t\t\t\t/* option letter list index */\n\tint optchar, short_too;\n\tstatic int posixly_correct = -1;\n\n\tif (options == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * XXX Some GNU programs (like cvs) set optind to 0 instead of\n\t * XXX using optreset.  Work around this braindamage.\n\t */\n\tif (optind == 0)\n\t\toptind = optreset = 1;\n\n\t/*\n\t * Disable GNU extensions if POSIXLY_CORRECT is set or options\n\t * string begins with a '+'.\n\t */\n\tif (posixly_correct == -1 || optreset)\n\t\tposixly_correct = (getenv(\"POSIXLY_CORRECT\") != NULL);\n\tif (*options == '-')\n\t\tflags |= FLAG_ALLARGS;\n\telse if (posixly_correct || *options == '+')\n\t\tflags &= ~FLAG_PERMUTE;\n\tif (*options == '+' || *options == '-')\n\t\toptions++;\n\n\toptarg = NULL;\n\tif (optreset)\n\t\tnonopt_start = nonopt_end = -1;\nstart:\n\tif (optreset || !*place) {\t\t/* update scanning pointer */\n\t\toptreset = 0;\n\t\tif (optind >= nargc) {          /* end of argument vector */\n\t\t\tplace = EMSG;\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\t/* do permutation, if we have to */\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\telse if (nonopt_start != -1) {\n\t\t\t\t/*\n\t\t\t\t * If we skipped non-options, set optind\n\t\t\t\t * to the first of them.\n\t\t\t\t */\n\t\t\t\toptind = nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (*(place = nargv[optind]) != '-' ||\n\t\t    (place[1] == '\\0' && strchr(options, '-') == NULL)) {\n\t\t\tplace = EMSG;\t\t/* found non-option */\n\t\t\tif (flags & FLAG_ALLARGS) {\n\t\t\t\t/*\n\t\t\t\t * GNU extension:\n\t\t\t\t * return non-option as argument to option 1\n\t\t\t\t */\n\t\t\t\toptarg = nargv[optind++];\n\t\t\t\treturn (INORDER);\n\t\t\t}\n\t\t\tif (!(flags & FLAG_PERMUTE)) {\n\t\t\t\t/*\n\t\t\t\t * If no permutation wanted, stop parsing\n\t\t\t\t * at first non-option.\n\t\t\t\t */\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t/* do permutation */\n\t\t\tif (nonopt_start == -1)\n\t\t\t\tnonopt_start = optind;\n\t\t\telse if (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\tnonopt_start = optind -\n\t\t\t\t    (nonopt_end - nonopt_start);\n\t\t\t\tnonopt_end = -1;\n\t\t\t}\n\t\t\toptind++;\n\t\t\t/* process next argument */\n\t\t\tgoto start;\n\t\t}\n\t\tif (nonopt_start != -1 && nonopt_end == -1)\n\t\t\tnonopt_end = optind;\n\n\t\t/*\n\t\t * If we have \"-\" do nothing, if \"--\" we are done.\n\t\t */\n\t\tif (place[1] != '\\0' && *++place == '-' && place[1] == '\\0') {\n\t\t\toptind++;\n\t\t\tplace = EMSG;\n\t\t\t/*\n\t\t\t * We found an option (--), so if we skipped\n\t\t\t * non-options, we have to permute.\n\t\t\t */\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t/*\n\t * Check long options if:\n\t *  1) we were passed some\n\t *  2) the arg is not just \"-\"\n\t *  3) either the arg starts with -- we are getopt_long_only()\n\t */\n\tif (long_options != NULL && place != nargv[optind] &&\n\t    (*place == '-' || (flags & FLAG_LONGONLY))) {\n\t\tshort_too = 0;\n\t\tif (*place == '-')\n\t\t\tplace++;\t\t/* --foo long option */\n\t\telse if (*place != ':' && strchr(options, *place) != NULL)\n\t\t\tshort_too = 1;\t\t/* could be short option too */\n\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, short_too);\n\t\tif (optchar != -1) {\n\t\t\tplace = EMSG;\n\t\t\treturn (optchar);\n\t\t}\n\t}\n\n\tif ((optchar = (int)*place++) == (int)':' ||\n\t    (optchar == (int)'-' && *place != '\\0') ||\n\t    (oli = strchr(options, optchar)) == NULL) {\n\t\t/*\n\t\t * If the user specified \"-\" and  '-' isn't listed in\n\t\t * options, return -1 (non-option) as per POSIX.\n\t\t * Otherwise, it is an unknown option character (or ':').\n\t\t */\n\t\tif (optchar == (int)'-' && *place == '\\0')\n\t\t\treturn (-1);\n\t\tif (!*place)\n\t\t\t++optind;\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptchar, optchar);\n\t\toptopt = optchar;\n\t\treturn (BADCH);\n\t}\n\tif (long_options != NULL && optchar == 'W' && oli[1] == ';') {\n\t\t/* -W long-option */\n\t\tif (*place)\t\t\t/* no space */\n\t\t\t/* NOTHING */;\n\t\telse if (++optind >= nargc) {\t/* no arg */\n\t\t\tplace = EMSG;\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargchar, optchar);\n\t\t\toptopt = optchar;\n\t\t\treturn (BADARG);\n\t\t} else\t\t\t\t/* white space */\n\t\t\tplace = nargv[optind];\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, 0);\n\t\tplace = EMSG;\n\t\treturn (optchar);\n\t}\n\tif (*++oli != ':') {\t\t\t/* doesn't take argument */\n\t\tif (!*place)\n\t\t\t++optind;\n\t} else {\t\t\t\t/* takes (optional) argument */\n\t\toptarg = NULL;\n\t\tif (*place)\t\t\t/* no white space */\n\t\t\toptarg = place;\n\t\telse if (oli[1] != ':') {\t/* arg not optional */\n\t\t\tif (++optind >= nargc) {\t/* no arg */\n\t\t\t\tplace = EMSG;\n\t\t\t\tif (PRINT_ERROR)\n\t\t\t\t\twarnx(recargchar, optchar);\n\t\t\t\toptopt = optchar;\n\t\t\t\treturn (BADARG);\n\t\t\t} else\n\t\t\t\toptarg = nargv[optind];\n\t\t}\n\t\tplace = EMSG;\n\t\t++optind;\n\t}\n\t/* dump back option letter */\n\treturn (optchar);\n}"
  },
  {
    "function_name": "parse_long_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
    "lines": "175-287",
    "snippet": "static int\nparse_long_options(char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int short_too)\n{\n\tchar *current_argv, *has_equal;\n\tsize_t current_argv_len;\n\tint i, match;\n\n\tcurrent_argv = place;\n\tmatch = -1;\n\n\toptind++;\n\n\tif ((has_equal = strchr(current_argv, '=')) != NULL) {\n\t\t/* argument found (--option=arg) */\n\t\tcurrent_argv_len = has_equal - current_argv;\n\t\thas_equal++;\n\t} else\n\t\tcurrent_argv_len = strlen(current_argv);\n\n\tfor (i = 0; long_options[i].name; i++) {\n\t\t/* find matching long option */\n\t\tif (strncmp(current_argv, long_options[i].name,\n\t\t    current_argv_len))\n\t\t\tcontinue;\n\n\t\tif (strlen(long_options[i].name) == current_argv_len) {\n\t\t\t/* exact match */\n\t\t\tmatch = i;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If this is a known short option, don't allow\n\t\t * a partial match of a single character.\n\t\t */\n\t\tif (short_too && current_argv_len == 1)\n\t\t\tcontinue;\n\n\t\tif (match == -1)\t/* partial match */\n\t\t\tmatch = i;\n\t\telse {\n\t\t\t/* ambiguous abbreviation */\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(ambig, (int)current_argv_len,\n\t\t\t\t     current_argv);\n\t\t\toptopt = 0;\n\t\t\treturn (BADCH);\n\t\t}\n\t}\n\tif (match != -1) {\t\t/* option found */\n\t\tif (long_options[match].has_arg == no_argument\n\t\t    && has_equal) {\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(noarg, (int)current_argv_len,\n\t\t\t\t     current_argv);\n\t\t\t/*\n\t\t\t * XXX: GNU sets optopt to val regardless of flag\n\t\t\t */\n\t\t\tif (long_options[match].flag == NULL)\n\t\t\t\toptopt = long_options[match].val;\n\t\t\telse\n\t\t\t\toptopt = 0;\n\t\t\treturn (BADARG);\n\t\t}\n\t\tif (long_options[match].has_arg == required_argument ||\n\t\t    long_options[match].has_arg == optional_argument) {\n\t\t\tif (has_equal)\n\t\t\t\toptarg = has_equal;\n\t\t\telse if (long_options[match].has_arg ==\n\t\t\t    required_argument) {\n\t\t\t\t/*\n\t\t\t\t * optional argument doesn't use next nargv\n\t\t\t\t */\n\t\t\t\toptarg = nargv[optind++];\n\t\t\t}\n\t\t}\n\t\tif ((long_options[match].has_arg == required_argument)\n\t\t    && (optarg == NULL)) {\n\t\t\t/*\n\t\t\t * Missing argument; leading ':' indicates no error\n\t\t\t * should be generated.\n\t\t\t */\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargstring,\n\t\t\t\t    current_argv);\n\t\t\t/*\n\t\t\t * XXX: GNU sets optopt to val regardless of flag\n\t\t\t */\n\t\t\tif (long_options[match].flag == NULL)\n\t\t\t\toptopt = long_options[match].val;\n\t\t\telse\n\t\t\t\toptopt = 0;\n\t\t\t--optind;\n\t\t\treturn (BADARG);\n\t\t}\n\t} else {\t\t\t/* unknown option */\n\t\tif (short_too) {\n\t\t\t--optind;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptstring, current_argv);\n\t\toptopt = 0;\n\t\treturn (BADCH);\n\t}\n\tif (idx)\n\t\t*idx = match;\n\tif (long_options[match].flag) {\n\t\t*long_options[match].flag = long_options[match].val;\n\t\treturn (0);\n\t} else\n\t\treturn (long_options[match].val);\n}",
    "includes": [
      "#include \"log.h\"",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <getopt.h>",
      "#include <err.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tBADARG\t\t((*options == ':') ? (int)':' : (int)'?')",
      "#define\tBADCH\t\t(int)'?'",
      "#define PRINT_ERROR\t((opterr) && (*options != ':'))",
      "#define warnx\t\tlogit"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "warnx",
          "args": [
            "illoptstring",
            "current_argv"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warnx",
          "args": [
            "recargstring",
            "current_argv"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warnx",
          "args": [
            "noarg",
            "(int)current_argv_len",
            "current_argv"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warnx",
          "args": [
            "ambig",
            "(int)current_argv_len",
            "current_argv"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "long_options[i].name"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "current_argv",
            "long_options[i].name",
            "current_argv_len"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "current_argv"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "current_argv",
            "'='"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define\tBADARG\t\t((*options == ':') ? (int)':' : (int)'?')\n#define\tBADCH\t\t(int)'?'\n#define PRINT_ERROR\t((opterr) && (*options != ':'))\n#define warnx\t\tlogit\n\nstatic int\nparse_long_options(char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int short_too)\n{\n\tchar *current_argv, *has_equal;\n\tsize_t current_argv_len;\n\tint i, match;\n\n\tcurrent_argv = place;\n\tmatch = -1;\n\n\toptind++;\n\n\tif ((has_equal = strchr(current_argv, '=')) != NULL) {\n\t\t/* argument found (--option=arg) */\n\t\tcurrent_argv_len = has_equal - current_argv;\n\t\thas_equal++;\n\t} else\n\t\tcurrent_argv_len = strlen(current_argv);\n\n\tfor (i = 0; long_options[i].name; i++) {\n\t\t/* find matching long option */\n\t\tif (strncmp(current_argv, long_options[i].name,\n\t\t    current_argv_len))\n\t\t\tcontinue;\n\n\t\tif (strlen(long_options[i].name) == current_argv_len) {\n\t\t\t/* exact match */\n\t\t\tmatch = i;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If this is a known short option, don't allow\n\t\t * a partial match of a single character.\n\t\t */\n\t\tif (short_too && current_argv_len == 1)\n\t\t\tcontinue;\n\n\t\tif (match == -1)\t/* partial match */\n\t\t\tmatch = i;\n\t\telse {\n\t\t\t/* ambiguous abbreviation */\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(ambig, (int)current_argv_len,\n\t\t\t\t     current_argv);\n\t\t\toptopt = 0;\n\t\t\treturn (BADCH);\n\t\t}\n\t}\n\tif (match != -1) {\t\t/* option found */\n\t\tif (long_options[match].has_arg == no_argument\n\t\t    && has_equal) {\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(noarg, (int)current_argv_len,\n\t\t\t\t     current_argv);\n\t\t\t/*\n\t\t\t * XXX: GNU sets optopt to val regardless of flag\n\t\t\t */\n\t\t\tif (long_options[match].flag == NULL)\n\t\t\t\toptopt = long_options[match].val;\n\t\t\telse\n\t\t\t\toptopt = 0;\n\t\t\treturn (BADARG);\n\t\t}\n\t\tif (long_options[match].has_arg == required_argument ||\n\t\t    long_options[match].has_arg == optional_argument) {\n\t\t\tif (has_equal)\n\t\t\t\toptarg = has_equal;\n\t\t\telse if (long_options[match].has_arg ==\n\t\t\t    required_argument) {\n\t\t\t\t/*\n\t\t\t\t * optional argument doesn't use next nargv\n\t\t\t\t */\n\t\t\t\toptarg = nargv[optind++];\n\t\t\t}\n\t\t}\n\t\tif ((long_options[match].has_arg == required_argument)\n\t\t    && (optarg == NULL)) {\n\t\t\t/*\n\t\t\t * Missing argument; leading ':' indicates no error\n\t\t\t * should be generated.\n\t\t\t */\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargstring,\n\t\t\t\t    current_argv);\n\t\t\t/*\n\t\t\t * XXX: GNU sets optopt to val regardless of flag\n\t\t\t */\n\t\t\tif (long_options[match].flag == NULL)\n\t\t\t\toptopt = long_options[match].val;\n\t\t\telse\n\t\t\t\toptopt = 0;\n\t\t\t--optind;\n\t\t\treturn (BADARG);\n\t\t}\n\t} else {\t\t\t/* unknown option */\n\t\tif (short_too) {\n\t\t\t--optind;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptstring, current_argv);\n\t\toptopt = 0;\n\t\treturn (BADCH);\n\t}\n\tif (idx)\n\t\t*idx = match;\n\tif (long_options[match].flag) {\n\t\t*long_options[match].flag = long_options[match].val;\n\t\treturn (0);\n\t} else\n\t\treturn (long_options[match].val);\n}"
  },
  {
    "function_name": "permute_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
    "lines": "138-168",
    "snippet": "static void\npermute_args(int panonopt_start, int panonopt_end, int opt_end,\n\tchar * const *nargv)\n{\n\tint cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;\n\tchar *swap;\n\n\t/*\n\t * compute lengths of blocks and number and size of cycles\n\t */\n\tnnonopts = panonopt_end - panonopt_start;\n\tnopts = opt_end - panonopt_end;\n\tncycle = gcd(nnonopts, nopts);\n\tcyclelen = (opt_end - panonopt_start) / ncycle;\n\n\tfor (i = 0; i < ncycle; i++) {\n\t\tcstart = panonopt_end+i;\n\t\tpos = cstart;\n\t\tfor (j = 0; j < cyclelen; j++) {\n\t\t\tif (pos >= panonopt_end)\n\t\t\t\tpos -= nnonopts;\n\t\t\telse\n\t\t\t\tpos += nopts;\n\t\t\tswap = nargv[pos];\n\t\t\t/* LINTED const cast */\n\t\t\t((char **) nargv)[pos] = nargv[cstart];\n\t\t\t/* LINTED const cast */\n\t\t\t((char **)nargv)[cstart] = swap;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"log.h\"",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <getopt.h>",
      "#include <err.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcd",
          "args": [
            "nnonopts",
            "nopts"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "118-131",
          "snippet": "static int\ngcd(int a, int b)\n{\n\tint c;\n\n\tc = a % b;\n\twhile (c != 0) {\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\n\treturn (b);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\nstatic int\ngcd(int a, int b)\n{\n\tint c;\n\n\tc = a % b;\n\twhile (c != 0) {\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\n\treturn (b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\nstatic void\npermute_args(int panonopt_start, int panonopt_end, int opt_end,\n\tchar * const *nargv)\n{\n\tint cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;\n\tchar *swap;\n\n\t/*\n\t * compute lengths of blocks and number and size of cycles\n\t */\n\tnnonopts = panonopt_end - panonopt_start;\n\tnopts = opt_end - panonopt_end;\n\tncycle = gcd(nnonopts, nopts);\n\tcyclelen = (opt_end - panonopt_start) / ncycle;\n\n\tfor (i = 0; i < ncycle; i++) {\n\t\tcstart = panonopt_end+i;\n\t\tpos = cstart;\n\t\tfor (j = 0; j < cyclelen; j++) {\n\t\t\tif (pos >= panonopt_end)\n\t\t\t\tpos -= nnonopts;\n\t\t\telse\n\t\t\t\tpos += nopts;\n\t\t\tswap = nargv[pos];\n\t\t\t/* LINTED const cast */\n\t\t\t((char **) nargv)[pos] = nargv[cstart];\n\t\t\t/* LINTED const cast */\n\t\t\t((char **)nargv)[cstart] = swap;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "gcd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
    "lines": "118-131",
    "snippet": "static int\ngcd(int a, int b)\n{\n\tint c;\n\n\tc = a % b;\n\twhile (c != 0) {\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\n\treturn (b);\n}",
    "includes": [
      "#include \"log.h\"",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <getopt.h>",
      "#include <err.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\nstatic int\ngcd(int a, int b)\n{\n\tint c;\n\n\tc = a % b;\n\twhile (c != 0) {\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\n\treturn (b);\n}"
  }
]