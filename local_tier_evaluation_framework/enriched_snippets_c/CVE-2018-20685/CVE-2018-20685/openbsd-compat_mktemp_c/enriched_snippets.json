[
  {
    "function_name": "mkdtemp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
    "lines": "132-139",
    "snippet": "char *\nmkdtemp(char *path)\n{\n\tint error;\n\n\terror = mktemp_internal(path, 0, MKTEMP_DIR);\n\treturn(error ? NULL : path);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MKTEMP_DIR\t2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mktemp_internal",
          "args": [
            "path",
            "0",
            "MKTEMP_DIR"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "mktemp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
          "lines": "46-97",
          "snippet": "static int\nmktemp_internal(char *path, int slen, int mode)\n{\n\tchar *start, *cp, *ep;\n\tconst char *tempchars = TEMPCHARS;\n\tunsigned int r, tries;\n\tstruct stat sb;\n\tsize_t len;\n\tint fd;\n\n\tlen = strlen(path);\n\tif (len == 0 || slen < 0 || (size_t)slen >= len) {\n\t\terrno = EINVAL;\n\t\treturn(-1);\n\t}\n\tep = path + len - slen;\n\n\ttries = 1;\n\tfor (start = ep; start > path && start[-1] == 'X'; start--) {\n\t\tif (tries < INT_MAX / NUM_CHARS)\n\t\t\ttries *= NUM_CHARS;\n\t}\n\ttries *= 2;\n\n\tdo {\n\t\tfor (cp = start; cp != ep; cp++) {\n\t\t\tr = arc4random_uniform(NUM_CHARS);\n\t\t\t*cp = tempchars[r];\n\t\t}\n\n\t\tswitch (mode) {\n\t\tcase MKTEMP_NAME:\n\t\t\tif (lstat(path, &sb) != 0)\n\t\t\t\treturn(errno == ENOENT ? 0 : -1);\n\t\t\tbreak;\n\t\tcase MKTEMP_FILE:\n\t\t\tfd = open(path, O_CREAT|O_EXCL|O_RDWR, S_IRUSR|S_IWUSR);\n\t\t\tif (fd != -1 || errno != EEXIST)\n\t\t\t\treturn(fd);\n\t\t\tbreak;\n\t\tcase MKTEMP_DIR:\n\t\t\tif (mkdir(path, S_IRUSR|S_IWUSR|S_IXUSR) == 0)\n\t\t\t\treturn(0);\n\t\t\tif (errno != EEXIST)\n\t\t\t\treturn(-1);\n\t\t\tbreak;\n\t\t}\n\t} while (--tries);\n\n\terrno = EEXIST;\n\treturn(-1);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define NUM_CHARS\t(sizeof(TEMPCHARS) - 1)",
            "#define TEMPCHARS\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"",
            "#define MKTEMP_DIR\t2",
            "#define MKTEMP_FILE\t1",
            "#define MKTEMP_NAME\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define NUM_CHARS\t(sizeof(TEMPCHARS) - 1)\n#define TEMPCHARS\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n#define MKTEMP_DIR\t2\n#define MKTEMP_FILE\t1\n#define MKTEMP_NAME\t0\n\nstatic int\nmktemp_internal(char *path, int slen, int mode)\n{\n\tchar *start, *cp, *ep;\n\tconst char *tempchars = TEMPCHARS;\n\tunsigned int r, tries;\n\tstruct stat sb;\n\tsize_t len;\n\tint fd;\n\n\tlen = strlen(path);\n\tif (len == 0 || slen < 0 || (size_t)slen >= len) {\n\t\terrno = EINVAL;\n\t\treturn(-1);\n\t}\n\tep = path + len - slen;\n\n\ttries = 1;\n\tfor (start = ep; start > path && start[-1] == 'X'; start--) {\n\t\tif (tries < INT_MAX / NUM_CHARS)\n\t\t\ttries *= NUM_CHARS;\n\t}\n\ttries *= 2;\n\n\tdo {\n\t\tfor (cp = start; cp != ep; cp++) {\n\t\t\tr = arc4random_uniform(NUM_CHARS);\n\t\t\t*cp = tempchars[r];\n\t\t}\n\n\t\tswitch (mode) {\n\t\tcase MKTEMP_NAME:\n\t\t\tif (lstat(path, &sb) != 0)\n\t\t\t\treturn(errno == ENOENT ? 0 : -1);\n\t\t\tbreak;\n\t\tcase MKTEMP_FILE:\n\t\t\tfd = open(path, O_CREAT|O_EXCL|O_RDWR, S_IRUSR|S_IWUSR);\n\t\t\tif (fd != -1 || errno != EEXIST)\n\t\t\t\treturn(fd);\n\t\t\tbreak;\n\t\tcase MKTEMP_DIR:\n\t\t\tif (mkdir(path, S_IRUSR|S_IWUSR|S_IXUSR) == 0)\n\t\t\t\treturn(0);\n\t\t\tif (errno != EEXIST)\n\t\t\t\treturn(-1);\n\t\t\tbreak;\n\t\t}\n\t} while (--tries);\n\n\terrno = EEXIST;\n\treturn(-1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MKTEMP_DIR\t2\n\nchar *\nmkdtemp(char *path)\n{\n\tint error;\n\n\terror = mktemp_internal(path, 0, MKTEMP_DIR);\n\treturn(error ? NULL : path);\n}"
  },
  {
    "function_name": "mkstemps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
    "lines": "126-130",
    "snippet": "int\nmkstemps(char *path, int slen)\n{\n\treturn(mktemp_internal(path, slen, MKTEMP_FILE));\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MKTEMP_FILE\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mktemp_internal",
          "args": [
            "path",
            "slen",
            "MKTEMP_FILE"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "mktemp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
          "lines": "46-97",
          "snippet": "static int\nmktemp_internal(char *path, int slen, int mode)\n{\n\tchar *start, *cp, *ep;\n\tconst char *tempchars = TEMPCHARS;\n\tunsigned int r, tries;\n\tstruct stat sb;\n\tsize_t len;\n\tint fd;\n\n\tlen = strlen(path);\n\tif (len == 0 || slen < 0 || (size_t)slen >= len) {\n\t\terrno = EINVAL;\n\t\treturn(-1);\n\t}\n\tep = path + len - slen;\n\n\ttries = 1;\n\tfor (start = ep; start > path && start[-1] == 'X'; start--) {\n\t\tif (tries < INT_MAX / NUM_CHARS)\n\t\t\ttries *= NUM_CHARS;\n\t}\n\ttries *= 2;\n\n\tdo {\n\t\tfor (cp = start; cp != ep; cp++) {\n\t\t\tr = arc4random_uniform(NUM_CHARS);\n\t\t\t*cp = tempchars[r];\n\t\t}\n\n\t\tswitch (mode) {\n\t\tcase MKTEMP_NAME:\n\t\t\tif (lstat(path, &sb) != 0)\n\t\t\t\treturn(errno == ENOENT ? 0 : -1);\n\t\t\tbreak;\n\t\tcase MKTEMP_FILE:\n\t\t\tfd = open(path, O_CREAT|O_EXCL|O_RDWR, S_IRUSR|S_IWUSR);\n\t\t\tif (fd != -1 || errno != EEXIST)\n\t\t\t\treturn(fd);\n\t\t\tbreak;\n\t\tcase MKTEMP_DIR:\n\t\t\tif (mkdir(path, S_IRUSR|S_IWUSR|S_IXUSR) == 0)\n\t\t\t\treturn(0);\n\t\t\tif (errno != EEXIST)\n\t\t\t\treturn(-1);\n\t\t\tbreak;\n\t\t}\n\t} while (--tries);\n\n\terrno = EEXIST;\n\treturn(-1);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define NUM_CHARS\t(sizeof(TEMPCHARS) - 1)",
            "#define TEMPCHARS\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"",
            "#define MKTEMP_DIR\t2",
            "#define MKTEMP_FILE\t1",
            "#define MKTEMP_NAME\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define NUM_CHARS\t(sizeof(TEMPCHARS) - 1)\n#define TEMPCHARS\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n#define MKTEMP_DIR\t2\n#define MKTEMP_FILE\t1\n#define MKTEMP_NAME\t0\n\nstatic int\nmktemp_internal(char *path, int slen, int mode)\n{\n\tchar *start, *cp, *ep;\n\tconst char *tempchars = TEMPCHARS;\n\tunsigned int r, tries;\n\tstruct stat sb;\n\tsize_t len;\n\tint fd;\n\n\tlen = strlen(path);\n\tif (len == 0 || slen < 0 || (size_t)slen >= len) {\n\t\terrno = EINVAL;\n\t\treturn(-1);\n\t}\n\tep = path + len - slen;\n\n\ttries = 1;\n\tfor (start = ep; start > path && start[-1] == 'X'; start--) {\n\t\tif (tries < INT_MAX / NUM_CHARS)\n\t\t\ttries *= NUM_CHARS;\n\t}\n\ttries *= 2;\n\n\tdo {\n\t\tfor (cp = start; cp != ep; cp++) {\n\t\t\tr = arc4random_uniform(NUM_CHARS);\n\t\t\t*cp = tempchars[r];\n\t\t}\n\n\t\tswitch (mode) {\n\t\tcase MKTEMP_NAME:\n\t\t\tif (lstat(path, &sb) != 0)\n\t\t\t\treturn(errno == ENOENT ? 0 : -1);\n\t\t\tbreak;\n\t\tcase MKTEMP_FILE:\n\t\t\tfd = open(path, O_CREAT|O_EXCL|O_RDWR, S_IRUSR|S_IWUSR);\n\t\t\tif (fd != -1 || errno != EEXIST)\n\t\t\t\treturn(fd);\n\t\t\tbreak;\n\t\tcase MKTEMP_DIR:\n\t\t\tif (mkdir(path, S_IRUSR|S_IWUSR|S_IXUSR) == 0)\n\t\t\t\treturn(0);\n\t\t\tif (errno != EEXIST)\n\t\t\t\treturn(-1);\n\t\t\tbreak;\n\t\t}\n\t} while (--tries);\n\n\terrno = EEXIST;\n\treturn(-1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MKTEMP_FILE\t1\n\nint\nmkstemps(char *path, int slen)\n{\n\treturn(mktemp_internal(path, slen, MKTEMP_FILE));\n}"
  },
  {
    "function_name": "mkstemp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
    "lines": "120-124",
    "snippet": "int\nmkstemp(char *path)\n{\n\treturn(mktemp_internal(path, 0, MKTEMP_FILE));\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MKTEMP_FILE\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mktemp_internal",
          "args": [
            "path",
            "0",
            "MKTEMP_FILE"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "mktemp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
          "lines": "46-97",
          "snippet": "static int\nmktemp_internal(char *path, int slen, int mode)\n{\n\tchar *start, *cp, *ep;\n\tconst char *tempchars = TEMPCHARS;\n\tunsigned int r, tries;\n\tstruct stat sb;\n\tsize_t len;\n\tint fd;\n\n\tlen = strlen(path);\n\tif (len == 0 || slen < 0 || (size_t)slen >= len) {\n\t\terrno = EINVAL;\n\t\treturn(-1);\n\t}\n\tep = path + len - slen;\n\n\ttries = 1;\n\tfor (start = ep; start > path && start[-1] == 'X'; start--) {\n\t\tif (tries < INT_MAX / NUM_CHARS)\n\t\t\ttries *= NUM_CHARS;\n\t}\n\ttries *= 2;\n\n\tdo {\n\t\tfor (cp = start; cp != ep; cp++) {\n\t\t\tr = arc4random_uniform(NUM_CHARS);\n\t\t\t*cp = tempchars[r];\n\t\t}\n\n\t\tswitch (mode) {\n\t\tcase MKTEMP_NAME:\n\t\t\tif (lstat(path, &sb) != 0)\n\t\t\t\treturn(errno == ENOENT ? 0 : -1);\n\t\t\tbreak;\n\t\tcase MKTEMP_FILE:\n\t\t\tfd = open(path, O_CREAT|O_EXCL|O_RDWR, S_IRUSR|S_IWUSR);\n\t\t\tif (fd != -1 || errno != EEXIST)\n\t\t\t\treturn(fd);\n\t\t\tbreak;\n\t\tcase MKTEMP_DIR:\n\t\t\tif (mkdir(path, S_IRUSR|S_IWUSR|S_IXUSR) == 0)\n\t\t\t\treturn(0);\n\t\t\tif (errno != EEXIST)\n\t\t\t\treturn(-1);\n\t\t\tbreak;\n\t\t}\n\t} while (--tries);\n\n\terrno = EEXIST;\n\treturn(-1);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define NUM_CHARS\t(sizeof(TEMPCHARS) - 1)",
            "#define TEMPCHARS\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"",
            "#define MKTEMP_DIR\t2",
            "#define MKTEMP_FILE\t1",
            "#define MKTEMP_NAME\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define NUM_CHARS\t(sizeof(TEMPCHARS) - 1)\n#define TEMPCHARS\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n#define MKTEMP_DIR\t2\n#define MKTEMP_FILE\t1\n#define MKTEMP_NAME\t0\n\nstatic int\nmktemp_internal(char *path, int slen, int mode)\n{\n\tchar *start, *cp, *ep;\n\tconst char *tempchars = TEMPCHARS;\n\tunsigned int r, tries;\n\tstruct stat sb;\n\tsize_t len;\n\tint fd;\n\n\tlen = strlen(path);\n\tif (len == 0 || slen < 0 || (size_t)slen >= len) {\n\t\terrno = EINVAL;\n\t\treturn(-1);\n\t}\n\tep = path + len - slen;\n\n\ttries = 1;\n\tfor (start = ep; start > path && start[-1] == 'X'; start--) {\n\t\tif (tries < INT_MAX / NUM_CHARS)\n\t\t\ttries *= NUM_CHARS;\n\t}\n\ttries *= 2;\n\n\tdo {\n\t\tfor (cp = start; cp != ep; cp++) {\n\t\t\tr = arc4random_uniform(NUM_CHARS);\n\t\t\t*cp = tempchars[r];\n\t\t}\n\n\t\tswitch (mode) {\n\t\tcase MKTEMP_NAME:\n\t\t\tif (lstat(path, &sb) != 0)\n\t\t\t\treturn(errno == ENOENT ? 0 : -1);\n\t\t\tbreak;\n\t\tcase MKTEMP_FILE:\n\t\t\tfd = open(path, O_CREAT|O_EXCL|O_RDWR, S_IRUSR|S_IWUSR);\n\t\t\tif (fd != -1 || errno != EEXIST)\n\t\t\t\treturn(fd);\n\t\t\tbreak;\n\t\tcase MKTEMP_DIR:\n\t\t\tif (mkdir(path, S_IRUSR|S_IWUSR|S_IXUSR) == 0)\n\t\t\t\treturn(0);\n\t\t\tif (errno != EEXIST)\n\t\t\t\treturn(-1);\n\t\t\tbreak;\n\t\t}\n\t} while (--tries);\n\n\terrno = EEXIST;\n\treturn(-1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MKTEMP_FILE\t1\n\nint\nmkstemp(char *path)\n{\n\treturn(mktemp_internal(path, 0, MKTEMP_FILE));\n}"
  },
  {
    "function_name": "mktemp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
    "lines": "113-117",
    "snippet": "char *\nmktemp(char *path)\n{\n\treturn(_mktemp(path));\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_mktemp",
          "args": [
            "path"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "_mktemp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
          "lines": "102-108",
          "snippet": "char *\n_mktemp(char *path)\n{\n\tif (mktemp_internal(path, 0, MKTEMP_NAME) == -1)\n\t\treturn(NULL);\n\treturn(path);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MKTEMP_NAME\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MKTEMP_NAME\t0\n\nchar *\n_mktemp(char *path)\n{\n\tif (mktemp_internal(path, 0, MKTEMP_NAME) == -1)\n\t\treturn(NULL);\n\treturn(path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nmktemp(char *path)\n{\n\treturn(_mktemp(path));\n}"
  },
  {
    "function_name": "_mktemp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
    "lines": "102-108",
    "snippet": "char *\n_mktemp(char *path)\n{\n\tif (mktemp_internal(path, 0, MKTEMP_NAME) == -1)\n\t\treturn(NULL);\n\treturn(path);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MKTEMP_NAME\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mktemp_internal",
          "args": [
            "path",
            "0",
            "MKTEMP_NAME"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "mktemp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
          "lines": "46-97",
          "snippet": "static int\nmktemp_internal(char *path, int slen, int mode)\n{\n\tchar *start, *cp, *ep;\n\tconst char *tempchars = TEMPCHARS;\n\tunsigned int r, tries;\n\tstruct stat sb;\n\tsize_t len;\n\tint fd;\n\n\tlen = strlen(path);\n\tif (len == 0 || slen < 0 || (size_t)slen >= len) {\n\t\terrno = EINVAL;\n\t\treturn(-1);\n\t}\n\tep = path + len - slen;\n\n\ttries = 1;\n\tfor (start = ep; start > path && start[-1] == 'X'; start--) {\n\t\tif (tries < INT_MAX / NUM_CHARS)\n\t\t\ttries *= NUM_CHARS;\n\t}\n\ttries *= 2;\n\n\tdo {\n\t\tfor (cp = start; cp != ep; cp++) {\n\t\t\tr = arc4random_uniform(NUM_CHARS);\n\t\t\t*cp = tempchars[r];\n\t\t}\n\n\t\tswitch (mode) {\n\t\tcase MKTEMP_NAME:\n\t\t\tif (lstat(path, &sb) != 0)\n\t\t\t\treturn(errno == ENOENT ? 0 : -1);\n\t\t\tbreak;\n\t\tcase MKTEMP_FILE:\n\t\t\tfd = open(path, O_CREAT|O_EXCL|O_RDWR, S_IRUSR|S_IWUSR);\n\t\t\tif (fd != -1 || errno != EEXIST)\n\t\t\t\treturn(fd);\n\t\t\tbreak;\n\t\tcase MKTEMP_DIR:\n\t\t\tif (mkdir(path, S_IRUSR|S_IWUSR|S_IXUSR) == 0)\n\t\t\t\treturn(0);\n\t\t\tif (errno != EEXIST)\n\t\t\t\treturn(-1);\n\t\t\tbreak;\n\t\t}\n\t} while (--tries);\n\n\terrno = EEXIST;\n\treturn(-1);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define NUM_CHARS\t(sizeof(TEMPCHARS) - 1)",
            "#define TEMPCHARS\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"",
            "#define MKTEMP_DIR\t2",
            "#define MKTEMP_FILE\t1",
            "#define MKTEMP_NAME\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define NUM_CHARS\t(sizeof(TEMPCHARS) - 1)\n#define TEMPCHARS\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n#define MKTEMP_DIR\t2\n#define MKTEMP_FILE\t1\n#define MKTEMP_NAME\t0\n\nstatic int\nmktemp_internal(char *path, int slen, int mode)\n{\n\tchar *start, *cp, *ep;\n\tconst char *tempchars = TEMPCHARS;\n\tunsigned int r, tries;\n\tstruct stat sb;\n\tsize_t len;\n\tint fd;\n\n\tlen = strlen(path);\n\tif (len == 0 || slen < 0 || (size_t)slen >= len) {\n\t\terrno = EINVAL;\n\t\treturn(-1);\n\t}\n\tep = path + len - slen;\n\n\ttries = 1;\n\tfor (start = ep; start > path && start[-1] == 'X'; start--) {\n\t\tif (tries < INT_MAX / NUM_CHARS)\n\t\t\ttries *= NUM_CHARS;\n\t}\n\ttries *= 2;\n\n\tdo {\n\t\tfor (cp = start; cp != ep; cp++) {\n\t\t\tr = arc4random_uniform(NUM_CHARS);\n\t\t\t*cp = tempchars[r];\n\t\t}\n\n\t\tswitch (mode) {\n\t\tcase MKTEMP_NAME:\n\t\t\tif (lstat(path, &sb) != 0)\n\t\t\t\treturn(errno == ENOENT ? 0 : -1);\n\t\t\tbreak;\n\t\tcase MKTEMP_FILE:\n\t\t\tfd = open(path, O_CREAT|O_EXCL|O_RDWR, S_IRUSR|S_IWUSR);\n\t\t\tif (fd != -1 || errno != EEXIST)\n\t\t\t\treturn(fd);\n\t\t\tbreak;\n\t\tcase MKTEMP_DIR:\n\t\t\tif (mkdir(path, S_IRUSR|S_IWUSR|S_IXUSR) == 0)\n\t\t\t\treturn(0);\n\t\t\tif (errno != EEXIST)\n\t\t\t\treturn(-1);\n\t\t\tbreak;\n\t\t}\n\t} while (--tries);\n\n\terrno = EEXIST;\n\treturn(-1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MKTEMP_NAME\t0\n\nchar *\n_mktemp(char *path)\n{\n\tif (mktemp_internal(path, 0, MKTEMP_NAME) == -1)\n\t\treturn(NULL);\n\treturn(path);\n}"
  },
  {
    "function_name": "mktemp_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
    "lines": "46-97",
    "snippet": "static int\nmktemp_internal(char *path, int slen, int mode)\n{\n\tchar *start, *cp, *ep;\n\tconst char *tempchars = TEMPCHARS;\n\tunsigned int r, tries;\n\tstruct stat sb;\n\tsize_t len;\n\tint fd;\n\n\tlen = strlen(path);\n\tif (len == 0 || slen < 0 || (size_t)slen >= len) {\n\t\terrno = EINVAL;\n\t\treturn(-1);\n\t}\n\tep = path + len - slen;\n\n\ttries = 1;\n\tfor (start = ep; start > path && start[-1] == 'X'; start--) {\n\t\tif (tries < INT_MAX / NUM_CHARS)\n\t\t\ttries *= NUM_CHARS;\n\t}\n\ttries *= 2;\n\n\tdo {\n\t\tfor (cp = start; cp != ep; cp++) {\n\t\t\tr = arc4random_uniform(NUM_CHARS);\n\t\t\t*cp = tempchars[r];\n\t\t}\n\n\t\tswitch (mode) {\n\t\tcase MKTEMP_NAME:\n\t\t\tif (lstat(path, &sb) != 0)\n\t\t\t\treturn(errno == ENOENT ? 0 : -1);\n\t\t\tbreak;\n\t\tcase MKTEMP_FILE:\n\t\t\tfd = open(path, O_CREAT|O_EXCL|O_RDWR, S_IRUSR|S_IWUSR);\n\t\t\tif (fd != -1 || errno != EEXIST)\n\t\t\t\treturn(fd);\n\t\t\tbreak;\n\t\tcase MKTEMP_DIR:\n\t\t\tif (mkdir(path, S_IRUSR|S_IWUSR|S_IXUSR) == 0)\n\t\t\t\treturn(0);\n\t\t\tif (errno != EEXIST)\n\t\t\t\treturn(-1);\n\t\t\tbreak;\n\t\t}\n\t} while (--tries);\n\n\terrno = EEXIST;\n\treturn(-1);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define NUM_CHARS\t(sizeof(TEMPCHARS) - 1)",
      "#define TEMPCHARS\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"",
      "#define MKTEMP_DIR\t2",
      "#define MKTEMP_FILE\t1",
      "#define MKTEMP_NAME\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "path",
            "S_IRUSR|S_IWUSR|S_IXUSR"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_CREAT|O_EXCL|O_RDWR",
            "S_IRUSR|S_IWUSR"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "binary_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-cygwin_util.c",
          "lines": "43-53",
          "snippet": "int\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "path",
            "&sb"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "fudge_lstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-glob.c",
          "lines": "110-121",
          "snippet": "static int\nfudge_lstat(const char *path, struct stat *st)\n{\n\tAttrib *a;\n\n\tif (!(a = do_lstat(cur.conn, (char *)path, 1)))\n\t\treturn(-1);\n\n\tattrib_to_stat(a, st);\n\n\treturn(0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <dirent.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct sftp_conn *conn;\n} cur;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <dirent.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tstruct sftp_conn *conn;\n} cur;\n\nstatic int\nfudge_lstat(const char *path, struct stat *st)\n{\n\tAttrib *a;\n\n\tif (!(a = do_lstat(cur.conn, (char *)path, 1)))\n\t\treturn(-1);\n\n\tattrib_to_stat(a, st);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4random_uniform",
          "args": [
            "NUM_CHARS"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_uniform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "291-315",
          "snippet": "u_int32_t\narc4random_uniform(u_int32_t upper_bound)\n{\n\tu_int32_t r, min;\n\n\tif (upper_bound < 2)\n\t\treturn 0;\n\n\t/* 2**32 % x == (2**32 - x) % x */\n\tmin = -upper_bound % upper_bound;\n\n\t/*\n\t * This could theoretically loop forever but each retry has\n\t * p > 0.5 (worst case, usually far better) of selecting a\n\t * number inside the range we need, so it should rarely need\n\t * to re-roll.\n\t */\n\tfor (;;) {\n\t\tr = arc4random();\n\t\tif (r >= min)\n\t\t\tbreak;\n\t}\n\n\treturn r % upper_bound;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\narc4random_uniform(u_int32_t upper_bound)\n{\n\tu_int32_t r, min;\n\n\tif (upper_bound < 2)\n\t\treturn 0;\n\n\t/* 2**32 % x == (2**32 - x) % x */\n\tmin = -upper_bound % upper_bound;\n\n\t/*\n\t * This could theoretically loop forever but each retry has\n\t * p > 0.5 (worst case, usually far better) of selecting a\n\t * number inside the range we need, so it should rarely need\n\t * to re-roll.\n\t */\n\tfor (;;) {\n\t\tr = arc4random();\n\t\tif (r >= min)\n\t\t\tbreak;\n\t}\n\n\treturn r % upper_bound;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define NUM_CHARS\t(sizeof(TEMPCHARS) - 1)\n#define TEMPCHARS\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n#define MKTEMP_DIR\t2\n#define MKTEMP_FILE\t1\n#define MKTEMP_NAME\t0\n\nstatic int\nmktemp_internal(char *path, int slen, int mode)\n{\n\tchar *start, *cp, *ep;\n\tconst char *tempchars = TEMPCHARS;\n\tunsigned int r, tries;\n\tstruct stat sb;\n\tsize_t len;\n\tint fd;\n\n\tlen = strlen(path);\n\tif (len == 0 || slen < 0 || (size_t)slen >= len) {\n\t\terrno = EINVAL;\n\t\treturn(-1);\n\t}\n\tep = path + len - slen;\n\n\ttries = 1;\n\tfor (start = ep; start > path && start[-1] == 'X'; start--) {\n\t\tif (tries < INT_MAX / NUM_CHARS)\n\t\t\ttries *= NUM_CHARS;\n\t}\n\ttries *= 2;\n\n\tdo {\n\t\tfor (cp = start; cp != ep; cp++) {\n\t\t\tr = arc4random_uniform(NUM_CHARS);\n\t\t\t*cp = tempchars[r];\n\t\t}\n\n\t\tswitch (mode) {\n\t\tcase MKTEMP_NAME:\n\t\t\tif (lstat(path, &sb) != 0)\n\t\t\t\treturn(errno == ENOENT ? 0 : -1);\n\t\t\tbreak;\n\t\tcase MKTEMP_FILE:\n\t\t\tfd = open(path, O_CREAT|O_EXCL|O_RDWR, S_IRUSR|S_IWUSR);\n\t\t\tif (fd != -1 || errno != EEXIST)\n\t\t\t\treturn(fd);\n\t\t\tbreak;\n\t\tcase MKTEMP_DIR:\n\t\t\tif (mkdir(path, S_IRUSR|S_IWUSR|S_IXUSR) == 0)\n\t\t\t\treturn(0);\n\t\t\tif (errno != EEXIST)\n\t\t\t\treturn(-1);\n\t\t\tbreak;\n\t\t}\n\t} while (--tries);\n\n\terrno = EEXIST;\n\treturn(-1);\n}"
  }
]