[
  {
    "function_name": "ssh_remove_all_identities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "559-580",
    "snippet": "int\nssh_remove_all_identities(int sock, int version)\n{\n\tstruct sshbuf *msg;\n\tu_char type = (version == 1) ?\n\t    SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES :\n\t    SSH2_AGENTC_REMOVE_ALL_IDENTITIES;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_u8(msg, type)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tr = decode_reply(type);\n out:\n\tsshbuf_free(msg);\n\treturn r;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_reply",
          "args": [
            "type"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "decode_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "74-83",
          "snippet": "static int\ndecode_reply(u_char type)\n{\n\tif (agent_failed(type))\n\t\treturn SSH_ERR_AGENT_FAILURE;\n\telse if (type == SSH_AGENT_SUCCESS)\n\t\treturn 0;\n\telse\n\t\treturn SSH_ERR_INVALID_FORMAT;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndecode_reply(u_char type)\n{\n\tif (agent_failed(type))\n\t\treturn SSH_ERR_AGENT_FAILURE;\n\telse if (type == SSH_AGENT_SUCCESS)\n\t\treturn 0;\n\telse\n\t\treturn SSH_ERR_INVALID_FORMAT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_request_reply",
          "args": [
            "sock",
            "msg",
            "msg"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_request_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "123-164",
          "snippet": "static int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */\n\nstatic int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "type"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remove_all_identities(int sock, int version)\n{\n\tstruct sshbuf *msg;\n\tu_char type = (version == 1) ?\n\t    SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES :\n\t    SSH2_AGENTC_REMOVE_ALL_IDENTITIES;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_u8(msg, type)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tr = decode_reply(type);\n out:\n\tsshbuf_free(msg);\n\treturn r;\n}"
  },
  {
    "function_name": "ssh_update_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "517-549",
    "snippet": "int\nssh_update_card(int sock, int add, const char *reader_id, const char *pin,\n    u_int life, u_int confirm)\n{\n\tstruct sshbuf *msg;\n\tint r, constrained = (life || confirm);\n\tu_char type;\n\n\tif (add) {\n\t\ttype = constrained ?\n\t\t    SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED :\n\t\t    SSH_AGENTC_ADD_SMARTCARD_KEY;\n\t} else\n\t\ttype = SSH_AGENTC_REMOVE_SMARTCARD_KEY;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_u8(msg, type)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, reader_id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, pin)) != 0)\n\t\tgoto out;\n\tif (constrained &&\n\t    (r = encode_constraints(msg, life, confirm, 0)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tr = decode_reply(type);\n out:\n\tsshbuf_free(msg);\n\treturn r;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_reply",
          "args": [
            "type"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "decode_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "74-83",
          "snippet": "static int\ndecode_reply(u_char type)\n{\n\tif (agent_failed(type))\n\t\treturn SSH_ERR_AGENT_FAILURE;\n\telse if (type == SSH_AGENT_SUCCESS)\n\t\treturn 0;\n\telse\n\t\treturn SSH_ERR_INVALID_FORMAT;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndecode_reply(u_char type)\n{\n\tif (agent_failed(type))\n\t\treturn SSH_ERR_AGENT_FAILURE;\n\telse if (type == SSH_AGENT_SUCCESS)\n\t\treturn 0;\n\telse\n\t\treturn SSH_ERR_INVALID_FORMAT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_request_reply",
          "args": [
            "sock",
            "msg",
            "msg"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_request_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "123-164",
          "snippet": "static int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */\n\nstatic int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_constraints",
          "args": [
            "msg",
            "life",
            "confirm",
            "0"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "encode_constraints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "395-417",
          "snippet": "static int\nencode_constraints(struct sshbuf *m, u_int life, u_int confirm, u_int maxsign)\n{\n\tint r;\n\n\tif (life != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_LIFETIME)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, life)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (confirm != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_CONFIRM)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (maxsign != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_MAXSIGN)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, maxsign)) != 0)\n\t\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\treturn r;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nencode_constraints(struct sshbuf *m, u_int life, u_int confirm, u_int maxsign)\n{\n\tint r;\n\n\tif (life != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_LIFETIME)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, life)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (confirm != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_CONFIRM)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (maxsign != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_MAXSIGN)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, maxsign)) != 0)\n\t\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "pin"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "type"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_update_card(int sock, int add, const char *reader_id, const char *pin,\n    u_int life, u_int confirm)\n{\n\tstruct sshbuf *msg;\n\tint r, constrained = (life || confirm);\n\tu_char type;\n\n\tif (add) {\n\t\ttype = constrained ?\n\t\t    SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED :\n\t\t    SSH_AGENTC_ADD_SMARTCARD_KEY;\n\t} else\n\t\ttype = SSH_AGENTC_REMOVE_SMARTCARD_KEY;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_u8(msg, type)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, reader_id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, pin)) != 0)\n\t\tgoto out;\n\tif (constrained &&\n\t    (r = encode_constraints(msg, life, confirm, 0)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tr = decode_reply(type);\n out:\n\tsshbuf_free(msg);\n\treturn r;\n}"
  },
  {
    "function_name": "ssh_remove_identity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "477-511",
    "snippet": "int\nssh_remove_identity(int sock, struct sshkey *key)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\tu_char type, *blob = NULL;\n\tsize_t blen;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif (key->type != KEY_UNSPEC) {\n\t\tif ((r = sshkey_to_blob(key, &blob, &blen)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = sshbuf_put_u8(msg,\n\t\t    SSH2_AGENTC_REMOVE_IDENTITY)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, blob, blen)) != 0)\n\t\t\tgoto out;\n\t} else {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tr = decode_reply(type);\n out:\n\tif (blob != NULL) {\n\t\texplicit_bzero(blob, blen);\n\t\tfree(blob);\n\t}\n\tsshbuf_free(msg);\n\treturn r;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "blob"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_free_identitylist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "302-316",
          "snippet": "void\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "blob",
            "blen"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_reply",
          "args": [
            "type"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "decode_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "74-83",
          "snippet": "static int\ndecode_reply(u_char type)\n{\n\tif (agent_failed(type))\n\t\treturn SSH_ERR_AGENT_FAILURE;\n\telse if (type == SSH_AGENT_SUCCESS)\n\t\treturn 0;\n\telse\n\t\treturn SSH_ERR_INVALID_FORMAT;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndecode_reply(u_char type)\n{\n\tif (agent_failed(type))\n\t\treturn SSH_ERR_AGENT_FAILURE;\n\telse if (type == SSH_AGENT_SUCCESS)\n\t\treturn 0;\n\telse\n\t\treturn SSH_ERR_INVALID_FORMAT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_request_reply",
          "args": [
            "sock",
            "msg",
            "msg"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_request_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "123-164",
          "snippet": "static int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */\n\nstatic int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "msg",
            "blob",
            "blen"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_AGENTC_REMOVE_IDENTITY"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_to_blob",
          "args": [
            "key",
            "&blob",
            "&blen"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "880-884",
          "snippet": "int\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remove_identity(int sock, struct sshkey *key)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\tu_char type, *blob = NULL;\n\tsize_t blen;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif (key->type != KEY_UNSPEC) {\n\t\tif ((r = sshkey_to_blob(key, &blob, &blen)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = sshbuf_put_u8(msg,\n\t\t    SSH2_AGENTC_REMOVE_IDENTITY)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, blob, blen)) != 0)\n\t\t\tgoto out;\n\t} else {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tr = decode_reply(type);\n out:\n\tif (blob != NULL) {\n\t\texplicit_bzero(blob, blen);\n\t\tfree(blob);\n\t}\n\tsshbuf_free(msg);\n\treturn r;\n}"
  },
  {
    "function_name": "ssh_add_identity_constrained",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "423-471",
    "snippet": "int\nssh_add_identity_constrained(int sock, const struct sshkey *key,\n    const char *comment, u_int life, u_int confirm, u_int maxsign)\n{\n\tstruct sshbuf *msg;\n\tint r, constrained = (life || confirm || maxsign);\n\tu_char type;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n#endif\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\ttype = constrained ?\n\t\t    SSH2_AGENTC_ADD_ID_CONSTRAINED :\n\t\t    SSH2_AGENTC_ADD_IDENTITY;\n\t\tif ((r = sshbuf_put_u8(msg, type)) != 0 ||\n\t\t    (r = sshkey_private_serialize_maxsign(key, msg, maxsign,\n\t\t    NULL)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg, comment)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (constrained &&\n\t    (r = encode_constraints(msg, life, confirm, maxsign)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tr = decode_reply(type);\n out:\n\tsshbuf_free(msg);\n\treturn r;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_reply",
          "args": [
            "type"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "decode_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "74-83",
          "snippet": "static int\ndecode_reply(u_char type)\n{\n\tif (agent_failed(type))\n\t\treturn SSH_ERR_AGENT_FAILURE;\n\telse if (type == SSH_AGENT_SUCCESS)\n\t\treturn 0;\n\telse\n\t\treturn SSH_ERR_INVALID_FORMAT;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndecode_reply(u_char type)\n{\n\tif (agent_failed(type))\n\t\treturn SSH_ERR_AGENT_FAILURE;\n\telse if (type == SSH_AGENT_SUCCESS)\n\t\treturn 0;\n\telse\n\t\treturn SSH_ERR_INVALID_FORMAT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_request_reply",
          "args": [
            "sock",
            "msg",
            "msg"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_request_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "123-164",
          "snippet": "static int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */\n\nstatic int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_constraints",
          "args": [
            "msg",
            "life",
            "confirm",
            "maxsign"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "encode_constraints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "395-417",
          "snippet": "static int\nencode_constraints(struct sshbuf *m, u_int life, u_int confirm, u_int maxsign)\n{\n\tint r;\n\n\tif (life != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_LIFETIME)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, life)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (confirm != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_CONFIRM)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (maxsign != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_MAXSIGN)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, maxsign)) != 0)\n\t\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\treturn r;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nencode_constraints(struct sshbuf *m, u_int life, u_int confirm, u_int maxsign)\n{\n\tint r;\n\n\tif (life != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_LIFETIME)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, life)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (confirm != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_CONFIRM)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (maxsign != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_MAXSIGN)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, maxsign)) != 0)\n\t\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "comment"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_private_serialize_maxsign",
          "args": [
            "key",
            "msg",
            "maxsign",
            "NULL"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_private_serialize_maxsign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "4139-4144",
          "snippet": "int\nsshkey_private_serialize_maxsign(const struct sshkey *k, struct sshbuf *b,\n    u_int32_t maxsign, sshkey_printfn *pr)\n{\n\treturn sshkey_private_serialize_opt(k, b, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_private_serialize_maxsign(const struct sshkey *k, struct sshbuf *b,\n    u_int32_t maxsign, sshkey_printfn *pr)\n{\n\treturn sshkey_private_serialize_opt(k, b, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "type"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_add_identity_constrained(int sock, const struct sshkey *key,\n    const char *comment, u_int life, u_int confirm, u_int maxsign)\n{\n\tstruct sshbuf *msg;\n\tint r, constrained = (life || confirm || maxsign);\n\tu_char type;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n#endif\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\ttype = constrained ?\n\t\t    SSH2_AGENTC_ADD_ID_CONSTRAINED :\n\t\t    SSH2_AGENTC_ADD_IDENTITY;\n\t\tif ((r = sshbuf_put_u8(msg, type)) != 0 ||\n\t\t    (r = sshkey_private_serialize_maxsign(key, msg, maxsign,\n\t\t    NULL)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg, comment)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (constrained &&\n\t    (r = encode_constraints(msg, life, confirm, maxsign)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tr = decode_reply(type);\n out:\n\tsshbuf_free(msg);\n\treturn r;\n}"
  },
  {
    "function_name": "encode_constraints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "395-417",
    "snippet": "static int\nencode_constraints(struct sshbuf *m, u_int life, u_int confirm, u_int maxsign)\n{\n\tint r;\n\n\tif (life != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_LIFETIME)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, life)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (confirm != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_CONFIRM)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (maxsign != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_MAXSIGN)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, maxsign)) != 0)\n\t\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\treturn r;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "maxsign"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "m",
            "SSH_AGENT_CONSTRAIN_MAXSIGN"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nencode_constraints(struct sshbuf *m, u_int life, u_int confirm, u_int maxsign)\n{\n\tint r;\n\n\tif (life != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_LIFETIME)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, life)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (confirm != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_CONFIRM)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (maxsign != 0) {\n\t\tif ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_MAXSIGN)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, maxsign)) != 0)\n\t\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\treturn r;\n}"
  },
  {
    "function_name": "ssh_agent_sign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "340-390",
    "snippet": "int\nssh_agent_sign(int sock, const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tstruct sshbuf *msg;\n\tu_char *sig = NULL, type = 0;\n\tsize_t len = 0;\n\tu_int flags = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tflags |= agent_encode_alg(key, alg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||\n\t    (r = sshkey_puts(key, msg)) != 0 ||\n\t    (r = sshbuf_put_string(msg, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, flags)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_SIGN_RESPONSE) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_string(msg, &sig, &len)) != 0)\n\t\tgoto out;\n\t/* Check what we actually got back from the agent. */\n\tif ((r = sshkey_check_sigtype(sig, len, alg)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*sigp = sig;\n\t*lenp = len;\n\tsig = NULL;\n\tlen = 0;\n\tr = 0;\n out:\n\tfreezero(sig, len);\n\tsshbuf_free(msg);\n\treturn r;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "sig",
            "len"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_check_sigtype",
          "args": [
            "sig",
            "len",
            "alg"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_check_sigtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2366-2383",
          "snippet": "int\nsshkey_check_sigtype(const u_char *sig, size_t siglen,\n    const char *requested_alg)\n{\n\tconst char *expected_alg;\n\tchar *sigtype = NULL;\n\tint r;\n\n\tif (requested_alg == NULL)\n\t\treturn 0;\n\tif ((expected_alg = sshkey_sigalg_by_name(requested_alg)) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = get_sigtype(sig, siglen, &sigtype)) != 0)\n\t\treturn r;\n\tr = strcmp(expected_alg, sigtype) == 0;\n\tfree(sigtype);\n\treturn r ? 0 : SSH_ERR_SIGN_ALG_UNSUPPORTED;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_check_sigtype(const u_char *sig, size_t siglen,\n    const char *requested_alg)\n{\n\tconst char *expected_alg;\n\tchar *sigtype = NULL;\n\tint r;\n\n\tif (requested_alg == NULL)\n\t\treturn 0;\n\tif ((expected_alg = sshkey_sigalg_by_name(requested_alg)) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = get_sigtype(sig, siglen, &sigtype)) != 0)\n\t\treturn r;\n\tr = strcmp(expected_alg, sigtype) == 0;\n\tfree(sigtype);\n\treturn r ? 0 : SSH_ERR_SIGN_ALG_UNSUPPORTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "msg",
            "&sig",
            "&len"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "agent_failed",
          "args": [
            "type"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_request_reply",
          "args": [
            "sock",
            "msg",
            "msg"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_request_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "123-164",
          "snippet": "static int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */\n\nstatic int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "flags"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "msg",
            "data",
            "datalen"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_puts",
          "args": [
            "key",
            "msg"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "836-840",
          "snippet": "int\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_AGENTC_SIGN_REQUEST"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "agent_encode_alg",
          "args": [
            "key",
            "alg"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "agent_encode_alg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "327-337",
          "snippet": "static u_int\nagent_encode_alg(const struct sshkey *key, const char *alg)\n{\n\tif (alg != NULL && key->type == KEY_RSA) {\n\t\tif (strcmp(alg, \"rsa-sha2-256\") == 0)\n\t\t\treturn SSH_AGENT_RSA_SHA2_256;\n\t\telse if (strcmp(alg, \"rsa-sha2-512\") == 0)\n\t\t\treturn SSH_AGENT_RSA_SHA2_512;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int\nagent_encode_alg(const struct sshkey *key, const char *alg)\n{\n\tif (alg != NULL && key->type == KEY_RSA) {\n\t\tif (strcmp(alg, \"rsa-sha2-256\") == 0)\n\t\t\treturn SSH_AGENT_RSA_SHA2_256;\n\t\telse if (strcmp(alg, \"rsa-sha2-512\") == 0)\n\t\t\treturn SSH_AGENT_RSA_SHA2_512;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_agent_sign(int sock, const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tstruct sshbuf *msg;\n\tu_char *sig = NULL, type = 0;\n\tsize_t len = 0;\n\tu_int flags = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tflags |= agent_encode_alg(key, alg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||\n\t    (r = sshkey_puts(key, msg)) != 0 ||\n\t    (r = sshbuf_put_string(msg, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, flags)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_SIGN_RESPONSE) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_string(msg, &sig, &len)) != 0)\n\t\tgoto out;\n\t/* Check what we actually got back from the agent. */\n\tif ((r = sshkey_check_sigtype(sig, len, alg)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*sigp = sig;\n\t*lenp = len;\n\tsig = NULL;\n\tlen = 0;\n\tr = 0;\n out:\n\tfreezero(sig, len);\n\tsshbuf_free(msg);\n\treturn r;\n}"
  },
  {
    "function_name": "agent_encode_alg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "327-337",
    "snippet": "static u_int\nagent_encode_alg(const struct sshkey *key, const char *alg)\n{\n\tif (alg != NULL && key->type == KEY_RSA) {\n\t\tif (strcmp(alg, \"rsa-sha2-256\") == 0)\n\t\t\treturn SSH_AGENT_RSA_SHA2_256;\n\t\telse if (strcmp(alg, \"rsa-sha2-512\") == 0)\n\t\t\treturn SSH_AGENT_RSA_SHA2_512;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "alg",
            "\"rsa-sha2-512\""
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int\nagent_encode_alg(const struct sshkey *key, const char *alg)\n{\n\tif (alg != NULL && key->type == KEY_RSA) {\n\t\tif (strcmp(alg, \"rsa-sha2-256\") == 0)\n\t\t\treturn SSH_AGENT_RSA_SHA2_256;\n\t\telse if (strcmp(alg, \"rsa-sha2-512\") == 0)\n\t\t\treturn SSH_AGENT_RSA_SHA2_512;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_free_identitylist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "302-316",
    "snippet": "void\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "idl"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_free_identitylist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "302-316",
          "snippet": "void\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "idl->keys[i]"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}"
  },
  {
    "function_name": "ssh_fetch_identitylist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "228-300",
    "snippet": "int\nssh_fetch_identitylist(int sock, struct ssh_identitylist **idlp)\n{\n\tu_char type;\n\tu_int32_t num, i;\n\tstruct sshbuf *msg;\n\tstruct ssh_identitylist *idl = NULL;\n\tint r;\n\n\t/*\n\t * Send a message to the agent requesting for a list of the\n\t * identities it can represent.\n\t */\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_REQUEST_IDENTITIES)) != 0)\n\t\tgoto out;\n\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\n\t/* Get message type, and verify that we got a proper answer. */\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* Get the number of entries in the response and check it for sanity. */\n\tif ((r = sshbuf_get_u32(msg, &num)) != 0)\n\t\tgoto out;\n\tif (num > MAX_AGENT_IDENTITIES) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (num == 0) {\n\t\tr = SSH_ERR_AGENT_NO_IDENTITIES;\n\t\tgoto out;\n\t}\n\n\t/* Deserialise the response into a list of keys/comments */\n\tif ((idl = calloc(1, sizeof(*idl))) == NULL ||\n\t    (idl->keys = calloc(num, sizeof(*idl->keys))) == NULL ||\n\t    (idl->comments = calloc(num, sizeof(*idl->comments))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < num;) {\n\t\tif ((r = deserialise_identity2(msg, &(idl->keys[i]),\n\t\t    &(idl->comments[i]))) != 0) {\n\t\t\tif (r == SSH_ERR_KEY_TYPE_UNKNOWN) {\n\t\t\t\t/* Gracefully skip unknown key types */\n\t\t\t\tnum--;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tgoto out;\n\t\t}\n\t\ti++;\n\t}\n\tidl->nkeys = num;\n\t*idlp = idl;\n\tidl = NULL;\n\tr = 0;\n out:\n\tsshbuf_free(msg);\n\tif (idl != NULL)\n\t\tssh_free_identitylist(idl);\n\treturn r;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MAX_AGENT_IDENTITIES\t2048\t\t/* Max keys in agent reply */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_free_identitylist",
          "args": [
            "idl"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_free_identitylist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "302-316",
          "snippet": "void\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deserialise_identity2",
          "args": [
            "msg",
            "&(idl->keys[i])",
            "&(idl->comments[i])"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "deserialise_identity2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "202-223",
          "snippet": "static int\ndeserialise_identity2(struct sshbuf *ids, struct sshkey **keyp, char **commentp)\n{\n\tint r;\n\tchar *comment = NULL;\n\tconst u_char *blob;\n\tsize_t blen;\n\n\tif ((r = sshbuf_get_string_direct(ids, &blob, &blen)) != 0 ||\n\t    (r = sshbuf_get_cstring(ids, &comment, NULL)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_from_blob(blob, blen, keyp)) != 0)\n\t\tgoto out;\n\tif (commentp != NULL) {\n\t\t*commentp = comment;\n\t\tcomment = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(comment);\n\treturn r;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndeserialise_identity2(struct sshbuf *ids, struct sshkey **keyp, char **commentp)\n{\n\tint r;\n\tchar *comment = NULL;\n\tconst u_char *blob;\n\tsize_t blen;\n\n\tif ((r = sshbuf_get_string_direct(ids, &blob, &blen)) != 0 ||\n\t    (r = sshbuf_get_cstring(ids, &comment, NULL)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_from_blob(blob, blen, keyp)) != 0)\n\t\tgoto out;\n\tif (commentp != NULL) {\n\t\t*commentp = comment;\n\t\tcomment = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(comment);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "num",
            "sizeof(*idl->comments)"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "msg",
            "&num"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "agent_failed",
          "args": [
            "type"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_request_reply",
          "args": [
            "sock",
            "msg",
            "msg"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_request_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "123-164",
          "snippet": "static int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */\n\nstatic int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_AGENTC_REQUEST_IDENTITIES"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_AGENT_IDENTITIES\t2048\t\t/* Max keys in agent reply */\n\nint\nssh_fetch_identitylist(int sock, struct ssh_identitylist **idlp)\n{\n\tu_char type;\n\tu_int32_t num, i;\n\tstruct sshbuf *msg;\n\tstruct ssh_identitylist *idl = NULL;\n\tint r;\n\n\t/*\n\t * Send a message to the agent requesting for a list of the\n\t * identities it can represent.\n\t */\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_REQUEST_IDENTITIES)) != 0)\n\t\tgoto out;\n\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\n\t/* Get message type, and verify that we got a proper answer. */\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* Get the number of entries in the response and check it for sanity. */\n\tif ((r = sshbuf_get_u32(msg, &num)) != 0)\n\t\tgoto out;\n\tif (num > MAX_AGENT_IDENTITIES) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (num == 0) {\n\t\tr = SSH_ERR_AGENT_NO_IDENTITIES;\n\t\tgoto out;\n\t}\n\n\t/* Deserialise the response into a list of keys/comments */\n\tif ((idl = calloc(1, sizeof(*idl))) == NULL ||\n\t    (idl->keys = calloc(num, sizeof(*idl->keys))) == NULL ||\n\t    (idl->comments = calloc(num, sizeof(*idl->comments))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < num;) {\n\t\tif ((r = deserialise_identity2(msg, &(idl->keys[i]),\n\t\t    &(idl->comments[i]))) != 0) {\n\t\t\tif (r == SSH_ERR_KEY_TYPE_UNKNOWN) {\n\t\t\t\t/* Gracefully skip unknown key types */\n\t\t\t\tnum--;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tgoto out;\n\t\t}\n\t\ti++;\n\t}\n\tidl->nkeys = num;\n\t*idlp = idl;\n\tidl = NULL;\n\tr = 0;\n out:\n\tsshbuf_free(msg);\n\tif (idl != NULL)\n\t\tssh_free_identitylist(idl);\n\treturn r;\n}"
  },
  {
    "function_name": "deserialise_identity2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "202-223",
    "snippet": "static int\ndeserialise_identity2(struct sshbuf *ids, struct sshkey **keyp, char **commentp)\n{\n\tint r;\n\tchar *comment = NULL;\n\tconst u_char *blob;\n\tsize_t blen;\n\n\tif ((r = sshbuf_get_string_direct(ids, &blob, &blen)) != 0 ||\n\t    (r = sshbuf_get_cstring(ids, &comment, NULL)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_from_blob(blob, blen, keyp)) != 0)\n\t\tgoto out;\n\tif (commentp != NULL) {\n\t\t*commentp = comment;\n\t\tcomment = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(comment);\n\treturn r;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "comment"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_free_identitylist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "302-316",
          "snippet": "void\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob",
          "args": [
            "blob",
            "blen",
            "keyp"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2263-2274",
          "snippet": "int\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "ids",
            "&comment",
            "NULL"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string_direct",
          "args": [
            "ids",
            "&blob",
            "&blen"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndeserialise_identity2(struct sshbuf *ids, struct sshkey **keyp, char **commentp)\n{\n\tint r;\n\tchar *comment = NULL;\n\tconst u_char *blob;\n\tsize_t blen;\n\n\tif ((r = sshbuf_get_string_direct(ids, &blob, &blen)) != 0 ||\n\t    (r = sshbuf_get_cstring(ids, &comment, NULL)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_from_blob(blob, blen, keyp)) != 0)\n\t\tgoto out;\n\tif (commentp != NULL) {\n\t\t*commentp = comment;\n\t\tcomment = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(comment);\n\treturn r;\n}"
  },
  {
    "function_name": "ssh_lock_agent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "179-199",
    "snippet": "int\nssh_lock_agent(int sock, int lock, const char *password)\n{\n\tint r;\n\tu_char type = lock ? SSH_AGENTC_LOCK : SSH_AGENTC_UNLOCK;\n\tstruct sshbuf *msg;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_u8(msg, type)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, password)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tr = decode_reply(type);\n out:\n\tsshbuf_free(msg);\n\treturn r;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_reply",
          "args": [
            "type"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "decode_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "74-83",
          "snippet": "static int\ndecode_reply(u_char type)\n{\n\tif (agent_failed(type))\n\t\treturn SSH_ERR_AGENT_FAILURE;\n\telse if (type == SSH_AGENT_SUCCESS)\n\t\treturn 0;\n\telse\n\t\treturn SSH_ERR_INVALID_FORMAT;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndecode_reply(u_char type)\n{\n\tif (agent_failed(type))\n\t\treturn SSH_ERR_AGENT_FAILURE;\n\telse if (type == SSH_AGENT_SUCCESS)\n\t\treturn 0;\n\telse\n\t\treturn SSH_ERR_INVALID_FORMAT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_request_reply",
          "args": [
            "sock",
            "msg",
            "msg"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_request_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "123-164",
          "snippet": "static int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */\n\nstatic int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "password"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "type"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_lock_agent(int sock, int lock, const char *password)\n{\n\tint r;\n\tu_char type = lock ? SSH_AGENTC_LOCK : SSH_AGENTC_UNLOCK;\n\tstruct sshbuf *msg;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_u8(msg, type)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, password)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tr = decode_reply(type);\n out:\n\tsshbuf_free(msg);\n\treturn r;\n}"
  },
  {
    "function_name": "ssh_close_authentication_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "171-176",
    "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "SSH_AUTHSOCKET_ENV_NAME"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
  },
  {
    "function_name": "ssh_request_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "123-164",
    "snippet": "static int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "reply",
            "buf",
            "l"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "read",
            "sock",
            "buf",
            "l"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "reply"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "buf"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "request"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_mutable_ptr",
          "args": [
            "request"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_mutable_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "276-282",
          "snippet": "u_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "POKE_U32",
          "args": [
            "buf",
            "len"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_AGENT_REPLY_LEN\t(256 * 1024) \t/* Max bytes in agent reply */\n\nstatic int\nssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)\n{\n\tint r;\n\tsize_t l, len;\n\tchar buf[1024];\n\n\t/* Get the length of the message, and format it in the buffer. */\n\tlen = sshbuf_len(request);\n\tPOKE_U32(buf, len);\n\n\t/* Send the length and then the packet to the agent. */\n\tif (atomicio(vwrite, sock, buf, 4) != 4 ||\n\t    atomicio(vwrite, sock, sshbuf_mutable_ptr(request),\n\t    sshbuf_len(request)) != sshbuf_len(request))\n\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t/*\n\t * Wait for response from the agent.  First read the length of the\n\t * response packet.\n\t */\n\tif (atomicio(read, sock, buf, 4) != 4)\n\t    return SSH_ERR_AGENT_COMMUNICATION;\n\n\t/* Extract the length, and check it for sanity. */\n\tlen = PEEK_U32(buf);\n\tif (len > MAX_AGENT_REPLY_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* Read the rest of the response in to the buffer. */\n\tsshbuf_reset(reply);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, sock, buf, l) != l)\n\t\t\treturn SSH_ERR_AGENT_COMMUNICATION;\n\t\tif ((r = sshbuf_put(reply, buf, l)) != 0)\n\t\t\treturn r;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_get_authentication_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "86-120",
    "snippet": "int\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sock",
            "(struct sockaddr *)&sunaddr",
            "sizeof(sunaddr)"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "298-308",
          "snippet": "void\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "sock",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "67-111",
          "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "sunaddr.sun_path",
            "authsocket",
            "sizeof(sunaddr.sun_path)"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sunaddr",
            "0",
            "sizeof(sunaddr)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "SSH_AUTHSOCKET_ENV_NAME"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
    "lines": "74-83",
    "snippet": "static int\ndecode_reply(u_char type)\n{\n\tif (agent_failed(type))\n\t\treturn SSH_ERR_AGENT_FAILURE;\n\telse if (type == SSH_AGENT_SUCCESS)\n\t\treturn 0;\n\telse\n\t\treturn SSH_ERR_INVALID_FORMAT;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"misc.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"cipher.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "agent_failed",
          "args": [
            "type"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndecode_reply(u_char type)\n{\n\tif (agent_failed(type))\n\t\treturn SSH_ERR_AGENT_FAILURE;\n\telse if (type == SSH_AGENT_SUCCESS)\n\t\treturn 0;\n\telse\n\t\treturn SSH_ERR_INVALID_FORMAT;\n}"
  }
]