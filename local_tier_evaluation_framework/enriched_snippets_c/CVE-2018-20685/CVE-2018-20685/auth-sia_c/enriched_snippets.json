[
  {
    "function_name": "session_setup_sia",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-sia.c",
    "lines": "83-113",
    "snippet": "void\nsession_setup_sia(struct passwd *pw, char *tty)\n{\n\tSIAENTITY *ent = NULL;\n\tconst char *host;\n\n\thost = get_canonical_hostname(options.use_dns);\n\n\tif (sia_ses_init(&ent, saved_argc, saved_argv, host, pw->pw_name,\n\t    tty, 0, NULL) != SIASUCCESS)\n\t\tfatal(\"sia_ses_init failed\");\n\n\tif (sia_make_entity_pwd(pw, ent) != SIASUCCESS) {\n\t\tsia_ses_release(&ent);\n\t\tfatal(\"sia_make_entity_pwd failed\");\n\t}\n\n\tent->authtype = SIA_A_NONE;\n\tif (sia_ses_estab(sia_collect_trm, ent) != SIASUCCESS)\n\t\tfatal(\"Couldn't establish session for %s from %s\",\n\t\t    pw->pw_name, host);\n\n\tif (sia_ses_launch(sia_collect_trm, ent) != SIASUCCESS)\n\t\tfatal(\"Couldn't launch session for %s from %s\",\n\t\t    pw->pw_name, host);\n\n\tsia_ses_release(&ent);\n\n\tsetuid(0);\n\tpermanently_set_uid(pw);\n}",
    "includes": [
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"log.h\"",
      "#include \"auth-sia.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/resource.h>",
      "#include <setjmp.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <siad.h>",
      "#include <sia.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "permanently_set_uid",
          "args": [
            "pw"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "permanently_set_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "178-236",
          "snippet": "void\npermanently_set_uid(struct passwd *pw)\n{\n#ifndef NO_UID_RESTORATION_TEST\n\tuid_t old_uid = getuid();\n\tgid_t old_gid = getgid();\n#endif\n\n\tif (pw == NULL)\n\t\tfatal(\"permanently_set_uid: no user given\");\n\tif (temporarily_use_uid_effective)\n\t\tfatal(\"permanently_set_uid: temporarily_use_uid effective\");\n\tdebug(\"permanently_set_uid: %u/%u\", (u_int)pw->pw_uid,\n\t    (u_int)pw->pw_gid);\n\n\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) < 0)\n\t\tfatal(\"setresgid %u: %.100s\", (u_int)pw->pw_gid, strerror(errno));\n\n#ifdef __APPLE__\n\t/*\n\t * OS X requires initgroups after setgid to opt back into\n\t * memberd support for >16 supplemental groups.\n\t */\n\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\tfatal(\"initgroups %.100s %u: %.100s\",\n\t\t    pw->pw_name, (u_int)pw->pw_gid, strerror(errno));\n#endif\n\n\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) < 0)\n\t\tfatal(\"setresuid %u: %.100s\", (u_int)pw->pw_uid, strerror(errno));\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of GID if changed (test clearing of saved gid) */\n\tif (old_gid != pw->pw_gid && pw->pw_uid != 0 &&\n\t    (setgid(old_gid) != -1 || setegid(old_gid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]gid\", __func__);\n#endif\n\n\t/* Verify GID drop was successful */\n\tif (getgid() != pw->pw_gid || getegid() != pw->pw_gid) {\n\t\tfatal(\"%s: egid incorrect gid:%u egid:%u (should be %u)\",\n\t\t    __func__, (u_int)getgid(), (u_int)getegid(),\n\t\t    (u_int)pw->pw_gid);\n\t}\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of UID if changed (test clearing of saved uid) */\n\tif (old_uid != pw->pw_uid &&\n\t    (setuid(old_uid) != -1 || seteuid(old_uid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]uid\", __func__);\n#endif\n\n\t/* Verify UID drop was successful */\n\tif (getuid() != pw->pw_uid || geteuid() != pw->pw_uid) {\n\t\tfatal(\"%s: euid incorrect uid:%u euid:%u (should be %u)\",\n\t\t    __func__, (u_int)getuid(), (u_int)geteuid(),\n\t\t    (u_int)pw->pw_uid);\n\t}\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttemporarily_use_uid_effective = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\nstatic int\ttemporarily_use_uid_effective = 0;\n\nvoid\npermanently_set_uid(struct passwd *pw)\n{\n#ifndef NO_UID_RESTORATION_TEST\n\tuid_t old_uid = getuid();\n\tgid_t old_gid = getgid();\n#endif\n\n\tif (pw == NULL)\n\t\tfatal(\"permanently_set_uid: no user given\");\n\tif (temporarily_use_uid_effective)\n\t\tfatal(\"permanently_set_uid: temporarily_use_uid effective\");\n\tdebug(\"permanently_set_uid: %u/%u\", (u_int)pw->pw_uid,\n\t    (u_int)pw->pw_gid);\n\n\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) < 0)\n\t\tfatal(\"setresgid %u: %.100s\", (u_int)pw->pw_gid, strerror(errno));\n\n#ifdef __APPLE__\n\t/*\n\t * OS X requires initgroups after setgid to opt back into\n\t * memberd support for >16 supplemental groups.\n\t */\n\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\tfatal(\"initgroups %.100s %u: %.100s\",\n\t\t    pw->pw_name, (u_int)pw->pw_gid, strerror(errno));\n#endif\n\n\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) < 0)\n\t\tfatal(\"setresuid %u: %.100s\", (u_int)pw->pw_uid, strerror(errno));\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of GID if changed (test clearing of saved gid) */\n\tif (old_gid != pw->pw_gid && pw->pw_uid != 0 &&\n\t    (setgid(old_gid) != -1 || setegid(old_gid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]gid\", __func__);\n#endif\n\n\t/* Verify GID drop was successful */\n\tif (getgid() != pw->pw_gid || getegid() != pw->pw_gid) {\n\t\tfatal(\"%s: egid incorrect gid:%u egid:%u (should be %u)\",\n\t\t    __func__, (u_int)getgid(), (u_int)getegid(),\n\t\t    (u_int)pw->pw_gid);\n\t}\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of UID if changed (test clearing of saved uid) */\n\tif (old_uid != pw->pw_uid &&\n\t    (setuid(old_uid) != -1 || seteuid(old_uid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]uid\", __func__);\n#endif\n\n\t/* Verify UID drop was successful */\n\tif (getuid() != pw->pw_uid || geteuid() != pw->pw_uid) {\n\t\tfatal(\"%s: euid incorrect uid:%u euid:%u (should be %u)\",\n\t\t    __func__, (u_int)getuid(), (u_int)geteuid(),\n\t\t    (u_int)pw->pw_uid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "0"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sia_ses_release",
          "args": [
            "&ent"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Couldn't launch session for %s from %s\"",
            "pw->pw_name",
            "host"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sia_ses_launch",
          "args": [
            "sia_collect_trm",
            "ent"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sia_ses_estab",
          "args": [
            "sia_collect_trm",
            "ent"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sia_ses_release",
          "args": [
            "&ent"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sia_make_entity_pwd",
          "args": [
            "pw",
            "ent"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sia_ses_init",
          "args": [
            "&ent",
            "saved_argc",
            "saved_argv",
            "host",
            "pw->pw_name",
            "tty",
            "0",
            "NULL"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_canonical_hostname",
          "args": [
            "options.use_dns"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"log.h\"\n#include \"auth-sia.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/resource.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <pwd.h>\n#include <siad.h>\n#include <sia.h>\n#include \"includes.h\"\n\nvoid\nsession_setup_sia(struct passwd *pw, char *tty)\n{\n\tSIAENTITY *ent = NULL;\n\tconst char *host;\n\n\thost = get_canonical_hostname(options.use_dns);\n\n\tif (sia_ses_init(&ent, saved_argc, saved_argv, host, pw->pw_name,\n\t    tty, 0, NULL) != SIASUCCESS)\n\t\tfatal(\"sia_ses_init failed\");\n\n\tif (sia_make_entity_pwd(pw, ent) != SIASUCCESS) {\n\t\tsia_ses_release(&ent);\n\t\tfatal(\"sia_make_entity_pwd failed\");\n\t}\n\n\tent->authtype = SIA_A_NONE;\n\tif (sia_ses_estab(sia_collect_trm, ent) != SIASUCCESS)\n\t\tfatal(\"Couldn't establish session for %s from %s\",\n\t\t    pw->pw_name, host);\n\n\tif (sia_ses_launch(sia_collect_trm, ent) != SIASUCCESS)\n\t\tfatal(\"Couldn't launch session for %s from %s\",\n\t\t    pw->pw_name, host);\n\n\tsia_ses_release(&ent);\n\n\tsetuid(0);\n\tpermanently_set_uid(pw);\n}"
  },
  {
    "function_name": "sys_auth_passwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-sia.c",
    "lines": "52-81",
    "snippet": "int\nsys_auth_passwd(struct ssh *ssh, const char *pass)\n{\n\tint ret;\n\tSIAENTITY *ent = NULL;\n\tconst char *host;\n\tAuthctxt *authctxt = ssh->authctxt;\n\n\thost = get_canonical_hostname(options.use_dns);\n\n\tif (!authctxt->user || pass == NULL || pass[0] == '\\0')\n\t\treturn (0);\n\n\tif (sia_ses_init(&ent, saved_argc, saved_argv, host, authctxt->user,\n\t    NULL, 0, NULL) != SIASUCCESS)\n\t\treturn (0);\n\n\tif ((ret = sia_ses_authent(NULL, pass, ent)) != SIASUCCESS) {\n\t\terror(\"Couldn't authenticate %s from %s\",\n\t\t    authctxt->user, host);\n\t\tif (ret & SIASTOP)\n\t\t\tsia_ses_release(&ent);\n\n\t\treturn (0);\n\t}\n\n\tsia_ses_release(&ent);\n\n\treturn (1);\n}",
    "includes": [
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"log.h\"",
      "#include \"auth-sia.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/resource.h>",
      "#include <setjmp.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <siad.h>",
      "#include <sia.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sia_ses_release",
          "args": [
            "&ent"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sia_ses_release",
          "args": [
            "&ent"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't authenticate %s from %s\"",
            "authctxt->user",
            "host"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sia_ses_authent",
          "args": [
            "NULL",
            "pass",
            "ent"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sia_ses_init",
          "args": [
            "&ent",
            "saved_argc",
            "saved_argv",
            "host",
            "authctxt->user",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_canonical_hostname",
          "args": [
            "options.use_dns"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"log.h\"\n#include \"auth-sia.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/resource.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <pwd.h>\n#include <siad.h>\n#include <sia.h>\n#include \"includes.h\"\n\nint\nsys_auth_passwd(struct ssh *ssh, const char *pass)\n{\n\tint ret;\n\tSIAENTITY *ent = NULL;\n\tconst char *host;\n\tAuthctxt *authctxt = ssh->authctxt;\n\n\thost = get_canonical_hostname(options.use_dns);\n\n\tif (!authctxt->user || pass == NULL || pass[0] == '\\0')\n\t\treturn (0);\n\n\tif (sia_ses_init(&ent, saved_argc, saved_argv, host, authctxt->user,\n\t    NULL, 0, NULL) != SIASUCCESS)\n\t\treturn (0);\n\n\tif ((ret = sia_ses_authent(NULL, pass, ent)) != SIASUCCESS) {\n\t\terror(\"Couldn't authenticate %s from %s\",\n\t\t    authctxt->user, host);\n\t\tif (ret & SIASTOP)\n\t\t\tsia_ses_release(&ent);\n\n\t\treturn (0);\n\t}\n\n\tsia_ses_release(&ent);\n\n\treturn (1);\n}"
  }
]