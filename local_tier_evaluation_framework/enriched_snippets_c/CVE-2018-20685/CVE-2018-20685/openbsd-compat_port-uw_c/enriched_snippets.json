[
  {
    "function_name": "get_iaf_password",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-uw.c",
    "lines": "135-150",
    "snippet": "char *\nget_iaf_password(struct passwd *pw)\n{\n\tchar *pw_password = NULL;\n\n\tuinfo_t uinfo;\n\tif (!ia_openinfo(pw->pw_name,&uinfo)) {\n\t\tia_get_logpwd(uinfo, &pw_password);\n\t\tif (pw_password == NULL)\n\t\t\tfatal(\"ia_get_logpwd: Unable to get the shadow passwd\");\n\t\tia_closeinfo(uinfo);\n\t \treturn pw_password;\n\t}\n\telse\n\t\tfatal(\"ia_openinfo: Unable to open the shadow passwd file\");\n}",
    "includes": [
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"\t/* servconf.h needs misc.h for struct ForwardOptions */",
      "#include \"log.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <crypt.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"ia_openinfo: Unable to open the shadow passwd file\""
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ia_closeinfo",
          "args": [
            "uinfo"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ia_get_logpwd",
          "args": [
            "uinfo",
            "&pw_password"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ia_openinfo",
          "args": [
            "pw->pw_name",
            "&uinfo"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\t/* servconf.h needs misc.h for struct ForwardOptions */\n#include \"log.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <crypt.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_iaf_password(struct passwd *pw)\n{\n\tchar *pw_password = NULL;\n\n\tuinfo_t uinfo;\n\tif (!ia_openinfo(pw->pw_name,&uinfo)) {\n\t\tia_get_logpwd(uinfo, &pw_password);\n\t\tif (pw_password == NULL)\n\t\t\tfatal(\"ia_get_logpwd: Unable to get the shadow passwd\");\n\t\tia_closeinfo(uinfo);\n\t \treturn pw_password;\n\t}\n\telse\n\t\tfatal(\"ia_openinfo: Unable to open the shadow passwd file\");\n}"
  },
  {
    "function_name": "nischeck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-uw.c",
    "lines": "94-125",
    "snippet": "int\nnischeck(char *namep)\n{\n\tchar password_file[] = \"/etc/passwd\";\n\tFILE *fd;\n\tstruct passwd *ent = NULL;\n\n\tif ((fd = fopen (password_file, \"r\")) == NULL) {\n\t\t/*\n\t\t * If the passwd file has disappeared we are in a bad state.\n\t\t * However, returning 0 will send us back through the\n\t\t * authentication scheme that has checked the ia database for\n\t\t * passwords earlier.\n\t\t */\n\t\treturn(0);\n\t}\n\n\t/*\n\t * fgetpwent() only reads from password file, so we know for certain\n\t * that the user is local.\n\t */\n\twhile (ent = fgetpwent(fd)) {\n\t\tif (strcmp (ent->pw_name, namep) == 0) {\n\t\t\t/* Local user */\n\t\t\tfclose (fd);\n\t\t\treturn(0);\n\t\t}\n\t}\n\n\tfclose (fd);\n\treturn (1);\n}",
    "includes": [
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"\t/* servconf.h needs misc.h for struct ForwardOptions */",
      "#include \"log.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <crypt.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fd"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fd"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ent->pw_name",
            "namep"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgetpwent",
          "args": [
            "fd"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "password_file",
            "\"r\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\t/* servconf.h needs misc.h for struct ForwardOptions */\n#include \"log.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <crypt.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nnischeck(char *namep)\n{\n\tchar password_file[] = \"/etc/passwd\";\n\tFILE *fd;\n\tstruct passwd *ent = NULL;\n\n\tif ((fd = fopen (password_file, \"r\")) == NULL) {\n\t\t/*\n\t\t * If the passwd file has disappeared we are in a bad state.\n\t\t * However, returning 0 will send us back through the\n\t\t * authentication scheme that has checked the ia database for\n\t\t * passwords earlier.\n\t\t */\n\t\treturn(0);\n\t}\n\n\t/*\n\t * fgetpwent() only reads from password file, so we know for certain\n\t * that the user is local.\n\t */\n\twhile (ent = fgetpwent(fd)) {\n\t\tif (strcmp (ent->pw_name, namep) == 0) {\n\t\t\t/* Local user */\n\t\t\tfclose (fd);\n\t\t\treturn(0);\n\t\t}\n\t}\n\n\tfclose (fd);\n\treturn (1);\n}"
  },
  {
    "function_name": "sys_auth_passwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-uw.c",
    "lines": "52-91",
    "snippet": "int\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tchar *salt;\n\tint result;\n\n\t/* Just use the supplied fake password if authctxt is invalid */\n\tchar *pw_password = authctxt->valid ? shadow_pw(pw) : pw->pw_passwd;\n\n\tif (pw_password == NULL)\n\t\treturn 0;\n\n\t/* Check for users with no password. */\n\tif (strcmp(pw_password, \"\") == 0 && strcmp(password, \"\") == 0)\n\t\treturn (1);\n\n\t/* Encrypt the candidate password using the proper salt. */\n\tsalt = (pw_password[0] && pw_password[1]) ? pw_password : \"xx\";\n\n\t/*\n\t * Authentication is accepted if the encrypted passwords\n\t * are identical.\n\t */\n#ifdef UNIXWARE_LONG_PASSWORDS\n\tif (!nischeck(pw->pw_name)) {\n\t\tresult = ((strcmp(bigcrypt(password, salt), pw_password) == 0)\n\t\t||  (strcmp(osr5bigcrypt(password, salt), pw_password) == 0));\n\t}\n\telse\n#endif /* UNIXWARE_LONG_PASSWORDS */\n\t\tresult = (strcmp(xcrypt(password, salt), pw_password) == 0);\n\n#ifdef USE_LIBIAF\n\tif (authctxt->valid)\n\t\tfree(pw_password);\n#endif\n\treturn(result);\n}",
    "includes": [
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"\t/* servconf.h needs misc.h for struct ForwardOptions */",
      "#include \"log.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <crypt.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pw_password"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "xcrypt(password, salt)",
            "pw_password"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcrypt",
          "args": [
            "password",
            "salt"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "xcrypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/xcrypt.c",
          "lines": "99-128",
          "snippet": "char *\nxcrypt(const char *password, const char *salt)\n{\n\tchar *crypted;\n\n\t/*\n\t * If we don't have a salt we are encrypting a fake password for\n\t * for timing purposes.  Pick an appropriate salt.\n\t */\n\tif (salt == NULL)\n\t\tsalt = pick_salt();\n\n# ifdef HAVE_MD5_PASSWORDS\n\tif (is_md5_salt(salt))\n\t\tcrypted = md5_crypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(__hpux) && !defined(HAVE_SECUREWARE)\n\tif (iscomsec())\n\t\tcrypted = bigcrypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(HAVE_SECUREWARE)\n\tcrypted = bigcrypt(password, salt);\n# else\n\tcrypted = crypt(password, salt);\n# endif\n\n\treturn crypted;\n}",
          "includes": [
            "#  include <openssl/des.h>",
            "#  include \"md5crypt.h\"",
            "#  include <pwdadj.h>",
            "#  include <sys/audit.h>",
            "#  include <sys/label.h>",
            "#  include <shadow.h>",
            "#  include <prot.h>",
            "#  include <sys/audit.h>",
            "#  include <sys/security.h>",
            "#  include <prot.h>",
            "#  include <hpsecurity.h>",
            "#  include <crypt.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <openssl/des.h>\n#  include \"md5crypt.h\"\n#  include <pwdadj.h>\n#  include <sys/audit.h>\n#  include <sys/label.h>\n#  include <shadow.h>\n#  include <prot.h>\n#  include <sys/audit.h>\n#  include <sys/security.h>\n#  include <prot.h>\n#  include <hpsecurity.h>\n#  include <crypt.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nxcrypt(const char *password, const char *salt)\n{\n\tchar *crypted;\n\n\t/*\n\t * If we don't have a salt we are encrypting a fake password for\n\t * for timing purposes.  Pick an appropriate salt.\n\t */\n\tif (salt == NULL)\n\t\tsalt = pick_salt();\n\n# ifdef HAVE_MD5_PASSWORDS\n\tif (is_md5_salt(salt))\n\t\tcrypted = md5_crypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(__hpux) && !defined(HAVE_SECUREWARE)\n\tif (iscomsec())\n\t\tcrypted = bigcrypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(HAVE_SECUREWARE)\n\tcrypted = bigcrypt(password, salt);\n# else\n\tcrypted = crypt(password, salt);\n# endif\n\n\treturn crypted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "osr5bigcrypt",
          "args": [
            "password",
            "salt"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bigcrypt",
          "args": [
            "password",
            "salt"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nischeck",
          "args": [
            "pw->pw_name"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "nischeck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-uw.c",
          "lines": "94-125",
          "snippet": "int\nnischeck(char *namep)\n{\n\tchar password_file[] = \"/etc/passwd\";\n\tFILE *fd;\n\tstruct passwd *ent = NULL;\n\n\tif ((fd = fopen (password_file, \"r\")) == NULL) {\n\t\t/*\n\t\t * If the passwd file has disappeared we are in a bad state.\n\t\t * However, returning 0 will send us back through the\n\t\t * authentication scheme that has checked the ia database for\n\t\t * passwords earlier.\n\t\t */\n\t\treturn(0);\n\t}\n\n\t/*\n\t * fgetpwent() only reads from password file, so we know for certain\n\t * that the user is local.\n\t */\n\twhile (ent = fgetpwent(fd)) {\n\t\tif (strcmp (ent->pw_name, namep) == 0) {\n\t\t\t/* Local user */\n\t\t\tfclose (fd);\n\t\t\treturn(0);\n\t\t}\n\t}\n\n\tfclose (fd);\n\treturn (1);\n}",
          "includes": [
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"\t/* servconf.h needs misc.h for struct ForwardOptions */",
            "#include \"log.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <crypt.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\t/* servconf.h needs misc.h for struct ForwardOptions */\n#include \"log.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <crypt.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nnischeck(char *namep)\n{\n\tchar password_file[] = \"/etc/passwd\";\n\tFILE *fd;\n\tstruct passwd *ent = NULL;\n\n\tif ((fd = fopen (password_file, \"r\")) == NULL) {\n\t\t/*\n\t\t * If the passwd file has disappeared we are in a bad state.\n\t\t * However, returning 0 will send us back through the\n\t\t * authentication scheme that has checked the ia database for\n\t\t * passwords earlier.\n\t\t */\n\t\treturn(0);\n\t}\n\n\t/*\n\t * fgetpwent() only reads from password file, so we know for certain\n\t * that the user is local.\n\t */\n\twhile (ent = fgetpwent(fd)) {\n\t\tif (strcmp (ent->pw_name, namep) == 0) {\n\t\t\t/* Local user */\n\t\t\tfclose (fd);\n\t\t\treturn(0);\n\t\t}\n\t}\n\n\tfclose (fd);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shadow_pw",
          "args": [
            "pw"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "shadow_pw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/xcrypt.c",
          "lines": "135-163",
          "snippet": "char *\nshadow_pw(struct passwd *pw)\n{\n\tchar *pw_password = pw->pw_passwd;\n\n# if defined(HAVE_SHADOW_H) && !defined(DISABLE_SHADOW)\n\tstruct spwd *spw = getspnam(pw->pw_name);\n\n\tif (spw != NULL)\n\t\tpw_password = spw->sp_pwdp;\n# endif\n\n#ifdef USE_LIBIAF\n\treturn(get_iaf_password(pw));\n#endif\n\n# if defined(HAVE_GETPWANAM) && !defined(DISABLE_SHADOW)\n\tstruct passwd_adjunct *spw;\n\tif (issecure() && (spw = getpwanam(pw->pw_name)) != NULL)\n\t\tpw_password = spw->pwa_passwd;\n# elif defined(HAVE_SECUREWARE)\n\tstruct pr_passwd *spw = getprpwnam(pw->pw_name);\n\n\tif (spw != NULL)\n\t\tpw_password = spw->ufld.fd_encrypt;\n# endif\n\n\treturn pw_password;\n}",
          "includes": [
            "#  include <openssl/des.h>",
            "#  include \"md5crypt.h\"",
            "#  include <pwdadj.h>",
            "#  include <sys/audit.h>",
            "#  include <sys/label.h>",
            "#  include <shadow.h>",
            "#  include <prot.h>",
            "#  include <sys/audit.h>",
            "#  include <sys/security.h>",
            "#  include <prot.h>",
            "#  include <hpsecurity.h>",
            "#  include <crypt.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <openssl/des.h>\n#  include \"md5crypt.h\"\n#  include <pwdadj.h>\n#  include <sys/audit.h>\n#  include <sys/label.h>\n#  include <shadow.h>\n#  include <prot.h>\n#  include <sys/audit.h>\n#  include <sys/security.h>\n#  include <prot.h>\n#  include <hpsecurity.h>\n#  include <crypt.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nshadow_pw(struct passwd *pw)\n{\n\tchar *pw_password = pw->pw_passwd;\n\n# if defined(HAVE_SHADOW_H) && !defined(DISABLE_SHADOW)\n\tstruct spwd *spw = getspnam(pw->pw_name);\n\n\tif (spw != NULL)\n\t\tpw_password = spw->sp_pwdp;\n# endif\n\n#ifdef USE_LIBIAF\n\treturn(get_iaf_password(pw));\n#endif\n\n# if defined(HAVE_GETPWANAM) && !defined(DISABLE_SHADOW)\n\tstruct passwd_adjunct *spw;\n\tif (issecure() && (spw = getpwanam(pw->pw_name)) != NULL)\n\t\tpw_password = spw->pwa_passwd;\n# elif defined(HAVE_SECUREWARE)\n\tstruct pr_passwd *spw = getprpwnam(pw->pw_name);\n\n\tif (spw != NULL)\n\t\tpw_password = spw->ufld.fd_encrypt;\n# endif\n\n\treturn pw_password;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\t/* servconf.h needs misc.h for struct ForwardOptions */\n#include \"log.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <crypt.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tchar *salt;\n\tint result;\n\n\t/* Just use the supplied fake password if authctxt is invalid */\n\tchar *pw_password = authctxt->valid ? shadow_pw(pw) : pw->pw_passwd;\n\n\tif (pw_password == NULL)\n\t\treturn 0;\n\n\t/* Check for users with no password. */\n\tif (strcmp(pw_password, \"\") == 0 && strcmp(password, \"\") == 0)\n\t\treturn (1);\n\n\t/* Encrypt the candidate password using the proper salt. */\n\tsalt = (pw_password[0] && pw_password[1]) ? pw_password : \"xx\";\n\n\t/*\n\t * Authentication is accepted if the encrypted passwords\n\t * are identical.\n\t */\n#ifdef UNIXWARE_LONG_PASSWORDS\n\tif (!nischeck(pw->pw_name)) {\n\t\tresult = ((strcmp(bigcrypt(password, salt), pw_password) == 0)\n\t\t||  (strcmp(osr5bigcrypt(password, salt), pw_password) == 0));\n\t}\n\telse\n#endif /* UNIXWARE_LONG_PASSWORDS */\n\t\tresult = (strcmp(xcrypt(password, salt), pw_password) == 0);\n\n#ifdef USE_LIBIAF\n\tif (authctxt->valid)\n\t\tfree(pw_password);\n#endif\n\treturn(result);\n}"
  }
]