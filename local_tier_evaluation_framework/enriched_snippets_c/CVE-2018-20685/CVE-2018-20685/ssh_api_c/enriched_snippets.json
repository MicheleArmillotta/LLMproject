[
  {
    "function_name": "_ssh_host_key_sign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "536-542",
    "snippet": "int\n_ssh_host_key_sign(struct sshkey *privkey, struct sshkey *pubkey,\n    u_char **signature, size_t *slen, const u_char *data, size_t dlen,\n    const char *alg, u_int compat)\n{\n\treturn sshkey_sign(privkey, signature, slen, data, dlen, alg, compat);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_host_key_sign(struct sshkey *, struct sshkey *,\n    u_char **, size_t *, const u_char *, size_t, const char *, u_int);",
      "int\tmm_sshkey_sign(struct sshkey *, u_char **, u_int *,\n    u_char *, u_int, char *, u_int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_sign",
          "args": [
            "privkey",
            "signature",
            "slen",
            "data",
            "dlen",
            "alg",
            "compat"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "mm_sshkey_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "59-64",
          "snippet": "int\nmm_sshkey_sign(struct sshkey *key, u_char **sigp, u_int *lenp,\n    u_char *data, u_int datalen, char *alg, u_int compat)\n{\n\treturn (-1);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_host_key_sign(struct sshkey *, struct sshkey *,\n    u_char **, size_t *, const u_char *, size_t, const char *, u_int);",
            "int\tmm_sshkey_sign(struct sshkey *, u_char **, u_int *,\n    u_char *, u_int, char *, u_int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_host_key_sign(struct sshkey *, struct sshkey *,\n    u_char **, size_t *, const u_char *, size_t, const char *, u_int);\nint\tmm_sshkey_sign(struct sshkey *, u_char **, u_int *,\n    u_char *, u_int, char *, u_int);\n\nint\nmm_sshkey_sign(struct sshkey *key, u_char **sigp, u_int *lenp,\n    u_char *data, u_int datalen, char *alg, u_int compat)\n{\n\treturn (-1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_host_key_sign(struct sshkey *, struct sshkey *,\n    u_char **, size_t *, const u_char *, size_t, const char *, u_int);\nint\tmm_sshkey_sign(struct sshkey *, u_char **, u_int *,\n    u_char *, u_int, char *, u_int);\n\nint\n_ssh_host_key_sign(struct sshkey *privkey, struct sshkey *pubkey,\n    u_char **signature, size_t *slen, const u_char *data, size_t dlen,\n    const char *alg, u_int compat)\n{\n\treturn sshkey_sign(privkey, signature, slen, data, dlen, alg, compat);\n}"
  },
  {
    "function_name": "_ssh_order_hostkeyalgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "484-534",
    "snippet": "int\n_ssh_order_hostkeyalgs(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\tchar *orig, *avail, *oavail = NULL, *alg, *replace = NULL;\n\tchar **proposal;\n\tsize_t maxlen;\n\tint ktype, r;\n\n\t/* XXX we de-serialize ssh->kex->my, modify it, and change it */\n\tif ((r = kex_buf2prop(ssh->kex->my, NULL, &proposal)) != 0)\n\t\treturn r;\n\torig = proposal[PROPOSAL_SERVER_HOST_KEY_ALGS];\n\tif ((oavail = avail = strdup(orig)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tmaxlen = strlen(avail) + 1;\n\tif ((replace = calloc(1, maxlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t*replace = '\\0';\n\twhile ((alg = strsep(&avail, \",\")) && *alg != '\\0') {\n\t\tif ((ktype = sshkey_type_from_name(alg)) == KEY_UNSPEC)\n\t\t\tcontinue;\n\t\tTAILQ_FOREACH(k, &ssh->public_keys, next) {\n\t\t\tif (k->key->type == ktype ||\n\t\t\t    (sshkey_is_cert(k->key) && k->key->type ==\n\t\t\t    sshkey_type_plain(ktype))) {\n\t\t\t\tif (*replace != '\\0')\n\t\t\t\t\tstrlcat(replace, \",\", maxlen);\n\t\t\t\tstrlcat(replace, alg, maxlen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (*replace != '\\0') {\n\t\tdebug2(\"%s: orig/%d    %s\", __func__, ssh->kex->server, orig);\n\t\tdebug2(\"%s: replace/%d %s\", __func__, ssh->kex->server, replace);\n\t\tfree(orig);\n\t\tproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = replace;\n\t\treplace = NULL;\t/* owned by proposal */\n\t\tr = kex_prop2buf(ssh->kex->my, proposal);\n\t}\n out:\n\tfree(oavail);\n\tfree(replace);\n\tkex_prop_free(proposal);\n\treturn r;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kex_prop_free",
          "args": [
            "proposal"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "kex_prop_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "365-375",
          "snippet": "void\nkex_prop_free(char **proposal)\n{\n\tu_int i;\n\n\tif (proposal == NULL)\n\t\treturn;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tfree(proposal[i]);\n\tfree(proposal);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nvoid\nkex_prop_free(char **proposal)\n{\n\tu_int i;\n\n\tif (proposal == NULL)\n\t\treturn;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tfree(proposal[i]);\n\tfree(proposal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "replace"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "139-162",
          "snippet": "void\nssh_free(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tssh_packet_close(ssh);\n\t/*\n\t * we've only created the public keys variants in case we\n\t * are a acting as a server.\n\t */\n\twhile ((k = TAILQ_FIRST(&ssh->public_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->public_keys, k, next);\n\t\tif (ssh->kex && ssh->kex->server)\n\t\t\tsshkey_free(k->key);\n\t\tfree(k);\n\t}\n\twhile ((k = TAILQ_FIRST(&ssh->private_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->private_keys, k, next);\n\t\tfree(k);\n\t}\n\tif (ssh->kex)\n\t\tkex_free(ssh->kex);\n\tfree(ssh);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nvoid\nssh_free(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tssh_packet_close(ssh);\n\t/*\n\t * we've only created the public keys variants in case we\n\t * are a acting as a server.\n\t */\n\twhile ((k = TAILQ_FIRST(&ssh->public_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->public_keys, k, next);\n\t\tif (ssh->kex && ssh->kex->server)\n\t\t\tsshkey_free(k->key);\n\t\tfree(k);\n\t}\n\twhile ((k = TAILQ_FIRST(&ssh->private_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->private_keys, k, next);\n\t\tfree(k);\n\t}\n\tif (ssh->kex)\n\t\tkex_free(ssh->kex);\n\tfree(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_prop2buf",
          "args": [
            "ssh->kex->my",
            "proposal"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "kex_prop2buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "297-321",
          "snippet": "int\nkex_prop2buf(struct sshbuf *b, char *proposal[PROPOSAL_MAX])\n{\n\tu_int i;\n\tint r;\n\n\tsshbuf_reset(b);\n\n\t/*\n\t * add a dummy cookie, the cookie will be overwritten by\n\t * kex_send_kexinit(), each time a kexinit is set\n\t */\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++) {\n\t\tif ((r = sshbuf_put_u8(b, 0)) != 0)\n\t\t\treturn r;\n\t}\n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tif ((r = sshbuf_put_cstring(b, proposal[i])) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* first_kex_packet_follows */\n\t    (r = sshbuf_put_u32(b, 0)) != 0)\t/* uint32 reserved */\n\t\treturn r;\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nint\nkex_prop2buf(struct sshbuf *b, char *proposal[PROPOSAL_MAX])\n{\n\tu_int i;\n\tint r;\n\n\tsshbuf_reset(b);\n\n\t/*\n\t * add a dummy cookie, the cookie will be overwritten by\n\t * kex_send_kexinit(), each time a kexinit is set\n\t */\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++) {\n\t\tif ((r = sshbuf_put_u8(b, 0)) != 0)\n\t\t\treturn r;\n\t}\n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tif ((r = sshbuf_put_cstring(b, proposal[i])) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* first_kex_packet_follows */\n\t    (r = sshbuf_put_u32(b, 0)) != 0)\t/* uint32 reserved */\n\t\treturn r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: replace/%d %s\"",
            "__func__",
            "ssh->kex->server",
            "replace"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "replace",
            "alg",
            "maxlen"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "strlcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcat.c",
          "lines": "34-60",
          "snippet": "size_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "ktype"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "k->key"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH",
          "args": [
            "k",
            "&ssh->public_keys",
            "next"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "alg"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&avail",
            "\",\""
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "xstrsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keyscan.c",
          "lines": "162-178",
          "snippet": "static char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}",
          "includes": [
            "#include \"dns.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"myproposal.h\"",
            "#include \"compat.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <openssl/bn.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/resource.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"compat.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <netdb.h>\n#include <openssl/bn.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/resource.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "maxlen"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "avail"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "orig"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_buf2prop",
          "args": [
            "ssh->kex->my",
            "NULL",
            "&proposal"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "kex_buf2prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "324-363",
          "snippet": "int\nkex_buf2prop(struct sshbuf *raw, int *first_kex_follows, char ***propp)\n{\n\tstruct sshbuf *b = NULL;\n\tu_char v;\n\tu_int i;\n\tchar **proposal = NULL;\n\tint r;\n\n\t*propp = NULL;\n\tif ((proposal = calloc(PROPOSAL_MAX, sizeof(char *))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((b = sshbuf_fromb(raw)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(b, KEX_COOKIE_LEN)) != 0) /* skip cookie */\n\t\tgoto out;\n\t/* extract kex init proposal strings */\n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tif ((r = sshbuf_get_cstring(b, &(proposal[i]), NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"%s: %s\", proposal_names[i], proposal[i]);\n\t}\n\t/* first kex follows / reserved */\n\tif ((r = sshbuf_get_u8(b, &v)) != 0 ||\t/* first_kex_follows */\n\t    (r = sshbuf_get_u32(b, &i)) != 0)\t/* reserved */\n\t\tgoto out;\n\tif (first_kex_follows != NULL)\n\t\t*first_kex_follows = v;\n\tdebug2(\"first_kex_follows %d \", v);\n\tdebug2(\"reserved %u \", i);\n\tr = 0;\n\t*propp = proposal;\n out:\n\tif (r != 0 && proposal != NULL)\n\t\tkex_prop_free(proposal);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *proposal_names[PROPOSAL_MAX] = {\n\t\"KEX algorithms\",\n\t\"host key algorithms\",\n\t\"ciphers ctos\",\n\t\"ciphers stoc\",\n\t\"MACs ctos\",\n\t\"MACs stoc\",\n\t\"compression ctos\",\n\t\"compression stoc\",\n\t\"languages ctos\",\n\t\"languages stoc\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nstatic const char *proposal_names[PROPOSAL_MAX] = {\n\t\"KEX algorithms\",\n\t\"host key algorithms\",\n\t\"ciphers ctos\",\n\t\"ciphers stoc\",\n\t\"MACs ctos\",\n\t\"MACs stoc\",\n\t\"compression ctos\",\n\t\"compression stoc\",\n\t\"languages ctos\",\n\t\"languages stoc\",\n};\n\nint\nkex_buf2prop(struct sshbuf *raw, int *first_kex_follows, char ***propp)\n{\n\tstruct sshbuf *b = NULL;\n\tu_char v;\n\tu_int i;\n\tchar **proposal = NULL;\n\tint r;\n\n\t*propp = NULL;\n\tif ((proposal = calloc(PROPOSAL_MAX, sizeof(char *))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((b = sshbuf_fromb(raw)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(b, KEX_COOKIE_LEN)) != 0) /* skip cookie */\n\t\tgoto out;\n\t/* extract kex init proposal strings */\n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tif ((r = sshbuf_get_cstring(b, &(proposal[i]), NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"%s: %s\", proposal_names[i], proposal[i]);\n\t}\n\t/* first kex follows / reserved */\n\tif ((r = sshbuf_get_u8(b, &v)) != 0 ||\t/* first_kex_follows */\n\t    (r = sshbuf_get_u32(b, &i)) != 0)\t/* reserved */\n\t\tgoto out;\n\tif (first_kex_follows != NULL)\n\t\t*first_kex_follows = v;\n\tdebug2(\"first_kex_follows %d \", v);\n\tdebug2(\"reserved %u \", i);\n\tr = 0;\n\t*propp = proposal;\n out:\n\tif (r != 0 && proposal != NULL)\n\t\tkex_prop_free(proposal);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\n_ssh_order_hostkeyalgs(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\tchar *orig, *avail, *oavail = NULL, *alg, *replace = NULL;\n\tchar **proposal;\n\tsize_t maxlen;\n\tint ktype, r;\n\n\t/* XXX we de-serialize ssh->kex->my, modify it, and change it */\n\tif ((r = kex_buf2prop(ssh->kex->my, NULL, &proposal)) != 0)\n\t\treturn r;\n\torig = proposal[PROPOSAL_SERVER_HOST_KEY_ALGS];\n\tif ((oavail = avail = strdup(orig)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tmaxlen = strlen(avail) + 1;\n\tif ((replace = calloc(1, maxlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t*replace = '\\0';\n\twhile ((alg = strsep(&avail, \",\")) && *alg != '\\0') {\n\t\tif ((ktype = sshkey_type_from_name(alg)) == KEY_UNSPEC)\n\t\t\tcontinue;\n\t\tTAILQ_FOREACH(k, &ssh->public_keys, next) {\n\t\t\tif (k->key->type == ktype ||\n\t\t\t    (sshkey_is_cert(k->key) && k->key->type ==\n\t\t\t    sshkey_type_plain(ktype))) {\n\t\t\t\tif (*replace != '\\0')\n\t\t\t\t\tstrlcat(replace, \",\", maxlen);\n\t\t\t\tstrlcat(replace, alg, maxlen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (*replace != '\\0') {\n\t\tdebug2(\"%s: orig/%d    %s\", __func__, ssh->kex->server, orig);\n\t\tdebug2(\"%s: replace/%d %s\", __func__, ssh->kex->server, replace);\n\t\tfree(orig);\n\t\tproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = replace;\n\t\treplace = NULL;\t/* owned by proposal */\n\t\tr = kex_prop2buf(ssh->kex->my, proposal);\n\t}\n out:\n\tfree(oavail);\n\tfree(replace);\n\tkex_prop_free(proposal);\n\treturn r;\n}"
  },
  {
    "function_name": "_ssh_verify_host_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "469-481",
    "snippet": "int\n_ssh_verify_host_key(struct sshkey *hostkey, struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tdebug3(\"%s: need %s\", __func__, sshkey_type(hostkey));\n\tTAILQ_FOREACH(k, &ssh->public_keys, next) {\n\t\tdebug3(\"%s: check %s\", __func__, sshkey_type(k->key));\n\t\tif (sshkey_equal_public(hostkey, k->key))\n\t\t\treturn (0);\t/* ok */\n\t}\n\treturn (-1);\t/* failed */\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_equal_public",
          "args": [
            "hostkey",
            "k->key"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "627-702",
          "snippet": "int\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: check %s\"",
            "__func__",
            "sshkey_type(k->key)"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "k->key"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH",
          "args": [
            "k",
            "&ssh->public_keys",
            "next"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\n_ssh_verify_host_key(struct sshkey *hostkey, struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tdebug3(\"%s: need %s\", __func__, sshkey_type(hostkey));\n\tTAILQ_FOREACH(k, &ssh->public_keys, next) {\n\t\tdebug3(\"%s: check %s\", __func__, sshkey_type(k->key));\n\t\tif (sshkey_equal_public(hostkey, k->key))\n\t\t\treturn (0);\t/* ok */\n\t}\n\treturn (-1);\t/* failed */\n}"
  },
  {
    "function_name": "_ssh_host_private_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "454-467",
    "snippet": "struct sshkey *\n_ssh_host_private_key(int type, int nid, struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tdebug3(\"%s: need %d\", __func__, type);\n\tTAILQ_FOREACH(k, &ssh->private_keys, next) {\n\t\tdebug3(\"%s: check %s\", __func__, sshkey_type(k->key));\n\t\tif (k->key->type == type &&\n\t\t    (type != KEY_ECDSA || k->key->ecdsa_nid == nid))\n\t\t\treturn (k->key);\n\t}\n\treturn (NULL);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: check %s\"",
            "__func__",
            "sshkey_type(k->key)"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "k->key"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH",
          "args": [
            "k",
            "&ssh->private_keys",
            "next"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nstruct sshkey *\n_ssh_host_private_key(int type, int nid, struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tdebug3(\"%s: need %d\", __func__, type);\n\tTAILQ_FOREACH(k, &ssh->private_keys, next) {\n\t\tdebug3(\"%s: check %s\", __func__, sshkey_type(k->key));\n\t\tif (k->key->type == type &&\n\t\t    (type != KEY_ECDSA || k->key->ecdsa_nid == nid))\n\t\t\treturn (k->key);\n\t}\n\treturn (NULL);\n}"
  },
  {
    "function_name": "_ssh_host_public_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "439-452",
    "snippet": "struct sshkey *\n_ssh_host_public_key(int type, int nid, struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tdebug3(\"%s: need %d\", __func__, type);\n\tTAILQ_FOREACH(k, &ssh->public_keys, next) {\n\t\tdebug3(\"%s: check %s\", __func__, sshkey_type(k->key));\n\t\tif (k->key->type == type &&\n\t\t    (type != KEY_ECDSA || k->key->ecdsa_nid == nid))\n\t\t\treturn (k->key);\n\t}\n\treturn (NULL);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: check %s\"",
            "__func__",
            "sshkey_type(k->key)"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "k->key"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH",
          "args": [
            "k",
            "&ssh->public_keys",
            "next"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nstruct sshkey *\n_ssh_host_public_key(int type, int nid, struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tdebug3(\"%s: need %d\", __func__, type);\n\tTAILQ_FOREACH(k, &ssh->public_keys, next) {\n\t\tdebug3(\"%s: check %s\", __func__, sshkey_type(k->key));\n\t\tif (k->key->type == type &&\n\t\t    (type != KEY_ECDSA || k->key->ecdsa_nid == nid))\n\t\t\treturn (k->key);\n\t}\n\treturn (NULL);\n}"
  },
  {
    "function_name": "_ssh_exchange_banner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "400-437",
    "snippet": "int\n_ssh_exchange_banner(struct ssh *ssh)\n{\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\t/*\n\t * if _ssh_read_banner() cannot parse a full version string\n\t * it will return NULL and we end up calling it again.\n\t */\n\n\tr = 0;\n\tif (kex->server) {\n\t\tif (kex->server_version_string == NULL)\n\t\t\tr = _ssh_send_banner(ssh, &kex->server_version_string);\n\t\tif (r == 0 &&\n\t\t    kex->server_version_string != NULL &&\n\t\t    kex->client_version_string == NULL)\n\t\t\tr = _ssh_read_banner(ssh, &kex->client_version_string);\n\t} else {\n\t\tif (kex->server_version_string == NULL)\n\t\t\tr = _ssh_read_banner(ssh, &kex->server_version_string);\n\t\tif (r == 0 &&\n\t\t    kex->server_version_string != NULL &&\n\t\t    kex->client_version_string == NULL)\n\t\t\tr = _ssh_send_banner(ssh, &kex->client_version_string);\n\t}\n\tif (r != 0)\n\t\treturn r;\n\t/* start initial kex as soon as we have exchanged the banners */\n\tif (kex->server_version_string != NULL &&\n\t    kex->client_version_string != NULL) {\n\t\tif ((r = _ssh_order_hostkeyalgs(ssh)) != 0 ||\n\t\t    (r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kex_send_kexinit",
          "args": [
            "ssh"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "kex_send_kexinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "498-525",
          "snippet": "int\nkex_send_kexinit(struct ssh *ssh)\n{\n\tu_char *cookie;\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif (kex->flags & KEX_INIT_SENT)\n\t\treturn 0;\n\tkex->done = 0;\n\n\t/* generate a random cookie */\n\tif (sshbuf_len(kex->my) < KEX_COOKIE_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((cookie = sshbuf_mutable_ptr(kex->my)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tarc4random_buf(cookie, KEX_COOKIE_LEN);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_KEXINIT)) != 0 ||\n\t    (r = sshpkt_putb(ssh, kex->my)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\tdebug(\"SSH2_MSG_KEXINIT sent\");\n\tkex->flags |= KEX_INIT_SENT;\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kex_choose_conf(struct ssh *);",
            "static int kex_input_newkeys(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nstatic int kex_choose_conf(struct ssh *);\nstatic int kex_input_newkeys(int, u_int32_t, struct ssh *);\n\nint\nkex_send_kexinit(struct ssh *ssh)\n{\n\tu_char *cookie;\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif (kex->flags & KEX_INIT_SENT)\n\t\treturn 0;\n\tkex->done = 0;\n\n\t/* generate a random cookie */\n\tif (sshbuf_len(kex->my) < KEX_COOKIE_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((cookie = sshbuf_mutable_ptr(kex->my)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tarc4random_buf(cookie, KEX_COOKIE_LEN);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_KEXINIT)) != 0 ||\n\t    (r = sshpkt_putb(ssh, kex->my)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\tdebug(\"SSH2_MSG_KEXINIT sent\");\n\tkex->flags |= KEX_INIT_SENT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ssh_order_hostkeyalgs",
          "args": [
            "ssh"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "_ssh_order_hostkeyalgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "484-534",
          "snippet": "int\n_ssh_order_hostkeyalgs(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\tchar *orig, *avail, *oavail = NULL, *alg, *replace = NULL;\n\tchar **proposal;\n\tsize_t maxlen;\n\tint ktype, r;\n\n\t/* XXX we de-serialize ssh->kex->my, modify it, and change it */\n\tif ((r = kex_buf2prop(ssh->kex->my, NULL, &proposal)) != 0)\n\t\treturn r;\n\torig = proposal[PROPOSAL_SERVER_HOST_KEY_ALGS];\n\tif ((oavail = avail = strdup(orig)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tmaxlen = strlen(avail) + 1;\n\tif ((replace = calloc(1, maxlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t*replace = '\\0';\n\twhile ((alg = strsep(&avail, \",\")) && *alg != '\\0') {\n\t\tif ((ktype = sshkey_type_from_name(alg)) == KEY_UNSPEC)\n\t\t\tcontinue;\n\t\tTAILQ_FOREACH(k, &ssh->public_keys, next) {\n\t\t\tif (k->key->type == ktype ||\n\t\t\t    (sshkey_is_cert(k->key) && k->key->type ==\n\t\t\t    sshkey_type_plain(ktype))) {\n\t\t\t\tif (*replace != '\\0')\n\t\t\t\t\tstrlcat(replace, \",\", maxlen);\n\t\t\t\tstrlcat(replace, alg, maxlen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (*replace != '\\0') {\n\t\tdebug2(\"%s: orig/%d    %s\", __func__, ssh->kex->server, orig);\n\t\tdebug2(\"%s: replace/%d %s\", __func__, ssh->kex->server, replace);\n\t\tfree(orig);\n\t\tproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = replace;\n\t\treplace = NULL;\t/* owned by proposal */\n\t\tr = kex_prop2buf(ssh->kex->my, proposal);\n\t}\n out:\n\tfree(oavail);\n\tfree(replace);\n\tkex_prop_free(proposal);\n\treturn r;\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\n_ssh_order_hostkeyalgs(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\tchar *orig, *avail, *oavail = NULL, *alg, *replace = NULL;\n\tchar **proposal;\n\tsize_t maxlen;\n\tint ktype, r;\n\n\t/* XXX we de-serialize ssh->kex->my, modify it, and change it */\n\tif ((r = kex_buf2prop(ssh->kex->my, NULL, &proposal)) != 0)\n\t\treturn r;\n\torig = proposal[PROPOSAL_SERVER_HOST_KEY_ALGS];\n\tif ((oavail = avail = strdup(orig)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tmaxlen = strlen(avail) + 1;\n\tif ((replace = calloc(1, maxlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t*replace = '\\0';\n\twhile ((alg = strsep(&avail, \",\")) && *alg != '\\0') {\n\t\tif ((ktype = sshkey_type_from_name(alg)) == KEY_UNSPEC)\n\t\t\tcontinue;\n\t\tTAILQ_FOREACH(k, &ssh->public_keys, next) {\n\t\t\tif (k->key->type == ktype ||\n\t\t\t    (sshkey_is_cert(k->key) && k->key->type ==\n\t\t\t    sshkey_type_plain(ktype))) {\n\t\t\t\tif (*replace != '\\0')\n\t\t\t\t\tstrlcat(replace, \",\", maxlen);\n\t\t\t\tstrlcat(replace, alg, maxlen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (*replace != '\\0') {\n\t\tdebug2(\"%s: orig/%d    %s\", __func__, ssh->kex->server, orig);\n\t\tdebug2(\"%s: replace/%d %s\", __func__, ssh->kex->server, replace);\n\t\tfree(orig);\n\t\tproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = replace;\n\t\treplace = NULL;\t/* owned by proposal */\n\t\tr = kex_prop2buf(ssh->kex->my, proposal);\n\t}\n out:\n\tfree(oavail);\n\tfree(replace);\n\tkex_prop_free(proposal);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ssh_send_banner",
          "args": [
            "ssh",
            "&kex->client_version_string"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "_ssh_send_banner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "384-398",
          "snippet": "int\n_ssh_send_banner(struct ssh *ssh, char **bannerp)\n{\n\tchar buf[256];\n\tint r;\n\n\tsnprintf(buf, sizeof buf, \"SSH-2.0-%.100s\\r\\n\", SSH_VERSION);\n\tif ((r = sshbuf_put(ssh_packet_get_output(ssh), buf, strlen(buf))) != 0)\n\t\treturn r;\n\tchop(buf);\n\tdebug(\"Local version string %.100s\", buf);\n\tif ((*bannerp = strdup(buf)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\n_ssh_send_banner(struct ssh *ssh, char **bannerp)\n{\n\tchar buf[256];\n\tint r;\n\n\tsnprintf(buf, sizeof buf, \"SSH-2.0-%.100s\\r\\n\", SSH_VERSION);\n\tif ((r = sshbuf_put(ssh_packet_get_output(ssh), buf, strlen(buf))) != 0)\n\t\treturn r;\n\tchop(buf);\n\tdebug(\"Local version string %.100s\", buf);\n\tif ((*bannerp = strdup(buf)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ssh_read_banner",
          "args": [
            "ssh",
            "&kex->server_version_string"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "_ssh_read_banner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "316-381",
          "snippet": "int\n_ssh_read_banner(struct ssh *ssh, char **bannerp)\n{\n\tstruct sshbuf *input;\n\tconst char *s;\n\tchar buf[256], remote_version[256];\t/* must be same size! */\n\tconst char *mismatch = \"Protocol mismatch.\\r\\n\";\n\tint r, remote_major, remote_minor;\n\tsize_t i, n, j, len;\n\n\t*bannerp = NULL;\n\tinput = ssh_packet_get_input(ssh);\n\tlen = sshbuf_len(input);\n\ts = (const char *)sshbuf_ptr(input);\n\tfor (j = n = 0;;) {\n\t\tfor (i = 0; i < sizeof(buf) - 1; i++) {\n\t\t\tif (j >= len)\n\t\t\t\treturn (0);\n\t\t\tbuf[i] = s[j++];\n\t\t\tif (buf[i] == '\\r') {\n\t\t\t\tbuf[i] = '\\n';\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tcontinue;\t\t/**XXX wait for \\n */\n\t\t\t}\n\t\t\tif (buf[i] == '\\n') {\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbuf[sizeof(buf) - 1] = 0;\n\t\tif (strncmp(buf, \"SSH-\", 4) == 0)\n\t\t\tbreak;\n\t\tdebug(\"ssh_exchange_identification: %s\", buf);\n\t\tif (ssh->kex->server || ++n > 65536) {\n\t\t\tif ((r = sshbuf_put(ssh_packet_get_output(ssh),\n\t\t\t   mismatch, strlen(mismatch))) != 0)\n\t\t\t\treturn r;\n\t\t\treturn SSH_ERR_NO_PROTOCOL_VERSION;\n\t\t}\n\t}\n\tif ((r = sshbuf_consume(input, j)) != 0)\n\t\treturn r;\n\n\t/*\n\t * Check that the versions match.  In future this might accept\n\t * several versions and set appropriate flags to handle them.\n\t */\n\tif (sscanf(buf, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tdebug(\"Remote protocol version %d.%d, remote software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\n\tssh->compat = compat_datafellows(remote_version);\n\tif  (remote_major == 1 && remote_minor == 99) {\n\t\tremote_major = 2;\n\t\tremote_minor = 0;\n\t}\n\tif (remote_major != 2)\n\t\treturn SSH_ERR_PROTOCOL_MISMATCH;\n\tchop(buf);\n\tdebug(\"Remote version string %.100s\", buf);\n\tif ((*bannerp = strdup(buf)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\n_ssh_read_banner(struct ssh *ssh, char **bannerp)\n{\n\tstruct sshbuf *input;\n\tconst char *s;\n\tchar buf[256], remote_version[256];\t/* must be same size! */\n\tconst char *mismatch = \"Protocol mismatch.\\r\\n\";\n\tint r, remote_major, remote_minor;\n\tsize_t i, n, j, len;\n\n\t*bannerp = NULL;\n\tinput = ssh_packet_get_input(ssh);\n\tlen = sshbuf_len(input);\n\ts = (const char *)sshbuf_ptr(input);\n\tfor (j = n = 0;;) {\n\t\tfor (i = 0; i < sizeof(buf) - 1; i++) {\n\t\t\tif (j >= len)\n\t\t\t\treturn (0);\n\t\t\tbuf[i] = s[j++];\n\t\t\tif (buf[i] == '\\r') {\n\t\t\t\tbuf[i] = '\\n';\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tcontinue;\t\t/**XXX wait for \\n */\n\t\t\t}\n\t\t\tif (buf[i] == '\\n') {\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbuf[sizeof(buf) - 1] = 0;\n\t\tif (strncmp(buf, \"SSH-\", 4) == 0)\n\t\t\tbreak;\n\t\tdebug(\"ssh_exchange_identification: %s\", buf);\n\t\tif (ssh->kex->server || ++n > 65536) {\n\t\t\tif ((r = sshbuf_put(ssh_packet_get_output(ssh),\n\t\t\t   mismatch, strlen(mismatch))) != 0)\n\t\t\t\treturn r;\n\t\t\treturn SSH_ERR_NO_PROTOCOL_VERSION;\n\t\t}\n\t}\n\tif ((r = sshbuf_consume(input, j)) != 0)\n\t\treturn r;\n\n\t/*\n\t * Check that the versions match.  In future this might accept\n\t * several versions and set appropriate flags to handle them.\n\t */\n\tif (sscanf(buf, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tdebug(\"Remote protocol version %d.%d, remote software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\n\tssh->compat = compat_datafellows(remote_version);\n\tif  (remote_major == 1 && remote_minor == 99) {\n\t\tremote_major = 2;\n\t\tremote_minor = 0;\n\t}\n\tif (remote_major != 2)\n\t\treturn SSH_ERR_PROTOCOL_MISMATCH;\n\tchop(buf);\n\tdebug(\"Remote version string %.100s\", buf);\n\tif ((*bannerp = strdup(buf)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\n_ssh_exchange_banner(struct ssh *ssh)\n{\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\t/*\n\t * if _ssh_read_banner() cannot parse a full version string\n\t * it will return NULL and we end up calling it again.\n\t */\n\n\tr = 0;\n\tif (kex->server) {\n\t\tif (kex->server_version_string == NULL)\n\t\t\tr = _ssh_send_banner(ssh, &kex->server_version_string);\n\t\tif (r == 0 &&\n\t\t    kex->server_version_string != NULL &&\n\t\t    kex->client_version_string == NULL)\n\t\t\tr = _ssh_read_banner(ssh, &kex->client_version_string);\n\t} else {\n\t\tif (kex->server_version_string == NULL)\n\t\t\tr = _ssh_read_banner(ssh, &kex->server_version_string);\n\t\tif (r == 0 &&\n\t\t    kex->server_version_string != NULL &&\n\t\t    kex->client_version_string == NULL)\n\t\t\tr = _ssh_send_banner(ssh, &kex->client_version_string);\n\t}\n\tif (r != 0)\n\t\treturn r;\n\t/* start initial kex as soon as we have exchanged the banners */\n\tif (kex->server_version_string != NULL &&\n\t    kex->client_version_string != NULL) {\n\t\tif ((r = _ssh_order_hostkeyalgs(ssh)) != 0 ||\n\t\t    (r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "_ssh_send_banner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "384-398",
    "snippet": "int\n_ssh_send_banner(struct ssh *ssh, char **bannerp)\n{\n\tchar buf[256];\n\tint r;\n\n\tsnprintf(buf, sizeof buf, \"SSH-2.0-%.100s\\r\\n\", SSH_VERSION);\n\tif ((r = sshbuf_put(ssh_packet_get_output(ssh), buf, strlen(buf))) != 0)\n\t\treturn r;\n\tchop(buf);\n\tdebug(\"Local version string %.100s\", buf);\n\tif ((*bannerp = strdup(buf)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "buf"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Local version string %.100s\"",
            "buf"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chop",
          "args": [
            "buf"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "chop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "76-89",
          "snippet": "char *\nchop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nchop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "ssh_packet_get_output(ssh)",
            "buf",
            "strlen(buf)"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_get_output",
          "args": [
            "ssh"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_get_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2140-2144",
          "snippet": "void *\nssh_packet_get_output(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->output;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nssh_packet_get_output(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->output;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof buf",
            "\"SSH-2.0-%.100s\\r\\n\"",
            "SSH_VERSION"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\n_ssh_send_banner(struct ssh *ssh, char **bannerp)\n{\n\tchar buf[256];\n\tint r;\n\n\tsnprintf(buf, sizeof buf, \"SSH-2.0-%.100s\\r\\n\", SSH_VERSION);\n\tif ((r = sshbuf_put(ssh_packet_get_output(ssh), buf, strlen(buf))) != 0)\n\t\treturn r;\n\tchop(buf);\n\tdebug(\"Local version string %.100s\", buf);\n\tif ((*bannerp = strdup(buf)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}"
  },
  {
    "function_name": "_ssh_read_banner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "316-381",
    "snippet": "int\n_ssh_read_banner(struct ssh *ssh, char **bannerp)\n{\n\tstruct sshbuf *input;\n\tconst char *s;\n\tchar buf[256], remote_version[256];\t/* must be same size! */\n\tconst char *mismatch = \"Protocol mismatch.\\r\\n\";\n\tint r, remote_major, remote_minor;\n\tsize_t i, n, j, len;\n\n\t*bannerp = NULL;\n\tinput = ssh_packet_get_input(ssh);\n\tlen = sshbuf_len(input);\n\ts = (const char *)sshbuf_ptr(input);\n\tfor (j = n = 0;;) {\n\t\tfor (i = 0; i < sizeof(buf) - 1; i++) {\n\t\t\tif (j >= len)\n\t\t\t\treturn (0);\n\t\t\tbuf[i] = s[j++];\n\t\t\tif (buf[i] == '\\r') {\n\t\t\t\tbuf[i] = '\\n';\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tcontinue;\t\t/**XXX wait for \\n */\n\t\t\t}\n\t\t\tif (buf[i] == '\\n') {\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbuf[sizeof(buf) - 1] = 0;\n\t\tif (strncmp(buf, \"SSH-\", 4) == 0)\n\t\t\tbreak;\n\t\tdebug(\"ssh_exchange_identification: %s\", buf);\n\t\tif (ssh->kex->server || ++n > 65536) {\n\t\t\tif ((r = sshbuf_put(ssh_packet_get_output(ssh),\n\t\t\t   mismatch, strlen(mismatch))) != 0)\n\t\t\t\treturn r;\n\t\t\treturn SSH_ERR_NO_PROTOCOL_VERSION;\n\t\t}\n\t}\n\tif ((r = sshbuf_consume(input, j)) != 0)\n\t\treturn r;\n\n\t/*\n\t * Check that the versions match.  In future this might accept\n\t * several versions and set appropriate flags to handle them.\n\t */\n\tif (sscanf(buf, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tdebug(\"Remote protocol version %d.%d, remote software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\n\tssh->compat = compat_datafellows(remote_version);\n\tif  (remote_major == 1 && remote_minor == 99) {\n\t\tremote_major = 2;\n\t\tremote_minor = 0;\n\t}\n\tif (remote_major != 2)\n\t\treturn SSH_ERR_PROTOCOL_MISMATCH;\n\tchop(buf);\n\tdebug(\"Remote version string %.100s\", buf);\n\tif ((*bannerp = strdup(buf)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "buf"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Remote version string %.100s\"",
            "buf"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chop",
          "args": [
            "buf"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "chop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "76-89",
          "snippet": "char *\nchop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nchop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_datafellows",
          "args": [
            "remote_version"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "compat_datafellows",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/compat.c",
          "lines": "44-158",
          "snippet": "u_int\ncompat_datafellows(const char *version)\n{\n\tint i;\n\tstatic struct {\n\t\tchar\t*pat;\n\t\tint\tbugs;\n\t} check[] = {\n\t\t{ \"OpenSSH_2.*,\"\n\t\t  \"OpenSSH_3.0*,\"\n\t\t  \"OpenSSH_3.1*\",\tSSH_BUG_EXTEOF|SSH_OLD_FORWARD_ADDR|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_3.*\",\tSSH_OLD_FORWARD_ADDR|SSH_BUG_SIGTYPE },\n\t\t{ \"Sun_SSH_1.0*\",\tSSH_BUG_NOREKEY|SSH_BUG_EXTEOF|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_2*,\"\n\t\t  \"OpenSSH_3*,\"\n\t\t  \"OpenSSH_4*\",\t\tSSH_BUG_SIGTYPE },\n\t\t{ \"OpenSSH_5*\",\t\tSSH_NEW_OPENSSH|SSH_BUG_DYNAMIC_RPORT|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_6.6.1*\",\tSSH_NEW_OPENSSH|SSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_6.5*,\"\n\t\t  \"OpenSSH_6.6*\",\tSSH_NEW_OPENSSH|SSH_BUG_CURVE25519PAD|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_7.0*,\"\n\t\t  \"OpenSSH_7.1*,\"\n\t\t  \"OpenSSH_7.2*,\"\n\t\t  \"OpenSSH_7.3*,\"\n\t\t  \"OpenSSH_7.4*,\"\n\t\t  \"OpenSSH_7.5*,\"\n\t\t  \"OpenSSH_7.6*,\"\n\t\t  \"OpenSSH_7.7*\",\tSSH_NEW_OPENSSH|SSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH*\",\t\tSSH_NEW_OPENSSH },\n\t\t{ \"*MindTerm*\",\t\t0 },\n\t\t{ \"3.0.*\",\t\tSSH_BUG_DEBUG },\n\t\t{ \"3.0 SecureCRT*\",\tSSH_OLD_SESSIONID },\n\t\t{ \"1.7 SecureFX*\",\tSSH_OLD_SESSIONID },\n\t\t{ \"1.2.18*,\"\n\t\t  \"1.2.19*,\"\n\t\t  \"1.2.20*,\"\n\t\t  \"1.2.21*,\"\n\t\t  \"1.2.22*\",\t\tSSH_BUG_IGNOREMSG },\n\t\t{ \"1.3.2*\",\t\t/* F-Secure */\n\t\t\t\t\tSSH_BUG_IGNOREMSG },\n\t\t{ \"Cisco-1.*\",\t\tSSH_BUG_DHGEX_LARGE|\n\t\t\t\t\tSSH_BUG_HOSTKEYS },\n\t\t{ \"*SSH Compatible Server*\",\t\t\t/* Netscreen */\n\t\t\t\t\tSSH_BUG_PASSWORDPAD },\n\t\t{ \"*OSU_0*,\"\n\t\t  \"OSU_1.0*,\"\n\t\t  \"OSU_1.1*,\"\n\t\t  \"OSU_1.2*,\"\n\t\t  \"OSU_1.3*,\"\n\t\t  \"OSU_1.4*,\"\n\t\t  \"OSU_1.5alpha1*,\"\n\t\t  \"OSU_1.5alpha2*,\"\n\t\t  \"OSU_1.5alpha3*\",\tSSH_BUG_PASSWORDPAD },\n\t\t{ \"*SSH_Version_Mapper*\",\n\t\t\t\t\tSSH_BUG_SCANNER },\n\t\t{ \"PuTTY_Local:*,\"\t/* dev versions < Sep 2014 */\n\t\t  \"PuTTY-Release-0.5*,\" /* 0.50-0.57, DH-GEX in >=0.52 */\n\t\t  \"PuTTY_Release_0.5*,\"\t/* 0.58-0.59 */\n\t\t  \"PuTTY_Release_0.60*,\"\n\t\t  \"PuTTY_Release_0.61*,\"\n\t\t  \"PuTTY_Release_0.62*,\"\n\t\t  \"PuTTY_Release_0.63*,\"\n\t\t  \"PuTTY_Release_0.64*\",\n\t\t\t\t\tSSH_OLD_DHGEX },\n\t\t{ \"FuTTY*\",\t\tSSH_OLD_DHGEX }, /* Putty Fork */\n\t\t{ \"Probe-*\",\n\t\t\t\t\tSSH_BUG_PROBE },\n\t\t{ \"TeraTerm SSH*,\"\n\t\t  \"TTSSH/1.5.*,\"\n\t\t  \"TTSSH/2.1*,\"\n\t\t  \"TTSSH/2.2*,\"\n\t\t  \"TTSSH/2.3*,\"\n\t\t  \"TTSSH/2.4*,\"\n\t\t  \"TTSSH/2.5*,\"\n\t\t  \"TTSSH/2.6*,\"\n\t\t  \"TTSSH/2.70*,\"\n\t\t  \"TTSSH/2.71*,\"\n\t\t  \"TTSSH/2.72*\",\tSSH_BUG_HOSTKEYS },\n\t\t{ \"WinSCP_release_4*,\"\n\t\t  \"WinSCP_release_5.0*,\"\n\t\t  \"WinSCP_release_5.1,\"\n\t\t  \"WinSCP_release_5.1.*,\"\n\t\t  \"WinSCP_release_5.5,\"\n\t\t  \"WinSCP_release_5.5.*,\"\n\t\t  \"WinSCP_release_5.6,\"\n\t\t  \"WinSCP_release_5.6.*,\"\n\t\t  \"WinSCP_release_5.7,\"\n\t\t  \"WinSCP_release_5.7.1,\"\n\t\t  \"WinSCP_release_5.7.2,\"\n\t\t  \"WinSCP_release_5.7.3,\"\n\t\t  \"WinSCP_release_5.7.4\",\n\t\t\t\t\tSSH_OLD_DHGEX },\n\t\t{ \"ConfD-*\",\n\t\t\t\t\tSSH_BUG_UTF8TTYMODE },\n\t\t{ \"Twisted_*\",\t\t0 },\n\t\t{ \"Twisted*\",\t\tSSH_BUG_DEBUG },\n\t\t{ NULL,\t\t\t0 }\n\t};\n\n\t/* process table, return first match */\n\tfor (i = 0; check[i].pat; i++) {\n\t\tif (match_pattern_list(version, check[i].pat, 0) == 1) {\n\t\t\tdebug(\"match: %s pat %s compat 0x%08x\",\n\t\t\t    version, check[i].pat, check[i].bugs);\n\t\t\tdatafellows = check[i].bugs;\t/* XXX for now */\n\t\t\treturn check[i].bugs;\n\t\t}\n\t}\n\tdebug(\"no match: %s\", version);\n\treturn 0;\n}",
          "includes": [
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int datafellows = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kex.h\"\n#include \"match.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint datafellows = 0;\n\nu_int\ncompat_datafellows(const char *version)\n{\n\tint i;\n\tstatic struct {\n\t\tchar\t*pat;\n\t\tint\tbugs;\n\t} check[] = {\n\t\t{ \"OpenSSH_2.*,\"\n\t\t  \"OpenSSH_3.0*,\"\n\t\t  \"OpenSSH_3.1*\",\tSSH_BUG_EXTEOF|SSH_OLD_FORWARD_ADDR|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_3.*\",\tSSH_OLD_FORWARD_ADDR|SSH_BUG_SIGTYPE },\n\t\t{ \"Sun_SSH_1.0*\",\tSSH_BUG_NOREKEY|SSH_BUG_EXTEOF|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_2*,\"\n\t\t  \"OpenSSH_3*,\"\n\t\t  \"OpenSSH_4*\",\t\tSSH_BUG_SIGTYPE },\n\t\t{ \"OpenSSH_5*\",\t\tSSH_NEW_OPENSSH|SSH_BUG_DYNAMIC_RPORT|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_6.6.1*\",\tSSH_NEW_OPENSSH|SSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_6.5*,\"\n\t\t  \"OpenSSH_6.6*\",\tSSH_NEW_OPENSSH|SSH_BUG_CURVE25519PAD|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_7.0*,\"\n\t\t  \"OpenSSH_7.1*,\"\n\t\t  \"OpenSSH_7.2*,\"\n\t\t  \"OpenSSH_7.3*,\"\n\t\t  \"OpenSSH_7.4*,\"\n\t\t  \"OpenSSH_7.5*,\"\n\t\t  \"OpenSSH_7.6*,\"\n\t\t  \"OpenSSH_7.7*\",\tSSH_NEW_OPENSSH|SSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH*\",\t\tSSH_NEW_OPENSSH },\n\t\t{ \"*MindTerm*\",\t\t0 },\n\t\t{ \"3.0.*\",\t\tSSH_BUG_DEBUG },\n\t\t{ \"3.0 SecureCRT*\",\tSSH_OLD_SESSIONID },\n\t\t{ \"1.7 SecureFX*\",\tSSH_OLD_SESSIONID },\n\t\t{ \"1.2.18*,\"\n\t\t  \"1.2.19*,\"\n\t\t  \"1.2.20*,\"\n\t\t  \"1.2.21*,\"\n\t\t  \"1.2.22*\",\t\tSSH_BUG_IGNOREMSG },\n\t\t{ \"1.3.2*\",\t\t/* F-Secure */\n\t\t\t\t\tSSH_BUG_IGNOREMSG },\n\t\t{ \"Cisco-1.*\",\t\tSSH_BUG_DHGEX_LARGE|\n\t\t\t\t\tSSH_BUG_HOSTKEYS },\n\t\t{ \"*SSH Compatible Server*\",\t\t\t/* Netscreen */\n\t\t\t\t\tSSH_BUG_PASSWORDPAD },\n\t\t{ \"*OSU_0*,\"\n\t\t  \"OSU_1.0*,\"\n\t\t  \"OSU_1.1*,\"\n\t\t  \"OSU_1.2*,\"\n\t\t  \"OSU_1.3*,\"\n\t\t  \"OSU_1.4*,\"\n\t\t  \"OSU_1.5alpha1*,\"\n\t\t  \"OSU_1.5alpha2*,\"\n\t\t  \"OSU_1.5alpha3*\",\tSSH_BUG_PASSWORDPAD },\n\t\t{ \"*SSH_Version_Mapper*\",\n\t\t\t\t\tSSH_BUG_SCANNER },\n\t\t{ \"PuTTY_Local:*,\"\t/* dev versions < Sep 2014 */\n\t\t  \"PuTTY-Release-0.5*,\" /* 0.50-0.57, DH-GEX in >=0.52 */\n\t\t  \"PuTTY_Release_0.5*,\"\t/* 0.58-0.59 */\n\t\t  \"PuTTY_Release_0.60*,\"\n\t\t  \"PuTTY_Release_0.61*,\"\n\t\t  \"PuTTY_Release_0.62*,\"\n\t\t  \"PuTTY_Release_0.63*,\"\n\t\t  \"PuTTY_Release_0.64*\",\n\t\t\t\t\tSSH_OLD_DHGEX },\n\t\t{ \"FuTTY*\",\t\tSSH_OLD_DHGEX }, /* Putty Fork */\n\t\t{ \"Probe-*\",\n\t\t\t\t\tSSH_BUG_PROBE },\n\t\t{ \"TeraTerm SSH*,\"\n\t\t  \"TTSSH/1.5.*,\"\n\t\t  \"TTSSH/2.1*,\"\n\t\t  \"TTSSH/2.2*,\"\n\t\t  \"TTSSH/2.3*,\"\n\t\t  \"TTSSH/2.4*,\"\n\t\t  \"TTSSH/2.5*,\"\n\t\t  \"TTSSH/2.6*,\"\n\t\t  \"TTSSH/2.70*,\"\n\t\t  \"TTSSH/2.71*,\"\n\t\t  \"TTSSH/2.72*\",\tSSH_BUG_HOSTKEYS },\n\t\t{ \"WinSCP_release_4*,\"\n\t\t  \"WinSCP_release_5.0*,\"\n\t\t  \"WinSCP_release_5.1,\"\n\t\t  \"WinSCP_release_5.1.*,\"\n\t\t  \"WinSCP_release_5.5,\"\n\t\t  \"WinSCP_release_5.5.*,\"\n\t\t  \"WinSCP_release_5.6,\"\n\t\t  \"WinSCP_release_5.6.*,\"\n\t\t  \"WinSCP_release_5.7,\"\n\t\t  \"WinSCP_release_5.7.1,\"\n\t\t  \"WinSCP_release_5.7.2,\"\n\t\t  \"WinSCP_release_5.7.3,\"\n\t\t  \"WinSCP_release_5.7.4\",\n\t\t\t\t\tSSH_OLD_DHGEX },\n\t\t{ \"ConfD-*\",\n\t\t\t\t\tSSH_BUG_UTF8TTYMODE },\n\t\t{ \"Twisted_*\",\t\t0 },\n\t\t{ \"Twisted*\",\t\tSSH_BUG_DEBUG },\n\t\t{ NULL,\t\t\t0 }\n\t};\n\n\t/* process table, return first match */\n\tfor (i = 0; check[i].pat; i++) {\n\t\tif (match_pattern_list(version, check[i].pat, 0) == 1) {\n\t\t\tdebug(\"match: %s pat %s compat 0x%08x\",\n\t\t\t    version, check[i].pat, check[i].bugs);\n\t\t\tdatafellows = check[i].bugs;\t/* XXX for now */\n\t\t\treturn check[i].bugs;\n\t\t}\n\t}\n\tdebug(\"no match: %s\", version);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"SSH-%d.%d-%[^\\n]\\n\"",
            "&remote_major",
            "&remote_minor",
            "remote_version"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "input",
            "j"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "ssh_packet_get_output(ssh)",
            "mismatch",
            "strlen(mismatch)"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mismatch"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_get_output",
          "args": [
            "ssh"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_get_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2140-2144",
          "snippet": "void *\nssh_packet_get_output(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->output;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nssh_packet_get_output(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->output;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"SSH-\"",
            "4"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "input"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "input"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_get_input",
          "args": [
            "ssh"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_get_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2134-2138",
          "snippet": "void *\nssh_packet_get_input(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->input;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nssh_packet_get_input(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->input;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\n_ssh_read_banner(struct ssh *ssh, char **bannerp)\n{\n\tstruct sshbuf *input;\n\tconst char *s;\n\tchar buf[256], remote_version[256];\t/* must be same size! */\n\tconst char *mismatch = \"Protocol mismatch.\\r\\n\";\n\tint r, remote_major, remote_minor;\n\tsize_t i, n, j, len;\n\n\t*bannerp = NULL;\n\tinput = ssh_packet_get_input(ssh);\n\tlen = sshbuf_len(input);\n\ts = (const char *)sshbuf_ptr(input);\n\tfor (j = n = 0;;) {\n\t\tfor (i = 0; i < sizeof(buf) - 1; i++) {\n\t\t\tif (j >= len)\n\t\t\t\treturn (0);\n\t\t\tbuf[i] = s[j++];\n\t\t\tif (buf[i] == '\\r') {\n\t\t\t\tbuf[i] = '\\n';\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tcontinue;\t\t/**XXX wait for \\n */\n\t\t\t}\n\t\t\tif (buf[i] == '\\n') {\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbuf[sizeof(buf) - 1] = 0;\n\t\tif (strncmp(buf, \"SSH-\", 4) == 0)\n\t\t\tbreak;\n\t\tdebug(\"ssh_exchange_identification: %s\", buf);\n\t\tif (ssh->kex->server || ++n > 65536) {\n\t\t\tif ((r = sshbuf_put(ssh_packet_get_output(ssh),\n\t\t\t   mismatch, strlen(mismatch))) != 0)\n\t\t\t\treturn r;\n\t\t\treturn SSH_ERR_NO_PROTOCOL_VERSION;\n\t\t}\n\t}\n\tif ((r = sshbuf_consume(input, j)) != 0)\n\t\treturn r;\n\n\t/*\n\t * Check that the versions match.  In future this might accept\n\t * several versions and set appropriate flags to handle them.\n\t */\n\tif (sscanf(buf, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tdebug(\"Remote protocol version %d.%d, remote software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\n\tssh->compat = compat_datafellows(remote_version);\n\tif  (remote_major == 1 && remote_minor == 99) {\n\t\tremote_major = 2;\n\t\tremote_minor = 0;\n\t}\n\tif (remote_major != 2)\n\t\treturn SSH_ERR_PROTOCOL_MISMATCH;\n\tchop(buf);\n\tdebug(\"Remote version string %.100s\", buf);\n\tif ((*bannerp = strdup(buf)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_input_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "309-313",
    "snippet": "int\nssh_input_space(struct ssh *ssh, size_t len)\n{\n\treturn (0 == sshbuf_check_reserve(ssh_packet_get_input(ssh), len));\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_check_reserve",
          "args": [
            "ssh_packet_get_input(ssh)",
            "len"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "284-298",
          "snippet": "int\nsshbuf_check_reserve(const struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tSSHBUF_TELL(\"check\");\n\t/* Check that len is reasonable and that max_size + available < len */\n\tif (len > buf->max_size || buf->max_size - len < buf->size - buf->off)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_check_reserve(const struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tSSHBUF_TELL(\"check\");\n\t/* Check that len is reasonable and that max_size + available < len */\n\tif (len > buf->max_size || buf->max_size - len < buf->size - buf->off)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_get_input",
          "args": [
            "ssh"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_get_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2134-2138",
          "snippet": "void *\nssh_packet_get_input(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->input;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nssh_packet_get_input(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->input;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_input_space(struct ssh *ssh, size_t len)\n{\n\treturn (0 == sshbuf_check_reserve(ssh_packet_get_input(ssh), len));\n}"
  },
  {
    "function_name": "ssh_output_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "303-307",
    "snippet": "int\nssh_output_space(struct ssh *ssh, size_t len)\n{\n\treturn (0 == sshbuf_check_reserve(ssh_packet_get_output(ssh), len));\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_check_reserve",
          "args": [
            "ssh_packet_get_output(ssh)",
            "len"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "284-298",
          "snippet": "int\nsshbuf_check_reserve(const struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tSSHBUF_TELL(\"check\");\n\t/* Check that len is reasonable and that max_size + available < len */\n\tif (len > buf->max_size || buf->max_size - len < buf->size - buf->off)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_check_reserve(const struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tSSHBUF_TELL(\"check\");\n\t/* Check that len is reasonable and that max_size + available < len */\n\tif (len > buf->max_size || buf->max_size - len < buf->size - buf->off)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_get_output",
          "args": [
            "ssh"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_get_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2140-2144",
          "snippet": "void *\nssh_packet_get_output(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->output;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nssh_packet_get_output(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->output;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_output_space(struct ssh *ssh, size_t len)\n{\n\treturn (0 == sshbuf_check_reserve(ssh_packet_get_output(ssh), len));\n}"
  },
  {
    "function_name": "ssh_output_consume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "297-301",
    "snippet": "int\nssh_output_consume(struct ssh *ssh, size_t len)\n{\n\treturn sshbuf_consume(ssh_packet_get_output(ssh), len);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "ssh_packet_get_output(ssh)",
            "len"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_get_output",
          "args": [
            "ssh"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_get_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2140-2144",
          "snippet": "void *\nssh_packet_get_output(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->output;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nssh_packet_get_output(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->output;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_output_consume(struct ssh *ssh, size_t len)\n{\n\treturn sshbuf_consume(ssh_packet_get_output(ssh), len);\n}"
  },
  {
    "function_name": "ssh_output_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "288-295",
    "snippet": "const u_char *\nssh_output_ptr(struct ssh *ssh, size_t *len)\n{\n\tstruct sshbuf *output = ssh_packet_get_output(ssh);\n\n\t*len = sshbuf_len(output);\n\treturn sshbuf_ptr(output);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "output"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "output"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_get_output",
          "args": [
            "ssh"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_get_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2140-2144",
          "snippet": "void *\nssh_packet_get_output(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->output;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nssh_packet_get_output(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->output;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nconst u_char *\nssh_output_ptr(struct ssh *ssh, size_t *len)\n{\n\tstruct sshbuf *output = ssh_packet_get_output(ssh);\n\n\t*len = sshbuf_len(output);\n\treturn sshbuf_ptr(output);\n}"
  },
  {
    "function_name": "ssh_packet_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "276-286",
    "snippet": "int\nssh_packet_put(struct ssh *ssh, int type, const u_char *data, size_t len)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t    (r = sshpkt_put(ssh, data, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\treturn 0;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put",
          "args": [
            "ssh",
            "data",
            "len"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_ec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2473-2477",
          "snippet": "int\nsshpkt_put_ec(struct ssh *ssh, const EC_POINT *v, const EC_GROUP *g)\n{\n\treturn sshbuf_put_ec(ssh->state->outgoing_packet, v, g);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_ec(struct ssh *ssh, const EC_POINT *v, const EC_GROUP *g)\n{\n\treturn sshbuf_put_ec(ssh->state->outgoing_packet, v, g);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "type"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_packet_put(struct ssh *ssh, int type, const u_char *data, size_t len)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t    (r = sshpkt_put(ssh, data, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_packet_payload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "270-274",
    "snippet": "const u_char *\nssh_packet_payload(struct ssh *ssh, size_t *lenp)\n{\n\treturn sshpkt_ptr(ssh, lenp);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshpkt_ptr",
          "args": [
            "ssh",
            "lenp"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2563-2569",
          "snippet": "const u_char *\nsshpkt_ptr(struct ssh *ssh, size_t *lenp)\n{\n\tif (lenp != NULL)\n\t\t*lenp = sshbuf_len(ssh->state->incoming_packet);\n\treturn sshbuf_ptr(ssh->state->incoming_packet);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshpkt_ptr(struct ssh *ssh, size_t *lenp)\n{\n\tif (lenp != NULL)\n\t\t*lenp = sshbuf_len(ssh->state->incoming_packet);\n\treturn sshbuf_ptr(ssh->state->incoming_packet);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nconst u_char *\nssh_packet_payload(struct ssh *ssh, size_t *lenp)\n{\n\treturn sshpkt_ptr(ssh, lenp);\n}"
  },
  {
    "function_name": "ssh_packet_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "229-268",
    "snippet": "int\nssh_packet_next(struct ssh *ssh, u_char *typep)\n{\n\tint r;\n\tu_int32_t seqnr;\n\tu_char type;\n\n\t/*\n\t * Try to read a packet. Return SSH_MSG_NONE if no packet or not\n\t * enough data.\n\t */\n\t*typep = SSH_MSG_NONE;\n\tif (ssh->kex->client_version_string == NULL ||\n\t    ssh->kex->server_version_string == NULL)\n\t\treturn _ssh_exchange_banner(ssh);\n\t/*\n\t * If we enough data and a dispatch function then\n\t * call the function and get the next packet.\n\t * Otherwise return the packet type to the caller so it\n\t * can decide how to go on.\n\t *\n\t * We will only call the dispatch function for:\n\t *     20-29    Algorithm negotiation\n\t *     30-49    Key exchange method specific (numbers can be reused for\n\t *              different authentication methods)\n\t */\n\tfor (;;) {\n\t\tif ((r = ssh_packet_read_poll2(ssh, &type, &seqnr)) != 0)\n\t\t\treturn r;\n\t\tif (type > 0 && type < DISPATCH_MAX &&\n\t\t    type >= SSH2_MSG_KEXINIT && type <= SSH2_MSG_TRANSPORT_MAX &&\n\t\t    ssh->dispatch[type] != NULL) {\n\t\t\tif ((r = (*ssh->dispatch[type])(type, seqnr, ssh)) != 0)\n\t\t\t\treturn r;\n\t\t} else {\n\t\t\t*typep = type;\n\t\t\treturn 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "type",
            "seqnr",
            "ssh"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_read_poll2",
          "args": [
            "ssh",
            "&type",
            "&seqnr"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_read_poll2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1443-1673",
          "snippet": "int\nssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)\n{\n\tstruct session_state *state = ssh->state;\n\tu_int padlen, need;\n\tu_char *cp;\n\tu_int maclen, aadlen = 0, authlen = 0, block_size;\n\tstruct sshenc *enc   = NULL;\n\tstruct sshmac *mac   = NULL;\n\tstruct sshcomp *comp = NULL;\n\tint r;\n\n\tif (state->mux)\n\t\treturn ssh_packet_read_poll2_mux(ssh, typep, seqnr_p);\n\n\t*typep = SSH_MSG_NONE;\n\n\tif (state->packet_discard)\n\t\treturn 0;\n\n\tif (state->newkeys[MODE_IN] != NULL) {\n\t\tenc  = &state->newkeys[MODE_IN]->enc;\n\t\tmac  = &state->newkeys[MODE_IN]->mac;\n\t\tcomp = &state->newkeys[MODE_IN]->comp;\n\t\t/* disable mac for authenticated encryption */\n\t\tif ((authlen = cipher_authlen(enc->cipher)) != 0)\n\t\t\tmac = NULL;\n\t}\n\tmaclen = mac && mac->enabled ? mac->mac_len : 0;\n\tblock_size = enc ? enc->block_size : 8;\n\taadlen = (mac && mac->enabled && mac->etm) || authlen ? 4 : 0;\n\n\tif (aadlen && state->packlen == 0) {\n\t\tif (cipher_get_length(state->receive_context,\n\t\t    &state->packlen, state->p_read.seqnr,\n\t\t    sshbuf_ptr(state->input), sshbuf_len(state->input)) != 0)\n\t\t\treturn 0;\n\t\tif (state->packlen < 1 + 4 ||\n\t\t    state->packlen > PACKET_MAX_SIZE) {\n#ifdef PACKET_DEBUG\n\t\t\tsshbuf_dump(state->input, stderr);\n#endif\n\t\t\tlogit(\"Bad packet length %u.\", state->packlen);\n\t\t\tif ((r = sshpkt_disconnect(ssh, \"Packet corrupt\")) != 0)\n\t\t\t\treturn r;\n\t\t\treturn SSH_ERR_CONN_CORRUPT;\n\t\t}\n\t\tsshbuf_reset(state->incoming_packet);\n\t} else if (state->packlen == 0) {\n\t\t/*\n\t\t * check if input size is less than the cipher block size,\n\t\t * decrypt first block and extract length of incoming packet\n\t\t */\n\t\tif (sshbuf_len(state->input) < block_size)\n\t\t\treturn 0;\n\t\tsshbuf_reset(state->incoming_packet);\n\t\tif ((r = sshbuf_reserve(state->incoming_packet, block_size,\n\t\t    &cp)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = cipher_crypt(state->receive_context,\n\t\t    state->p_send.seqnr, cp, sshbuf_ptr(state->input),\n\t\t    block_size, 0, 0)) != 0)\n\t\t\tgoto out;\n\t\tstate->packlen = PEEK_U32(sshbuf_ptr(state->incoming_packet));\n\t\tif (state->packlen < 1 + 4 ||\n\t\t    state->packlen > PACKET_MAX_SIZE) {\n#ifdef PACKET_DEBUG\n\t\t\tfprintf(stderr, \"input: \\n\");\n\t\t\tsshbuf_dump(state->input, stderr);\n\t\t\tfprintf(stderr, \"incoming_packet: \\n\");\n\t\t\tsshbuf_dump(state->incoming_packet, stderr);\n#endif\n\t\t\tlogit(\"Bad packet length %u.\", state->packlen);\n\t\t\treturn ssh_packet_start_discard(ssh, enc, mac, 0,\n\t\t\t    PACKET_MAX_SIZE);\n\t\t}\n\t\tif ((r = sshbuf_consume(state->input, block_size)) != 0)\n\t\t\tgoto out;\n\t}\n\tDBG(debug(\"input: packet len %u\", state->packlen+4));\n\n\tif (aadlen) {\n\t\t/* only the payload is encrypted */\n\t\tneed = state->packlen;\n\t} else {\n\t\t/*\n\t\t * the payload size and the payload are encrypted, but we\n\t\t * have a partial packet of block_size bytes\n\t\t */\n\t\tneed = 4 + state->packlen - block_size;\n\t}\n\tDBG(debug(\"partial packet: block %d, need %d, maclen %d, authlen %d,\"\n\t    \" aadlen %d\", block_size, need, maclen, authlen, aadlen));\n\tif (need % block_size != 0) {\n\t\tlogit(\"padding error: need %d block %d mod %d\",\n\t\t    need, block_size, need % block_size);\n\t\treturn ssh_packet_start_discard(ssh, enc, mac, 0,\n\t\t    PACKET_MAX_SIZE - block_size);\n\t}\n\t/*\n\t * check if the entire packet has been received and\n\t * decrypt into incoming_packet:\n\t * 'aadlen' bytes are unencrypted, but authenticated.\n\t * 'need' bytes are encrypted, followed by either\n\t * 'authlen' bytes of authentication tag or\n\t * 'maclen' bytes of message authentication code.\n\t */\n\tif (sshbuf_len(state->input) < aadlen + need + authlen + maclen)\n\t\treturn 0; /* packet is incomplete */\n#ifdef PACKET_DEBUG\n\tfprintf(stderr, \"read_poll enc/full: \");\n\tsshbuf_dump(state->input, stderr);\n#endif\n\t/* EtM: check mac over encrypted input */\n\tif (mac && mac->enabled && mac->etm) {\n\t\tif ((r = mac_check(mac, state->p_read.seqnr,\n\t\t    sshbuf_ptr(state->input), aadlen + need,\n\t\t    sshbuf_ptr(state->input) + aadlen + need + authlen,\n\t\t    maclen)) != 0) {\n\t\t\tif (r == SSH_ERR_MAC_INVALID)\n\t\t\t\tlogit(\"Corrupted MAC on input.\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((r = sshbuf_reserve(state->incoming_packet, aadlen + need,\n\t    &cp)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(state->receive_context, state->p_read.seqnr, cp,\n\t    sshbuf_ptr(state->input), need, aadlen, authlen)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_consume(state->input, aadlen + need + authlen)) != 0)\n\t\tgoto out;\n\tif (mac && mac->enabled) {\n\t\t/* Not EtM: check MAC over cleartext */\n\t\tif (!mac->etm && (r = mac_check(mac, state->p_read.seqnr,\n\t\t    sshbuf_ptr(state->incoming_packet),\n\t\t    sshbuf_len(state->incoming_packet),\n\t\t    sshbuf_ptr(state->input), maclen)) != 0) {\n\t\t\tif (r != SSH_ERR_MAC_INVALID)\n\t\t\t\tgoto out;\n\t\t\tlogit(\"Corrupted MAC on input.\");\n\t\t\tif (need + block_size > PACKET_MAX_SIZE)\n\t\t\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t\t\treturn ssh_packet_start_discard(ssh, enc, mac,\n\t\t\t    sshbuf_len(state->incoming_packet),\n\t\t\t    PACKET_MAX_SIZE - need - block_size);\n\t\t}\n\t\t/* Remove MAC from input buffer */\n\t\tDBG(debug(\"MAC #%d ok\", state->p_read.seqnr));\n\t\tif ((r = sshbuf_consume(state->input, mac->mac_len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (seqnr_p != NULL)\n\t\t*seqnr_p = state->p_read.seqnr;\n\tif (++state->p_read.seqnr == 0)\n\t\tlogit(\"incoming seqnr wraps around\");\n\tif (++state->p_read.packets == 0)\n\t\tif (!(ssh->compat & SSH_BUG_NOREKEY))\n\t\t\treturn SSH_ERR_NEED_REKEY;\n\tstate->p_read.blocks += (state->packlen + 4) / block_size;\n\tstate->p_read.bytes += state->packlen + 4;\n\n\t/* get padlen */\n\tpadlen = sshbuf_ptr(state->incoming_packet)[4];\n\tDBG(debug(\"input: padlen %d\", padlen));\n\tif (padlen < 4)\t{\n\t\tif ((r = sshpkt_disconnect(ssh,\n\t\t    \"Corrupted padlen %d on input.\", padlen)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\treturn r;\n\t\treturn SSH_ERR_CONN_CORRUPT;\n\t}\n\n\t/* skip packet size + padlen, discard padding */\n\tif ((r = sshbuf_consume(state->incoming_packet, 4 + 1)) != 0 ||\n\t    ((r = sshbuf_consume_end(state->incoming_packet, padlen)) != 0))\n\t\tgoto out;\n\n\tDBG(debug(\"input: len before de-compress %zd\",\n\t    sshbuf_len(state->incoming_packet)));\n\tif (comp && comp->enabled) {\n\t\tsshbuf_reset(state->compression_buffer);\n\t\tif ((r = uncompress_buffer(ssh, state->incoming_packet,\n\t\t    state->compression_buffer)) != 0)\n\t\t\tgoto out;\n\t\tsshbuf_reset(state->incoming_packet);\n\t\tif ((r = sshbuf_putb(state->incoming_packet,\n\t\t    state->compression_buffer)) != 0)\n\t\t\tgoto out;\n\t\tDBG(debug(\"input: len after de-compress %zd\",\n\t\t    sshbuf_len(state->incoming_packet)));\n\t}\n\t/*\n\t * get packet type, implies consume.\n\t * return length of payload (without type field)\n\t */\n\tif ((r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)\n\t\tgoto out;\n\tif (ssh_packet_log_type(*typep))\n\t\tdebug3(\"receive packet: type %u\", *typep);\n\tif (*typep < SSH2_MSG_MIN || *typep >= SSH2_MSG_LOCAL_MIN) {\n\t\tif ((r = sshpkt_disconnect(ssh,\n\t\t    \"Invalid ssh2 packet type: %d\", *typep)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\treturn r;\n\t\treturn SSH_ERR_PROTOCOL_ERROR;\n\t}\n\tif (state->hook_in != NULL &&\n\t    (r = state->hook_in(ssh, state->incoming_packet, typep,\n\t    state->hook_in_ctx)) != 0)\n\t\treturn r;\n\tif (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)\n\t\tr = ssh_packet_enable_delayed_compress(ssh);\n\telse\n\t\tr = 0;\n#ifdef PACKET_DEBUG\n\tfprintf(stderr, \"read/plain[%d]:\\r\\n\", *typep);\n\tsshbuf_dump(state->incoming_packet, stderr);\n#endif\n\t/* reset for next packet */\n\tstate->packlen = 0;\n\n\t/* do we need to rekey? */\n\tif (ssh_packet_need_rekeying(ssh, 0)) {\n\t\tdebug3(\"%s: rekex triggered\", __func__);\n\t\tif ((r = kex_start_rekex(ssh)) != 0)\n\t\t\treturn r;\n\t}\n out:\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define PACKET_MAX_SIZE (256 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define PACKET_MAX_SIZE (256 * 1024)\n\nint\nssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)\n{\n\tstruct session_state *state = ssh->state;\n\tu_int padlen, need;\n\tu_char *cp;\n\tu_int maclen, aadlen = 0, authlen = 0, block_size;\n\tstruct sshenc *enc   = NULL;\n\tstruct sshmac *mac   = NULL;\n\tstruct sshcomp *comp = NULL;\n\tint r;\n\n\tif (state->mux)\n\t\treturn ssh_packet_read_poll2_mux(ssh, typep, seqnr_p);\n\n\t*typep = SSH_MSG_NONE;\n\n\tif (state->packet_discard)\n\t\treturn 0;\n\n\tif (state->newkeys[MODE_IN] != NULL) {\n\t\tenc  = &state->newkeys[MODE_IN]->enc;\n\t\tmac  = &state->newkeys[MODE_IN]->mac;\n\t\tcomp = &state->newkeys[MODE_IN]->comp;\n\t\t/* disable mac for authenticated encryption */\n\t\tif ((authlen = cipher_authlen(enc->cipher)) != 0)\n\t\t\tmac = NULL;\n\t}\n\tmaclen = mac && mac->enabled ? mac->mac_len : 0;\n\tblock_size = enc ? enc->block_size : 8;\n\taadlen = (mac && mac->enabled && mac->etm) || authlen ? 4 : 0;\n\n\tif (aadlen && state->packlen == 0) {\n\t\tif (cipher_get_length(state->receive_context,\n\t\t    &state->packlen, state->p_read.seqnr,\n\t\t    sshbuf_ptr(state->input), sshbuf_len(state->input)) != 0)\n\t\t\treturn 0;\n\t\tif (state->packlen < 1 + 4 ||\n\t\t    state->packlen > PACKET_MAX_SIZE) {\n#ifdef PACKET_DEBUG\n\t\t\tsshbuf_dump(state->input, stderr);\n#endif\n\t\t\tlogit(\"Bad packet length %u.\", state->packlen);\n\t\t\tif ((r = sshpkt_disconnect(ssh, \"Packet corrupt\")) != 0)\n\t\t\t\treturn r;\n\t\t\treturn SSH_ERR_CONN_CORRUPT;\n\t\t}\n\t\tsshbuf_reset(state->incoming_packet);\n\t} else if (state->packlen == 0) {\n\t\t/*\n\t\t * check if input size is less than the cipher block size,\n\t\t * decrypt first block and extract length of incoming packet\n\t\t */\n\t\tif (sshbuf_len(state->input) < block_size)\n\t\t\treturn 0;\n\t\tsshbuf_reset(state->incoming_packet);\n\t\tif ((r = sshbuf_reserve(state->incoming_packet, block_size,\n\t\t    &cp)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = cipher_crypt(state->receive_context,\n\t\t    state->p_send.seqnr, cp, sshbuf_ptr(state->input),\n\t\t    block_size, 0, 0)) != 0)\n\t\t\tgoto out;\n\t\tstate->packlen = PEEK_U32(sshbuf_ptr(state->incoming_packet));\n\t\tif (state->packlen < 1 + 4 ||\n\t\t    state->packlen > PACKET_MAX_SIZE) {\n#ifdef PACKET_DEBUG\n\t\t\tfprintf(stderr, \"input: \\n\");\n\t\t\tsshbuf_dump(state->input, stderr);\n\t\t\tfprintf(stderr, \"incoming_packet: \\n\");\n\t\t\tsshbuf_dump(state->incoming_packet, stderr);\n#endif\n\t\t\tlogit(\"Bad packet length %u.\", state->packlen);\n\t\t\treturn ssh_packet_start_discard(ssh, enc, mac, 0,\n\t\t\t    PACKET_MAX_SIZE);\n\t\t}\n\t\tif ((r = sshbuf_consume(state->input, block_size)) != 0)\n\t\t\tgoto out;\n\t}\n\tDBG(debug(\"input: packet len %u\", state->packlen+4));\n\n\tif (aadlen) {\n\t\t/* only the payload is encrypted */\n\t\tneed = state->packlen;\n\t} else {\n\t\t/*\n\t\t * the payload size and the payload are encrypted, but we\n\t\t * have a partial packet of block_size bytes\n\t\t */\n\t\tneed = 4 + state->packlen - block_size;\n\t}\n\tDBG(debug(\"partial packet: block %d, need %d, maclen %d, authlen %d,\"\n\t    \" aadlen %d\", block_size, need, maclen, authlen, aadlen));\n\tif (need % block_size != 0) {\n\t\tlogit(\"padding error: need %d block %d mod %d\",\n\t\t    need, block_size, need % block_size);\n\t\treturn ssh_packet_start_discard(ssh, enc, mac, 0,\n\t\t    PACKET_MAX_SIZE - block_size);\n\t}\n\t/*\n\t * check if the entire packet has been received and\n\t * decrypt into incoming_packet:\n\t * 'aadlen' bytes are unencrypted, but authenticated.\n\t * 'need' bytes are encrypted, followed by either\n\t * 'authlen' bytes of authentication tag or\n\t * 'maclen' bytes of message authentication code.\n\t */\n\tif (sshbuf_len(state->input) < aadlen + need + authlen + maclen)\n\t\treturn 0; /* packet is incomplete */\n#ifdef PACKET_DEBUG\n\tfprintf(stderr, \"read_poll enc/full: \");\n\tsshbuf_dump(state->input, stderr);\n#endif\n\t/* EtM: check mac over encrypted input */\n\tif (mac && mac->enabled && mac->etm) {\n\t\tif ((r = mac_check(mac, state->p_read.seqnr,\n\t\t    sshbuf_ptr(state->input), aadlen + need,\n\t\t    sshbuf_ptr(state->input) + aadlen + need + authlen,\n\t\t    maclen)) != 0) {\n\t\t\tif (r == SSH_ERR_MAC_INVALID)\n\t\t\t\tlogit(\"Corrupted MAC on input.\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((r = sshbuf_reserve(state->incoming_packet, aadlen + need,\n\t    &cp)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(state->receive_context, state->p_read.seqnr, cp,\n\t    sshbuf_ptr(state->input), need, aadlen, authlen)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_consume(state->input, aadlen + need + authlen)) != 0)\n\t\tgoto out;\n\tif (mac && mac->enabled) {\n\t\t/* Not EtM: check MAC over cleartext */\n\t\tif (!mac->etm && (r = mac_check(mac, state->p_read.seqnr,\n\t\t    sshbuf_ptr(state->incoming_packet),\n\t\t    sshbuf_len(state->incoming_packet),\n\t\t    sshbuf_ptr(state->input), maclen)) != 0) {\n\t\t\tif (r != SSH_ERR_MAC_INVALID)\n\t\t\t\tgoto out;\n\t\t\tlogit(\"Corrupted MAC on input.\");\n\t\t\tif (need + block_size > PACKET_MAX_SIZE)\n\t\t\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t\t\treturn ssh_packet_start_discard(ssh, enc, mac,\n\t\t\t    sshbuf_len(state->incoming_packet),\n\t\t\t    PACKET_MAX_SIZE - need - block_size);\n\t\t}\n\t\t/* Remove MAC from input buffer */\n\t\tDBG(debug(\"MAC #%d ok\", state->p_read.seqnr));\n\t\tif ((r = sshbuf_consume(state->input, mac->mac_len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (seqnr_p != NULL)\n\t\t*seqnr_p = state->p_read.seqnr;\n\tif (++state->p_read.seqnr == 0)\n\t\tlogit(\"incoming seqnr wraps around\");\n\tif (++state->p_read.packets == 0)\n\t\tif (!(ssh->compat & SSH_BUG_NOREKEY))\n\t\t\treturn SSH_ERR_NEED_REKEY;\n\tstate->p_read.blocks += (state->packlen + 4) / block_size;\n\tstate->p_read.bytes += state->packlen + 4;\n\n\t/* get padlen */\n\tpadlen = sshbuf_ptr(state->incoming_packet)[4];\n\tDBG(debug(\"input: padlen %d\", padlen));\n\tif (padlen < 4)\t{\n\t\tif ((r = sshpkt_disconnect(ssh,\n\t\t    \"Corrupted padlen %d on input.\", padlen)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\treturn r;\n\t\treturn SSH_ERR_CONN_CORRUPT;\n\t}\n\n\t/* skip packet size + padlen, discard padding */\n\tif ((r = sshbuf_consume(state->incoming_packet, 4 + 1)) != 0 ||\n\t    ((r = sshbuf_consume_end(state->incoming_packet, padlen)) != 0))\n\t\tgoto out;\n\n\tDBG(debug(\"input: len before de-compress %zd\",\n\t    sshbuf_len(state->incoming_packet)));\n\tif (comp && comp->enabled) {\n\t\tsshbuf_reset(state->compression_buffer);\n\t\tif ((r = uncompress_buffer(ssh, state->incoming_packet,\n\t\t    state->compression_buffer)) != 0)\n\t\t\tgoto out;\n\t\tsshbuf_reset(state->incoming_packet);\n\t\tif ((r = sshbuf_putb(state->incoming_packet,\n\t\t    state->compression_buffer)) != 0)\n\t\t\tgoto out;\n\t\tDBG(debug(\"input: len after de-compress %zd\",\n\t\t    sshbuf_len(state->incoming_packet)));\n\t}\n\t/*\n\t * get packet type, implies consume.\n\t * return length of payload (without type field)\n\t */\n\tif ((r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)\n\t\tgoto out;\n\tif (ssh_packet_log_type(*typep))\n\t\tdebug3(\"receive packet: type %u\", *typep);\n\tif (*typep < SSH2_MSG_MIN || *typep >= SSH2_MSG_LOCAL_MIN) {\n\t\tif ((r = sshpkt_disconnect(ssh,\n\t\t    \"Invalid ssh2 packet type: %d\", *typep)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\treturn r;\n\t\treturn SSH_ERR_PROTOCOL_ERROR;\n\t}\n\tif (state->hook_in != NULL &&\n\t    (r = state->hook_in(ssh, state->incoming_packet, typep,\n\t    state->hook_in_ctx)) != 0)\n\t\treturn r;\n\tif (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)\n\t\tr = ssh_packet_enable_delayed_compress(ssh);\n\telse\n\t\tr = 0;\n#ifdef PACKET_DEBUG\n\tfprintf(stderr, \"read/plain[%d]:\\r\\n\", *typep);\n\tsshbuf_dump(state->incoming_packet, stderr);\n#endif\n\t/* reset for next packet */\n\tstate->packlen = 0;\n\n\t/* do we need to rekey? */\n\tif (ssh_packet_need_rekeying(ssh, 0)) {\n\t\tdebug3(\"%s: rekex triggered\", __func__);\n\t\tif ((r = kex_start_rekex(ssh)) != 0)\n\t\t\treturn r;\n\t}\n out:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ssh_exchange_banner",
          "args": [
            "ssh"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "_ssh_exchange_banner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "400-437",
          "snippet": "int\n_ssh_exchange_banner(struct ssh *ssh)\n{\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\t/*\n\t * if _ssh_read_banner() cannot parse a full version string\n\t * it will return NULL and we end up calling it again.\n\t */\n\n\tr = 0;\n\tif (kex->server) {\n\t\tif (kex->server_version_string == NULL)\n\t\t\tr = _ssh_send_banner(ssh, &kex->server_version_string);\n\t\tif (r == 0 &&\n\t\t    kex->server_version_string != NULL &&\n\t\t    kex->client_version_string == NULL)\n\t\t\tr = _ssh_read_banner(ssh, &kex->client_version_string);\n\t} else {\n\t\tif (kex->server_version_string == NULL)\n\t\t\tr = _ssh_read_banner(ssh, &kex->server_version_string);\n\t\tif (r == 0 &&\n\t\t    kex->server_version_string != NULL &&\n\t\t    kex->client_version_string == NULL)\n\t\t\tr = _ssh_send_banner(ssh, &kex->client_version_string);\n\t}\n\tif (r != 0)\n\t\treturn r;\n\t/* start initial kex as soon as we have exchanged the banners */\n\tif (kex->server_version_string != NULL &&\n\t    kex->client_version_string != NULL) {\n\t\tif ((r = _ssh_order_hostkeyalgs(ssh)) != 0 ||\n\t\t    (r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\n_ssh_exchange_banner(struct ssh *ssh)\n{\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\t/*\n\t * if _ssh_read_banner() cannot parse a full version string\n\t * it will return NULL and we end up calling it again.\n\t */\n\n\tr = 0;\n\tif (kex->server) {\n\t\tif (kex->server_version_string == NULL)\n\t\t\tr = _ssh_send_banner(ssh, &kex->server_version_string);\n\t\tif (r == 0 &&\n\t\t    kex->server_version_string != NULL &&\n\t\t    kex->client_version_string == NULL)\n\t\t\tr = _ssh_read_banner(ssh, &kex->client_version_string);\n\t} else {\n\t\tif (kex->server_version_string == NULL)\n\t\t\tr = _ssh_read_banner(ssh, &kex->server_version_string);\n\t\tif (r == 0 &&\n\t\t    kex->server_version_string != NULL &&\n\t\t    kex->client_version_string == NULL)\n\t\t\tr = _ssh_send_banner(ssh, &kex->client_version_string);\n\t}\n\tif (r != 0)\n\t\treturn r;\n\t/* start initial kex as soon as we have exchanged the banners */\n\tif (kex->server_version_string != NULL &&\n\t    kex->client_version_string != NULL) {\n\t\tif ((r = _ssh_order_hostkeyalgs(ssh)) != 0 ||\n\t\t    (r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_packet_next(struct ssh *ssh, u_char *typep)\n{\n\tint r;\n\tu_int32_t seqnr;\n\tu_char type;\n\n\t/*\n\t * Try to read a packet. Return SSH_MSG_NONE if no packet or not\n\t * enough data.\n\t */\n\t*typep = SSH_MSG_NONE;\n\tif (ssh->kex->client_version_string == NULL ||\n\t    ssh->kex->server_version_string == NULL)\n\t\treturn _ssh_exchange_banner(ssh);\n\t/*\n\t * If we enough data and a dispatch function then\n\t * call the function and get the next packet.\n\t * Otherwise return the packet type to the caller so it\n\t * can decide how to go on.\n\t *\n\t * We will only call the dispatch function for:\n\t *     20-29    Algorithm negotiation\n\t *     30-49    Key exchange method specific (numbers can be reused for\n\t *              different authentication methods)\n\t */\n\tfor (;;) {\n\t\tif ((r = ssh_packet_read_poll2(ssh, &type, &seqnr)) != 0)\n\t\t\treturn r;\n\t\tif (type > 0 && type < DISPATCH_MAX &&\n\t\t    type >= SSH2_MSG_KEXINIT && type <= SSH2_MSG_TRANSPORT_MAX &&\n\t\t    ssh->dispatch[type] != NULL) {\n\t\t\tif ((r = (*ssh->dispatch[type])(type, seqnr, ssh)) != 0)\n\t\t\t\treturn r;\n\t\t} else {\n\t\t\t*typep = type;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ssh_input_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "223-227",
    "snippet": "int\nssh_input_append(struct ssh *ssh, const u_char *data, size_t len)\n{\n\treturn sshbuf_put(ssh_packet_get_input(ssh), data, len);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "ssh_packet_get_input(ssh)",
            "data",
            "len"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_get_input",
          "args": [
            "ssh"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_get_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2134-2138",
          "snippet": "void *\nssh_packet_get_input(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->input;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nssh_packet_get_input(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->input;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_input_append(struct ssh *ssh, const u_char *data, size_t len)\n{\n\treturn sshbuf_put(ssh_packet_get_input(ssh), data, len);\n}"
  },
  {
    "function_name": "ssh_set_verify_host_key_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "211-221",
    "snippet": "int\nssh_set_verify_host_key_callback(struct ssh *ssh,\n    int (*cb)(struct sshkey *, struct ssh *))\n{\n\tif (cb == NULL || ssh->kex == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tssh->kex->verify_host_key = cb;\n\n\treturn 0;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_set_verify_host_key_callback(struct ssh *ssh,\n    int (*cb)(struct sshkey *, struct ssh *))\n{\n\tif (cb == NULL || ssh->kex == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tssh->kex->verify_host_key = cb;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_add_hostkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "177-209",
    "snippet": "int\nssh_add_hostkey(struct ssh *ssh, struct sshkey *key)\n{\n\tstruct sshkey *pubkey = NULL;\n\tstruct key_entry *k = NULL, *k_prv = NULL;\n\tint r;\n\n\tif (ssh->kex->server) {\n\t\tif ((r = sshkey_from_private(key, &pubkey)) != 0)\n\t\t\treturn r;\n\t\tif ((k = malloc(sizeof(*k))) == NULL ||\n\t\t    (k_prv = malloc(sizeof(*k_prv))) == NULL) {\n\t\t\tfree(k);\n\t\t\tsshkey_free(pubkey);\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tk_prv->key = key;\n\t\tTAILQ_INSERT_TAIL(&ssh->private_keys, k_prv, next);\n\n\t\t/* add the public key, too */\n\t\tk->key = pubkey;\n\t\tTAILQ_INSERT_TAIL(&ssh->public_keys, k, next);\n\t\tr = 0;\n\t} else {\n\t\tif ((k = malloc(sizeof(*k))) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tk->key = key;\n\t\tTAILQ_INSERT_TAIL(&ssh->public_keys, k, next);\n\t\tr = 0;\n\t}\n\n\treturn r;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&ssh->public_keys",
            "k",
            "next"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*k)"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&ssh->public_keys",
            "k",
            "next"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&ssh->private_keys",
            "k_prv",
            "next"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "pubkey"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "k"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "139-162",
          "snippet": "void\nssh_free(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tssh_packet_close(ssh);\n\t/*\n\t * we've only created the public keys variants in case we\n\t * are a acting as a server.\n\t */\n\twhile ((k = TAILQ_FIRST(&ssh->public_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->public_keys, k, next);\n\t\tif (ssh->kex && ssh->kex->server)\n\t\t\tsshkey_free(k->key);\n\t\tfree(k);\n\t}\n\twhile ((k = TAILQ_FIRST(&ssh->private_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->private_keys, k, next);\n\t\tfree(k);\n\t}\n\tif (ssh->kex)\n\t\tkex_free(ssh->kex);\n\tfree(ssh);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nvoid\nssh_free(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tssh_packet_close(ssh);\n\t/*\n\t * we've only created the public keys variants in case we\n\t * are a acting as a server.\n\t */\n\twhile ((k = TAILQ_FIRST(&ssh->public_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->public_keys, k, next);\n\t\tif (ssh->kex && ssh->kex->server)\n\t\t\tsshkey_free(k->key);\n\t\tfree(k);\n\t}\n\twhile ((k = TAILQ_FIRST(&ssh->private_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->private_keys, k, next);\n\t\tfree(k);\n\t}\n\tif (ssh->kex)\n\t\tkex_free(ssh->kex);\n\tfree(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "key",
            "&pubkey"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_add_hostkey(struct ssh *ssh, struct sshkey *key)\n{\n\tstruct sshkey *pubkey = NULL;\n\tstruct key_entry *k = NULL, *k_prv = NULL;\n\tint r;\n\n\tif (ssh->kex->server) {\n\t\tif ((r = sshkey_from_private(key, &pubkey)) != 0)\n\t\t\treturn r;\n\t\tif ((k = malloc(sizeof(*k))) == NULL ||\n\t\t    (k_prv = malloc(sizeof(*k_prv))) == NULL) {\n\t\t\tfree(k);\n\t\t\tsshkey_free(pubkey);\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tk_prv->key = key;\n\t\tTAILQ_INSERT_TAIL(&ssh->private_keys, k_prv, next);\n\n\t\t/* add the public key, too */\n\t\tk->key = pubkey;\n\t\tTAILQ_INSERT_TAIL(&ssh->public_keys, k, next);\n\t\tr = 0;\n\t} else {\n\t\tif ((k = malloc(sizeof(*k))) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tk->key = key;\n\t\tTAILQ_INSERT_TAIL(&ssh->public_keys, k, next);\n\t\tr = 0;\n\t}\n\n\treturn r;\n}"
  },
  {
    "function_name": "ssh_get_app_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "170-174",
    "snippet": "void *\nssh_get_app_data(struct ssh *ssh)\n{\n\treturn ssh->app_data;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nvoid *\nssh_get_app_data(struct ssh *ssh)\n{\n\treturn ssh->app_data;\n}"
  },
  {
    "function_name": "ssh_set_app_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "164-168",
    "snippet": "void\nssh_set_app_data(struct ssh *ssh, void *app_data)\n{\n\tssh->app_data = app_data;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nvoid\nssh_set_app_data(struct ssh *ssh, void *app_data)\n{\n\tssh->app_data = app_data;\n}"
  },
  {
    "function_name": "ssh_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "139-162",
    "snippet": "void\nssh_free(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tssh_packet_close(ssh);\n\t/*\n\t * we've only created the public keys variants in case we\n\t * are a acting as a server.\n\t */\n\twhile ((k = TAILQ_FIRST(&ssh->public_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->public_keys, k, next);\n\t\tif (ssh->kex && ssh->kex->server)\n\t\t\tsshkey_free(k->key);\n\t\tfree(k);\n\t}\n\twhile ((k = TAILQ_FIRST(&ssh->private_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->private_keys, k, next);\n\t\tfree(k);\n\t}\n\tif (ssh->kex)\n\t\tkex_free(ssh->kex);\n\tfree(ssh);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ssh"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "139-162",
          "snippet": "void\nssh_free(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tssh_packet_close(ssh);\n\t/*\n\t * we've only created the public keys variants in case we\n\t * are a acting as a server.\n\t */\n\twhile ((k = TAILQ_FIRST(&ssh->public_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->public_keys, k, next);\n\t\tif (ssh->kex && ssh->kex->server)\n\t\t\tsshkey_free(k->key);\n\t\tfree(k);\n\t}\n\twhile ((k = TAILQ_FIRST(&ssh->private_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->private_keys, k, next);\n\t\tfree(k);\n\t}\n\tif (ssh->kex)\n\t\tkex_free(ssh->kex);\n\tfree(ssh);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kex_free",
          "args": [
            "ssh->kex"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "kex_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "638-662",
          "snippet": "void\nkex_free(struct kex *kex)\n{\n\tu_int mode;\n\n#ifdef WITH_OPENSSL\n\tDH_free(kex->dh);\n#ifdef OPENSSL_HAS_ECC\n\tEC_KEY_free(kex->ec_client_key);\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tkex_free_newkeys(kex->newkeys[mode]);\n\t\tkex->newkeys[mode] = NULL;\n\t}\n\tsshbuf_free(kex->peer);\n\tsshbuf_free(kex->my);\n\tfree(kex->session_id);\n\tfree(kex->client_version_string);\n\tfree(kex->server_version_string);\n\tfree(kex->failed_choice);\n\tfree(kex->hostkey_alg);\n\tfree(kex->name);\n\tfree(kex);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nvoid\nkex_free(struct kex *kex)\n{\n\tu_int mode;\n\n#ifdef WITH_OPENSSL\n\tDH_free(kex->dh);\n#ifdef OPENSSL_HAS_ECC\n\tEC_KEY_free(kex->ec_client_key);\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tkex_free_newkeys(kex->newkeys[mode]);\n\t\tkex->newkeys[mode] = NULL;\n\t}\n\tsshbuf_free(kex->peer);\n\tsshbuf_free(kex->my);\n\tfree(kex->session_id);\n\tfree(kex->client_version_string);\n\tfree(kex->server_version_string);\n\tfree(kex->failed_choice);\n\tfree(kex->hostkey_alg);\n\tfree(kex->name);\n\tfree(kex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&ssh->private_keys",
            "k",
            "next"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&ssh->private_keys"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "k->key"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&ssh->public_keys",
            "k",
            "next"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&ssh->public_keys"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_close",
          "args": [
            "ssh"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "646-650",
          "snippet": "void\nssh_packet_close(struct ssh *ssh)\n{\n\tssh_packet_close_internal(ssh, 1);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_packet_close(struct ssh *ssh)\n{\n\tssh_packet_close_internal(ssh, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nvoid\nssh_free(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tssh_packet_close(ssh);\n\t/*\n\t * we've only created the public keys variants in case we\n\t * are a acting as a server.\n\t */\n\twhile ((k = TAILQ_FIRST(&ssh->public_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->public_keys, k, next);\n\t\tif (ssh->kex && ssh->kex->server)\n\t\t\tsshkey_free(k->key);\n\t\tfree(k);\n\t}\n\twhile ((k = TAILQ_FIRST(&ssh->private_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->private_keys, k, next);\n\t\tfree(k);\n\t}\n\tif (ssh->kex)\n\t\tkex_free(ssh->kex);\n\tfree(ssh);\n}"
  },
  {
    "function_name": "ssh_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "74-137",
    "snippet": "int\nssh_init(struct ssh **sshp, int is_server, struct kex_params *kex_params)\n{\n        char *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tstruct ssh *ssh;\n\tchar **proposal;\n\tstatic int called;\n\tint r;\n\n\tif (!called) {\n#ifdef WITH_OPENSSL\n\t\tOpenSSL_add_all_algorithms();\n#endif /* WITH_OPENSSL */\n\t\tcalled = 1;\n\t}\n\n\tif ((ssh = ssh_packet_set_connection(NULL, -1, -1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (is_server)\n\t\tssh_packet_set_server(ssh);\n\n\t/* Initialize key exchange */\n\tproposal = kex_params ? kex_params->proposal : myproposal;\n\tif ((r = kex_new(ssh, proposal, &ssh->kex)) != 0) {\n\t\tssh_free(ssh);\n\t\treturn r;\n\t}\n\tssh->kex->server = is_server;\n\tif (is_server) {\n#ifdef WITH_OPENSSL\n\t\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\t\tssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif /* WITH_OPENSSL */\n\t\tssh->kex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\t\tssh->kex->load_host_public_key=&_ssh_host_public_key;\n\t\tssh->kex->load_host_private_key=&_ssh_host_private_key;\n\t\tssh->kex->sign=&_ssh_host_key_sign;\n\t} else {\n#ifdef WITH_OPENSSL\n\t\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\t\tssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_client;\n# endif\n#endif /* WITH_OPENSSL */\n\t\tssh->kex->kex[KEX_C25519_SHA256] = kexc25519_client;\n\t\tssh->kex->verify_host_key =&_ssh_verify_host_key;\n\t}\n\t*sshp = ssh;\n\treturn 0;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_exchange_banner(struct ssh *);",
      "int\t_ssh_send_banner(struct ssh *, char **);",
      "int\t_ssh_read_banner(struct ssh *, char **);",
      "int\t_ssh_order_hostkeyalgs(struct ssh *);",
      "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
      "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
      "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_free",
          "args": [
            "ssh"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "139-162",
          "snippet": "void\nssh_free(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tssh_packet_close(ssh);\n\t/*\n\t * we've only created the public keys variants in case we\n\t * are a acting as a server.\n\t */\n\twhile ((k = TAILQ_FIRST(&ssh->public_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->public_keys, k, next);\n\t\tif (ssh->kex && ssh->kex->server)\n\t\t\tsshkey_free(k->key);\n\t\tfree(k);\n\t}\n\twhile ((k = TAILQ_FIRST(&ssh->private_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->private_keys, k, next);\n\t\tfree(k);\n\t}\n\tif (ssh->kex)\n\t\tkex_free(ssh->kex);\n\tfree(ssh);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nvoid\nssh_free(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tssh_packet_close(ssh);\n\t/*\n\t * we've only created the public keys variants in case we\n\t * are a acting as a server.\n\t */\n\twhile ((k = TAILQ_FIRST(&ssh->public_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->public_keys, k, next);\n\t\tif (ssh->kex && ssh->kex->server)\n\t\t\tsshkey_free(k->key);\n\t\tfree(k);\n\t}\n\twhile ((k = TAILQ_FIRST(&ssh->private_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->private_keys, k, next);\n\t\tfree(k);\n\t}\n\tif (ssh->kex)\n\t\tkex_free(ssh->kex);\n\tfree(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_new",
          "args": [
            "ssh",
            "proposal",
            "&ssh->kex"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "kex_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "580-605",
          "snippet": "int\nkex_new(struct ssh *ssh, char *proposal[PROPOSAL_MAX], struct kex **kexp)\n{\n\tstruct kex *kex;\n\tint r;\n\n\t*kexp = NULL;\n\tif ((kex = calloc(1, sizeof(*kex))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((kex->peer = sshbuf_new()) == NULL ||\n\t    (kex->my = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = kex_prop2buf(kex->my, proposal)) != 0)\n\t\tgoto out;\n\tkex->done = 0;\n\tkex_reset_dispatch(ssh);\n\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, &kex_input_kexinit);\n\tr = 0;\n\t*kexp = kex;\n out:\n\tif (r != 0)\n\t\tkex_free(kex);\n\treturn r;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kex_choose_conf(struct ssh *);",
            "static int kex_input_newkeys(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nstatic int kex_choose_conf(struct ssh *);\nstatic int kex_input_newkeys(int, u_int32_t, struct ssh *);\n\nint\nkex_new(struct ssh *ssh, char *proposal[PROPOSAL_MAX], struct kex **kexp)\n{\n\tstruct kex *kex;\n\tint r;\n\n\t*kexp = NULL;\n\tif ((kex = calloc(1, sizeof(*kex))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((kex->peer = sshbuf_new()) == NULL ||\n\t    (kex->my = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = kex_prop2buf(kex->my, proposal)) != 0)\n\t\tgoto out;\n\tkex->done = 0;\n\tkex_reset_dispatch(ssh);\n\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, &kex_input_kexinit);\n\tr = 0;\n\t*kexp = kex;\n out:\n\tif (r != 0)\n\t\tkex_free(kex);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_set_server",
          "args": [
            "ssh"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_set_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2122-2126",
          "snippet": "void\nssh_packet_set_server(struct ssh *ssh)\n{\n\tssh->state->server_side = 1;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_packet_set_server(struct ssh *ssh)\n{\n\tssh->state->server_side = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_set_connection",
          "args": [
            "NULL",
            "-1",
            "-1"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_set_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "282-317",
          "snippet": "struct ssh *\nssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)\n{\n\tstruct session_state *state;\n\tconst struct sshcipher *none = cipher_by_name(\"none\");\n\tint r;\n\n\tif (none == NULL) {\n\t\terror(\"%s: cannot load cipher 'none'\", __func__);\n\t\treturn NULL;\n\t}\n\tif (ssh == NULL)\n\t\tssh = ssh_alloc_session_state();\n\tif (ssh == NULL) {\n\t\terror(\"%s: cound not allocate state\", __func__);\n\t\treturn NULL;\n\t}\n\tstate = ssh->state;\n\tstate->connection_in = fd_in;\n\tstate->connection_out = fd_out;\n\tif ((r = cipher_init(&state->send_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||\n\t    (r = cipher_init(&state->receive_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {\n\t\terror(\"%s: cipher_init failed: %s\", __func__, ssh_err(r));\n\t\tfree(ssh); /* XXX need ssh_free_session_state? */\n\t\treturn NULL;\n\t}\n\tstate->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;\n\t/*\n\t * Cache the IP address of the remote connection for use in error\n\t * messages that might be generated after the connection has closed.\n\t */\n\t(void)ssh_remote_ipaddr(ssh);\n\treturn ssh;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct ssh *\nssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)\n{\n\tstruct session_state *state;\n\tconst struct sshcipher *none = cipher_by_name(\"none\");\n\tint r;\n\n\tif (none == NULL) {\n\t\terror(\"%s: cannot load cipher 'none'\", __func__);\n\t\treturn NULL;\n\t}\n\tif (ssh == NULL)\n\t\tssh = ssh_alloc_session_state();\n\tif (ssh == NULL) {\n\t\terror(\"%s: cound not allocate state\", __func__);\n\t\treturn NULL;\n\t}\n\tstate = ssh->state;\n\tstate->connection_in = fd_in;\n\tstate->connection_out = fd_out;\n\tif ((r = cipher_init(&state->send_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||\n\t    (r = cipher_init(&state->receive_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {\n\t\terror(\"%s: cipher_init failed: %s\", __func__, ssh_err(r));\n\t\tfree(ssh); /* XXX need ssh_free_session_state? */\n\t\treturn NULL;\n\t}\n\tstate->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;\n\t/*\n\t * Cache the IP address of the remote connection for use in error\n\t * messages that might be generated after the connection has closed.\n\t */\n\t(void)ssh_remote_ipaddr(ssh);\n\treturn ssh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OpenSSL_add_all_algorithms",
          "args": [],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_OpenSSL_add_all_algorithms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/openssl-compat.c",
          "lines": "70-85",
          "snippet": "void\nssh_OpenSSL_add_all_algorithms(void)\n{\n\tOpenSSL_add_all_algorithms();\n\n\t/* Enable use of crypto hardware */\n\tENGINE_load_builtin_engines();\n\tENGINE_register_all_complete();\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tOPENSSL_config(NULL);\n#else\n\tOPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS |\n\t    OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#endif\n}",
          "includes": [
            "#include \"openssl-compat.h\"",
            "#include \"log.h\"",
            "# include <openssl/conf.h>",
            "# include <openssl/engine.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openssl-compat.h\"\n#include \"log.h\"\n# include <openssl/conf.h>\n# include <openssl/engine.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nssh_OpenSSL_add_all_algorithms(void)\n{\n\tOpenSSL_add_all_algorithms();\n\n\t/* Enable use of crypto hardware */\n\tENGINE_load_builtin_engines();\n\tENGINE_register_all_complete();\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tOPENSSL_config(NULL);\n#else\n\tOPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS |\n\t    OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_init(struct ssh **sshp, int is_server, struct kex_params *kex_params)\n{\n        char *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tstruct ssh *ssh;\n\tchar **proposal;\n\tstatic int called;\n\tint r;\n\n\tif (!called) {\n#ifdef WITH_OPENSSL\n\t\tOpenSSL_add_all_algorithms();\n#endif /* WITH_OPENSSL */\n\t\tcalled = 1;\n\t}\n\n\tif ((ssh = ssh_packet_set_connection(NULL, -1, -1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (is_server)\n\t\tssh_packet_set_server(ssh);\n\n\t/* Initialize key exchange */\n\tproposal = kex_params ? kex_params->proposal : myproposal;\n\tif ((r = kex_new(ssh, proposal, &ssh->kex)) != 0) {\n\t\tssh_free(ssh);\n\t\treturn r;\n\t}\n\tssh->kex->server = is_server;\n\tif (is_server) {\n#ifdef WITH_OPENSSL\n\t\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\t\tssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif /* WITH_OPENSSL */\n\t\tssh->kex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\t\tssh->kex->load_host_public_key=&_ssh_host_public_key;\n\t\tssh->kex->load_host_private_key=&_ssh_host_private_key;\n\t\tssh->kex->sign=&_ssh_host_key_sign;\n\t} else {\n#ifdef WITH_OPENSSL\n\t\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\t\tssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_client;\n# endif\n#endif /* WITH_OPENSSL */\n\t\tssh->kex->kex[KEX_C25519_SHA256] = kexc25519_client;\n\t\tssh->kex->verify_host_key =&_ssh_verify_host_key;\n\t}\n\t*sshp = ssh;\n\treturn 0;\n}"
  },
  {
    "function_name": "mm_choose_dh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "66-70",
    "snippet": "DH *\nmm_choose_dh(int min, int nbits, int max)\n{\n\treturn (NULL);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DH\t*mm_choose_dh(int, int, int);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nDH\t*mm_choose_dh(int, int, int);\n\nDH *\nmm_choose_dh(int min, int nbits, int max)\n{\n\treturn (NULL);\n}"
  },
  {
    "function_name": "mm_sshkey_sign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
    "lines": "59-64",
    "snippet": "int\nmm_sshkey_sign(struct sshkey *key, u_char **sigp, u_int *lenp,\n    u_char *data, u_int datalen, char *alg, u_int compat)\n{\n\treturn (-1);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"myproposal.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"ssh_api.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t_ssh_host_key_sign(struct sshkey *, struct sshkey *,\n    u_char **, size_t *, const u_char *, size_t, const char *, u_int);",
      "int\tmm_sshkey_sign(struct sshkey *, u_char **, u_int *,\n    u_char *, u_int, char *, u_int);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_host_key_sign(struct sshkey *, struct sshkey *,\n    u_char **, size_t *, const u_char *, size_t, const char *, u_int);\nint\tmm_sshkey_sign(struct sshkey *, u_char **, u_int *,\n    u_char *, u_int, char *, u_int);\n\nint\nmm_sshkey_sign(struct sshkey *key, u_char **sigp, u_int *lenp,\n    u_char *data, u_int datalen, char *alg, u_int compat)\n{\n\treturn (-1);\n}"
  }
]