[
  {
    "function_name": "sshbuf_getput_fuzz_tests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshbuf/test_sshbuf_getput_fuzz.c",
    "lines": "80-129",
    "snippet": "void\nsshbuf_getput_fuzz_tests(void)\n{\n\tu_char blob[] = {\n\t\t/* u8 */\n\t\t0xd0,\n\t\t/* u16 */\n\t\t0xc0, 0xde,\n\t\t/* u32 */\n\t\t0xfa, 0xce, 0xde, 0xad,\n\t\t/* u64 */\n\t\t0xfe, 0xed, 0xac, 0x1d, 0x1f, 0x1c, 0xbe, 0xef,\n\t\t/* string */\n\t\t0x00, 0x00, 0x00, 0x09,\n\t\t'O', ' ', 'G', 'o', 'r', 'g', 'o', 'n', '!',\n\t\t/* bignum1 */\n\t\t0x79,\n\t\t0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n\t\t0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,\n\t\t/* bignum2 */\n\t\t0x00, 0x00, 0x00, 0x14,\n\t\t0x00,\n\t\t0xf0, 0xe0, 0xd0, 0xc0, 0xb0, 0xa0, 0x90, 0x80,\n\t\t0x70, 0x60, 0x50, 0x40, 0x30, 0x20, 0x10, 0x00,\n\t\t0x7f, 0xff, 0x11,\n\t\t/* EC point (NIST-256 curve) */\n\t\t0x00, 0x00, 0x00, 0x41,\n\t\t0x04,\n\t\t0x0c, 0x82, 0x80, 0x04, 0x83, 0x9d, 0x01, 0x06,\n\t\t0xaa, 0x59, 0x57, 0x52, 0x16, 0x19, 0x13, 0x57,\n\t\t0x34, 0xb4, 0x51, 0x45, 0x9d, 0xad, 0xb5, 0x86,\n\t\t0x67, 0x7e, 0xf9, 0xdf, 0x55, 0x78, 0x49, 0x99,\n\t\t0x4d, 0x19, 0x6b, 0x50, 0xf0, 0xb4, 0xe9, 0x4b,\n\t\t0x3c, 0x73, 0xe3, 0xa9, 0xd4, 0xcd, 0x9d, 0xf2,\n\t\t0xc8, 0xf9, 0xa3, 0x5e, 0x42, 0xbd, 0xd0, 0x47,\n\t\t0x55, 0x0f, 0x69, 0xd8, 0x0e, 0xc2, 0x3c, 0xd4,\n\t};\n\tstruct fuzz *fuzz;\n\n\tTEST_START(\"fuzz blob parsing\");\n\tfuzz = fuzz_begin(FUZZ_1_BIT_FLIP | FUZZ_2_BIT_FLIP |\n\t    FUZZ_1_BYTE_FLIP | FUZZ_2_BYTE_FLIP |\n\t    FUZZ_TRUNCATE_START | FUZZ_TRUNCATE_END, blob, sizeof(blob));\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz))\n\t\tattempt_parse_blob(blob, sizeof(blob));\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\tTEST_ONERROR(NULL, NULL);\n}",
    "includes": [
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/objects.h>",
      "#include <openssl/bn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sshbuf_getput_fuzz_tests(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TEST_ONERROR",
          "args": [
            "NULL",
            "NULL"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuzz_cleanup",
          "args": [
            "fuzz"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "243-258",
          "snippet": "void\nfuzz_cleanup(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"cleanup, fuzz = %p\", fuzz));\n\tlast_fuzz = NULL;\n#ifdef SIGINFO\n\tsignal(SIGINFO, SIG_DFL);\n#endif\n\tsignal(SIGUSR1, SIG_DFL);\n\tassert(fuzz != NULL);\n\tassert(fuzz->seed != NULL);\n\tassert(fuzz->fuzzed != NULL);\n\tfree(fuzz->seed);\n\tfree(fuzz->fuzzed);\n\tfree(fuzz);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fuzz *last_fuzz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct fuzz *last_fuzz;\n\nvoid\nfuzz_cleanup(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"cleanup, fuzz = %p\", fuzz));\n\tlast_fuzz = NULL;\n#ifdef SIGINFO\n\tsignal(SIGINFO, SIG_DFL);\n#endif\n\tsignal(SIGUSR1, SIG_DFL);\n\tassert(fuzz != NULL);\n\tassert(fuzz->seed != NULL);\n\tassert(fuzz->fuzzed != NULL);\n\tfree(fuzz->seed);\n\tfree(fuzz->fuzzed);\n\tfree(fuzz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "attempt_parse_blob",
          "args": [
            "blob",
            "sizeof(blob)"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "attempt_parse_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshbuf/test_sshbuf_getput_fuzz.c",
          "lines": "31-70",
          "snippet": "static void\nattempt_parse_blob(u_char *blob, size_t len)\n{\n\tstruct sshbuf *p1;\n\tBIGNUM *bn;\n#if defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256)\n\tEC_KEY *eck;\n#endif\n\tu_char *s;\n\tsize_t l;\n\tu_int8_t u8;\n\tu_int16_t u16;\n\tu_int32_t u32;\n\tu_int64_t u64;\n\n\tp1 = sshbuf_new();\n\tASSERT_PTR_NE(p1, NULL);\n\tASSERT_INT_EQ(sshbuf_put(p1, blob, len), 0);\n\tsshbuf_get_u8(p1, &u8);\n\tsshbuf_get_u16(p1, &u16);\n\tsshbuf_get_u32(p1, &u32);\n\tsshbuf_get_u64(p1, &u64);\n\tif (sshbuf_get_string(p1, &s, &l) == 0) {\n\t\tbzero(s, l);\n\t\tfree(s);\n\t}\n\tbn = BN_new();\n\tsshbuf_get_bignum1(p1, bn);\n\tBN_clear_free(bn);\n\tbn = BN_new();\n\tsshbuf_get_bignum2(p1, bn);\n\tBN_clear_free(bn);\n#if defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256)\n\teck = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\tASSERT_PTR_NE(eck, NULL);\n\tsshbuf_get_eckey(p1, eck);\n\tEC_KEY_free(eck);\n#endif\n\tsshbuf_free(p1);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nattempt_parse_blob(u_char *blob, size_t len)\n{\n\tstruct sshbuf *p1;\n\tBIGNUM *bn;\n#if defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256)\n\tEC_KEY *eck;\n#endif\n\tu_char *s;\n\tsize_t l;\n\tu_int8_t u8;\n\tu_int16_t u16;\n\tu_int32_t u32;\n\tu_int64_t u64;\n\n\tp1 = sshbuf_new();\n\tASSERT_PTR_NE(p1, NULL);\n\tASSERT_INT_EQ(sshbuf_put(p1, blob, len), 0);\n\tsshbuf_get_u8(p1, &u8);\n\tsshbuf_get_u16(p1, &u16);\n\tsshbuf_get_u32(p1, &u32);\n\tsshbuf_get_u64(p1, &u64);\n\tif (sshbuf_get_string(p1, &s, &l) == 0) {\n\t\tbzero(s, l);\n\t\tfree(s);\n\t}\n\tbn = BN_new();\n\tsshbuf_get_bignum1(p1, bn);\n\tBN_clear_free(bn);\n\tbn = BN_new();\n\tsshbuf_get_bignum2(p1, bn);\n\tBN_clear_free(bn);\n#if defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256)\n\teck = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\tASSERT_PTR_NE(eck, NULL);\n\tsshbuf_get_eckey(p1, eck);\n\tEC_KEY_free(eck);\n#endif\n\tsshbuf_free(p1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_next",
          "args": [
            "fuzz"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "283-378",
          "snippet": "void\nfuzz_next(struct fuzz *fuzz)\n{\n\tu_int i;\n\n\tFUZZ_DBG((\"start, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tif (fuzz->strategy == 0 || fuzz_strategy_done(fuzz)) {\n\t\t/* If we are just starting out, we need to allocate too */\n\t\tif (fuzz->fuzzed == NULL) {\n\t\t\tFUZZ_DBG((\"alloc\"));\n\t\t\tfuzz->fuzzed = calloc(fuzz->slen, 1);\n\t\t}\n\t\t/* Pick next strategy */\n\t\tFUZZ_DBG((\"advance\"));\n\t\tfor (i = 1; i <= FUZZ_MAX; i <<= 1) {\n\t\t\tif ((fuzz->strategies & i) != 0) {\n\t\t\t\tfuzz->strategy = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFUZZ_DBG((\"selected = %u\", fuzz->strategy));\n\t\tif (fuzz->strategy == 0) {\n\t\t\tFUZZ_DBG((\"done, no more strategies\"));\n\t\t\treturn;\n\t\t}\n\t\tfuzz->strategies &= ~(fuzz->strategy);\n\t\tfuzz->o1 = fuzz->o2 = 0;\n\t}\n\n\tassert(fuzz->fuzzed != NULL);\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tassert(fuzz->o2 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->fuzzed[fuzz->o2 / 8] ^= 1 << (fuzz->o2 % 8);\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen * 8) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->fuzzed[fuzz->o2] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] = fuzz_b64chars[fuzz->o2];\n\t\tfuzz->o2++;\n\t\tif (fuzz->o2 >= sizeof(fuzz_b64chars) - 1) {\n\t\t\tfuzz->o2 = 0;\n\t\t\tfuzz->o1++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tFUZZ_DBG((\"done, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nvoid\nfuzz_next(struct fuzz *fuzz)\n{\n\tu_int i;\n\n\tFUZZ_DBG((\"start, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tif (fuzz->strategy == 0 || fuzz_strategy_done(fuzz)) {\n\t\t/* If we are just starting out, we need to allocate too */\n\t\tif (fuzz->fuzzed == NULL) {\n\t\t\tFUZZ_DBG((\"alloc\"));\n\t\t\tfuzz->fuzzed = calloc(fuzz->slen, 1);\n\t\t}\n\t\t/* Pick next strategy */\n\t\tFUZZ_DBG((\"advance\"));\n\t\tfor (i = 1; i <= FUZZ_MAX; i <<= 1) {\n\t\t\tif ((fuzz->strategies & i) != 0) {\n\t\t\t\tfuzz->strategy = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFUZZ_DBG((\"selected = %u\", fuzz->strategy));\n\t\tif (fuzz->strategy == 0) {\n\t\t\tFUZZ_DBG((\"done, no more strategies\"));\n\t\t\treturn;\n\t\t}\n\t\tfuzz->strategies &= ~(fuzz->strategy);\n\t\tfuzz->o1 = fuzz->o2 = 0;\n\t}\n\n\tassert(fuzz->fuzzed != NULL);\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tassert(fuzz->o2 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->fuzzed[fuzz->o2 / 8] ^= 1 << (fuzz->o2 % 8);\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen * 8) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->fuzzed[fuzz->o2] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] = fuzz_b64chars[fuzz->o2];\n\t\tfuzz->o2++;\n\t\tif (fuzz->o2 >= sizeof(fuzz_b64chars) - 1) {\n\t\t\tfuzz->o2 = 0;\n\t\t\tfuzz->o1++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tFUZZ_DBG((\"done, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_done",
          "args": [
            "fuzz"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "388-395",
          "snippet": "int\nfuzz_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategies = 0x%lx\", fuzz,\n\t    (u_long)fuzz->strategies));\n\n\treturn fuzz_strategy_done(fuzz) && fuzz->strategies == 0;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nfuzz_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategies = 0x%lx\", fuzz,\n\t    (u_long)fuzz->strategies));\n\n\treturn fuzz_strategy_done(fuzz) && fuzz->strategies == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_ONERROR",
          "args": [
            "onerror",
            "fuzz"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuzz_begin",
          "args": [
            "FUZZ_1_BIT_FLIP | FUZZ_2_BIT_FLIP |\n\t    FUZZ_1_BYTE_FLIP | FUZZ_2_BYTE_FLIP |\n\t    FUZZ_TRUNCATE_START | FUZZ_TRUNCATE_END",
            "blob",
            "sizeof(blob)"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "214-241",
          "snippet": "struct fuzz *\nfuzz_begin(u_int strategies, const void *p, size_t l)\n{\n\tstruct fuzz *ret = calloc(sizeof(*ret), 1);\n\n\tassert(p != NULL);\n\tassert(ret != NULL);\n\tret->seed = malloc(l);\n\tassert(ret->seed != NULL);\n\tmemcpy(ret->seed, p, l);\n\tret->slen = l;\n\tret->strategies = strategies;\n\n\tassert(ret->slen < SIZE_MAX / 8);\n\tassert(ret->strategies <= (FUZZ_MAX|(FUZZ_MAX-1)));\n\n\tFUZZ_DBG((\"begin, ret = %p\", ret));\n\n\tfuzz_next(ret);\n\n\tlast_fuzz = ret;\n#ifdef SIGINFO\n\tsignal(SIGINFO, siginfo);\n#endif\n\tsignal(SIGUSR1, siginfo);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fuzz *last_fuzz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct fuzz *last_fuzz;\n\nstruct fuzz *\nfuzz_begin(u_int strategies, const void *p, size_t l)\n{\n\tstruct fuzz *ret = calloc(sizeof(*ret), 1);\n\n\tassert(p != NULL);\n\tassert(ret != NULL);\n\tret->seed = malloc(l);\n\tassert(ret->seed != NULL);\n\tmemcpy(ret->seed, p, l);\n\tret->slen = l;\n\tret->strategies = strategies;\n\n\tassert(ret->slen < SIZE_MAX / 8);\n\tassert(ret->strategies <= (FUZZ_MAX|(FUZZ_MAX-1)));\n\n\tFUZZ_DBG((\"begin, ret = %p\", ret));\n\n\tfuzz_next(ret);\n\n\tlast_fuzz = ret;\n#ifdef SIGINFO\n\tsignal(SIGINFO, siginfo);\n#endif\n\tsignal(SIGUSR1, siginfo);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz blob parsing\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid sshbuf_getput_fuzz_tests(void);\n\nvoid\nsshbuf_getput_fuzz_tests(void)\n{\n\tu_char blob[] = {\n\t\t/* u8 */\n\t\t0xd0,\n\t\t/* u16 */\n\t\t0xc0, 0xde,\n\t\t/* u32 */\n\t\t0xfa, 0xce, 0xde, 0xad,\n\t\t/* u64 */\n\t\t0xfe, 0xed, 0xac, 0x1d, 0x1f, 0x1c, 0xbe, 0xef,\n\t\t/* string */\n\t\t0x00, 0x00, 0x00, 0x09,\n\t\t'O', ' ', 'G', 'o', 'r', 'g', 'o', 'n', '!',\n\t\t/* bignum1 */\n\t\t0x79,\n\t\t0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n\t\t0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,\n\t\t/* bignum2 */\n\t\t0x00, 0x00, 0x00, 0x14,\n\t\t0x00,\n\t\t0xf0, 0xe0, 0xd0, 0xc0, 0xb0, 0xa0, 0x90, 0x80,\n\t\t0x70, 0x60, 0x50, 0x40, 0x30, 0x20, 0x10, 0x00,\n\t\t0x7f, 0xff, 0x11,\n\t\t/* EC point (NIST-256 curve) */\n\t\t0x00, 0x00, 0x00, 0x41,\n\t\t0x04,\n\t\t0x0c, 0x82, 0x80, 0x04, 0x83, 0x9d, 0x01, 0x06,\n\t\t0xaa, 0x59, 0x57, 0x52, 0x16, 0x19, 0x13, 0x57,\n\t\t0x34, 0xb4, 0x51, 0x45, 0x9d, 0xad, 0xb5, 0x86,\n\t\t0x67, 0x7e, 0xf9, 0xdf, 0x55, 0x78, 0x49, 0x99,\n\t\t0x4d, 0x19, 0x6b, 0x50, 0xf0, 0xb4, 0xe9, 0x4b,\n\t\t0x3c, 0x73, 0xe3, 0xa9, 0xd4, 0xcd, 0x9d, 0xf2,\n\t\t0xc8, 0xf9, 0xa3, 0x5e, 0x42, 0xbd, 0xd0, 0x47,\n\t\t0x55, 0x0f, 0x69, 0xd8, 0x0e, 0xc2, 0x3c, 0xd4,\n\t};\n\tstruct fuzz *fuzz;\n\n\tTEST_START(\"fuzz blob parsing\");\n\tfuzz = fuzz_begin(FUZZ_1_BIT_FLIP | FUZZ_2_BIT_FLIP |\n\t    FUZZ_1_BYTE_FLIP | FUZZ_2_BYTE_FLIP |\n\t    FUZZ_TRUNCATE_START | FUZZ_TRUNCATE_END, blob, sizeof(blob));\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz))\n\t\tattempt_parse_blob(blob, sizeof(blob));\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\tTEST_ONERROR(NULL, NULL);\n}"
  },
  {
    "function_name": "onerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshbuf/test_sshbuf_getput_fuzz.c",
    "lines": "73-78",
    "snippet": "static void\nonerror(void *fuzz)\n{\n\tfprintf(stderr, \"Failed during fuzz:\\n\");\n\tfuzz_dump((struct fuzz *)fuzz);\n}",
    "includes": [
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/objects.h>",
      "#include <openssl/bn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuzz_dump",
          "args": [
            "(struct fuzz *)fuzz"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "183-197",
          "snippet": "void\nfuzz_dump(struct fuzz *fuzz)\n{\n\tchar buf[256];\n\n\tif (fuzz_fmt(fuzz, buf, sizeof(buf)) != 0) {\n\t\tfprintf(stderr, \"%s: fuzz invalid\\n\", __func__);\n\t\tabort();\n\t}\n\tfputs(buf, stderr);\n\tfprintf(stderr, \"fuzz original %p len = %zu\\n\", fuzz->seed, fuzz->slen);\n\tdump(fuzz->seed, fuzz->slen);\n\tfprintf(stderr, \"fuzz context %p len = %zu\\n\", fuzz, fuzz_len(fuzz));\n\tdump(fuzz_ptr(fuzz), fuzz_len(fuzz));\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfuzz_dump(struct fuzz *fuzz)\n{\n\tchar buf[256];\n\n\tif (fuzz_fmt(fuzz, buf, sizeof(buf)) != 0) {\n\t\tfprintf(stderr, \"%s: fuzz invalid\\n\", __func__);\n\t\tabort();\n\t}\n\tfputs(buf, stderr);\n\tfprintf(stderr, \"fuzz original %p len = %zu\\n\", fuzz->seed, fuzz->slen);\n\tdump(fuzz->seed, fuzz->slen);\n\tfprintf(stderr, \"fuzz context %p len = %zu\\n\", fuzz, fuzz_len(fuzz));\n\tdump(fuzz_ptr(fuzz), fuzz_len(fuzz));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed during fuzz:\\n\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nonerror(void *fuzz)\n{\n\tfprintf(stderr, \"Failed during fuzz:\\n\");\n\tfuzz_dump((struct fuzz *)fuzz);\n}"
  },
  {
    "function_name": "attempt_parse_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshbuf/test_sshbuf_getput_fuzz.c",
    "lines": "31-70",
    "snippet": "static void\nattempt_parse_blob(u_char *blob, size_t len)\n{\n\tstruct sshbuf *p1;\n\tBIGNUM *bn;\n#if defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256)\n\tEC_KEY *eck;\n#endif\n\tu_char *s;\n\tsize_t l;\n\tu_int8_t u8;\n\tu_int16_t u16;\n\tu_int32_t u32;\n\tu_int64_t u64;\n\n\tp1 = sshbuf_new();\n\tASSERT_PTR_NE(p1, NULL);\n\tASSERT_INT_EQ(sshbuf_put(p1, blob, len), 0);\n\tsshbuf_get_u8(p1, &u8);\n\tsshbuf_get_u16(p1, &u16);\n\tsshbuf_get_u32(p1, &u32);\n\tsshbuf_get_u64(p1, &u64);\n\tif (sshbuf_get_string(p1, &s, &l) == 0) {\n\t\tbzero(s, l);\n\t\tfree(s);\n\t}\n\tbn = BN_new();\n\tsshbuf_get_bignum1(p1, bn);\n\tBN_clear_free(bn);\n\tbn = BN_new();\n\tsshbuf_get_bignum2(p1, bn);\n\tBN_clear_free(bn);\n#if defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256)\n\teck = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\tASSERT_PTR_NE(eck, NULL);\n\tsshbuf_get_eckey(p1, eck);\n\tEC_KEY_free(eck);\n#endif\n\tsshbuf_free(p1);\n}",
    "includes": [
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/objects.h>",
      "#include <openssl/bn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "p1"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_free",
          "args": [
            "eck"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_eckey",
          "args": [
            "p1",
            "eck"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_eckey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-crypto.c",
          "lines": "110-143",
          "snippet": "int\nsshbuf_get_eckey(struct sshbuf *buf, EC_KEY *v)\n{\n\tEC_POINT *pt = EC_POINT_new(EC_KEY_get0_group(v));\n\tint r;\n\tconst u_char *d;\n\tsize_t len;\n\n\tif (pt == NULL) {\n\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_peek_string_direct(buf, &d, &len)) < 0) {\n\t\tEC_POINT_free(pt);\n\t\treturn r;\n\t}\n\tif ((r = get_ec(d, len, pt, EC_KEY_get0_group(v))) != 0) {\n\t\tEC_POINT_free(pt);\n\t\treturn r;\n\t}\n\tif (EC_KEY_set_public_key(v, pt) != 1) {\n\t\tEC_POINT_free(pt);\n\t\treturn SSH_ERR_ALLOC_FAIL; /* XXX assumption */\n\t}\n\tEC_POINT_free(pt);\n\t/* Skip string */\n\tif (sshbuf_get_string_direct(buf, NULL, NULL) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\t\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n# include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_eckey(struct sshbuf *buf, EC_KEY *v)\n{\n\tEC_POINT *pt = EC_POINT_new(EC_KEY_get0_group(v));\n\tint r;\n\tconst u_char *d;\n\tsize_t len;\n\n\tif (pt == NULL) {\n\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_peek_string_direct(buf, &d, &len)) < 0) {\n\t\tEC_POINT_free(pt);\n\t\treturn r;\n\t}\n\tif ((r = get_ec(d, len, pt, EC_KEY_get0_group(v))) != 0) {\n\t\tEC_POINT_free(pt);\n\t\treturn r;\n\t}\n\tif (EC_KEY_set_public_key(v, pt) != 1) {\n\t\tEC_POINT_free(pt);\n\t\treturn SSH_ERR_ALLOC_FAIL; /* XXX assumption */\n\t}\n\tEC_POINT_free(pt);\n\t/* Skip string */\n\tif (sshbuf_get_string_direct(buf, NULL, NULL) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "eck",
            "NULL"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_new_by_curve_name",
          "args": [
            "NID_X9_62_prime256v1"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "bn"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_bignum2",
          "args": [
            "p1",
            "bn"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_bignum2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-crypto.c",
          "lines": "34-46",
          "snippet": "int\nsshbuf_get_bignum2(struct sshbuf *buf, BIGNUM *v)\n{\n\tconst u_char *d;\n\tsize_t len;\n\tint r;\n\n\tif ((r = sshbuf_get_bignum2_bytes_direct(buf, &d, &len)) != 0)\n\t\treturn r;\n\tif (v != NULL && BN_bin2bn(d, len, v) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n# include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_bignum2(struct sshbuf *buf, BIGNUM *v)\n{\n\tconst u_char *d;\n\tsize_t len;\n\tint r;\n\n\tif ((r = sshbuf_get_bignum2_bytes_direct(buf, &d, &len)) != 0)\n\t\treturn r;\n\tif (v != NULL && BN_bin2bn(d, len, v) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "bn"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_bignum1",
          "args": [
            "p1",
            "bn"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_bignum1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-crypto.c",
          "lines": "48-72",
          "snippet": "int\nsshbuf_get_bignum1(struct sshbuf *buf, BIGNUM *v)\n{\n\tconst u_char *d = sshbuf_ptr(buf);\n\tu_int16_t len_bits;\n\tsize_t len_bytes;\n\n\t/* Length in bits */\n\tif (sshbuf_len(buf) < 2)\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tlen_bits = PEEK_U16(d);\n\tlen_bytes = (len_bits + 7) >> 3;\n\tif (len_bytes > SSHBUF_MAX_BIGNUM)\n\t\treturn SSH_ERR_BIGNUM_TOO_LARGE;\n\tif (sshbuf_len(buf) < 2 + len_bytes)\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tif (v != NULL && BN_bin2bn(d + 2, len_bytes, v) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (sshbuf_consume(buf, 2 + len_bytes) != 0) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n# include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_bignum1(struct sshbuf *buf, BIGNUM *v)\n{\n\tconst u_char *d = sshbuf_ptr(buf);\n\tu_int16_t len_bits;\n\tsize_t len_bytes;\n\n\t/* Length in bits */\n\tif (sshbuf_len(buf) < 2)\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tlen_bits = PEEK_U16(d);\n\tlen_bytes = (len_bits + 7) >> 3;\n\tif (len_bytes > SSHBUF_MAX_BIGNUM)\n\t\treturn SSH_ERR_BIGNUM_TOO_LARGE;\n\tif (sshbuf_len(buf) < 2 + len_bytes)\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tif (v != NULL && BN_bin2bn(d + 2, len_bytes, v) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (sshbuf_consume(buf, 2 + len_bytes) != 0) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "s",
            "l"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "288-292",
          "snippet": "void\nbzero(void *b, size_t n)\n{\n\t(void)memset(b, 0, n);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nbzero(void *b, size_t n)\n{\n\t(void)memset(b, 0, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "p1",
            "&s",
            "&l"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u64",
          "args": [
            "p1",
            "&u64"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "44-55",
          "snippet": "int\nsshbuf_get_u64(struct sshbuf *buf, u_int64_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 8)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U64(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u64(struct sshbuf *buf, u_int64_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 8)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U64(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "p1",
            "&u32"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u16",
          "args": [
            "p1",
            "&u16"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "70-81",
          "snippet": "int\nsshbuf_get_u16(struct sshbuf *buf, u_int16_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 2)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U16(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u16(struct sshbuf *buf, u_int16_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 2)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U16(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "p1",
            "&u8"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put(p1, blob, len)",
            "0"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "p1",
            "blob",
            "len"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "p1",
            "NULL"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nattempt_parse_blob(u_char *blob, size_t len)\n{\n\tstruct sshbuf *p1;\n\tBIGNUM *bn;\n#if defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256)\n\tEC_KEY *eck;\n#endif\n\tu_char *s;\n\tsize_t l;\n\tu_int8_t u8;\n\tu_int16_t u16;\n\tu_int32_t u32;\n\tu_int64_t u64;\n\n\tp1 = sshbuf_new();\n\tASSERT_PTR_NE(p1, NULL);\n\tASSERT_INT_EQ(sshbuf_put(p1, blob, len), 0);\n\tsshbuf_get_u8(p1, &u8);\n\tsshbuf_get_u16(p1, &u16);\n\tsshbuf_get_u32(p1, &u32);\n\tsshbuf_get_u64(p1, &u64);\n\tif (sshbuf_get_string(p1, &s, &l) == 0) {\n\t\tbzero(s, l);\n\t\tfree(s);\n\t}\n\tbn = BN_new();\n\tsshbuf_get_bignum1(p1, bn);\n\tBN_clear_free(bn);\n\tbn = BN_new();\n\tsshbuf_get_bignum2(p1, bn);\n\tBN_clear_free(bn);\n#if defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256)\n\teck = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\tASSERT_PTR_NE(eck, NULL);\n\tsshbuf_get_eckey(p1, eck);\n\tEC_KEY_free(eck);\n#endif\n\tsshbuf_free(p1);\n}"
  }
]