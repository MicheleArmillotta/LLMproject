[
  {
    "function_name": "sshkey_set_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "4158-4164",
    "snippet": "int\nsshkey_set_filename(struct sshkey *k, const char *filename)\n{\n\tif (k == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_set_filename(struct sshkey *k, const char *filename)\n{\n\tif (k == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_enable_maxsign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "4152-4156",
    "snippet": "int\nsshkey_enable_maxsign(struct sshkey *k, u_int32_t maxsign)\n{\n\treturn SSH_ERR_INVALID_ARGUMENT;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_enable_maxsign(struct sshkey *k, u_int32_t maxsign)\n{\n\treturn SSH_ERR_INVALID_ARGUMENT;\n}"
  },
  {
    "function_name": "sshkey_signatures_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "4146-4150",
    "snippet": "u_int32_t\nsshkey_signatures_left(const struct sshkey *k)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\nsshkey_signatures_left(const struct sshkey *k)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_private_serialize_maxsign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "4139-4144",
    "snippet": "int\nsshkey_private_serialize_maxsign(const struct sshkey *k, struct sshbuf *b,\n    u_int32_t maxsign, sshkey_printfn *pr)\n{\n\treturn sshkey_private_serialize_opt(k, b, SSHKEY_SERIALIZE_DEFAULT);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_private_serialize_opt",
          "args": [
            "k",
            "b",
            "SSHKEY_SERIALIZE_DEFAULT"
          ],
          "line": 4143
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_private_serialize_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2767-2906",
          "snippet": "int\nsshkey_private_serialize_opt(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *rsa_d, *rsa_iqmp, *rsa_p, *rsa_q;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key, *dsa_priv_key;\n#endif /* WITH_OPENSSL */\n\n\tif ((r = sshbuf_put_cstring(b, sshkey_ssh_name(key))) != 0)\n\t\tgoto out;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_bignum2(b, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tDSA_get0_key(key->dsa, NULL, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((r = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (r = sshbuf_put_eckey(b, key->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0 ||\n\t\t    key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nint\nsshkey_private_serialize_opt(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *rsa_d, *rsa_iqmp, *rsa_p, *rsa_q;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key, *dsa_priv_key;\n#endif /* WITH_OPENSSL */\n\n\tif ((r = sshbuf_put_cstring(b, sshkey_ssh_name(key))) != 0)\n\t\tgoto out;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_bignum2(b, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tDSA_get0_key(key->dsa, NULL, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((r = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (r = sshbuf_put_eckey(b, key->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0 ||\n\t\t    key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_private_serialize_maxsign(const struct sshkey *k, struct sshbuf *b,\n    u_int32_t maxsign, sshkey_printfn *pr)\n{\n\treturn sshkey_private_serialize_opt(k, b, SSHKEY_SERIALIZE_DEFAULT);\n}"
  },
  {
    "function_name": "sshkey_set_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "4125-4137",
    "snippet": "int\nsshkey_set_filename(struct sshkey *k, const char *filename)\n{\n\tif (k == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (sshkey_type_plain(k->type) != KEY_XMSS)\n\t\treturn 0;\n\tif (filename == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((k->xmss_filename = strdup(filename)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "filename"
          ],
          "line": 4134
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "k->type"
          ],
          "line": 4130
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_set_filename(struct sshkey *k, const char *filename)\n{\n\tif (k == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (sshkey_type_plain(k->type) != KEY_XMSS)\n\t\treturn 0;\n\tif (filename == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((k->xmss_filename = strdup(filename)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_enable_maxsign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "4117-4123",
    "snippet": "int\nsshkey_enable_maxsign(struct sshkey *k, u_int32_t maxsign)\n{\n\tif (sshkey_type_plain(k->type) != KEY_XMSS)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\treturn sshkey_xmss_enable_maxsign(k, maxsign);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_xmss_enable_maxsign",
          "args": [
            "k",
            "maxsign"
          ],
          "line": 4122
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_enable_maxsign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "1041-1054",
          "snippet": "int\nsshkey_xmss_enable_maxsign(struct sshkey *k, u_int32_t maxsign)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\n\tif (sshkey_type_plain(k->type) != KEY_XMSS)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (maxsign == 0)\n\t\treturn 0;\n\tif (state->idx + maxsign < state->idx)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tstate->maxidx = state->idx + maxsign;\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_enable_maxsign(struct sshkey *k, u_int32_t maxsign)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\n\tif (sshkey_type_plain(k->type) != KEY_XMSS)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (maxsign == 0)\n\t\treturn 0;\n\tif (state->idx + maxsign < state->idx)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tstate->maxidx = state->idx + maxsign;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "k->type"
          ],
          "line": 4120
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_enable_maxsign(struct sshkey *k, u_int32_t maxsign)\n{\n\tif (sshkey_type_plain(k->type) != KEY_XMSS)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\treturn sshkey_xmss_enable_maxsign(k, maxsign);\n}"
  },
  {
    "function_name": "sshkey_signatures_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "4109-4115",
    "snippet": "u_int32_t\nsshkey_signatures_left(const struct sshkey *k)\n{\n\tif (sshkey_type_plain(k->type) == KEY_XMSS)\n\t\treturn sshkey_xmss_signatures_left(k);\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_xmss_signatures_left",
          "args": [
            "k"
          ],
          "line": 4113
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_signatures_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "1026-1039",
          "snippet": "u_int32_t\nsshkey_xmss_signatures_left(const struct sshkey *k)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_int32_t idx;\n\n\tif (sshkey_type_plain(k->type) == KEY_XMSS && state &&\n\t    state->maxidx) {\n\t\tidx = k->xmss_sk ? PEEK_U32(k->xmss_sk) : state->idx;\n\t\tif (idx < state->maxidx)\n\t\t\treturn state->maxidx - idx;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\nsshkey_xmss_signatures_left(const struct sshkey *k)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_int32_t idx;\n\n\tif (sshkey_type_plain(k->type) == KEY_XMSS && state &&\n\t    state->maxidx) {\n\t\tidx = k->xmss_sk ? PEEK_U32(k->xmss_sk) : state->idx;\n\t\tif (idx < state->maxidx)\n\t\t\treturn state->maxidx - idx;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "k->type"
          ],
          "line": 4112
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\nsshkey_signatures_left(const struct sshkey *k)\n{\n\tif (sshkey_type_plain(k->type) == KEY_XMSS)\n\t\treturn sshkey_xmss_signatures_left(k);\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_private_serialize_maxsign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "4085-4107",
    "snippet": "int\nsshkey_private_serialize_maxsign(const struct sshkey *k, struct sshbuf *b,\n    u_int32_t maxsign, sshkey_printfn *pr)\n{\n\tint r, rupdate;\n\n\tif (maxsign == 0 ||\n\t    sshkey_type_plain(k->type) != KEY_XMSS)\n\t\treturn sshkey_private_serialize_opt(k, b,\n\t\t    SSHKEY_SERIALIZE_DEFAULT);\n\tif ((r = sshkey_xmss_get_state(k, pr)) != 0 ||\n\t    (r = sshkey_private_serialize_opt(k, b,\n\t    SSHKEY_SERIALIZE_STATE)) != 0 ||\n\t    (r = sshkey_xmss_forward_state(k, maxsign)) != 0)\n\t\tgoto out;\n\tr = 0;\nout:\n\tif ((rupdate = sshkey_xmss_update_state(k, pr)) != 0) {\n\t\tif (r == 0)\n\t\t\tr = rupdate;\n\t}\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_xmss_update_state",
          "args": [
            "k",
            "pr"
          ],
          "line": 4102
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_update_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "565-674",
          "snippet": "int\nsshkey_xmss_update_state(const struct sshkey *k, sshkey_printfn *pr)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *b = NULL, *enc = NULL;\n\tu_int32_t idx = 0;\n\tunsigned char buf[4];\n\tchar *filename = NULL;\n\tchar *statefile = NULL, *ostatefile = NULL, *nstatefile = NULL;\n\tint fd = -1;\n\tint ret = SSH_ERR_INVALID_ARGUMENT;\n\n\tif (state == NULL || !state->allow_update)\n\t\treturn ret;\n\tif (state->maxidx) {\n\t\t/* no update since the number of signatures is limited */\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\tidx = PEEK_U32(k->xmss_sk);\n\tif (idx == state->idx) {\n\t\t/* no signature happened, no need to update */\n\t\tret = 0;\n\t\tgoto done;\n\t} else if (idx != state->idx + 1) {\n\t\tPRINT(\"%s: more than one signature happened: idx %u state %u\",\n\t\t     __func__, idx, state->idx);\n\t\tgoto done;\n\t}\n\tstate->idx = idx;\n\tif ((filename = k->xmss_filename) == NULL)\n\t\tgoto done;\n\tif (asprintf(&statefile, \"%s.state\", filename) < 0 ||\n\t    asprintf(&ostatefile, \"%s.ostate\", filename) < 0 ||\n\t    asprintf(&nstatefile, \"%s.nstate\", filename) < 0) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tunlink(nstatefile);\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((ret = sshkey_xmss_serialize_state(k, b)) != 0) {\n\t\tPRINT(\"%s: SERLIALIZE FAILED: %d\", __func__, ret);\n\t\tgoto done;\n\t}\n\tif ((ret = sshkey_xmss_encrypt_state(k, b, &enc)) != 0) {\n\t\tPRINT(\"%s: ENCRYPT FAILED: %d\", __func__, ret);\n\t\tgoto done;\n\t}\n\tif ((fd = open(nstatefile, O_CREAT|O_WRONLY|O_EXCL, 0600)) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: open new state file: %s\", __func__, nstatefile);\n\t\tgoto done;\n\t}\n\tPOKE_U32(buf, sshbuf_len(enc));\n\tif (atomicio(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: write new state file hdr: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(enc), sshbuf_len(enc)) !=\n\t    sshbuf_len(enc)) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: write new state file data: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (fsync(fd) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: sync new state file: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (close(fd) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: close new state file: %s\", __func__, nstatefile);\n\t\tgoto done;\n\t}\n\tif (state->have_state) {\n\t\tunlink(ostatefile);\n\t\tif (link(statefile, ostatefile)) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: backup state %s to %s\", __func__, statefile,\n\t\t\t    ostatefile);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (rename(nstatefile, statefile) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: rename %s to %s\", __func__, nstatefile, statefile);\n\t\tgoto done;\n\t}\n\tret = 0;\ndone:\n\tif (state->lockfd != -1) {\n\t\tclose(state->lockfd);\n\t\tstate->lockfd = -1;\n\t}\n\tif (nstatefile)\n\t\tunlink(nstatefile);\n\tfree(statefile);\n\tfree(ostatefile);\n\tfree(nstatefile);\n\tsshbuf_free(b);\n\tsshbuf_free(enc);\n\treturn ret;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_update_state(const struct sshkey *k, sshkey_printfn *pr)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *b = NULL, *enc = NULL;\n\tu_int32_t idx = 0;\n\tunsigned char buf[4];\n\tchar *filename = NULL;\n\tchar *statefile = NULL, *ostatefile = NULL, *nstatefile = NULL;\n\tint fd = -1;\n\tint ret = SSH_ERR_INVALID_ARGUMENT;\n\n\tif (state == NULL || !state->allow_update)\n\t\treturn ret;\n\tif (state->maxidx) {\n\t\t/* no update since the number of signatures is limited */\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\tidx = PEEK_U32(k->xmss_sk);\n\tif (idx == state->idx) {\n\t\t/* no signature happened, no need to update */\n\t\tret = 0;\n\t\tgoto done;\n\t} else if (idx != state->idx + 1) {\n\t\tPRINT(\"%s: more than one signature happened: idx %u state %u\",\n\t\t     __func__, idx, state->idx);\n\t\tgoto done;\n\t}\n\tstate->idx = idx;\n\tif ((filename = k->xmss_filename) == NULL)\n\t\tgoto done;\n\tif (asprintf(&statefile, \"%s.state\", filename) < 0 ||\n\t    asprintf(&ostatefile, \"%s.ostate\", filename) < 0 ||\n\t    asprintf(&nstatefile, \"%s.nstate\", filename) < 0) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tunlink(nstatefile);\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((ret = sshkey_xmss_serialize_state(k, b)) != 0) {\n\t\tPRINT(\"%s: SERLIALIZE FAILED: %d\", __func__, ret);\n\t\tgoto done;\n\t}\n\tif ((ret = sshkey_xmss_encrypt_state(k, b, &enc)) != 0) {\n\t\tPRINT(\"%s: ENCRYPT FAILED: %d\", __func__, ret);\n\t\tgoto done;\n\t}\n\tif ((fd = open(nstatefile, O_CREAT|O_WRONLY|O_EXCL, 0600)) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: open new state file: %s\", __func__, nstatefile);\n\t\tgoto done;\n\t}\n\tPOKE_U32(buf, sshbuf_len(enc));\n\tif (atomicio(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: write new state file hdr: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(enc), sshbuf_len(enc)) !=\n\t    sshbuf_len(enc)) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: write new state file data: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (fsync(fd) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: sync new state file: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (close(fd) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: close new state file: %s\", __func__, nstatefile);\n\t\tgoto done;\n\t}\n\tif (state->have_state) {\n\t\tunlink(ostatefile);\n\t\tif (link(statefile, ostatefile)) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: backup state %s to %s\", __func__, statefile,\n\t\t\t    ostatefile);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (rename(nstatefile, statefile) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: rename %s to %s\", __func__, nstatefile, statefile);\n\t\tgoto done;\n\t}\n\tret = 0;\ndone:\n\tif (state->lockfd != -1) {\n\t\tclose(state->lockfd);\n\t\tstate->lockfd = -1;\n\t}\n\tif (nstatefile)\n\t\tunlink(nstatefile);\n\tfree(statefile);\n\tfree(ostatefile);\n\tfree(nstatefile);\n\tsshbuf_free(b);\n\tsshbuf_free(enc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_forward_state",
          "args": [
            "k",
            "maxsign"
          ],
          "line": 4098
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_forward_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "532-563",
          "snippet": "int\nsshkey_xmss_forward_state(const struct sshkey *k, u_int32_t reserve)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char *sig = NULL;\n\tsize_t required_siglen;\n\tunsigned long long smlen;\n\tu_char data;\n\tint ret, r;\n\n\tif (state == NULL || !state->allow_update)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (reserve == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state->idx + reserve <= state->idx)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(k, &required_siglen)) != 0)\n\t\treturn r;\n\tif ((sig = malloc(required_siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\twhile (reserve-- > 0) {\n\t\tstate->idx = PEEK_U32(k->xmss_sk);\n\t\tsmlen = required_siglen;\n\t\tif ((ret = xmss_sign(k->xmss_sk, sshkey_xmss_bds_state(k),\n\t\t    sig, &smlen, &data, 0, sshkey_xmss_params(k))) != 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(sig);\n\treturn r;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_forward_state(const struct sshkey *k, u_int32_t reserve)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char *sig = NULL;\n\tsize_t required_siglen;\n\tunsigned long long smlen;\n\tu_char data;\n\tint ret, r;\n\n\tif (state == NULL || !state->allow_update)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (reserve == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state->idx + reserve <= state->idx)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(k, &required_siglen)) != 0)\n\t\treturn r;\n\tif ((sig = malloc(required_siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\twhile (reserve-- > 0) {\n\t\tstate->idx = PEEK_U32(k->xmss_sk);\n\t\tsmlen = required_siglen;\n\t\tif ((ret = xmss_sign(k->xmss_sk, sshkey_xmss_bds_state(k),\n\t\t    sig, &smlen, &data, 0, sshkey_xmss_params(k))) != 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(sig);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_private_serialize_opt",
          "args": [
            "k",
            "b",
            "SSHKEY_SERIALIZE_STATE"
          ],
          "line": 4096
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_private_serialize_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2767-2906",
          "snippet": "int\nsshkey_private_serialize_opt(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *rsa_d, *rsa_iqmp, *rsa_p, *rsa_q;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key, *dsa_priv_key;\n#endif /* WITH_OPENSSL */\n\n\tif ((r = sshbuf_put_cstring(b, sshkey_ssh_name(key))) != 0)\n\t\tgoto out;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_bignum2(b, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tDSA_get0_key(key->dsa, NULL, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((r = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (r = sshbuf_put_eckey(b, key->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0 ||\n\t\t    key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nint\nsshkey_private_serialize_opt(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *rsa_d, *rsa_iqmp, *rsa_p, *rsa_q;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key, *dsa_priv_key;\n#endif /* WITH_OPENSSL */\n\n\tif ((r = sshbuf_put_cstring(b, sshkey_ssh_name(key))) != 0)\n\t\tgoto out;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_bignum2(b, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tDSA_get0_key(key->dsa, NULL, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((r = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (r = sshbuf_put_eckey(b, key->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0 ||\n\t\t    key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_get_state",
          "args": [
            "k",
            "pr"
          ],
          "line": 4095
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_get_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "442-530",
          "snippet": "int\nsshkey_xmss_get_state(const struct sshkey *k, sshkey_printfn *pr)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_int32_t idx = 0;\n\tchar *filename = NULL;\n\tchar *statefile = NULL, *ostatefile = NULL, *lockfile = NULL;\n\tint lockfd = -1, have_state = 0, have_ostate, tries = 0;\n\tint ret = SSH_ERR_INVALID_ARGUMENT, r;\n\n\tif (state == NULL)\n\t\tgoto done;\n\t/*\n\t * If maxidx is set, then we are allowed a limited number\n\t * of signatures, but don't need to access the disk.\n\t * Otherwise we need to deal with the on-disk state.\n\t */\n\tif (state->maxidx) {\n\t\t/* xmss_sk always contains the current state */\n\t\tidx = PEEK_U32(k->xmss_sk);\n\t\tif (idx < state->maxidx) {\n\t\t\tstate->allow_update = 1;\n\t\t\treturn 0;\n\t\t}\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif ((filename = k->xmss_filename) == NULL)\n\t\tgoto done;\n\tif (asprintf(&lockfile, \"%s.lock\", filename) < 0 ||\n\t    asprintf(&statefile, \"%s.state\", filename) < 0 ||\n\t    asprintf(&ostatefile, \"%s.ostate\", filename) < 0) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((lockfd = open(lockfile, O_CREAT|O_RDONLY, 0600)) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: cannot open/create: %s\", __func__, lockfile);\n\t\tgoto done;\n\t}\n\twhile (flock(lockfd, LOCK_EX|LOCK_NB) < 0) {\n\t\tif (errno != EWOULDBLOCK) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: cannot lock: %s\", __func__, lockfile);\n\t\t\tgoto done;\n\t\t}\n\t\tif (++tries > 10) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: giving up on: %s\", __func__, lockfile);\n\t\t\tgoto done;\n\t\t}\n\t\tusleep(1000*100*tries);\n\t}\n\t/* XXX no longer const */\n\tif ((r = sshkey_xmss_get_state_from_file((struct sshkey *)k,\n\t    statefile, &have_state, pr)) != 0) {\n\t\tif ((r = sshkey_xmss_get_state_from_file((struct sshkey *)k,\n\t\t    ostatefile, &have_ostate, pr)) == 0) {\n\t\t\tstate->allow_update = 1;\n\t\t\tr = sshkey_xmss_forward_state(k, 1);\n\t\t\tstate->idx = PEEK_U32(k->xmss_sk);\n\t\t\tstate->allow_update = 0;\n\t\t}\n\t}\n\tif (!have_state && !have_ostate) {\n\t\t/* check that bds state is initialized */\n\t\tif (state->bds.auth == NULL)\n\t\t\tgoto done;\n\t\tPRINT(\"%s: start from scratch idx 0: %u\", __func__, state->idx);\n\t} else if (r != 0) {\n\t\tret = r;\n\t\tgoto done;\n\t}\n\tif (state->idx + 1 < state->idx) {\n\t\tPRINT(\"%s: state wrap: %u\", __func__, state->idx);\n\t\tgoto done;\n\t}\n\tstate->have_state = have_state;\n\tstate->lockfd = lockfd;\n\tstate->allow_update = 1;\n\tlockfd = -1;\n\tret = 0;\ndone:\n\tif (lockfd != -1)\n\t\tclose(lockfd);\n\tfree(lockfile);\n\tfree(statefile);\n\tfree(ostatefile);\n\treturn ret;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_get_state(const struct sshkey *k, sshkey_printfn *pr)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_int32_t idx = 0;\n\tchar *filename = NULL;\n\tchar *statefile = NULL, *ostatefile = NULL, *lockfile = NULL;\n\tint lockfd = -1, have_state = 0, have_ostate, tries = 0;\n\tint ret = SSH_ERR_INVALID_ARGUMENT, r;\n\n\tif (state == NULL)\n\t\tgoto done;\n\t/*\n\t * If maxidx is set, then we are allowed a limited number\n\t * of signatures, but don't need to access the disk.\n\t * Otherwise we need to deal with the on-disk state.\n\t */\n\tif (state->maxidx) {\n\t\t/* xmss_sk always contains the current state */\n\t\tidx = PEEK_U32(k->xmss_sk);\n\t\tif (idx < state->maxidx) {\n\t\t\tstate->allow_update = 1;\n\t\t\treturn 0;\n\t\t}\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif ((filename = k->xmss_filename) == NULL)\n\t\tgoto done;\n\tif (asprintf(&lockfile, \"%s.lock\", filename) < 0 ||\n\t    asprintf(&statefile, \"%s.state\", filename) < 0 ||\n\t    asprintf(&ostatefile, \"%s.ostate\", filename) < 0) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((lockfd = open(lockfile, O_CREAT|O_RDONLY, 0600)) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: cannot open/create: %s\", __func__, lockfile);\n\t\tgoto done;\n\t}\n\twhile (flock(lockfd, LOCK_EX|LOCK_NB) < 0) {\n\t\tif (errno != EWOULDBLOCK) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: cannot lock: %s\", __func__, lockfile);\n\t\t\tgoto done;\n\t\t}\n\t\tif (++tries > 10) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: giving up on: %s\", __func__, lockfile);\n\t\t\tgoto done;\n\t\t}\n\t\tusleep(1000*100*tries);\n\t}\n\t/* XXX no longer const */\n\tif ((r = sshkey_xmss_get_state_from_file((struct sshkey *)k,\n\t    statefile, &have_state, pr)) != 0) {\n\t\tif ((r = sshkey_xmss_get_state_from_file((struct sshkey *)k,\n\t\t    ostatefile, &have_ostate, pr)) == 0) {\n\t\t\tstate->allow_update = 1;\n\t\t\tr = sshkey_xmss_forward_state(k, 1);\n\t\t\tstate->idx = PEEK_U32(k->xmss_sk);\n\t\t\tstate->allow_update = 0;\n\t\t}\n\t}\n\tif (!have_state && !have_ostate) {\n\t\t/* check that bds state is initialized */\n\t\tif (state->bds.auth == NULL)\n\t\t\tgoto done;\n\t\tPRINT(\"%s: start from scratch idx 0: %u\", __func__, state->idx);\n\t} else if (r != 0) {\n\t\tret = r;\n\t\tgoto done;\n\t}\n\tif (state->idx + 1 < state->idx) {\n\t\tPRINT(\"%s: state wrap: %u\", __func__, state->idx);\n\t\tgoto done;\n\t}\n\tstate->have_state = have_state;\n\tstate->lockfd = lockfd;\n\tstate->allow_update = 1;\n\tlockfd = -1;\n\tret = 0;\ndone:\n\tif (lockfd != -1)\n\t\tclose(lockfd);\n\tfree(lockfile);\n\tfree(statefile);\n\tfree(ostatefile);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "k->type"
          ],
          "line": 4092
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_private_serialize_maxsign(const struct sshkey *k, struct sshbuf *b,\n    u_int32_t maxsign, sshkey_printfn *pr)\n{\n\tint r, rupdate;\n\n\tif (maxsign == 0 ||\n\t    sshkey_type_plain(k->type) != KEY_XMSS)\n\t\treturn sshkey_private_serialize_opt(k, b,\n\t\t    SSHKEY_SERIALIZE_DEFAULT);\n\tif ((r = sshkey_xmss_get_state(k, pr)) != 0 ||\n\t    (r = sshkey_private_serialize_opt(k, b,\n\t    SSHKEY_SERIALIZE_STATE)) != 0 ||\n\t    (r = sshkey_xmss_forward_state(k, maxsign)) != 0)\n\t\tgoto out;\n\tr = 0;\nout:\n\tif ((rupdate = sshkey_xmss_update_state(k, pr)) != 0) {\n\t\tif (r == 0)\n\t\t\tr = rupdate;\n\t}\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_parse_private_fileblob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "4067-4078",
    "snippet": "int\nsshkey_parse_private_fileblob(struct sshbuf *buffer, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\treturn sshkey_parse_private_fileblob_type(buffer, KEY_UNSPEC,\n\t    passphrase, keyp, commentp);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_parse_private_fileblob_type",
          "args": [
            "buffer",
            "KEY_UNSPEC",
            "passphrase",
            "keyp",
            "commentp"
          ],
          "line": 4076
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_parse_private_fileblob_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "4025-4065",
          "snippet": "int\nsshkey_parse_private_fileblob_type(struct sshbuf *blob, int type,\n    const char *passphrase, struct sshkey **keyp, char **commentp)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_RSA:\n\t\treturn sshkey_parse_private_pem_fileblob(blob, type,\n\t\t    passphrase, keyp);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n#endif /* WITH_XMSS */\n\t\treturn sshkey_parse_private2(blob, type, passphrase,\n\t\t    keyp, commentp);\n\tcase KEY_UNSPEC:\n\t\tr = sshkey_parse_private2(blob, type, passphrase, keyp,\n\t\t    commentp);\n\t\t/* Do not fallback to PEM parser if only passphrase is wrong. */\n\t\tif (r == 0 || r == SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\t\treturn r;\n#ifdef WITH_OPENSSL\n\t\treturn sshkey_parse_private_pem_fileblob(blob, type,\n\t\t    passphrase, keyp);\n#else\n\t\treturn SSH_ERR_INVALID_FORMAT;\n#endif /* WITH_OPENSSL */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_parse_private_fileblob_type(struct sshbuf *blob, int type,\n    const char *passphrase, struct sshkey **keyp, char **commentp)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_RSA:\n\t\treturn sshkey_parse_private_pem_fileblob(blob, type,\n\t\t    passphrase, keyp);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n#endif /* WITH_XMSS */\n\t\treturn sshkey_parse_private2(blob, type, passphrase,\n\t\t    keyp, commentp);\n\tcase KEY_UNSPEC:\n\t\tr = sshkey_parse_private2(blob, type, passphrase, keyp,\n\t\t    commentp);\n\t\t/* Do not fallback to PEM parser if only passphrase is wrong. */\n\t\tif (r == 0 || r == SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\t\treturn r;\n#ifdef WITH_OPENSSL\n\t\treturn sshkey_parse_private_pem_fileblob(blob, type,\n\t\t    passphrase, keyp);\n#else\n\t\treturn SSH_ERR_INVALID_FORMAT;\n#endif /* WITH_OPENSSL */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_parse_private_fileblob(struct sshbuf *buffer, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\treturn sshkey_parse_private_fileblob_type(buffer, KEY_UNSPEC,\n\t    passphrase, keyp, commentp);\n}"
  },
  {
    "function_name": "sshkey_parse_private_fileblob_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "4025-4065",
    "snippet": "int\nsshkey_parse_private_fileblob_type(struct sshbuf *blob, int type,\n    const char *passphrase, struct sshkey **keyp, char **commentp)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_RSA:\n\t\treturn sshkey_parse_private_pem_fileblob(blob, type,\n\t\t    passphrase, keyp);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n#endif /* WITH_XMSS */\n\t\treturn sshkey_parse_private2(blob, type, passphrase,\n\t\t    keyp, commentp);\n\tcase KEY_UNSPEC:\n\t\tr = sshkey_parse_private2(blob, type, passphrase, keyp,\n\t\t    commentp);\n\t\t/* Do not fallback to PEM parser if only passphrase is wrong. */\n\t\tif (r == 0 || r == SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\t\treturn r;\n#ifdef WITH_OPENSSL\n\t\treturn sshkey_parse_private_pem_fileblob(blob, type,\n\t\t    passphrase, keyp);\n#else\n\t\treturn SSH_ERR_INVALID_FORMAT;\n#endif /* WITH_OPENSSL */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_parse_private_pem_fileblob",
          "args": [
            "blob",
            "type",
            "passphrase",
            "keyp"
          ],
          "line": 4057
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_parse_private_pem_fileblob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3922-4022",
          "snippet": "static int\nsshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,\n    const char *passphrase, struct sshkey **keyp)\n{\n\tEVP_PKEY *pk = NULL;\n\tstruct sshkey *prv = NULL;\n\tBIO *bio = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif ((bio = BIO_new(BIO_s_mem())) == NULL || sshbuf_len(blob) > INT_MAX)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (BIO_write(bio, sshbuf_ptr(blob), sshbuf_len(blob)) !=\n\t    (int)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tclear_libcrypto_errors();\n\tif ((pk = PEM_read_bio_PrivateKey(bio, NULL, pem_passphrase_cb,\n\t    (char *)passphrase)) == NULL) {\n\t       /*\n\t\t* libcrypto may return various ASN.1 errors when attempting\n\t\t* to parse a key with an incorrect passphrase.\n\t\t* Treat all format errors as \"incorrect passphrase\" if a\n\t\t* passphrase was supplied.\n\t\t*/\n\t\tif (passphrase != NULL && *passphrase != '\\0')\n\t\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\telse\n\t\t\tr = convert_libcrypto_error();\n\t\tgoto out;\n\t}\n\tif (EVP_PKEY_base_id(pk) == EVP_PKEY_RSA &&\n\t    (type == KEY_UNSPEC || type == KEY_RSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->rsa = EVP_PKEY_get1_RSA(pk);\n\t\tprv->type = KEY_RSA;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, prv->rsa, 8);\n#endif\n\t\tif (RSA_blinding_on(prv->rsa, NULL) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = check_rsa_length(prv->rsa)) != 0)\n\t\t\tgoto out;\n\t} else if (EVP_PKEY_base_id(pk) == EVP_PKEY_DSA &&\n\t    (type == KEY_UNSPEC || type == KEY_DSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->dsa = EVP_PKEY_get1_DSA(pk);\n\t\tprv->type = KEY_DSA;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, prv->dsa, 8);\n#endif\n#ifdef OPENSSL_HAS_ECC\n\t} else if (EVP_PKEY_base_id(pk) == EVP_PKEY_EC &&\n\t    (type == KEY_UNSPEC || type == KEY_ECDSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->ecdsa = EVP_PKEY_get1_EC_KEY(pk);\n\t\tprv->type = KEY_ECDSA;\n\t\tprv->ecdsa_nid = sshkey_ecdsa_key_to_nid(prv->ecdsa);\n\t\tif (prv->ecdsa_nid == -1 ||\n\t\t    sshkey_curve_nid_to_name(prv->ecdsa_nid) == NULL ||\n\t\t    sshkey_ec_validate_public(EC_KEY_get0_group(prv->ecdsa),\n\t\t    EC_KEY_get0_public_key(prv->ecdsa)) != 0 ||\n\t\t    sshkey_ec_validate_private(prv->ecdsa) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n# ifdef DEBUG_PK\n\t\tif (prv != NULL && prv->ecdsa != NULL)\n\t\t\tsshkey_dump_ec_key(prv->ecdsa);\n# endif\n#endif /* OPENSSL_HAS_ECC */\n\t} else {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = prv;\n\t\tprv = NULL;\n\t}\n out:\n\tBIO_free(bio);\n\tEVP_PKEY_free(pk);\n\tsshkey_free(prv);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nsshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,\n    const char *passphrase, struct sshkey **keyp)\n{\n\tEVP_PKEY *pk = NULL;\n\tstruct sshkey *prv = NULL;\n\tBIO *bio = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif ((bio = BIO_new(BIO_s_mem())) == NULL || sshbuf_len(blob) > INT_MAX)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (BIO_write(bio, sshbuf_ptr(blob), sshbuf_len(blob)) !=\n\t    (int)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tclear_libcrypto_errors();\n\tif ((pk = PEM_read_bio_PrivateKey(bio, NULL, pem_passphrase_cb,\n\t    (char *)passphrase)) == NULL) {\n\t       /*\n\t\t* libcrypto may return various ASN.1 errors when attempting\n\t\t* to parse a key with an incorrect passphrase.\n\t\t* Treat all format errors as \"incorrect passphrase\" if a\n\t\t* passphrase was supplied.\n\t\t*/\n\t\tif (passphrase != NULL && *passphrase != '\\0')\n\t\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\telse\n\t\t\tr = convert_libcrypto_error();\n\t\tgoto out;\n\t}\n\tif (EVP_PKEY_base_id(pk) == EVP_PKEY_RSA &&\n\t    (type == KEY_UNSPEC || type == KEY_RSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->rsa = EVP_PKEY_get1_RSA(pk);\n\t\tprv->type = KEY_RSA;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, prv->rsa, 8);\n#endif\n\t\tif (RSA_blinding_on(prv->rsa, NULL) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = check_rsa_length(prv->rsa)) != 0)\n\t\t\tgoto out;\n\t} else if (EVP_PKEY_base_id(pk) == EVP_PKEY_DSA &&\n\t    (type == KEY_UNSPEC || type == KEY_DSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->dsa = EVP_PKEY_get1_DSA(pk);\n\t\tprv->type = KEY_DSA;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, prv->dsa, 8);\n#endif\n#ifdef OPENSSL_HAS_ECC\n\t} else if (EVP_PKEY_base_id(pk) == EVP_PKEY_EC &&\n\t    (type == KEY_UNSPEC || type == KEY_ECDSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->ecdsa = EVP_PKEY_get1_EC_KEY(pk);\n\t\tprv->type = KEY_ECDSA;\n\t\tprv->ecdsa_nid = sshkey_ecdsa_key_to_nid(prv->ecdsa);\n\t\tif (prv->ecdsa_nid == -1 ||\n\t\t    sshkey_curve_nid_to_name(prv->ecdsa_nid) == NULL ||\n\t\t    sshkey_ec_validate_public(EC_KEY_get0_group(prv->ecdsa),\n\t\t    EC_KEY_get0_public_key(prv->ecdsa)) != 0 ||\n\t\t    sshkey_ec_validate_private(prv->ecdsa) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n# ifdef DEBUG_PK\n\t\tif (prv != NULL && prv->ecdsa != NULL)\n\t\t\tsshkey_dump_ec_key(prv->ecdsa);\n# endif\n#endif /* OPENSSL_HAS_ECC */\n\t} else {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = prv;\n\t\tprv = NULL;\n\t}\n out:\n\tBIO_free(bio);\n\tEVP_PKEY_free(pk);\n\tsshkey_free(prv);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_parse_private2",
          "args": [
            "blob",
            "type",
            "passphrase",
            "keyp",
            "commentp"
          ],
          "line": 4051
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_parse_private2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3543-3760",
          "snippet": "static int\nsshkey_parse_private2(struct sshbuf *blob, int type, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tchar *comment = NULL, *ciphername = NULL, *kdfname = NULL;\n\tconst struct sshcipher *cipher = NULL;\n\tconst u_char *cp;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tsize_t encoded_len;\n\tsize_t i, keylen = 0, ivlen = 0, authlen = 0, slen = 0;\n\tstruct sshbuf *encoded = NULL, *decoded = NULL;\n\tstruct sshbuf *kdf = NULL, *decrypted = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tstruct sshkey *k = NULL;\n\tu_char *key = NULL, *salt = NULL, *dp, pad, last;\n\tu_int blocksize, rounds, nkeys, encrypted_len, check1, check2;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((encoded = sshbuf_new()) == NULL ||\n\t    (decoded = sshbuf_new()) == NULL ||\n\t    (decrypted = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* check preamble */\n\tcp = sshbuf_ptr(blob);\n\tencoded_len = sshbuf_len(blob);\n\tif (encoded_len < (MARK_BEGIN_LEN + MARK_END_LEN) ||\n\t    memcmp(cp, MARK_BEGIN, MARK_BEGIN_LEN) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tcp += MARK_BEGIN_LEN;\n\tencoded_len -= MARK_BEGIN_LEN;\n\n\t/* Look for end marker, removing whitespace as we go */\n\twhile (encoded_len > 0) {\n\t\tif (*cp != '\\n' && *cp != '\\r') {\n\t\t\tif ((r = sshbuf_put_u8(encoded, *cp)) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tlast = *cp;\n\t\tencoded_len--;\n\t\tcp++;\n\t\tif (last == '\\n') {\n\t\t\tif (encoded_len >= MARK_END_LEN &&\n\t\t\t    memcmp(cp, MARK_END, MARK_END_LEN) == 0) {\n\t\t\t\t/* \\0 terminate */\n\t\t\t\tif ((r = sshbuf_put_u8(encoded, 0)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (encoded_len == 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* decode base64 */\n\tif ((r = sshbuf_b64tod(decoded, (char *)sshbuf_ptr(encoded))) != 0)\n\t\tgoto out;\n\n\t/* check magic */\n\tif (sshbuf_len(decoded) < sizeof(AUTH_MAGIC) ||\n\t    memcmp(sshbuf_ptr(decoded), AUTH_MAGIC, sizeof(AUTH_MAGIC))) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* parse public portion of key */\n\tif ((r = sshbuf_consume(decoded, sizeof(AUTH_MAGIC))) != 0 ||\n\t    (r = sshbuf_get_cstring(decoded, &ciphername, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(decoded, &kdfname, NULL)) != 0 ||\n\t    (r = sshbuf_froms(decoded, &kdf)) != 0 ||\n\t    (r = sshbuf_get_u32(decoded, &nkeys)) != 0 ||\n\t    (r = sshbuf_skip_string(decoded)) != 0 || /* pubkey */\n\t    (r = sshbuf_get_u32(decoded, &encrypted_len)) != 0)\n\t\tgoto out;\n\n\tif ((cipher = cipher_by_name(ciphername)) == NULL) {\n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif ((passphrase == NULL || strlen(passphrase) == 0) &&\n\t    strcmp(ciphername, \"none\") != 0) {\n\t\t/* passphrase required */\n\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"none\") != 0 && strcmp(kdfname, \"bcrypt\") != 0) {\n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif (!strcmp(kdfname, \"none\") && strcmp(ciphername, \"none\") != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (nkeys != 1) {\n\t\t/* XXX only one key supported */\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* check size of encrypted key blob */\n\tblocksize = cipher_blocksize(cipher);\n\tif (encrypted_len < blocksize || (encrypted_len % blocksize) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* setup key */\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif ((key = calloc(1, keylen + ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"bcrypt\") == 0) {\n\t\tif ((r = sshbuf_get_string(kdf, &salt, &slen)) != 0 ||\n\t\t    (r = sshbuf_get_u32(kdf, &rounds)) != 0)\n\t\t\tgoto out;\n\t\tif (bcrypt_pbkdf(passphrase, strlen(passphrase), salt, slen,\n\t\t    key, keylen + ivlen, rounds) < 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* check that an appropriate amount of auth data is present */\n\tif (sshbuf_len(decoded) < encrypted_len + authlen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* decrypt private portion of key */\n\tif ((r = sshbuf_reserve(decrypted, encrypted_len, &dp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    key + keylen, ivlen, 0)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(ciphercontext, 0, dp, sshbuf_ptr(decoded),\n\t    encrypted_len, 0, authlen)) != 0) {\n\t\t/* an integrity error here indicates an incorrect passphrase */\n\t\tif (r == SSH_ERR_MAC_INVALID)\n\t\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(decoded, encrypted_len + authlen)) != 0)\n\t\tgoto out;\n\t/* there should be no trailing data */\n\tif (sshbuf_len(decoded) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* check check bytes */\n\tif ((r = sshbuf_get_u32(decrypted, &check1)) != 0 ||\n\t    (r = sshbuf_get_u32(decrypted, &check2)) != 0)\n\t\tgoto out;\n\tif (check1 != check2) {\n\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\n\t/* Load the private key and comment */\n\tif ((r = sshkey_private_deserialize(decrypted, &k)) != 0 ||\n\t    (r = sshbuf_get_cstring(decrypted, &comment, NULL)) != 0)\n\t\tgoto out;\n\n\t/* Check deterministic padding */\n\ti = 0;\n\twhile (sshbuf_len(decrypted)) {\n\t\tif ((r = sshbuf_get_u8(decrypted, &pad)) != 0)\n\t\t\tgoto out;\n\t\tif (pad != (++i & 0xff)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* XXX decode pubkey and check against private */\n\n\t/* success */\n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = k;\n\t\tk = NULL;\n\t}\n\tif (commentp != NULL) {\n\t\t*commentp = comment;\n\t\tcomment = NULL;\n\t}\n out:\n\tpad = 0;\n\tcipher_free(ciphercontext);\n\tfree(ciphername);\n\tfree(kdfname);\n\tfree(comment);\n\tif (salt != NULL) {\n\t\texplicit_bzero(salt, slen);\n\t\tfree(salt);\n\t}\n\tif (key != NULL) {\n\t\texplicit_bzero(key, keylen + ivlen);\n\t\tfree(key);\n\t}\n\tsshbuf_free(encoded);\n\tsshbuf_free(decoded);\n\tsshbuf_free(kdf);\n\tsshbuf_free(decrypted);\n\tsshkey_free(k);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define AUTH_MAGIC\t\t\"openssh-key-v1\"",
            "#define MARK_END_LEN\t\t(sizeof(MARK_END) - 1)",
            "#define MARK_BEGIN_LEN\t\t(sizeof(MARK_BEGIN) - 1)",
            "#define MARK_END\t\t\"-----END OPENSSH PRIVATE KEY-----\\n\"",
            "#define MARK_BEGIN\t\t\"-----BEGIN OPENSSH PRIVATE KEY-----\\n\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define AUTH_MAGIC\t\t\"openssh-key-v1\"\n#define MARK_END_LEN\t\t(sizeof(MARK_END) - 1)\n#define MARK_BEGIN_LEN\t\t(sizeof(MARK_BEGIN) - 1)\n#define MARK_END\t\t\"-----END OPENSSH PRIVATE KEY-----\\n\"\n#define MARK_BEGIN\t\t\"-----BEGIN OPENSSH PRIVATE KEY-----\\n\"\n\nstatic int\nsshkey_parse_private2(struct sshbuf *blob, int type, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tchar *comment = NULL, *ciphername = NULL, *kdfname = NULL;\n\tconst struct sshcipher *cipher = NULL;\n\tconst u_char *cp;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tsize_t encoded_len;\n\tsize_t i, keylen = 0, ivlen = 0, authlen = 0, slen = 0;\n\tstruct sshbuf *encoded = NULL, *decoded = NULL;\n\tstruct sshbuf *kdf = NULL, *decrypted = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tstruct sshkey *k = NULL;\n\tu_char *key = NULL, *salt = NULL, *dp, pad, last;\n\tu_int blocksize, rounds, nkeys, encrypted_len, check1, check2;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((encoded = sshbuf_new()) == NULL ||\n\t    (decoded = sshbuf_new()) == NULL ||\n\t    (decrypted = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* check preamble */\n\tcp = sshbuf_ptr(blob);\n\tencoded_len = sshbuf_len(blob);\n\tif (encoded_len < (MARK_BEGIN_LEN + MARK_END_LEN) ||\n\t    memcmp(cp, MARK_BEGIN, MARK_BEGIN_LEN) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tcp += MARK_BEGIN_LEN;\n\tencoded_len -= MARK_BEGIN_LEN;\n\n\t/* Look for end marker, removing whitespace as we go */\n\twhile (encoded_len > 0) {\n\t\tif (*cp != '\\n' && *cp != '\\r') {\n\t\t\tif ((r = sshbuf_put_u8(encoded, *cp)) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tlast = *cp;\n\t\tencoded_len--;\n\t\tcp++;\n\t\tif (last == '\\n') {\n\t\t\tif (encoded_len >= MARK_END_LEN &&\n\t\t\t    memcmp(cp, MARK_END, MARK_END_LEN) == 0) {\n\t\t\t\t/* \\0 terminate */\n\t\t\t\tif ((r = sshbuf_put_u8(encoded, 0)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (encoded_len == 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* decode base64 */\n\tif ((r = sshbuf_b64tod(decoded, (char *)sshbuf_ptr(encoded))) != 0)\n\t\tgoto out;\n\n\t/* check magic */\n\tif (sshbuf_len(decoded) < sizeof(AUTH_MAGIC) ||\n\t    memcmp(sshbuf_ptr(decoded), AUTH_MAGIC, sizeof(AUTH_MAGIC))) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* parse public portion of key */\n\tif ((r = sshbuf_consume(decoded, sizeof(AUTH_MAGIC))) != 0 ||\n\t    (r = sshbuf_get_cstring(decoded, &ciphername, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(decoded, &kdfname, NULL)) != 0 ||\n\t    (r = sshbuf_froms(decoded, &kdf)) != 0 ||\n\t    (r = sshbuf_get_u32(decoded, &nkeys)) != 0 ||\n\t    (r = sshbuf_skip_string(decoded)) != 0 || /* pubkey */\n\t    (r = sshbuf_get_u32(decoded, &encrypted_len)) != 0)\n\t\tgoto out;\n\n\tif ((cipher = cipher_by_name(ciphername)) == NULL) {\n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif ((passphrase == NULL || strlen(passphrase) == 0) &&\n\t    strcmp(ciphername, \"none\") != 0) {\n\t\t/* passphrase required */\n\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"none\") != 0 && strcmp(kdfname, \"bcrypt\") != 0) {\n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif (!strcmp(kdfname, \"none\") && strcmp(ciphername, \"none\") != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (nkeys != 1) {\n\t\t/* XXX only one key supported */\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* check size of encrypted key blob */\n\tblocksize = cipher_blocksize(cipher);\n\tif (encrypted_len < blocksize || (encrypted_len % blocksize) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* setup key */\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif ((key = calloc(1, keylen + ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"bcrypt\") == 0) {\n\t\tif ((r = sshbuf_get_string(kdf, &salt, &slen)) != 0 ||\n\t\t    (r = sshbuf_get_u32(kdf, &rounds)) != 0)\n\t\t\tgoto out;\n\t\tif (bcrypt_pbkdf(passphrase, strlen(passphrase), salt, slen,\n\t\t    key, keylen + ivlen, rounds) < 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* check that an appropriate amount of auth data is present */\n\tif (sshbuf_len(decoded) < encrypted_len + authlen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* decrypt private portion of key */\n\tif ((r = sshbuf_reserve(decrypted, encrypted_len, &dp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    key + keylen, ivlen, 0)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(ciphercontext, 0, dp, sshbuf_ptr(decoded),\n\t    encrypted_len, 0, authlen)) != 0) {\n\t\t/* an integrity error here indicates an incorrect passphrase */\n\t\tif (r == SSH_ERR_MAC_INVALID)\n\t\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(decoded, encrypted_len + authlen)) != 0)\n\t\tgoto out;\n\t/* there should be no trailing data */\n\tif (sshbuf_len(decoded) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* check check bytes */\n\tif ((r = sshbuf_get_u32(decrypted, &check1)) != 0 ||\n\t    (r = sshbuf_get_u32(decrypted, &check2)) != 0)\n\t\tgoto out;\n\tif (check1 != check2) {\n\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\n\t/* Load the private key and comment */\n\tif ((r = sshkey_private_deserialize(decrypted, &k)) != 0 ||\n\t    (r = sshbuf_get_cstring(decrypted, &comment, NULL)) != 0)\n\t\tgoto out;\n\n\t/* Check deterministic padding */\n\ti = 0;\n\twhile (sshbuf_len(decrypted)) {\n\t\tif ((r = sshbuf_get_u8(decrypted, &pad)) != 0)\n\t\t\tgoto out;\n\t\tif (pad != (++i & 0xff)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* XXX decode pubkey and check against private */\n\n\t/* success */\n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = k;\n\t\tk = NULL;\n\t}\n\tif (commentp != NULL) {\n\t\t*commentp = comment;\n\t\tcomment = NULL;\n\t}\n out:\n\tpad = 0;\n\tcipher_free(ciphercontext);\n\tfree(ciphername);\n\tfree(kdfname);\n\tfree(comment);\n\tif (salt != NULL) {\n\t\texplicit_bzero(salt, slen);\n\t\tfree(salt);\n\t}\n\tif (key != NULL) {\n\t\texplicit_bzero(key, keylen + ivlen);\n\t\tfree(key);\n\t}\n\tsshbuf_free(encoded);\n\tsshbuf_free(decoded);\n\tsshbuf_free(kdf);\n\tsshbuf_free(decrypted);\n\tsshkey_free(k);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_parse_private_fileblob_type(struct sshbuf *blob, int type,\n    const char *passphrase, struct sshkey **keyp, char **commentp)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_RSA:\n\t\treturn sshkey_parse_private_pem_fileblob(blob, type,\n\t\t    passphrase, keyp);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n#endif /* WITH_XMSS */\n\t\treturn sshkey_parse_private2(blob, type, passphrase,\n\t\t    keyp, commentp);\n\tcase KEY_UNSPEC:\n\t\tr = sshkey_parse_private2(blob, type, passphrase, keyp,\n\t\t    commentp);\n\t\t/* Do not fallback to PEM parser if only passphrase is wrong. */\n\t\tif (r == 0 || r == SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\t\treturn r;\n#ifdef WITH_OPENSSL\n\t\treturn sshkey_parse_private_pem_fileblob(blob, type,\n\t\t    passphrase, keyp);\n#else\n\t\treturn SSH_ERR_INVALID_FORMAT;\n#endif /* WITH_OPENSSL */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
  },
  {
    "function_name": "sshkey_parse_private_pem_fileblob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "3922-4022",
    "snippet": "static int\nsshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,\n    const char *passphrase, struct sshkey **keyp)\n{\n\tEVP_PKEY *pk = NULL;\n\tstruct sshkey *prv = NULL;\n\tBIO *bio = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif ((bio = BIO_new(BIO_s_mem())) == NULL || sshbuf_len(blob) > INT_MAX)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (BIO_write(bio, sshbuf_ptr(blob), sshbuf_len(blob)) !=\n\t    (int)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tclear_libcrypto_errors();\n\tif ((pk = PEM_read_bio_PrivateKey(bio, NULL, pem_passphrase_cb,\n\t    (char *)passphrase)) == NULL) {\n\t       /*\n\t\t* libcrypto may return various ASN.1 errors when attempting\n\t\t* to parse a key with an incorrect passphrase.\n\t\t* Treat all format errors as \"incorrect passphrase\" if a\n\t\t* passphrase was supplied.\n\t\t*/\n\t\tif (passphrase != NULL && *passphrase != '\\0')\n\t\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\telse\n\t\t\tr = convert_libcrypto_error();\n\t\tgoto out;\n\t}\n\tif (EVP_PKEY_base_id(pk) == EVP_PKEY_RSA &&\n\t    (type == KEY_UNSPEC || type == KEY_RSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->rsa = EVP_PKEY_get1_RSA(pk);\n\t\tprv->type = KEY_RSA;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, prv->rsa, 8);\n#endif\n\t\tif (RSA_blinding_on(prv->rsa, NULL) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = check_rsa_length(prv->rsa)) != 0)\n\t\t\tgoto out;\n\t} else if (EVP_PKEY_base_id(pk) == EVP_PKEY_DSA &&\n\t    (type == KEY_UNSPEC || type == KEY_DSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->dsa = EVP_PKEY_get1_DSA(pk);\n\t\tprv->type = KEY_DSA;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, prv->dsa, 8);\n#endif\n#ifdef OPENSSL_HAS_ECC\n\t} else if (EVP_PKEY_base_id(pk) == EVP_PKEY_EC &&\n\t    (type == KEY_UNSPEC || type == KEY_ECDSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->ecdsa = EVP_PKEY_get1_EC_KEY(pk);\n\t\tprv->type = KEY_ECDSA;\n\t\tprv->ecdsa_nid = sshkey_ecdsa_key_to_nid(prv->ecdsa);\n\t\tif (prv->ecdsa_nid == -1 ||\n\t\t    sshkey_curve_nid_to_name(prv->ecdsa_nid) == NULL ||\n\t\t    sshkey_ec_validate_public(EC_KEY_get0_group(prv->ecdsa),\n\t\t    EC_KEY_get0_public_key(prv->ecdsa)) != 0 ||\n\t\t    sshkey_ec_validate_private(prv->ecdsa) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n# ifdef DEBUG_PK\n\t\tif (prv != NULL && prv->ecdsa != NULL)\n\t\t\tsshkey_dump_ec_key(prv->ecdsa);\n# endif\n#endif /* OPENSSL_HAS_ECC */\n\t} else {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = prv;\n\t\tprv = NULL;\n\t}\n out:\n\tBIO_free(bio);\n\tEVP_PKEY_free(pk);\n\tsshkey_free(prv);\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "prv"
          ],
          "line": 4020
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_free",
          "args": [
            "pk"
          ],
          "line": 4019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "bio"
          ],
          "line": 4018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_dump_ec_key",
          "args": [
            "prv->ecdsa"
          ],
          "line": 4005
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_dump_ec_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3379-3392",
          "snippet": "void\nsshkey_dump_ec_key(const EC_KEY *key)\n{\n\tconst BIGNUM *exponent;\n\n\tsshkey_dump_ec_point(EC_KEY_get0_group(key),\n\t    EC_KEY_get0_public_key(key));\n\tfputs(\"exponent=\", stderr);\n\tif ((exponent = EC_KEY_get0_private_key(key)) == NULL)\n\t\tfputs(\"(NULL)\", stderr);\n\telse\n\t\tBN_print_fp(stderr, EC_KEY_get0_private_key(key));\n\tfputs(\"\\n\", stderr);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_dump_ec_key(const EC_KEY *key)\n{\n\tconst BIGNUM *exponent;\n\n\tsshkey_dump_ec_point(EC_KEY_get0_group(key),\n\t    EC_KEY_get0_public_key(key));\n\tfputs(\"exponent=\", stderr);\n\tif ((exponent = EC_KEY_get0_private_key(key)) == NULL)\n\t\tfputs(\"(NULL)\", stderr);\n\telse\n\t\tBN_print_fp(stderr, EC_KEY_get0_private_key(key));\n\tfputs(\"\\n\", stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ec_validate_private",
          "args": [
            "prv->ecdsa"
          ],
          "line": 3999
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ec_validate_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3301-3338",
          "snippet": "int\nsshkey_ec_validate_private(const EC_KEY *key)\n{\n\tBN_CTX *bnctx;\n\tBIGNUM *order, *tmp;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tBN_CTX_start(bnctx);\n\n\tif ((order = BN_CTX_get(bnctx)) == NULL ||\n\t    (tmp = BN_CTX_get(bnctx)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* log2(private) > log2(order)/2 */\n\tif (EC_GROUP_get_order(EC_KEY_get0_group(key), order, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(EC_KEY_get0_private_key(key)) <=\n\t    BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t/* private < order - 1 */\n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(EC_KEY_get0_private_key(key), tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_CTX_free(bnctx);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_ec_validate_private(const EC_KEY *key)\n{\n\tBN_CTX *bnctx;\n\tBIGNUM *order, *tmp;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tBN_CTX_start(bnctx);\n\n\tif ((order = BN_CTX_get(bnctx)) == NULL ||\n\t    (tmp = BN_CTX_get(bnctx)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* log2(private) > log2(order)/2 */\n\tif (EC_GROUP_get_order(EC_KEY_get0_group(key), order, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(EC_KEY_get0_private_key(key)) <=\n\t    BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t/* private < order - 1 */\n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(EC_KEY_get0_private_key(key), tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_CTX_free(bnctx);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ec_validate_public",
          "args": [
            "EC_KEY_get0_group(prv->ecdsa)",
            "EC_KEY_get0_public_key(prv->ecdsa)"
          ],
          "line": 3997
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ec_validate_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3224-3299",
          "snippet": "int\nsshkey_ec_validate_public(const EC_GROUP *group, const EC_POINT *public)\n{\n\tBN_CTX *bnctx;\n\tEC_POINT *nq = NULL;\n\tBIGNUM *order, *x, *y, *tmp;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\t/*\n\t * NB. This assumes OpenSSL has already verified that the public\n\t * point lies on the curve. This is done by EC_POINT_oct2point()\n\t * implicitly calling EC_POINT_is_on_curve(). If this code is ever\n\t * reachable with public points not unmarshalled using\n\t * EC_POINT_oct2point then the caller will need to explicitly check.\n\t */\n\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tBN_CTX_start(bnctx);\n\n\t/*\n\t * We shouldn't ever hit this case because bignum_get_ecpoint()\n\t * refuses to load GF2m points.\n\t */\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field)\n\t\tgoto out;\n\n\t/* Q != infinity */\n\tif (EC_POINT_is_at_infinity(group, public))\n\t\tgoto out;\n\n\tif ((x = BN_CTX_get(bnctx)) == NULL ||\n\t    (y = BN_CTX_get(bnctx)) == NULL ||\n\t    (order = BN_CTX_get(bnctx)) == NULL ||\n\t    (tmp = BN_CTX_get(bnctx)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* log2(x) > log2(order)/2, log2(y) > log2(order)/2 */\n\tif (EC_GROUP_get_order(group, order, bnctx) != 1 ||\n\t    EC_POINT_get_affine_coordinates_GFp(group, public,\n\t    x, y, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(x) <= BN_num_bits(order) / 2 ||\n\t    BN_num_bits(y) <= BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t/* nQ == infinity (n == order of subgroup) */\n\tif ((nq = EC_POINT_new(group)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_mul(group, nq, NULL, public, order, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_is_at_infinity(group, nq) != 1)\n\t\tgoto out;\n\n\t/* x < order - 1, y < order - 1 */\n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(x, tmp) >= 0 || BN_cmp(y, tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_CTX_free(bnctx);\n\tEC_POINT_free(nq);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_ec_validate_public(const EC_GROUP *group, const EC_POINT *public)\n{\n\tBN_CTX *bnctx;\n\tEC_POINT *nq = NULL;\n\tBIGNUM *order, *x, *y, *tmp;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\t/*\n\t * NB. This assumes OpenSSL has already verified that the public\n\t * point lies on the curve. This is done by EC_POINT_oct2point()\n\t * implicitly calling EC_POINT_is_on_curve(). If this code is ever\n\t * reachable with public points not unmarshalled using\n\t * EC_POINT_oct2point then the caller will need to explicitly check.\n\t */\n\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tBN_CTX_start(bnctx);\n\n\t/*\n\t * We shouldn't ever hit this case because bignum_get_ecpoint()\n\t * refuses to load GF2m points.\n\t */\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field)\n\t\tgoto out;\n\n\t/* Q != infinity */\n\tif (EC_POINT_is_at_infinity(group, public))\n\t\tgoto out;\n\n\tif ((x = BN_CTX_get(bnctx)) == NULL ||\n\t    (y = BN_CTX_get(bnctx)) == NULL ||\n\t    (order = BN_CTX_get(bnctx)) == NULL ||\n\t    (tmp = BN_CTX_get(bnctx)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* log2(x) > log2(order)/2, log2(y) > log2(order)/2 */\n\tif (EC_GROUP_get_order(group, order, bnctx) != 1 ||\n\t    EC_POINT_get_affine_coordinates_GFp(group, public,\n\t    x, y, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(x) <= BN_num_bits(order) / 2 ||\n\t    BN_num_bits(y) <= BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t/* nQ == infinity (n == order of subgroup) */\n\tif ((nq = EC_POINT_new(group)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_mul(group, nq, NULL, public, order, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_is_at_infinity(group, nq) != 1)\n\t\tgoto out;\n\n\t/* x < order - 1, y < order - 1 */\n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(x, tmp) >= 0 || BN_cmp(y, tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_CTX_free(bnctx);\n\tEC_POINT_free(nq);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_public_key",
          "args": [
            "prv->ecdsa"
          ],
          "line": 3998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "prv->ecdsa"
          ],
          "line": 3997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_curve_nid_to_name",
          "args": [
            "prv->ecdsa_nid"
          ],
          "line": 3996
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_curve_nid_to_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "411-426",
          "snippet": "const char *\nsshkey_curve_nid_to_name(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn \"nistp256\";\n\tcase NID_secp384r1:\n\t\treturn \"nistp384\";\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn \"nistp521\";\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_curve_nid_to_name(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn \"nistp256\";\n\tcase NID_secp384r1:\n\t\treturn \"nistp384\";\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn \"nistp521\";\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ecdsa_key_to_nid",
          "args": [
            "prv->ecdsa"
          ],
          "line": 3994
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ecdsa_key_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1525-1573",
          "snippet": "int\nsshkey_ecdsa_key_to_nid(EC_KEY *k)\n{\n\tEC_GROUP *eg;\n\tint nids[] = {\n\t\tNID_X9_62_prime256v1,\n\t\tNID_secp384r1,\n#  ifdef OPENSSL_HAS_NISTP521\n\t\tNID_secp521r1,\n#  endif /* OPENSSL_HAS_NISTP521 */\n\t\t-1\n\t};\n\tint nid;\n\tu_int i;\n\tBN_CTX *bnctx;\n\tconst EC_GROUP *g = EC_KEY_get0_group(k);\n\n\t/*\n\t * The group may be stored in a ASN.1 encoded private key in one of two\n\t * ways: as a \"named group\", which is reconstituted by ASN.1 object ID\n\t * or explicit group parameters encoded into the key blob. Only the\n\t * \"named group\" case sets the group NID for us, but we can figure\n\t * it out for the other case by comparing against all the groups that\n\t * are supported.\n\t */\n\tif ((nid = EC_GROUP_get_curve_name(g)) > 0)\n\t\treturn nid;\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn -1;\n\tfor (i = 0; nids[i] != -1; i++) {\n\t\tif ((eg = EC_GROUP_new_by_curve_name(nids[i])) == NULL) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn -1;\n\t\t}\n\t\tif (EC_GROUP_cmp(g, eg, bnctx) == 0)\n\t\t\tbreak;\n\t\tEC_GROUP_free(eg);\n\t}\n\tBN_CTX_free(bnctx);\n\tif (nids[i] != -1) {\n\t\t/* Use the group with the NID attached */\n\t\tEC_GROUP_set_asn1_flag(eg, OPENSSL_EC_NAMED_CURVE);\n\t\tif (EC_KEY_set_group(k, eg) != 1) {\n\t\t\tEC_GROUP_free(eg);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn nids[i];\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_ecdsa_key_to_nid(EC_KEY *k)\n{\n\tEC_GROUP *eg;\n\tint nids[] = {\n\t\tNID_X9_62_prime256v1,\n\t\tNID_secp384r1,\n#  ifdef OPENSSL_HAS_NISTP521\n\t\tNID_secp521r1,\n#  endif /* OPENSSL_HAS_NISTP521 */\n\t\t-1\n\t};\n\tint nid;\n\tu_int i;\n\tBN_CTX *bnctx;\n\tconst EC_GROUP *g = EC_KEY_get0_group(k);\n\n\t/*\n\t * The group may be stored in a ASN.1 encoded private key in one of two\n\t * ways: as a \"named group\", which is reconstituted by ASN.1 object ID\n\t * or explicit group parameters encoded into the key blob. Only the\n\t * \"named group\" case sets the group NID for us, but we can figure\n\t * it out for the other case by comparing against all the groups that\n\t * are supported.\n\t */\n\tif ((nid = EC_GROUP_get_curve_name(g)) > 0)\n\t\treturn nid;\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn -1;\n\tfor (i = 0; nids[i] != -1; i++) {\n\t\tif ((eg = EC_GROUP_new_by_curve_name(nids[i])) == NULL) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn -1;\n\t\t}\n\t\tif (EC_GROUP_cmp(g, eg, bnctx) == 0)\n\t\t\tbreak;\n\t\tEC_GROUP_free(eg);\n\t}\n\tBN_CTX_free(bnctx);\n\tif (nids[i] != -1) {\n\t\t/* Use the group with the NID attached */\n\t\tEC_GROUP_set_asn1_flag(eg, OPENSSL_EC_NAMED_CURVE);\n\t\tif (EC_KEY_set_group(k, eg) != 1) {\n\t\t\tEC_GROUP_free(eg);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn nids[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_get1_EC_KEY",
          "args": [
            "pk"
          ],
          "line": 3992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_new",
          "args": [
            "KEY_UNSPEC"
          ],
          "line": 3988
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "485-550",
          "snippet": "struct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_base_id",
          "args": [
            "pk"
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_print_fp",
          "args": [
            "stderr",
            "prv->dsa",
            "8"
          ],
          "line": 3983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_get1_DSA",
          "args": [
            "pk"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_base_id",
          "args": [
            "pk"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_rsa_length",
          "args": [
            "prv->rsa"
          ],
          "line": 3972
        },
        "resolved": true,
        "details": {
          "function_name": "check_rsa_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1996-2005",
          "snippet": "static int\ncheck_rsa_length(const RSA *rsa)\n{\n\tconst BIGNUM *rsa_n;\n\n\tRSA_get0_key(rsa, &rsa_n, NULL, NULL);\n\tif (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncheck_rsa_length(const RSA *rsa)\n{\n\tconst BIGNUM *rsa_n;\n\n\tRSA_get0_key(rsa, &rsa_n, NULL, NULL);\n\tif (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_blinding_on",
          "args": [
            "prv->rsa",
            "NULL"
          ],
          "line": 3968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_print_fp",
          "args": [
            "stderr",
            "prv->rsa",
            "8"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_get1_RSA",
          "args": [
            "pk"
          ],
          "line": 3963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_base_id",
          "args": [
            "pk"
          ],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_libcrypto_error",
          "args": [],
          "line": 3954
        },
        "resolved": true,
        "details": {
          "function_name": "convert_libcrypto_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3895-3906",
          "snippet": "static int\nconvert_libcrypto_error(void)\n{\n\t/*\n\t * Some password errors are reported at the beginning\n\t * of the error queue.\n\t */\n\tif (translate_libcrypto_error(ERR_peek_error()) ==\n\t    SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n\treturn translate_libcrypto_error(ERR_peek_last_error());\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nconvert_libcrypto_error(void)\n{\n\t/*\n\t * Some password errors are reported at the beginning\n\t * of the error queue.\n\t */\n\tif (translate_libcrypto_error(ERR_peek_error()) ==\n\t    SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n\treturn translate_libcrypto_error(ERR_peek_last_error());\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEM_read_bio_PrivateKey",
          "args": [
            "bio",
            "NULL",
            "pem_passphrase_cb",
            "(char *)passphrase"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_libcrypto_errors",
          "args": [],
          "line": 3942
        },
        "resolved": true,
        "details": {
          "function_name": "clear_libcrypto_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3884-3889",
          "snippet": "static void\nclear_libcrypto_errors(void)\n{\n\twhile (ERR_get_error() != 0)\n\t\t;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nclear_libcrypto_errors(void)\n{\n\twhile (ERR_get_error() != 0)\n\t\t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "blob"
          ],
          "line": 3937
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BIO_write",
          "args": [
            "bio",
            "sshbuf_ptr(blob)",
            "sshbuf_len(blob)"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "blob"
          ],
          "line": 3936
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BIO_new",
          "args": [
            "BIO_s_mem()"
          ],
          "line": 3934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_s_mem",
          "args": [],
          "line": 3934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nsshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,\n    const char *passphrase, struct sshkey **keyp)\n{\n\tEVP_PKEY *pk = NULL;\n\tstruct sshkey *prv = NULL;\n\tBIO *bio = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif ((bio = BIO_new(BIO_s_mem())) == NULL || sshbuf_len(blob) > INT_MAX)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (BIO_write(bio, sshbuf_ptr(blob), sshbuf_len(blob)) !=\n\t    (int)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tclear_libcrypto_errors();\n\tif ((pk = PEM_read_bio_PrivateKey(bio, NULL, pem_passphrase_cb,\n\t    (char *)passphrase)) == NULL) {\n\t       /*\n\t\t* libcrypto may return various ASN.1 errors when attempting\n\t\t* to parse a key with an incorrect passphrase.\n\t\t* Treat all format errors as \"incorrect passphrase\" if a\n\t\t* passphrase was supplied.\n\t\t*/\n\t\tif (passphrase != NULL && *passphrase != '\\0')\n\t\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\telse\n\t\t\tr = convert_libcrypto_error();\n\t\tgoto out;\n\t}\n\tif (EVP_PKEY_base_id(pk) == EVP_PKEY_RSA &&\n\t    (type == KEY_UNSPEC || type == KEY_RSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->rsa = EVP_PKEY_get1_RSA(pk);\n\t\tprv->type = KEY_RSA;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, prv->rsa, 8);\n#endif\n\t\tif (RSA_blinding_on(prv->rsa, NULL) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = check_rsa_length(prv->rsa)) != 0)\n\t\t\tgoto out;\n\t} else if (EVP_PKEY_base_id(pk) == EVP_PKEY_DSA &&\n\t    (type == KEY_UNSPEC || type == KEY_DSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->dsa = EVP_PKEY_get1_DSA(pk);\n\t\tprv->type = KEY_DSA;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, prv->dsa, 8);\n#endif\n#ifdef OPENSSL_HAS_ECC\n\t} else if (EVP_PKEY_base_id(pk) == EVP_PKEY_EC &&\n\t    (type == KEY_UNSPEC || type == KEY_ECDSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->ecdsa = EVP_PKEY_get1_EC_KEY(pk);\n\t\tprv->type = KEY_ECDSA;\n\t\tprv->ecdsa_nid = sshkey_ecdsa_key_to_nid(prv->ecdsa);\n\t\tif (prv->ecdsa_nid == -1 ||\n\t\t    sshkey_curve_nid_to_name(prv->ecdsa_nid) == NULL ||\n\t\t    sshkey_ec_validate_public(EC_KEY_get0_group(prv->ecdsa),\n\t\t    EC_KEY_get0_public_key(prv->ecdsa)) != 0 ||\n\t\t    sshkey_ec_validate_private(prv->ecdsa) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n# ifdef DEBUG_PK\n\t\tif (prv != NULL && prv->ecdsa != NULL)\n\t\t\tsshkey_dump_ec_key(prv->ecdsa);\n# endif\n#endif /* OPENSSL_HAS_ECC */\n\t} else {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = prv;\n\t\tprv = NULL;\n\t}\n out:\n\tBIO_free(bio);\n\tEVP_PKEY_free(pk);\n\tsshkey_free(prv);\n\treturn r;\n}"
  },
  {
    "function_name": "pem_passphrase_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "3908-3920",
    "snippet": "static int\npem_passphrase_cb(char *buf, int size, int rwflag, void *u)\n{\n\tchar *p = (char *)u;\n\tsize_t len;\n\n\tif (p == NULL || (len = strlen(p)) == 0)\n\t\treturn -1;\n\tif (size < 0 || len > (size_t)size)\n\t\treturn -1;\n\tmemcpy(buf, p, len);\n\treturn (int)len;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "p",
            "len"
          ],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\npem_passphrase_cb(char *buf, int size, int rwflag, void *u)\n{\n\tchar *p = (char *)u;\n\tsize_t len;\n\n\tif (p == NULL || (len = strlen(p)) == 0)\n\t\treturn -1;\n\tif (size < 0 || len > (size_t)size)\n\t\treturn -1;\n\tmemcpy(buf, p, len);\n\treturn (int)len;\n}"
  },
  {
    "function_name": "convert_libcrypto_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "3895-3906",
    "snippet": "static int\nconvert_libcrypto_error(void)\n{\n\t/*\n\t * Some password errors are reported at the beginning\n\t * of the error queue.\n\t */\n\tif (translate_libcrypto_error(ERR_peek_error()) ==\n\t    SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n\treturn translate_libcrypto_error(ERR_peek_last_error());\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "translate_libcrypto_error",
          "args": [
            "ERR_peek_last_error()"
          ],
          "line": 3905
        },
        "resolved": true,
        "details": {
          "function_name": "translate_libcrypto_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3848-3882",
          "snippet": "static int\ntranslate_libcrypto_error(unsigned long pem_err)\n{\n\tint pem_reason = ERR_GET_REASON(pem_err);\n\n\tswitch (ERR_GET_LIB(pem_err)) {\n\tcase ERR_LIB_PEM:\n\t\tswitch (pem_reason) {\n\t\tcase PEM_R_BAD_PASSWORD_READ:\n\t\tcase PEM_R_PROBLEMS_GETTING_PASSWORD:\n\t\tcase PEM_R_BAD_DECRYPT:\n\t\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tdefault:\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t}\n\tcase ERR_LIB_EVP:\n\t\tswitch (pem_reason) {\n\t\tcase EVP_R_BAD_DECRYPT:\n\t\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n#ifdef EVP_R_BN_DECODE_ERROR\n\t\tcase EVP_R_BN_DECODE_ERROR:\n#endif\n\t\tcase EVP_R_DECODE_ERROR:\n#ifdef EVP_R_PRIVATE_KEY_DECODE_ERROR\n\t\tcase EVP_R_PRIVATE_KEY_DECODE_ERROR:\n#endif\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\tdefault:\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t}\n\tcase ERR_LIB_ASN1:\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\treturn SSH_ERR_LIBCRYPTO_ERROR;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ntranslate_libcrypto_error(unsigned long pem_err)\n{\n\tint pem_reason = ERR_GET_REASON(pem_err);\n\n\tswitch (ERR_GET_LIB(pem_err)) {\n\tcase ERR_LIB_PEM:\n\t\tswitch (pem_reason) {\n\t\tcase PEM_R_BAD_PASSWORD_READ:\n\t\tcase PEM_R_PROBLEMS_GETTING_PASSWORD:\n\t\tcase PEM_R_BAD_DECRYPT:\n\t\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tdefault:\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t}\n\tcase ERR_LIB_EVP:\n\t\tswitch (pem_reason) {\n\t\tcase EVP_R_BAD_DECRYPT:\n\t\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n#ifdef EVP_R_BN_DECODE_ERROR\n\t\tcase EVP_R_BN_DECODE_ERROR:\n#endif\n\t\tcase EVP_R_DECODE_ERROR:\n#ifdef EVP_R_PRIVATE_KEY_DECODE_ERROR\n\t\tcase EVP_R_PRIVATE_KEY_DECODE_ERROR:\n#endif\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\tdefault:\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t}\n\tcase ERR_LIB_ASN1:\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\treturn SSH_ERR_LIBCRYPTO_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_peek_last_error",
          "args": [],
          "line": 3905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_peek_error",
          "args": [],
          "line": 3902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nconvert_libcrypto_error(void)\n{\n\t/*\n\t * Some password errors are reported at the beginning\n\t * of the error queue.\n\t */\n\tif (translate_libcrypto_error(ERR_peek_error()) ==\n\t    SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n\treturn translate_libcrypto_error(ERR_peek_last_error());\n}"
  },
  {
    "function_name": "clear_libcrypto_errors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "3884-3889",
    "snippet": "static void\nclear_libcrypto_errors(void)\n{\n\twhile (ERR_get_error() != 0)\n\t\t;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_get_error",
          "args": [],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nclear_libcrypto_errors(void)\n{\n\twhile (ERR_get_error() != 0)\n\t\t;\n}"
  },
  {
    "function_name": "translate_libcrypto_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "3848-3882",
    "snippet": "static int\ntranslate_libcrypto_error(unsigned long pem_err)\n{\n\tint pem_reason = ERR_GET_REASON(pem_err);\n\n\tswitch (ERR_GET_LIB(pem_err)) {\n\tcase ERR_LIB_PEM:\n\t\tswitch (pem_reason) {\n\t\tcase PEM_R_BAD_PASSWORD_READ:\n\t\tcase PEM_R_PROBLEMS_GETTING_PASSWORD:\n\t\tcase PEM_R_BAD_DECRYPT:\n\t\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tdefault:\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t}\n\tcase ERR_LIB_EVP:\n\t\tswitch (pem_reason) {\n\t\tcase EVP_R_BAD_DECRYPT:\n\t\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n#ifdef EVP_R_BN_DECODE_ERROR\n\t\tcase EVP_R_BN_DECODE_ERROR:\n#endif\n\t\tcase EVP_R_DECODE_ERROR:\n#ifdef EVP_R_PRIVATE_KEY_DECODE_ERROR\n\t\tcase EVP_R_PRIVATE_KEY_DECODE_ERROR:\n#endif\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\tdefault:\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t}\n\tcase ERR_LIB_ASN1:\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\treturn SSH_ERR_LIBCRYPTO_ERROR;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_GET_LIB",
          "args": [
            "pem_err"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_GET_REASON",
          "args": [
            "pem_err"
          ],
          "line": 3851
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ntranslate_libcrypto_error(unsigned long pem_err)\n{\n\tint pem_reason = ERR_GET_REASON(pem_err);\n\n\tswitch (ERR_GET_LIB(pem_err)) {\n\tcase ERR_LIB_PEM:\n\t\tswitch (pem_reason) {\n\t\tcase PEM_R_BAD_PASSWORD_READ:\n\t\tcase PEM_R_PROBLEMS_GETTING_PASSWORD:\n\t\tcase PEM_R_BAD_DECRYPT:\n\t\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tdefault:\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t}\n\tcase ERR_LIB_EVP:\n\t\tswitch (pem_reason) {\n\t\tcase EVP_R_BAD_DECRYPT:\n\t\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n#ifdef EVP_R_BN_DECODE_ERROR\n\t\tcase EVP_R_BN_DECODE_ERROR:\n#endif\n\t\tcase EVP_R_DECODE_ERROR:\n#ifdef EVP_R_PRIVATE_KEY_DECODE_ERROR\n\t\tcase EVP_R_PRIVATE_KEY_DECODE_ERROR:\n#endif\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\tdefault:\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t}\n\tcase ERR_LIB_ASN1:\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\treturn SSH_ERR_LIBCRYPTO_ERROR;\n}"
  },
  {
    "function_name": "sshkey_private_to_fileblob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "3818-3844",
    "snippet": "int\nsshkey_private_to_fileblob(struct sshkey *key, struct sshbuf *blob,\n    const char *passphrase, const char *comment,\n    int force_new_format, const char *new_format_cipher, int new_format_rounds)\n{\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_RSA:\n\t\tif (force_new_format) {\n\t\t\treturn sshkey_private_to_blob2(key, blob, passphrase,\n\t\t\t    comment, new_format_cipher, new_format_rounds);\n\t\t}\n\t\treturn sshkey_private_pem_to_blob(key, blob,\n\t\t    passphrase, comment);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n#endif /* WITH_XMSS */\n\t\treturn sshkey_private_to_blob2(key, blob, passphrase,\n\t\t    comment, new_format_cipher, new_format_rounds);\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_private_to_blob2",
          "args": [
            "key",
            "blob",
            "passphrase",
            "comment",
            "new_format_cipher",
            "new_format_rounds"
          ],
          "line": 3839
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_private_to_blob2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3395-3541",
          "snippet": "static int\nsshkey_private_to_blob2(const struct sshkey *prv, struct sshbuf *blob,\n    const char *passphrase, const char *comment, const char *ciphername,\n    int rounds)\n{\n\tu_char *cp, *key = NULL, *pubkeyblob = NULL;\n\tu_char salt[SALT_LEN];\n\tchar *b64 = NULL;\n\tsize_t i, pubkeylen, keylen, ivlen, blocksize, authlen;\n\tu_int check;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher;\n\tconst char *kdfname = KDFNAME;\n\tstruct sshbuf *encoded = NULL, *encrypted = NULL, *kdf = NULL;\n\n\tif (rounds <= 0)\n\t\trounds = DEFAULT_ROUNDS;\n\tif (passphrase == NULL || !strlen(passphrase)) {\n\t\tciphername = \"none\";\n\t\tkdfname = \"none\";\n\t} else if (ciphername == NULL)\n\t\tciphername = DEFAULT_CIPHERNAME;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tif ((kdf = sshbuf_new()) == NULL ||\n\t    (encoded = sshbuf_new()) == NULL ||\n\t    (encrypted = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif ((key = calloc(1, keylen + ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"bcrypt\") == 0) {\n\t\tarc4random_buf(salt, SALT_LEN);\n\t\tif (bcrypt_pbkdf(passphrase, strlen(passphrase),\n\t\t    salt, SALT_LEN, key, keylen + ivlen, rounds) < 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_string(kdf, salt, SALT_LEN)) != 0 ||\n\t\t    (r = sshbuf_put_u32(kdf, rounds)) != 0)\n\t\t\tgoto out;\n\t} else if (strcmp(kdfname, \"none\") != 0) {\n\t\t/* Unsupported KDF type */\n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif ((r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    key + keylen, ivlen, 1)) != 0)\n\t\tgoto out;\n\n\tif ((r = sshbuf_put(encoded, AUTH_MAGIC, sizeof(AUTH_MAGIC))) != 0 ||\n\t    (r = sshbuf_put_cstring(encoded, ciphername)) != 0 ||\n\t    (r = sshbuf_put_cstring(encoded, kdfname)) != 0 ||\n\t    (r = sshbuf_put_stringb(encoded, kdf)) != 0 ||\n\t    (r = sshbuf_put_u32(encoded, 1)) != 0 ||\t/* number of keys */\n\t    (r = sshkey_to_blob(prv, &pubkeyblob, &pubkeylen)) != 0 ||\n\t    (r = sshbuf_put_string(encoded, pubkeyblob, pubkeylen)) != 0)\n\t\tgoto out;\n\n\t/* set up the buffer that will be encrypted */\n\n\t/* Random check bytes */\n\tcheck = arc4random();\n\tif ((r = sshbuf_put_u32(encrypted, check)) != 0 ||\n\t    (r = sshbuf_put_u32(encrypted, check)) != 0)\n\t\tgoto out;\n\n\t/* append private key and comment*/\n\tif ((r = sshkey_private_serialize_opt(prv, encrypted,\n\t     SSHKEY_SERIALIZE_FULL)) != 0 ||\n\t    (r = sshbuf_put_cstring(encrypted, comment)) != 0)\n\t\tgoto out;\n\n\t/* padding */\n\ti = 0;\n\twhile (sshbuf_len(encrypted) % blocksize) {\n\t\tif ((r = sshbuf_put_u8(encrypted, ++i & 0xff)) != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* length in destination buffer */\n\tif ((r = sshbuf_put_u32(encoded, sshbuf_len(encrypted))) != 0)\n\t\tgoto out;\n\n\t/* encrypt */\n\tif ((r = sshbuf_reserve(encoded,\n\t    sshbuf_len(encrypted) + authlen, &cp)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(ciphercontext, 0, cp,\n\t    sshbuf_ptr(encrypted), sshbuf_len(encrypted), 0, authlen)) != 0)\n\t\tgoto out;\n\n\t/* uuencode */\n\tif ((b64 = sshbuf_dtob64(encoded)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tsshbuf_reset(blob);\n\tif ((r = sshbuf_put(blob, MARK_BEGIN, MARK_BEGIN_LEN)) != 0)\n\t\tgoto out;\n\tfor (i = 0; i < strlen(b64); i++) {\n\t\tif ((r = sshbuf_put_u8(blob, b64[i])) != 0)\n\t\t\tgoto out;\n\t\t/* insert line breaks */\n\t\tif (i % 70 == 69 && (r = sshbuf_put_u8(blob, '\\n')) != 0)\n\t\t\tgoto out;\n\t}\n\tif (i % 70 != 69 && (r = sshbuf_put_u8(blob, '\\n')) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_put(blob, MARK_END, MARK_END_LEN)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n\n out:\n\tsshbuf_free(kdf);\n\tsshbuf_free(encoded);\n\tsshbuf_free(encrypted);\n\tcipher_free(ciphercontext);\n\texplicit_bzero(salt, sizeof(salt));\n\tif (key != NULL) {\n\t\texplicit_bzero(key, keylen + ivlen);\n\t\tfree(key);\n\t}\n\tif (pubkeyblob != NULL) {\n\t\texplicit_bzero(pubkeyblob, pubkeylen);\n\t\tfree(pubkeyblob);\n\t}\n\tif (b64 != NULL) {\n\t\texplicit_bzero(b64, strlen(b64));\n\t\tfree(b64);\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tDEFAULT_ROUNDS\t\t16",
            "#define DEFAULT_CIPHERNAME\t\"aes256-ctr\"",
            "#define SALT_LEN\t\t16",
            "#define AUTH_MAGIC\t\t\"openssh-key-v1\"",
            "#define KDFNAME\t\t\t\"bcrypt\"",
            "#define MARK_END_LEN\t\t(sizeof(MARK_END) - 1)",
            "#define MARK_BEGIN_LEN\t\t(sizeof(MARK_BEGIN) - 1)",
            "#define MARK_END\t\t\"-----END OPENSSH PRIVATE KEY-----\\n\"",
            "#define MARK_BEGIN\t\t\"-----BEGIN OPENSSH PRIVATE KEY-----\\n\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tDEFAULT_ROUNDS\t\t16\n#define DEFAULT_CIPHERNAME\t\"aes256-ctr\"\n#define SALT_LEN\t\t16\n#define AUTH_MAGIC\t\t\"openssh-key-v1\"\n#define KDFNAME\t\t\t\"bcrypt\"\n#define MARK_END_LEN\t\t(sizeof(MARK_END) - 1)\n#define MARK_BEGIN_LEN\t\t(sizeof(MARK_BEGIN) - 1)\n#define MARK_END\t\t\"-----END OPENSSH PRIVATE KEY-----\\n\"\n#define MARK_BEGIN\t\t\"-----BEGIN OPENSSH PRIVATE KEY-----\\n\"\n\nstatic int\nsshkey_private_to_blob2(const struct sshkey *prv, struct sshbuf *blob,\n    const char *passphrase, const char *comment, const char *ciphername,\n    int rounds)\n{\n\tu_char *cp, *key = NULL, *pubkeyblob = NULL;\n\tu_char salt[SALT_LEN];\n\tchar *b64 = NULL;\n\tsize_t i, pubkeylen, keylen, ivlen, blocksize, authlen;\n\tu_int check;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher;\n\tconst char *kdfname = KDFNAME;\n\tstruct sshbuf *encoded = NULL, *encrypted = NULL, *kdf = NULL;\n\n\tif (rounds <= 0)\n\t\trounds = DEFAULT_ROUNDS;\n\tif (passphrase == NULL || !strlen(passphrase)) {\n\t\tciphername = \"none\";\n\t\tkdfname = \"none\";\n\t} else if (ciphername == NULL)\n\t\tciphername = DEFAULT_CIPHERNAME;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tif ((kdf = sshbuf_new()) == NULL ||\n\t    (encoded = sshbuf_new()) == NULL ||\n\t    (encrypted = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif ((key = calloc(1, keylen + ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"bcrypt\") == 0) {\n\t\tarc4random_buf(salt, SALT_LEN);\n\t\tif (bcrypt_pbkdf(passphrase, strlen(passphrase),\n\t\t    salt, SALT_LEN, key, keylen + ivlen, rounds) < 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_string(kdf, salt, SALT_LEN)) != 0 ||\n\t\t    (r = sshbuf_put_u32(kdf, rounds)) != 0)\n\t\t\tgoto out;\n\t} else if (strcmp(kdfname, \"none\") != 0) {\n\t\t/* Unsupported KDF type */\n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif ((r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    key + keylen, ivlen, 1)) != 0)\n\t\tgoto out;\n\n\tif ((r = sshbuf_put(encoded, AUTH_MAGIC, sizeof(AUTH_MAGIC))) != 0 ||\n\t    (r = sshbuf_put_cstring(encoded, ciphername)) != 0 ||\n\t    (r = sshbuf_put_cstring(encoded, kdfname)) != 0 ||\n\t    (r = sshbuf_put_stringb(encoded, kdf)) != 0 ||\n\t    (r = sshbuf_put_u32(encoded, 1)) != 0 ||\t/* number of keys */\n\t    (r = sshkey_to_blob(prv, &pubkeyblob, &pubkeylen)) != 0 ||\n\t    (r = sshbuf_put_string(encoded, pubkeyblob, pubkeylen)) != 0)\n\t\tgoto out;\n\n\t/* set up the buffer that will be encrypted */\n\n\t/* Random check bytes */\n\tcheck = arc4random();\n\tif ((r = sshbuf_put_u32(encrypted, check)) != 0 ||\n\t    (r = sshbuf_put_u32(encrypted, check)) != 0)\n\t\tgoto out;\n\n\t/* append private key and comment*/\n\tif ((r = sshkey_private_serialize_opt(prv, encrypted,\n\t     SSHKEY_SERIALIZE_FULL)) != 0 ||\n\t    (r = sshbuf_put_cstring(encrypted, comment)) != 0)\n\t\tgoto out;\n\n\t/* padding */\n\ti = 0;\n\twhile (sshbuf_len(encrypted) % blocksize) {\n\t\tif ((r = sshbuf_put_u8(encrypted, ++i & 0xff)) != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* length in destination buffer */\n\tif ((r = sshbuf_put_u32(encoded, sshbuf_len(encrypted))) != 0)\n\t\tgoto out;\n\n\t/* encrypt */\n\tif ((r = sshbuf_reserve(encoded,\n\t    sshbuf_len(encrypted) + authlen, &cp)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(ciphercontext, 0, cp,\n\t    sshbuf_ptr(encrypted), sshbuf_len(encrypted), 0, authlen)) != 0)\n\t\tgoto out;\n\n\t/* uuencode */\n\tif ((b64 = sshbuf_dtob64(encoded)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tsshbuf_reset(blob);\n\tif ((r = sshbuf_put(blob, MARK_BEGIN, MARK_BEGIN_LEN)) != 0)\n\t\tgoto out;\n\tfor (i = 0; i < strlen(b64); i++) {\n\t\tif ((r = sshbuf_put_u8(blob, b64[i])) != 0)\n\t\t\tgoto out;\n\t\t/* insert line breaks */\n\t\tif (i % 70 == 69 && (r = sshbuf_put_u8(blob, '\\n')) != 0)\n\t\t\tgoto out;\n\t}\n\tif (i % 70 != 69 && (r = sshbuf_put_u8(blob, '\\n')) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_put(blob, MARK_END, MARK_END_LEN)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n\n out:\n\tsshbuf_free(kdf);\n\tsshbuf_free(encoded);\n\tsshbuf_free(encrypted);\n\tcipher_free(ciphercontext);\n\texplicit_bzero(salt, sizeof(salt));\n\tif (key != NULL) {\n\t\texplicit_bzero(key, keylen + ivlen);\n\t\tfree(key);\n\t}\n\tif (pubkeyblob != NULL) {\n\t\texplicit_bzero(pubkeyblob, pubkeylen);\n\t\tfree(pubkeyblob);\n\t}\n\tif (b64 != NULL) {\n\t\texplicit_bzero(b64, strlen(b64));\n\t\tfree(b64);\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_private_pem_to_blob",
          "args": [
            "key",
            "blob",
            "passphrase",
            "comment"
          ],
          "line": 3832
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_private_pem_to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3765-3814",
          "snippet": "static int\nsshkey_private_pem_to_blob(struct sshkey *key, struct sshbuf *blob,\n    const char *_passphrase, const char *comment)\n{\n\tint success, r;\n\tint blen, len = strlen(_passphrase);\n\tu_char *passphrase = (len > 0) ? (u_char *)_passphrase : NULL;\n\tconst EVP_CIPHER *cipher = (len > 0) ? EVP_aes_128_cbc() : NULL;\n\tchar *bptr;\n\tBIO *bio = NULL;\n\n\tif (len > 0 && len <= 4)\n\t\treturn SSH_ERR_PASSPHRASE_TOO_SHORT;\n\tif ((bio = BIO_new(BIO_s_mem())) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tswitch (key->type) {\n\tcase KEY_DSA:\n\t\tsuccess = PEM_write_bio_DSAPrivateKey(bio, key->dsa,\n\t\t    cipher, passphrase, len, NULL, NULL);\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tsuccess = PEM_write_bio_ECPrivateKey(bio, key->ecdsa,\n\t\t    cipher, passphrase, len, NULL, NULL);\n\t\tbreak;\n#endif\n\tcase KEY_RSA:\n\t\tsuccess = PEM_write_bio_RSAPrivateKey(bio, key->rsa,\n\t\t    cipher, passphrase, len, NULL, NULL);\n\t\tbreak;\n\tdefault:\n\t\tsuccess = 0;\n\t\tbreak;\n\t}\n\tif (success == 0) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif ((blen = BIO_get_mem_data(bio, &bptr)) <= 0) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put(blob, bptr, blen)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tBIO_free(bio);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nsshkey_private_pem_to_blob(struct sshkey *key, struct sshbuf *blob,\n    const char *_passphrase, const char *comment)\n{\n\tint success, r;\n\tint blen, len = strlen(_passphrase);\n\tu_char *passphrase = (len > 0) ? (u_char *)_passphrase : NULL;\n\tconst EVP_CIPHER *cipher = (len > 0) ? EVP_aes_128_cbc() : NULL;\n\tchar *bptr;\n\tBIO *bio = NULL;\n\n\tif (len > 0 && len <= 4)\n\t\treturn SSH_ERR_PASSPHRASE_TOO_SHORT;\n\tif ((bio = BIO_new(BIO_s_mem())) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tswitch (key->type) {\n\tcase KEY_DSA:\n\t\tsuccess = PEM_write_bio_DSAPrivateKey(bio, key->dsa,\n\t\t    cipher, passphrase, len, NULL, NULL);\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tsuccess = PEM_write_bio_ECPrivateKey(bio, key->ecdsa,\n\t\t    cipher, passphrase, len, NULL, NULL);\n\t\tbreak;\n#endif\n\tcase KEY_RSA:\n\t\tsuccess = PEM_write_bio_RSAPrivateKey(bio, key->rsa,\n\t\t    cipher, passphrase, len, NULL, NULL);\n\t\tbreak;\n\tdefault:\n\t\tsuccess = 0;\n\t\tbreak;\n\t}\n\tif (success == 0) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif ((blen = BIO_get_mem_data(bio, &bptr)) <= 0) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put(blob, bptr, blen)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tBIO_free(bio);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_private_to_fileblob(struct sshkey *key, struct sshbuf *blob,\n    const char *passphrase, const char *comment,\n    int force_new_format, const char *new_format_cipher, int new_format_rounds)\n{\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_RSA:\n\t\tif (force_new_format) {\n\t\t\treturn sshkey_private_to_blob2(key, blob, passphrase,\n\t\t\t    comment, new_format_cipher, new_format_rounds);\n\t\t}\n\t\treturn sshkey_private_pem_to_blob(key, blob,\n\t\t    passphrase, comment);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n#endif /* WITH_XMSS */\n\t\treturn sshkey_private_to_blob2(key, blob, passphrase,\n\t\t    comment, new_format_cipher, new_format_rounds);\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
  },
  {
    "function_name": "sshkey_private_pem_to_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "3765-3814",
    "snippet": "static int\nsshkey_private_pem_to_blob(struct sshkey *key, struct sshbuf *blob,\n    const char *_passphrase, const char *comment)\n{\n\tint success, r;\n\tint blen, len = strlen(_passphrase);\n\tu_char *passphrase = (len > 0) ? (u_char *)_passphrase : NULL;\n\tconst EVP_CIPHER *cipher = (len > 0) ? EVP_aes_128_cbc() : NULL;\n\tchar *bptr;\n\tBIO *bio = NULL;\n\n\tif (len > 0 && len <= 4)\n\t\treturn SSH_ERR_PASSPHRASE_TOO_SHORT;\n\tif ((bio = BIO_new(BIO_s_mem())) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tswitch (key->type) {\n\tcase KEY_DSA:\n\t\tsuccess = PEM_write_bio_DSAPrivateKey(bio, key->dsa,\n\t\t    cipher, passphrase, len, NULL, NULL);\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tsuccess = PEM_write_bio_ECPrivateKey(bio, key->ecdsa,\n\t\t    cipher, passphrase, len, NULL, NULL);\n\t\tbreak;\n#endif\n\tcase KEY_RSA:\n\t\tsuccess = PEM_write_bio_RSAPrivateKey(bio, key->rsa,\n\t\t    cipher, passphrase, len, NULL, NULL);\n\t\tbreak;\n\tdefault:\n\t\tsuccess = 0;\n\t\tbreak;\n\t}\n\tif (success == 0) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif ((blen = BIO_get_mem_data(bio, &bptr)) <= 0) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put(blob, bptr, blen)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tBIO_free(bio);\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "bio"
          ],
          "line": 3812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "blob",
            "bptr",
            "blen"
          ],
          "line": 3808
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BIO_get_mem_data",
          "args": [
            "bio",
            "&bptr"
          ],
          "line": 3804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_write_bio_RSAPrivateKey",
          "args": [
            "bio",
            "key->rsa",
            "cipher",
            "passphrase",
            "len",
            "NULL",
            "NULL"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_write_bio_ECPrivateKey",
          "args": [
            "bio",
            "key->ecdsa",
            "cipher",
            "passphrase",
            "len",
            "NULL",
            "NULL"
          ],
          "line": 3788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_write_bio_DSAPrivateKey",
          "args": [
            "bio",
            "key->dsa",
            "cipher",
            "passphrase",
            "len",
            "NULL",
            "NULL"
          ],
          "line": 3783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_new",
          "args": [
            "BIO_s_mem()"
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_s_mem",
          "args": [],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_aes_128_cbc",
          "args": [],
          "line": 3772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "_passphrase"
          ],
          "line": 3770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nsshkey_private_pem_to_blob(struct sshkey *key, struct sshbuf *blob,\n    const char *_passphrase, const char *comment)\n{\n\tint success, r;\n\tint blen, len = strlen(_passphrase);\n\tu_char *passphrase = (len > 0) ? (u_char *)_passphrase : NULL;\n\tconst EVP_CIPHER *cipher = (len > 0) ? EVP_aes_128_cbc() : NULL;\n\tchar *bptr;\n\tBIO *bio = NULL;\n\n\tif (len > 0 && len <= 4)\n\t\treturn SSH_ERR_PASSPHRASE_TOO_SHORT;\n\tif ((bio = BIO_new(BIO_s_mem())) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tswitch (key->type) {\n\tcase KEY_DSA:\n\t\tsuccess = PEM_write_bio_DSAPrivateKey(bio, key->dsa,\n\t\t    cipher, passphrase, len, NULL, NULL);\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tsuccess = PEM_write_bio_ECPrivateKey(bio, key->ecdsa,\n\t\t    cipher, passphrase, len, NULL, NULL);\n\t\tbreak;\n#endif\n\tcase KEY_RSA:\n\t\tsuccess = PEM_write_bio_RSAPrivateKey(bio, key->rsa,\n\t\t    cipher, passphrase, len, NULL, NULL);\n\t\tbreak;\n\tdefault:\n\t\tsuccess = 0;\n\t\tbreak;\n\t}\n\tif (success == 0) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif ((blen = BIO_get_mem_data(bio, &bptr)) <= 0) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put(blob, bptr, blen)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tBIO_free(bio);\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_parse_private2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "3543-3760",
    "snippet": "static int\nsshkey_parse_private2(struct sshbuf *blob, int type, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tchar *comment = NULL, *ciphername = NULL, *kdfname = NULL;\n\tconst struct sshcipher *cipher = NULL;\n\tconst u_char *cp;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tsize_t encoded_len;\n\tsize_t i, keylen = 0, ivlen = 0, authlen = 0, slen = 0;\n\tstruct sshbuf *encoded = NULL, *decoded = NULL;\n\tstruct sshbuf *kdf = NULL, *decrypted = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tstruct sshkey *k = NULL;\n\tu_char *key = NULL, *salt = NULL, *dp, pad, last;\n\tu_int blocksize, rounds, nkeys, encrypted_len, check1, check2;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((encoded = sshbuf_new()) == NULL ||\n\t    (decoded = sshbuf_new()) == NULL ||\n\t    (decrypted = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* check preamble */\n\tcp = sshbuf_ptr(blob);\n\tencoded_len = sshbuf_len(blob);\n\tif (encoded_len < (MARK_BEGIN_LEN + MARK_END_LEN) ||\n\t    memcmp(cp, MARK_BEGIN, MARK_BEGIN_LEN) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tcp += MARK_BEGIN_LEN;\n\tencoded_len -= MARK_BEGIN_LEN;\n\n\t/* Look for end marker, removing whitespace as we go */\n\twhile (encoded_len > 0) {\n\t\tif (*cp != '\\n' && *cp != '\\r') {\n\t\t\tif ((r = sshbuf_put_u8(encoded, *cp)) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tlast = *cp;\n\t\tencoded_len--;\n\t\tcp++;\n\t\tif (last == '\\n') {\n\t\t\tif (encoded_len >= MARK_END_LEN &&\n\t\t\t    memcmp(cp, MARK_END, MARK_END_LEN) == 0) {\n\t\t\t\t/* \\0 terminate */\n\t\t\t\tif ((r = sshbuf_put_u8(encoded, 0)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (encoded_len == 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* decode base64 */\n\tif ((r = sshbuf_b64tod(decoded, (char *)sshbuf_ptr(encoded))) != 0)\n\t\tgoto out;\n\n\t/* check magic */\n\tif (sshbuf_len(decoded) < sizeof(AUTH_MAGIC) ||\n\t    memcmp(sshbuf_ptr(decoded), AUTH_MAGIC, sizeof(AUTH_MAGIC))) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* parse public portion of key */\n\tif ((r = sshbuf_consume(decoded, sizeof(AUTH_MAGIC))) != 0 ||\n\t    (r = sshbuf_get_cstring(decoded, &ciphername, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(decoded, &kdfname, NULL)) != 0 ||\n\t    (r = sshbuf_froms(decoded, &kdf)) != 0 ||\n\t    (r = sshbuf_get_u32(decoded, &nkeys)) != 0 ||\n\t    (r = sshbuf_skip_string(decoded)) != 0 || /* pubkey */\n\t    (r = sshbuf_get_u32(decoded, &encrypted_len)) != 0)\n\t\tgoto out;\n\n\tif ((cipher = cipher_by_name(ciphername)) == NULL) {\n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif ((passphrase == NULL || strlen(passphrase) == 0) &&\n\t    strcmp(ciphername, \"none\") != 0) {\n\t\t/* passphrase required */\n\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"none\") != 0 && strcmp(kdfname, \"bcrypt\") != 0) {\n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif (!strcmp(kdfname, \"none\") && strcmp(ciphername, \"none\") != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (nkeys != 1) {\n\t\t/* XXX only one key supported */\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* check size of encrypted key blob */\n\tblocksize = cipher_blocksize(cipher);\n\tif (encrypted_len < blocksize || (encrypted_len % blocksize) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* setup key */\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif ((key = calloc(1, keylen + ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"bcrypt\") == 0) {\n\t\tif ((r = sshbuf_get_string(kdf, &salt, &slen)) != 0 ||\n\t\t    (r = sshbuf_get_u32(kdf, &rounds)) != 0)\n\t\t\tgoto out;\n\t\tif (bcrypt_pbkdf(passphrase, strlen(passphrase), salt, slen,\n\t\t    key, keylen + ivlen, rounds) < 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* check that an appropriate amount of auth data is present */\n\tif (sshbuf_len(decoded) < encrypted_len + authlen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* decrypt private portion of key */\n\tif ((r = sshbuf_reserve(decrypted, encrypted_len, &dp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    key + keylen, ivlen, 0)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(ciphercontext, 0, dp, sshbuf_ptr(decoded),\n\t    encrypted_len, 0, authlen)) != 0) {\n\t\t/* an integrity error here indicates an incorrect passphrase */\n\t\tif (r == SSH_ERR_MAC_INVALID)\n\t\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(decoded, encrypted_len + authlen)) != 0)\n\t\tgoto out;\n\t/* there should be no trailing data */\n\tif (sshbuf_len(decoded) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* check check bytes */\n\tif ((r = sshbuf_get_u32(decrypted, &check1)) != 0 ||\n\t    (r = sshbuf_get_u32(decrypted, &check2)) != 0)\n\t\tgoto out;\n\tif (check1 != check2) {\n\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\n\t/* Load the private key and comment */\n\tif ((r = sshkey_private_deserialize(decrypted, &k)) != 0 ||\n\t    (r = sshbuf_get_cstring(decrypted, &comment, NULL)) != 0)\n\t\tgoto out;\n\n\t/* Check deterministic padding */\n\ti = 0;\n\twhile (sshbuf_len(decrypted)) {\n\t\tif ((r = sshbuf_get_u8(decrypted, &pad)) != 0)\n\t\t\tgoto out;\n\t\tif (pad != (++i & 0xff)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* XXX decode pubkey and check against private */\n\n\t/* success */\n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = k;\n\t\tk = NULL;\n\t}\n\tif (commentp != NULL) {\n\t\t*commentp = comment;\n\t\tcomment = NULL;\n\t}\n out:\n\tpad = 0;\n\tcipher_free(ciphercontext);\n\tfree(ciphername);\n\tfree(kdfname);\n\tfree(comment);\n\tif (salt != NULL) {\n\t\texplicit_bzero(salt, slen);\n\t\tfree(salt);\n\t}\n\tif (key != NULL) {\n\t\texplicit_bzero(key, keylen + ivlen);\n\t\tfree(key);\n\t}\n\tsshbuf_free(encoded);\n\tsshbuf_free(decoded);\n\tsshbuf_free(kdf);\n\tsshbuf_free(decrypted);\n\tsshkey_free(k);\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define AUTH_MAGIC\t\t\"openssh-key-v1\"",
      "#define MARK_END_LEN\t\t(sizeof(MARK_END) - 1)",
      "#define MARK_BEGIN_LEN\t\t(sizeof(MARK_BEGIN) - 1)",
      "#define MARK_END\t\t\"-----END OPENSSH PRIVATE KEY-----\\n\"",
      "#define MARK_BEGIN\t\t\"-----BEGIN OPENSSH PRIVATE KEY-----\\n\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "k"
          ],
          "line": 3758
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "decrypted"
          ],
          "line": 3757
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "key",
            "keylen + ivlen"
          ],
          "line": 3751
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_free",
          "args": [
            "ciphercontext"
          ],
          "line": 3742
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "410-425",
          "snippet": "void\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nvoid\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "decrypted",
            "&pad"
          ],
          "line": 3720
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "decrypted"
          ],
          "line": 3719
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "decrypted",
            "&comment",
            "NULL"
          ],
          "line": 3714
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_private_deserialize",
          "args": [
            "decrypted",
            "&k"
          ],
          "line": 3713
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_private_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2915-3221",
          "snippet": "int\nsshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)\n{\n\tchar *tname = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *k = NULL;\n\tsize_t pklen = 0, sklen = 0;\n\tint type, r = SSH_ERR_INTERNAL_ERROR;\n\tu_char *ed25519_pk = NULL, *ed25519_sk = NULL;\n\tu_char *xmss_pk = NULL, *xmss_sk = NULL;\n#ifdef WITH_OPENSSL\n\tBIGNUM *exponent = NULL;\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n\tBIGNUM *rsa_iqmp = NULL, *rsa_p = NULL, *rsa_q = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL;\n\tBIGNUM *dsa_pub_key = NULL, *dsa_priv_key = NULL;\n#endif /* WITH_OPENSSL */\n\n\tif (kp != NULL)\n\t\t*kp = NULL;\n\tif ((r = sshbuf_get_cstring(buf, &tname, NULL)) != 0)\n\t\tgoto out;\n\ttype = sshkey_type_from_name(tname);\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL ||\n\t\t    (dsa_priv_key = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_bignum2(buf, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tif (!DSA_set0_pqg(k->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(k->dsa, dsa_pub_key, dsa_priv_key)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = dsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa_priv_key = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tif (!DSA_set0_key(k->dsa, NULL, dsa_priv_key)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((k->ecdsa_nid = sshkey_ecdsa_nid_from_name(tname)) == -1) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(buf, &curve, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif (k->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tr = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (k->ecdsa  == NULL || (exponent = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_eckey(buf, k->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, exponent)))\n\t\t\tgoto out;\n\t\tif (EC_KEY_set_private_key(k->ecdsa, exponent) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),\n\t\t    EC_KEY_get0_public_key(k->ecdsa))) != 0 ||\n\t\t    (r = sshkey_ec_validate_private(k->ecdsa)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif ((exponent = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, exponent)) != 0)\n\t\t\tgoto out;\n\t\tif (EC_KEY_set_private_key(k->ecdsa, exponent) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),\n\t\t    EC_KEY_get0_public_key(k->ecdsa))) != 0 ||\n\t\t    (r = sshkey_ec_validate_private(k->ecdsa)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_n = BN_new()) == NULL ||\n\t\t    (rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_bignum2(buf, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tif (!RSA_set0_key(k->rsa, rsa_n, rsa_e, rsa_d)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = rsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(k->rsa, rsa_p, rsa_q)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = check_rsa_length(k->rsa)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = ssh_rsa_complete_crt_parameters(k, rsa_iqmp)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tif (!RSA_set0_key(k->rsa, NULL, NULL, rsa_d)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(k->rsa, rsa_p, rsa_q)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = check_rsa_length(k->rsa)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = ssh_rsa_complete_crt_parameters(k, rsa_iqmp)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_string(buf, &ed25519_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != ED25519_PK_SZ || sklen != ED25519_SK_SZ) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ed25519_pk = ed25519_pk;\n\t\tk->ed25519_sk = ed25519_sk;\n\t\ted25519_pk = ed25519_sk = NULL;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != ED25519_PK_SZ || sklen != ED25519_SK_SZ) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ed25519_pk = ed25519_pk;\n\t\tk->ed25519_sk = ed25519_sk;\n\t\ted25519_pk = ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(buf, &xmss_name, NULL)) != 0 ||\n\t\t    (r = sshkey_xmss_init(k, xmss_name)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != sshkey_xmss_pklen(k) ||\n\t\t    sklen != sshkey_xmss_sklen(k)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->xmss_pk = xmss_pk;\n\t\tk->xmss_sk = xmss_sk;\n\t\txmss_pk = xmss_sk = NULL;\n\t\t/* optional internal state */\n\t\tif ((r = sshkey_xmss_deserialize_state_opt(k, buf)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_cstring(buf, &xmss_name, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (strcmp(xmss_name, k->xmss_name)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (pklen != sshkey_xmss_pklen(k) ||\n\t\t    sklen != sshkey_xmss_sklen(k)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->xmss_pk = xmss_pk;\n\t\tk->xmss_sk = xmss_sk;\n\t\txmss_pk = xmss_sk = NULL;\n\t\t/* optional internal state */\n\t\tif ((r = sshkey_xmss_deserialize_state_opt(k, buf)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n#ifdef WITH_OPENSSL\n\t/* enable blinding */\n\tswitch (k->type) {\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (RSA_blinding_on(k->rsa, NULL) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n#endif /* WITH_OPENSSL */\n\t/* success */\n\tr = 0;\n\tif (kp != NULL) {\n\t\t*kp = k;\n\t\tk = NULL;\n\t}\n out:\n\tfree(tname);\n\tfree(curve);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(exponent);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n\tBN_clear_free(dsa_priv_key);\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(rsa_d);\n\tBN_clear_free(rsa_p);\n\tBN_clear_free(rsa_q);\n\tBN_clear_free(rsa_iqmp);\n#endif /* WITH_OPENSSL */\n\tsshkey_free(k);\n\tfreezero(ed25519_pk, pklen);\n\tfreezero(ed25519_sk, sklen);\n\tfree(xmss_name);\n\tfreezero(xmss_pk, pklen);\n\tfreezero(xmss_sk, sklen);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)\n{\n\tchar *tname = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *k = NULL;\n\tsize_t pklen = 0, sklen = 0;\n\tint type, r = SSH_ERR_INTERNAL_ERROR;\n\tu_char *ed25519_pk = NULL, *ed25519_sk = NULL;\n\tu_char *xmss_pk = NULL, *xmss_sk = NULL;\n#ifdef WITH_OPENSSL\n\tBIGNUM *exponent = NULL;\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n\tBIGNUM *rsa_iqmp = NULL, *rsa_p = NULL, *rsa_q = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL;\n\tBIGNUM *dsa_pub_key = NULL, *dsa_priv_key = NULL;\n#endif /* WITH_OPENSSL */\n\n\tif (kp != NULL)\n\t\t*kp = NULL;\n\tif ((r = sshbuf_get_cstring(buf, &tname, NULL)) != 0)\n\t\tgoto out;\n\ttype = sshkey_type_from_name(tname);\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL ||\n\t\t    (dsa_priv_key = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_bignum2(buf, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tif (!DSA_set0_pqg(k->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(k->dsa, dsa_pub_key, dsa_priv_key)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = dsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa_priv_key = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tif (!DSA_set0_key(k->dsa, NULL, dsa_priv_key)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((k->ecdsa_nid = sshkey_ecdsa_nid_from_name(tname)) == -1) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(buf, &curve, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif (k->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tr = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (k->ecdsa  == NULL || (exponent = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_eckey(buf, k->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, exponent)))\n\t\t\tgoto out;\n\t\tif (EC_KEY_set_private_key(k->ecdsa, exponent) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),\n\t\t    EC_KEY_get0_public_key(k->ecdsa))) != 0 ||\n\t\t    (r = sshkey_ec_validate_private(k->ecdsa)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif ((exponent = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, exponent)) != 0)\n\t\t\tgoto out;\n\t\tif (EC_KEY_set_private_key(k->ecdsa, exponent) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),\n\t\t    EC_KEY_get0_public_key(k->ecdsa))) != 0 ||\n\t\t    (r = sshkey_ec_validate_private(k->ecdsa)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_n = BN_new()) == NULL ||\n\t\t    (rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_bignum2(buf, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tif (!RSA_set0_key(k->rsa, rsa_n, rsa_e, rsa_d)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = rsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(k->rsa, rsa_p, rsa_q)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = check_rsa_length(k->rsa)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = ssh_rsa_complete_crt_parameters(k, rsa_iqmp)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tif (!RSA_set0_key(k->rsa, NULL, NULL, rsa_d)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(k->rsa, rsa_p, rsa_q)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = check_rsa_length(k->rsa)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = ssh_rsa_complete_crt_parameters(k, rsa_iqmp)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_string(buf, &ed25519_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != ED25519_PK_SZ || sklen != ED25519_SK_SZ) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ed25519_pk = ed25519_pk;\n\t\tk->ed25519_sk = ed25519_sk;\n\t\ted25519_pk = ed25519_sk = NULL;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != ED25519_PK_SZ || sklen != ED25519_SK_SZ) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ed25519_pk = ed25519_pk;\n\t\tk->ed25519_sk = ed25519_sk;\n\t\ted25519_pk = ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(buf, &xmss_name, NULL)) != 0 ||\n\t\t    (r = sshkey_xmss_init(k, xmss_name)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != sshkey_xmss_pklen(k) ||\n\t\t    sklen != sshkey_xmss_sklen(k)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->xmss_pk = xmss_pk;\n\t\tk->xmss_sk = xmss_sk;\n\t\txmss_pk = xmss_sk = NULL;\n\t\t/* optional internal state */\n\t\tif ((r = sshkey_xmss_deserialize_state_opt(k, buf)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_cstring(buf, &xmss_name, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (strcmp(xmss_name, k->xmss_name)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (pklen != sshkey_xmss_pklen(k) ||\n\t\t    sklen != sshkey_xmss_sklen(k)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->xmss_pk = xmss_pk;\n\t\tk->xmss_sk = xmss_sk;\n\t\txmss_pk = xmss_sk = NULL;\n\t\t/* optional internal state */\n\t\tif ((r = sshkey_xmss_deserialize_state_opt(k, buf)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n#ifdef WITH_OPENSSL\n\t/* enable blinding */\n\tswitch (k->type) {\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (RSA_blinding_on(k->rsa, NULL) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n#endif /* WITH_OPENSSL */\n\t/* success */\n\tr = 0;\n\tif (kp != NULL) {\n\t\t*kp = k;\n\t\tk = NULL;\n\t}\n out:\n\tfree(tname);\n\tfree(curve);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(exponent);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n\tBN_clear_free(dsa_priv_key);\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(rsa_d);\n\tBN_clear_free(rsa_p);\n\tBN_clear_free(rsa_q);\n\tBN_clear_free(rsa_iqmp);\n#endif /* WITH_OPENSSL */\n\tsshkey_free(k);\n\tfreezero(ed25519_pk, pklen);\n\tfreezero(ed25519_sk, sklen);\n\tfree(xmss_name);\n\tfreezero(xmss_pk, pklen);\n\tfreezero(xmss_sk, sklen);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "decrypted",
            "&check2"
          ],
          "line": 3705
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "decoded",
            "encrypted_len + authlen"
          ],
          "line": 3695
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_crypt",
          "args": [
            "ciphercontext",
            "0",
            "dp",
            "sshbuf_ptr(decoded)",
            "encrypted_len",
            "0",
            "authlen"
          ],
          "line": 3688
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_crypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "334-394",
          "snippet": "int\ncipher_crypt(struct sshcipher_ctx *cc, u_int seqnr, u_char *dest,\n   const u_char *src, u_int len, u_int aadlen, u_int authlen)\n{\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\treturn chachapoly_crypt(&cc->cp_ctx, seqnr, dest, src,\n\t\t    len, aadlen, authlen, cc->encrypt);\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tmemcpy(dest, src, aadlen + len);\n\t\treturn 0;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\tif (aadlen)\n\t\t\tmemcpy(dest, src, aadlen);\n\t\taesctr_encrypt_bytes(&cc->ac_ctx, src + aadlen,\n\t\t    dest + aadlen, len);\n\t\treturn 0;\n\t}\n\treturn SSH_ERR_INVALID_ARGUMENT;\n#else\n\tif (authlen) {\n\t\tu_char lastiv[1];\n\n\t\tif (authlen != cipher_authlen(cc->cipher))\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t/* increment IV */\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,\n\t\t    1, lastiv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t/* set tag on decyption */\n\t\tif (!cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_TAG,\n\t\t    authlen, (u_char *)src + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\tif (aadlen) {\n\t\tif (authlen &&\n\t\t    EVP_Cipher(cc->evp, NULL, (u_char *)src, aadlen) < 0)\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\tmemcpy(dest, src, aadlen);\n\t}\n\tif (len % cc->cipher->block_size)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (EVP_Cipher(cc->evp, dest + aadlen, (u_char *)src + aadlen,\n\t    len) < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif (authlen) {\n\t\t/* compute tag (on encrypt) or verify tag (on decrypt) */\n\t\tif (EVP_Cipher(cc->evp, NULL, NULL, 0) < 0)\n\t\t\treturn cc->encrypt ?\n\t\t\t    SSH_ERR_LIBCRYPTO_ERROR : SSH_ERR_MAC_INVALID;\n\t\tif (cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_GET_TAG,\n\t\t    authlen, dest + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_NONE\t\t(1<<3)",
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_NONE\t\t(1<<3)\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nint\ncipher_crypt(struct sshcipher_ctx *cc, u_int seqnr, u_char *dest,\n   const u_char *src, u_int len, u_int aadlen, u_int authlen)\n{\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\treturn chachapoly_crypt(&cc->cp_ctx, seqnr, dest, src,\n\t\t    len, aadlen, authlen, cc->encrypt);\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tmemcpy(dest, src, aadlen + len);\n\t\treturn 0;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\tif (aadlen)\n\t\t\tmemcpy(dest, src, aadlen);\n\t\taesctr_encrypt_bytes(&cc->ac_ctx, src + aadlen,\n\t\t    dest + aadlen, len);\n\t\treturn 0;\n\t}\n\treturn SSH_ERR_INVALID_ARGUMENT;\n#else\n\tif (authlen) {\n\t\tu_char lastiv[1];\n\n\t\tif (authlen != cipher_authlen(cc->cipher))\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t/* increment IV */\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,\n\t\t    1, lastiv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t/* set tag on decyption */\n\t\tif (!cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_TAG,\n\t\t    authlen, (u_char *)src + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\tif (aadlen) {\n\t\tif (authlen &&\n\t\t    EVP_Cipher(cc->evp, NULL, (u_char *)src, aadlen) < 0)\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\tmemcpy(dest, src, aadlen);\n\t}\n\tif (len % cc->cipher->block_size)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (EVP_Cipher(cc->evp, dest + aadlen, (u_char *)src + aadlen,\n\t    len) < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif (authlen) {\n\t\t/* compute tag (on encrypt) or verify tag (on decrypt) */\n\t\tif (EVP_Cipher(cc->evp, NULL, NULL, 0) < 0)\n\t\t\treturn cc->encrypt ?\n\t\t\t    SSH_ERR_LIBCRYPTO_ERROR : SSH_ERR_MAC_INVALID;\n\t\tif (cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_GET_TAG,\n\t\t    authlen, dest + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "decoded"
          ],
          "line": 3688
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_init",
          "args": [
            "&ciphercontext",
            "cipher",
            "key",
            "keylen",
            "key + keylen",
            "ivlen",
            "0"
          ],
          "line": 3685
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "235-322",
          "snippet": "int\ncipher_init(struct sshcipher_ctx **ccp, const struct sshcipher *cipher,\n    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,\n    int do_encrypt)\n{\n\tstruct sshcipher_ctx *cc = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst EVP_CIPHER *type;\n\tint klen;\n#endif\n\n\t*ccp = NULL;\n\tif ((cc = calloc(sizeof(*cc), 1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tcc->plaintext = (cipher->flags & CFLAG_NONE) != 0;\n\tcc->encrypt = do_encrypt;\n\n\tif (keylen < cipher->key_len ||\n\t    (iv != NULL && ivlen < cipher_ivlen(cipher))) {\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tcc->cipher = cipher;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tret = chachapoly_init(&cc->cp_ctx, key, keylen);\n\t\tgoto out;\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\taesctr_keysetup(&cc->ac_ctx, key, 8 * keylen, 8 * ivlen);\n\t\taesctr_ivsetup(&cc->ac_ctx, iv);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tret = SSH_ERR_INVALID_ARGUMENT;\n\tgoto out;\n#else /* WITH_OPENSSL */\n\ttype = (*cipher->evptype)();\n\tif ((cc->evp = EVP_CIPHER_CTX_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EVP_CipherInit(cc->evp, type, NULL, (u_char *)iv,\n\t    (do_encrypt == CIPHER_ENCRYPT)) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (cipher_authlen(cipher) &&\n\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,\n\t    -1, (u_char *)iv)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tklen = EVP_CIPHER_CTX_key_length(cc->evp);\n\tif (klen > 0 && keylen != (u_int)klen) {\n\t\tif (EVP_CIPHER_CTX_set_key_length(cc->evp, keylen) == 0) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tret = 0;\n#endif /* WITH_OPENSSL */\n out:\n\tif (ret == 0) {\n\t\t/* success */\n\t\t*ccp = cc;\n\t} else {\n\t\tif (cc != NULL) {\n#ifdef WITH_OPENSSL\n\t\t\tEVP_CIPHER_CTX_free(cc->evp);\n#endif /* WITH_OPENSSL */\n\t\t\texplicit_bzero(cc, sizeof(*cc));\n\t\t\tfree(cc);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_NONE\t\t(1<<3)",
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_NONE\t\t(1<<3)\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nint\ncipher_init(struct sshcipher_ctx **ccp, const struct sshcipher *cipher,\n    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,\n    int do_encrypt)\n{\n\tstruct sshcipher_ctx *cc = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst EVP_CIPHER *type;\n\tint klen;\n#endif\n\n\t*ccp = NULL;\n\tif ((cc = calloc(sizeof(*cc), 1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tcc->plaintext = (cipher->flags & CFLAG_NONE) != 0;\n\tcc->encrypt = do_encrypt;\n\n\tif (keylen < cipher->key_len ||\n\t    (iv != NULL && ivlen < cipher_ivlen(cipher))) {\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tcc->cipher = cipher;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tret = chachapoly_init(&cc->cp_ctx, key, keylen);\n\t\tgoto out;\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\taesctr_keysetup(&cc->ac_ctx, key, 8 * keylen, 8 * ivlen);\n\t\taesctr_ivsetup(&cc->ac_ctx, iv);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tret = SSH_ERR_INVALID_ARGUMENT;\n\tgoto out;\n#else /* WITH_OPENSSL */\n\ttype = (*cipher->evptype)();\n\tif ((cc->evp = EVP_CIPHER_CTX_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EVP_CipherInit(cc->evp, type, NULL, (u_char *)iv,\n\t    (do_encrypt == CIPHER_ENCRYPT)) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (cipher_authlen(cipher) &&\n\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,\n\t    -1, (u_char *)iv)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tklen = EVP_CIPHER_CTX_key_length(cc->evp);\n\tif (klen > 0 && keylen != (u_int)klen) {\n\t\tif (EVP_CIPHER_CTX_set_key_length(cc->evp, keylen) == 0) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tret = 0;\n#endif /* WITH_OPENSSL */\n out:\n\tif (ret == 0) {\n\t\t/* success */\n\t\t*ccp = cc;\n\t} else {\n\t\tif (cc != NULL) {\n#ifdef WITH_OPENSSL\n\t\t\tEVP_CIPHER_CTX_free(cc->evp);\n#endif /* WITH_OPENSSL */\n\t\t\texplicit_bzero(cc, sizeof(*cc));\n\t\t\tfree(cc);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reserve",
          "args": [
            "decrypted",
            "encrypted_len",
            "&dp"
          ],
          "line": 3684
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "343-361",
          "snippet": "int\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcrypt_pbkdf",
          "args": [
            "passphrase",
            "strlen(passphrase)",
            "salt",
            "slen",
            "key",
            "keylen + ivlen",
            "rounds"
          ],
          "line": 3670
        },
        "resolved": true,
        "details": {
          "function_name": "bcrypt_pbkdf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bcrypt_pbkdf.c",
          "lines": "110-178",
          "snippet": "int\nbcrypt_pbkdf(const char *pass, size_t passlen, const u_int8_t *salt, size_t saltlen,\n    u_int8_t *key, size_t keylen, unsigned int rounds)\n{\n\tu_int8_t sha2pass[SHA512_DIGEST_LENGTH];\n\tu_int8_t sha2salt[SHA512_DIGEST_LENGTH];\n\tu_int8_t out[BCRYPT_HASHSIZE];\n\tu_int8_t tmpout[BCRYPT_HASHSIZE];\n\tu_int8_t *countsalt;\n\tsize_t i, j, amt, stride;\n\tuint32_t count;\n\tsize_t origkeylen = keylen;\n\n\t/* nothing crazy */\n\tif (rounds < 1)\n\t\treturn -1;\n\tif (passlen == 0 || saltlen == 0 || keylen == 0 ||\n\t    keylen > sizeof(out) * sizeof(out) || saltlen > 1<<20)\n\t\treturn -1;\n\tif ((countsalt = calloc(1, saltlen + 4)) == NULL)\n\t\treturn -1;\n\tstride = (keylen + sizeof(out) - 1) / sizeof(out);\n\tamt = (keylen + stride - 1) / stride;\n\n\tmemcpy(countsalt, salt, saltlen);\n\n\t/* collapse password */\n\tcrypto_hash_sha512(sha2pass, pass, passlen);\n\n\t/* generate key, sizeof(out) at a time */\n\tfor (count = 1; keylen > 0; count++) {\n\t\tcountsalt[saltlen + 0] = (count >> 24) & 0xff;\n\t\tcountsalt[saltlen + 1] = (count >> 16) & 0xff;\n\t\tcountsalt[saltlen + 2] = (count >> 8) & 0xff;\n\t\tcountsalt[saltlen + 3] = count & 0xff;\n\n\t\t/* first round, salt is salt */\n\t\tcrypto_hash_sha512(sha2salt, countsalt, saltlen + 4);\n\n\t\tbcrypt_hash(sha2pass, sha2salt, tmpout);\n\t\tmemcpy(out, tmpout, sizeof(out));\n\n\t\tfor (i = 1; i < rounds; i++) {\n\t\t\t/* subsequent rounds, salt is previous output */\n\t\t\tcrypto_hash_sha512(sha2salt, tmpout, sizeof(tmpout));\n\t\t\tbcrypt_hash(sha2pass, sha2salt, tmpout);\n\t\t\tfor (j = 0; j < sizeof(out); j++)\n\t\t\t\tout[j] ^= tmpout[j];\n\t\t}\n\n\t\t/*\n\t\t * pbkdf2 deviation: output the key material non-linearly.\n\t\t */\n\t\tamt = MINIMUM(amt, keylen);\n\t\tfor (i = 0; i < amt; i++) {\n\t\t\tsize_t dest = i * stride + (count - 1);\n\t\t\tif (dest >= origkeylen)\n\t\t\t\tbreak;\n\t\t\tkey[dest] = out[i];\n\t\t}\n\t\tkeylen -= i;\n\t}\n\n\t/* zap */\n\texplicit_bzero(out, sizeof(out));\n\tfree(countsalt);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"crypto_api.h\"",
            "# include <blf.h>",
            "#include <string.h>",
            "# include <stdlib.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define BCRYPT_HASHSIZE (BCRYPT_WORDS * 4)",
            "#define SHA512_DIGEST_LENGTH crypto_hash_sha512_BYTES"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"crypto_api.h\"\n# include <blf.h>\n#include <string.h>\n# include <stdlib.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BCRYPT_HASHSIZE (BCRYPT_WORDS * 4)\n#define SHA512_DIGEST_LENGTH crypto_hash_sha512_BYTES\n\nint\nbcrypt_pbkdf(const char *pass, size_t passlen, const u_int8_t *salt, size_t saltlen,\n    u_int8_t *key, size_t keylen, unsigned int rounds)\n{\n\tu_int8_t sha2pass[SHA512_DIGEST_LENGTH];\n\tu_int8_t sha2salt[SHA512_DIGEST_LENGTH];\n\tu_int8_t out[BCRYPT_HASHSIZE];\n\tu_int8_t tmpout[BCRYPT_HASHSIZE];\n\tu_int8_t *countsalt;\n\tsize_t i, j, amt, stride;\n\tuint32_t count;\n\tsize_t origkeylen = keylen;\n\n\t/* nothing crazy */\n\tif (rounds < 1)\n\t\treturn -1;\n\tif (passlen == 0 || saltlen == 0 || keylen == 0 ||\n\t    keylen > sizeof(out) * sizeof(out) || saltlen > 1<<20)\n\t\treturn -1;\n\tif ((countsalt = calloc(1, saltlen + 4)) == NULL)\n\t\treturn -1;\n\tstride = (keylen + sizeof(out) - 1) / sizeof(out);\n\tamt = (keylen + stride - 1) / stride;\n\n\tmemcpy(countsalt, salt, saltlen);\n\n\t/* collapse password */\n\tcrypto_hash_sha512(sha2pass, pass, passlen);\n\n\t/* generate key, sizeof(out) at a time */\n\tfor (count = 1; keylen > 0; count++) {\n\t\tcountsalt[saltlen + 0] = (count >> 24) & 0xff;\n\t\tcountsalt[saltlen + 1] = (count >> 16) & 0xff;\n\t\tcountsalt[saltlen + 2] = (count >> 8) & 0xff;\n\t\tcountsalt[saltlen + 3] = count & 0xff;\n\n\t\t/* first round, salt is salt */\n\t\tcrypto_hash_sha512(sha2salt, countsalt, saltlen + 4);\n\n\t\tbcrypt_hash(sha2pass, sha2salt, tmpout);\n\t\tmemcpy(out, tmpout, sizeof(out));\n\n\t\tfor (i = 1; i < rounds; i++) {\n\t\t\t/* subsequent rounds, salt is previous output */\n\t\t\tcrypto_hash_sha512(sha2salt, tmpout, sizeof(tmpout));\n\t\t\tbcrypt_hash(sha2pass, sha2salt, tmpout);\n\t\t\tfor (j = 0; j < sizeof(out); j++)\n\t\t\t\tout[j] ^= tmpout[j];\n\t\t}\n\n\t\t/*\n\t\t * pbkdf2 deviation: output the key material non-linearly.\n\t\t */\n\t\tamt = MINIMUM(amt, keylen);\n\t\tfor (i = 0; i < amt; i++) {\n\t\t\tsize_t dest = i * stride + (count - 1);\n\t\t\tif (dest >= origkeylen)\n\t\t\t\tbreak;\n\t\t\tkey[dest] = out[i];\n\t\t}\n\t\tkeylen -= i;\n\t}\n\n\t/* zap */\n\texplicit_bzero(out, sizeof(out));\n\tfree(countsalt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "kdf",
            "&salt",
            "&slen"
          ],
          "line": 3667
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kdfname",
            "\"bcrypt\""
          ],
          "line": 3666
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "keylen + ivlen"
          ],
          "line": 3662
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_authlen",
          "args": [
            "cipher"
          ],
          "line": 3661
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_authlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "163-167",
          "snippet": "u_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_ivlen",
          "args": [
            "cipher"
          ],
          "line": 3660
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_ivlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "169-178",
          "snippet": "u_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t/*\n\t * Default is cipher block size, except for chacha20+poly1305 that\n\t * needs no IV. XXX make iv_len == -1 default?\n\t */\n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nu_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t/*\n\t * Default is cipher block size, except for chacha20+poly1305 that\n\t * needs no IV. XXX make iv_len == -1 default?\n\t */\n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_keylen",
          "args": [
            "cipher"
          ],
          "line": 3659
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_keylen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "149-153",
          "snippet": "u_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_blocksize",
          "args": [
            "cipher"
          ],
          "line": 3652
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "143-147",
          "snippet": "u_int\ncipher_blocksize(const struct sshcipher *c)\n{\n\treturn (c->block_size);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_blocksize(const struct sshcipher *c)\n{\n\treturn (c->block_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher_by_name",
          "args": [
            "ciphername"
          ],
          "line": 3627
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "192-200",
          "snippet": "const struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};\n\nconst struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "decoded"
          ],
          "line": 3623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_froms",
          "args": [
            "decoded",
            "&kdf"
          ],
          "line": 3621
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_froms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "377-399",
          "snippet": "int\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sshbuf_ptr(decoded)",
            "AUTH_MAGIC",
            "sizeof(AUTH_MAGIC)"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_b64tod",
          "args": [
            "decoded",
            "(char *)sshbuf_ptr(encoded)"
          ],
          "line": 3608
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_b64tod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "113-137",
          "snippet": "int\nsshbuf_b64tod(struct sshbuf *buf, const char *b64)\n{\n\tsize_t plen = strlen(b64);\n\tint nlen, r;\n\tu_char *p;\n\n\tif (plen == 0)\n\t\treturn 0;\n\tif ((p = malloc(plen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((nlen = b64_pton(b64, p, plen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_put(buf, p, nlen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn r;\n\t}\n\texplicit_bzero(p, plen);\n\tfree(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_b64tod(struct sshbuf *buf, const char *b64)\n{\n\tsize_t plen = strlen(b64);\n\tint nlen, r;\n\tu_char *p;\n\n\tif (plen == 0)\n\t\treturn 0;\n\tif ((p = malloc(plen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((nlen = b64_pton(b64, p, plen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_put(buf, p, nlen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn r;\n\t}\n\texplicit_bzero(p, plen);\n\tfree(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "encoded",
            "0"
          ],
          "line": 3596
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "cp",
            "MARK_END",
            "MARK_END_LEN"
          ],
          "line": 3594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "cp",
            "MARK_BEGIN",
            "MARK_BEGIN_LEN"
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 3567
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define AUTH_MAGIC\t\t\"openssh-key-v1\"\n#define MARK_END_LEN\t\t(sizeof(MARK_END) - 1)\n#define MARK_BEGIN_LEN\t\t(sizeof(MARK_BEGIN) - 1)\n#define MARK_END\t\t\"-----END OPENSSH PRIVATE KEY-----\\n\"\n#define MARK_BEGIN\t\t\"-----BEGIN OPENSSH PRIVATE KEY-----\\n\"\n\nstatic int\nsshkey_parse_private2(struct sshbuf *blob, int type, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tchar *comment = NULL, *ciphername = NULL, *kdfname = NULL;\n\tconst struct sshcipher *cipher = NULL;\n\tconst u_char *cp;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tsize_t encoded_len;\n\tsize_t i, keylen = 0, ivlen = 0, authlen = 0, slen = 0;\n\tstruct sshbuf *encoded = NULL, *decoded = NULL;\n\tstruct sshbuf *kdf = NULL, *decrypted = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tstruct sshkey *k = NULL;\n\tu_char *key = NULL, *salt = NULL, *dp, pad, last;\n\tu_int blocksize, rounds, nkeys, encrypted_len, check1, check2;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((encoded = sshbuf_new()) == NULL ||\n\t    (decoded = sshbuf_new()) == NULL ||\n\t    (decrypted = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* check preamble */\n\tcp = sshbuf_ptr(blob);\n\tencoded_len = sshbuf_len(blob);\n\tif (encoded_len < (MARK_BEGIN_LEN + MARK_END_LEN) ||\n\t    memcmp(cp, MARK_BEGIN, MARK_BEGIN_LEN) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tcp += MARK_BEGIN_LEN;\n\tencoded_len -= MARK_BEGIN_LEN;\n\n\t/* Look for end marker, removing whitespace as we go */\n\twhile (encoded_len > 0) {\n\t\tif (*cp != '\\n' && *cp != '\\r') {\n\t\t\tif ((r = sshbuf_put_u8(encoded, *cp)) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tlast = *cp;\n\t\tencoded_len--;\n\t\tcp++;\n\t\tif (last == '\\n') {\n\t\t\tif (encoded_len >= MARK_END_LEN &&\n\t\t\t    memcmp(cp, MARK_END, MARK_END_LEN) == 0) {\n\t\t\t\t/* \\0 terminate */\n\t\t\t\tif ((r = sshbuf_put_u8(encoded, 0)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (encoded_len == 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* decode base64 */\n\tif ((r = sshbuf_b64tod(decoded, (char *)sshbuf_ptr(encoded))) != 0)\n\t\tgoto out;\n\n\t/* check magic */\n\tif (sshbuf_len(decoded) < sizeof(AUTH_MAGIC) ||\n\t    memcmp(sshbuf_ptr(decoded), AUTH_MAGIC, sizeof(AUTH_MAGIC))) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* parse public portion of key */\n\tif ((r = sshbuf_consume(decoded, sizeof(AUTH_MAGIC))) != 0 ||\n\t    (r = sshbuf_get_cstring(decoded, &ciphername, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(decoded, &kdfname, NULL)) != 0 ||\n\t    (r = sshbuf_froms(decoded, &kdf)) != 0 ||\n\t    (r = sshbuf_get_u32(decoded, &nkeys)) != 0 ||\n\t    (r = sshbuf_skip_string(decoded)) != 0 || /* pubkey */\n\t    (r = sshbuf_get_u32(decoded, &encrypted_len)) != 0)\n\t\tgoto out;\n\n\tif ((cipher = cipher_by_name(ciphername)) == NULL) {\n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif ((passphrase == NULL || strlen(passphrase) == 0) &&\n\t    strcmp(ciphername, \"none\") != 0) {\n\t\t/* passphrase required */\n\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"none\") != 0 && strcmp(kdfname, \"bcrypt\") != 0) {\n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif (!strcmp(kdfname, \"none\") && strcmp(ciphername, \"none\") != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (nkeys != 1) {\n\t\t/* XXX only one key supported */\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* check size of encrypted key blob */\n\tblocksize = cipher_blocksize(cipher);\n\tif (encrypted_len < blocksize || (encrypted_len % blocksize) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* setup key */\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif ((key = calloc(1, keylen + ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"bcrypt\") == 0) {\n\t\tif ((r = sshbuf_get_string(kdf, &salt, &slen)) != 0 ||\n\t\t    (r = sshbuf_get_u32(kdf, &rounds)) != 0)\n\t\t\tgoto out;\n\t\tif (bcrypt_pbkdf(passphrase, strlen(passphrase), salt, slen,\n\t\t    key, keylen + ivlen, rounds) < 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* check that an appropriate amount of auth data is present */\n\tif (sshbuf_len(decoded) < encrypted_len + authlen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* decrypt private portion of key */\n\tif ((r = sshbuf_reserve(decrypted, encrypted_len, &dp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    key + keylen, ivlen, 0)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(ciphercontext, 0, dp, sshbuf_ptr(decoded),\n\t    encrypted_len, 0, authlen)) != 0) {\n\t\t/* an integrity error here indicates an incorrect passphrase */\n\t\tif (r == SSH_ERR_MAC_INVALID)\n\t\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(decoded, encrypted_len + authlen)) != 0)\n\t\tgoto out;\n\t/* there should be no trailing data */\n\tif (sshbuf_len(decoded) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* check check bytes */\n\tif ((r = sshbuf_get_u32(decrypted, &check1)) != 0 ||\n\t    (r = sshbuf_get_u32(decrypted, &check2)) != 0)\n\t\tgoto out;\n\tif (check1 != check2) {\n\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\n\t/* Load the private key and comment */\n\tif ((r = sshkey_private_deserialize(decrypted, &k)) != 0 ||\n\t    (r = sshbuf_get_cstring(decrypted, &comment, NULL)) != 0)\n\t\tgoto out;\n\n\t/* Check deterministic padding */\n\ti = 0;\n\twhile (sshbuf_len(decrypted)) {\n\t\tif ((r = sshbuf_get_u8(decrypted, &pad)) != 0)\n\t\t\tgoto out;\n\t\tif (pad != (++i & 0xff)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* XXX decode pubkey and check against private */\n\n\t/* success */\n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = k;\n\t\tk = NULL;\n\t}\n\tif (commentp != NULL) {\n\t\t*commentp = comment;\n\t\tcomment = NULL;\n\t}\n out:\n\tpad = 0;\n\tcipher_free(ciphercontext);\n\tfree(ciphername);\n\tfree(kdfname);\n\tfree(comment);\n\tif (salt != NULL) {\n\t\texplicit_bzero(salt, slen);\n\t\tfree(salt);\n\t}\n\tif (key != NULL) {\n\t\texplicit_bzero(key, keylen + ivlen);\n\t\tfree(key);\n\t}\n\tsshbuf_free(encoded);\n\tsshbuf_free(decoded);\n\tsshbuf_free(kdf);\n\tsshbuf_free(decrypted);\n\tsshkey_free(k);\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_private_to_blob2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "3395-3541",
    "snippet": "static int\nsshkey_private_to_blob2(const struct sshkey *prv, struct sshbuf *blob,\n    const char *passphrase, const char *comment, const char *ciphername,\n    int rounds)\n{\n\tu_char *cp, *key = NULL, *pubkeyblob = NULL;\n\tu_char salt[SALT_LEN];\n\tchar *b64 = NULL;\n\tsize_t i, pubkeylen, keylen, ivlen, blocksize, authlen;\n\tu_int check;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher;\n\tconst char *kdfname = KDFNAME;\n\tstruct sshbuf *encoded = NULL, *encrypted = NULL, *kdf = NULL;\n\n\tif (rounds <= 0)\n\t\trounds = DEFAULT_ROUNDS;\n\tif (passphrase == NULL || !strlen(passphrase)) {\n\t\tciphername = \"none\";\n\t\tkdfname = \"none\";\n\t} else if (ciphername == NULL)\n\t\tciphername = DEFAULT_CIPHERNAME;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tif ((kdf = sshbuf_new()) == NULL ||\n\t    (encoded = sshbuf_new()) == NULL ||\n\t    (encrypted = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif ((key = calloc(1, keylen + ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"bcrypt\") == 0) {\n\t\tarc4random_buf(salt, SALT_LEN);\n\t\tif (bcrypt_pbkdf(passphrase, strlen(passphrase),\n\t\t    salt, SALT_LEN, key, keylen + ivlen, rounds) < 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_string(kdf, salt, SALT_LEN)) != 0 ||\n\t\t    (r = sshbuf_put_u32(kdf, rounds)) != 0)\n\t\t\tgoto out;\n\t} else if (strcmp(kdfname, \"none\") != 0) {\n\t\t/* Unsupported KDF type */\n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif ((r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    key + keylen, ivlen, 1)) != 0)\n\t\tgoto out;\n\n\tif ((r = sshbuf_put(encoded, AUTH_MAGIC, sizeof(AUTH_MAGIC))) != 0 ||\n\t    (r = sshbuf_put_cstring(encoded, ciphername)) != 0 ||\n\t    (r = sshbuf_put_cstring(encoded, kdfname)) != 0 ||\n\t    (r = sshbuf_put_stringb(encoded, kdf)) != 0 ||\n\t    (r = sshbuf_put_u32(encoded, 1)) != 0 ||\t/* number of keys */\n\t    (r = sshkey_to_blob(prv, &pubkeyblob, &pubkeylen)) != 0 ||\n\t    (r = sshbuf_put_string(encoded, pubkeyblob, pubkeylen)) != 0)\n\t\tgoto out;\n\n\t/* set up the buffer that will be encrypted */\n\n\t/* Random check bytes */\n\tcheck = arc4random();\n\tif ((r = sshbuf_put_u32(encrypted, check)) != 0 ||\n\t    (r = sshbuf_put_u32(encrypted, check)) != 0)\n\t\tgoto out;\n\n\t/* append private key and comment*/\n\tif ((r = sshkey_private_serialize_opt(prv, encrypted,\n\t     SSHKEY_SERIALIZE_FULL)) != 0 ||\n\t    (r = sshbuf_put_cstring(encrypted, comment)) != 0)\n\t\tgoto out;\n\n\t/* padding */\n\ti = 0;\n\twhile (sshbuf_len(encrypted) % blocksize) {\n\t\tif ((r = sshbuf_put_u8(encrypted, ++i & 0xff)) != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* length in destination buffer */\n\tif ((r = sshbuf_put_u32(encoded, sshbuf_len(encrypted))) != 0)\n\t\tgoto out;\n\n\t/* encrypt */\n\tif ((r = sshbuf_reserve(encoded,\n\t    sshbuf_len(encrypted) + authlen, &cp)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(ciphercontext, 0, cp,\n\t    sshbuf_ptr(encrypted), sshbuf_len(encrypted), 0, authlen)) != 0)\n\t\tgoto out;\n\n\t/* uuencode */\n\tif ((b64 = sshbuf_dtob64(encoded)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tsshbuf_reset(blob);\n\tif ((r = sshbuf_put(blob, MARK_BEGIN, MARK_BEGIN_LEN)) != 0)\n\t\tgoto out;\n\tfor (i = 0; i < strlen(b64); i++) {\n\t\tif ((r = sshbuf_put_u8(blob, b64[i])) != 0)\n\t\t\tgoto out;\n\t\t/* insert line breaks */\n\t\tif (i % 70 == 69 && (r = sshbuf_put_u8(blob, '\\n')) != 0)\n\t\t\tgoto out;\n\t}\n\tif (i % 70 != 69 && (r = sshbuf_put_u8(blob, '\\n')) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_put(blob, MARK_END, MARK_END_LEN)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n\n out:\n\tsshbuf_free(kdf);\n\tsshbuf_free(encoded);\n\tsshbuf_free(encrypted);\n\tcipher_free(ciphercontext);\n\texplicit_bzero(salt, sizeof(salt));\n\tif (key != NULL) {\n\t\texplicit_bzero(key, keylen + ivlen);\n\t\tfree(key);\n\t}\n\tif (pubkeyblob != NULL) {\n\t\texplicit_bzero(pubkeyblob, pubkeylen);\n\t\tfree(pubkeyblob);\n\t}\n\tif (b64 != NULL) {\n\t\texplicit_bzero(b64, strlen(b64));\n\t\tfree(b64);\n\t}\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tDEFAULT_ROUNDS\t\t16",
      "#define DEFAULT_CIPHERNAME\t\"aes256-ctr\"",
      "#define SALT_LEN\t\t16",
      "#define AUTH_MAGIC\t\t\"openssh-key-v1\"",
      "#define KDFNAME\t\t\t\"bcrypt\"",
      "#define MARK_END_LEN\t\t(sizeof(MARK_END) - 1)",
      "#define MARK_BEGIN_LEN\t\t(sizeof(MARK_BEGIN) - 1)",
      "#define MARK_END\t\t\"-----END OPENSSH PRIVATE KEY-----\\n\"",
      "#define MARK_BEGIN\t\t\"-----BEGIN OPENSSH PRIVATE KEY-----\\n\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "b64"
          ],
          "line": 3538
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "b64",
            "strlen(b64)"
          ],
          "line": 3537
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "b64"
          ],
          "line": 3537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher_free",
          "args": [
            "ciphercontext"
          ],
          "line": 3526
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "410-425",
          "snippet": "void\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nvoid\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "encrypted"
          ],
          "line": 3525
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "blob",
            "MARK_END",
            "MARK_END_LEN"
          ],
          "line": 3516
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "blob",
            "'\\n'"
          ],
          "line": 3514
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "b64"
          ],
          "line": 3507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "blob"
          ],
          "line": 3504
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_dtob64",
          "args": [
            "encoded"
          ],
          "line": 3499
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_dtob64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "92-111",
          "snippet": "char *\nsshbuf_dtob64(struct sshbuf *buf)\n{\n\tsize_t len = sshbuf_len(buf), plen;\n\tconst u_char *p = sshbuf_ptr(buf);\n\tchar *ret;\n\tint r;\n\n\tif (len == 0)\n\t\treturn strdup(\"\");\n\tplen = ((len + 2) / 3) * 4 + 1;\n\tif (SIZE_MAX / 2 <= len || (ret = malloc(plen)) == NULL)\n\t\treturn NULL;\n\tif ((r = b64_ntop(p, len, ret, plen)) == -1) {\n\t\texplicit_bzero(ret, plen);\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshbuf_dtob64(struct sshbuf *buf)\n{\n\tsize_t len = sshbuf_len(buf), plen;\n\tconst u_char *p = sshbuf_ptr(buf);\n\tchar *ret;\n\tint r;\n\n\tif (len == 0)\n\t\treturn strdup(\"\");\n\tplen = ((len + 2) / 3) * 4 + 1;\n\tif (SIZE_MAX / 2 <= len || (ret = malloc(plen)) == NULL)\n\t\treturn NULL;\n\tif ((r = b64_ntop(p, len, ret, plen)) == -1) {\n\t\texplicit_bzero(ret, plen);\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_crypt",
          "args": [
            "ciphercontext",
            "0",
            "cp",
            "sshbuf_ptr(encrypted)",
            "sshbuf_len(encrypted)",
            "0",
            "authlen"
          ],
          "line": 3494
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_crypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "334-394",
          "snippet": "int\ncipher_crypt(struct sshcipher_ctx *cc, u_int seqnr, u_char *dest,\n   const u_char *src, u_int len, u_int aadlen, u_int authlen)\n{\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\treturn chachapoly_crypt(&cc->cp_ctx, seqnr, dest, src,\n\t\t    len, aadlen, authlen, cc->encrypt);\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tmemcpy(dest, src, aadlen + len);\n\t\treturn 0;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\tif (aadlen)\n\t\t\tmemcpy(dest, src, aadlen);\n\t\taesctr_encrypt_bytes(&cc->ac_ctx, src + aadlen,\n\t\t    dest + aadlen, len);\n\t\treturn 0;\n\t}\n\treturn SSH_ERR_INVALID_ARGUMENT;\n#else\n\tif (authlen) {\n\t\tu_char lastiv[1];\n\n\t\tif (authlen != cipher_authlen(cc->cipher))\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t/* increment IV */\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,\n\t\t    1, lastiv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t/* set tag on decyption */\n\t\tif (!cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_TAG,\n\t\t    authlen, (u_char *)src + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\tif (aadlen) {\n\t\tif (authlen &&\n\t\t    EVP_Cipher(cc->evp, NULL, (u_char *)src, aadlen) < 0)\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\tmemcpy(dest, src, aadlen);\n\t}\n\tif (len % cc->cipher->block_size)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (EVP_Cipher(cc->evp, dest + aadlen, (u_char *)src + aadlen,\n\t    len) < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif (authlen) {\n\t\t/* compute tag (on encrypt) or verify tag (on decrypt) */\n\t\tif (EVP_Cipher(cc->evp, NULL, NULL, 0) < 0)\n\t\t\treturn cc->encrypt ?\n\t\t\t    SSH_ERR_LIBCRYPTO_ERROR : SSH_ERR_MAC_INVALID;\n\t\tif (cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_GET_TAG,\n\t\t    authlen, dest + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_NONE\t\t(1<<3)",
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_NONE\t\t(1<<3)\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nint\ncipher_crypt(struct sshcipher_ctx *cc, u_int seqnr, u_char *dest,\n   const u_char *src, u_int len, u_int aadlen, u_int authlen)\n{\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\treturn chachapoly_crypt(&cc->cp_ctx, seqnr, dest, src,\n\t\t    len, aadlen, authlen, cc->encrypt);\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tmemcpy(dest, src, aadlen + len);\n\t\treturn 0;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\tif (aadlen)\n\t\t\tmemcpy(dest, src, aadlen);\n\t\taesctr_encrypt_bytes(&cc->ac_ctx, src + aadlen,\n\t\t    dest + aadlen, len);\n\t\treturn 0;\n\t}\n\treturn SSH_ERR_INVALID_ARGUMENT;\n#else\n\tif (authlen) {\n\t\tu_char lastiv[1];\n\n\t\tif (authlen != cipher_authlen(cc->cipher))\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t/* increment IV */\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,\n\t\t    1, lastiv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t/* set tag on decyption */\n\t\tif (!cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_TAG,\n\t\t    authlen, (u_char *)src + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\tif (aadlen) {\n\t\tif (authlen &&\n\t\t    EVP_Cipher(cc->evp, NULL, (u_char *)src, aadlen) < 0)\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\tmemcpy(dest, src, aadlen);\n\t}\n\tif (len % cc->cipher->block_size)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (EVP_Cipher(cc->evp, dest + aadlen, (u_char *)src + aadlen,\n\t    len) < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif (authlen) {\n\t\t/* compute tag (on encrypt) or verify tag (on decrypt) */\n\t\tif (EVP_Cipher(cc->evp, NULL, NULL, 0) < 0)\n\t\t\treturn cc->encrypt ?\n\t\t\t    SSH_ERR_LIBCRYPTO_ERROR : SSH_ERR_MAC_INVALID;\n\t\tif (cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_GET_TAG,\n\t\t    authlen, dest + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "encrypted"
          ],
          "line": 3495
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "encrypted"
          ],
          "line": 3495
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reserve",
          "args": [
            "encoded",
            "sshbuf_len(encrypted) + authlen",
            "&cp"
          ],
          "line": 3491
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "343-361",
          "snippet": "int\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "encoded",
            "sshbuf_len(encrypted)"
          ],
          "line": 3487
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "encrypted",
            "comment"
          ],
          "line": 3476
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_private_serialize_opt",
          "args": [
            "prv",
            "encrypted",
            "SSHKEY_SERIALIZE_FULL"
          ],
          "line": 3474
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_private_serialize_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2767-2906",
          "snippet": "int\nsshkey_private_serialize_opt(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *rsa_d, *rsa_iqmp, *rsa_p, *rsa_q;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key, *dsa_priv_key;\n#endif /* WITH_OPENSSL */\n\n\tif ((r = sshbuf_put_cstring(b, sshkey_ssh_name(key))) != 0)\n\t\tgoto out;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_bignum2(b, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tDSA_get0_key(key->dsa, NULL, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((r = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (r = sshbuf_put_eckey(b, key->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0 ||\n\t\t    key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nint\nsshkey_private_serialize_opt(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *rsa_d, *rsa_iqmp, *rsa_p, *rsa_q;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key, *dsa_priv_key;\n#endif /* WITH_OPENSSL */\n\n\tif ((r = sshbuf_put_cstring(b, sshkey_ssh_name(key))) != 0)\n\t\tgoto out;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_bignum2(b, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tDSA_get0_key(key->dsa, NULL, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((r = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (r = sshbuf_put_eckey(b, key->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0 ||\n\t\t    key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4random",
          "args": [],
          "line": 3468
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "235-244",
          "snippet": "u_int32_t\narc4random(void)\n{\n\tu_int32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\narc4random(void)\n{\n\tu_int32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "encoded",
            "pubkeyblob",
            "pubkeylen"
          ],
          "line": 3462
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_to_blob",
          "args": [
            "prv",
            "&pubkeyblob",
            "&pubkeylen"
          ],
          "line": 3461
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "880-884",
          "snippet": "int\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "encoded",
            "kdf"
          ],
          "line": 3459
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_init",
          "args": [
            "&ciphercontext",
            "cipher",
            "key",
            "keylen",
            "key + keylen",
            "ivlen",
            "1"
          ],
          "line": 3452
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "235-322",
          "snippet": "int\ncipher_init(struct sshcipher_ctx **ccp, const struct sshcipher *cipher,\n    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,\n    int do_encrypt)\n{\n\tstruct sshcipher_ctx *cc = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst EVP_CIPHER *type;\n\tint klen;\n#endif\n\n\t*ccp = NULL;\n\tif ((cc = calloc(sizeof(*cc), 1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tcc->plaintext = (cipher->flags & CFLAG_NONE) != 0;\n\tcc->encrypt = do_encrypt;\n\n\tif (keylen < cipher->key_len ||\n\t    (iv != NULL && ivlen < cipher_ivlen(cipher))) {\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tcc->cipher = cipher;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tret = chachapoly_init(&cc->cp_ctx, key, keylen);\n\t\tgoto out;\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\taesctr_keysetup(&cc->ac_ctx, key, 8 * keylen, 8 * ivlen);\n\t\taesctr_ivsetup(&cc->ac_ctx, iv);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tret = SSH_ERR_INVALID_ARGUMENT;\n\tgoto out;\n#else /* WITH_OPENSSL */\n\ttype = (*cipher->evptype)();\n\tif ((cc->evp = EVP_CIPHER_CTX_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EVP_CipherInit(cc->evp, type, NULL, (u_char *)iv,\n\t    (do_encrypt == CIPHER_ENCRYPT)) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (cipher_authlen(cipher) &&\n\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,\n\t    -1, (u_char *)iv)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tklen = EVP_CIPHER_CTX_key_length(cc->evp);\n\tif (klen > 0 && keylen != (u_int)klen) {\n\t\tif (EVP_CIPHER_CTX_set_key_length(cc->evp, keylen) == 0) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tret = 0;\n#endif /* WITH_OPENSSL */\n out:\n\tif (ret == 0) {\n\t\t/* success */\n\t\t*ccp = cc;\n\t} else {\n\t\tif (cc != NULL) {\n#ifdef WITH_OPENSSL\n\t\t\tEVP_CIPHER_CTX_free(cc->evp);\n#endif /* WITH_OPENSSL */\n\t\t\texplicit_bzero(cc, sizeof(*cc));\n\t\t\tfree(cc);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_NONE\t\t(1<<3)",
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_NONE\t\t(1<<3)\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nint\ncipher_init(struct sshcipher_ctx **ccp, const struct sshcipher *cipher,\n    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,\n    int do_encrypt)\n{\n\tstruct sshcipher_ctx *cc = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst EVP_CIPHER *type;\n\tint klen;\n#endif\n\n\t*ccp = NULL;\n\tif ((cc = calloc(sizeof(*cc), 1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tcc->plaintext = (cipher->flags & CFLAG_NONE) != 0;\n\tcc->encrypt = do_encrypt;\n\n\tif (keylen < cipher->key_len ||\n\t    (iv != NULL && ivlen < cipher_ivlen(cipher))) {\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tcc->cipher = cipher;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tret = chachapoly_init(&cc->cp_ctx, key, keylen);\n\t\tgoto out;\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\taesctr_keysetup(&cc->ac_ctx, key, 8 * keylen, 8 * ivlen);\n\t\taesctr_ivsetup(&cc->ac_ctx, iv);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tret = SSH_ERR_INVALID_ARGUMENT;\n\tgoto out;\n#else /* WITH_OPENSSL */\n\ttype = (*cipher->evptype)();\n\tif ((cc->evp = EVP_CIPHER_CTX_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EVP_CipherInit(cc->evp, type, NULL, (u_char *)iv,\n\t    (do_encrypt == CIPHER_ENCRYPT)) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (cipher_authlen(cipher) &&\n\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,\n\t    -1, (u_char *)iv)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tklen = EVP_CIPHER_CTX_key_length(cc->evp);\n\tif (klen > 0 && keylen != (u_int)klen) {\n\t\tif (EVP_CIPHER_CTX_set_key_length(cc->evp, keylen) == 0) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tret = 0;\n#endif /* WITH_OPENSSL */\n out:\n\tif (ret == 0) {\n\t\t/* success */\n\t\t*ccp = cc;\n\t} else {\n\t\tif (cc != NULL) {\n#ifdef WITH_OPENSSL\n\t\t\tEVP_CIPHER_CTX_free(cc->evp);\n#endif /* WITH_OPENSSL */\n\t\t\texplicit_bzero(cc, sizeof(*cc));\n\t\t\tfree(cc);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kdfname",
            "\"none\""
          ],
          "line": 3447
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcrypt_pbkdf",
          "args": [
            "passphrase",
            "strlen(passphrase)",
            "salt",
            "SALT_LEN",
            "key",
            "keylen + ivlen",
            "rounds"
          ],
          "line": 3439
        },
        "resolved": true,
        "details": {
          "function_name": "bcrypt_pbkdf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bcrypt_pbkdf.c",
          "lines": "110-178",
          "snippet": "int\nbcrypt_pbkdf(const char *pass, size_t passlen, const u_int8_t *salt, size_t saltlen,\n    u_int8_t *key, size_t keylen, unsigned int rounds)\n{\n\tu_int8_t sha2pass[SHA512_DIGEST_LENGTH];\n\tu_int8_t sha2salt[SHA512_DIGEST_LENGTH];\n\tu_int8_t out[BCRYPT_HASHSIZE];\n\tu_int8_t tmpout[BCRYPT_HASHSIZE];\n\tu_int8_t *countsalt;\n\tsize_t i, j, amt, stride;\n\tuint32_t count;\n\tsize_t origkeylen = keylen;\n\n\t/* nothing crazy */\n\tif (rounds < 1)\n\t\treturn -1;\n\tif (passlen == 0 || saltlen == 0 || keylen == 0 ||\n\t    keylen > sizeof(out) * sizeof(out) || saltlen > 1<<20)\n\t\treturn -1;\n\tif ((countsalt = calloc(1, saltlen + 4)) == NULL)\n\t\treturn -1;\n\tstride = (keylen + sizeof(out) - 1) / sizeof(out);\n\tamt = (keylen + stride - 1) / stride;\n\n\tmemcpy(countsalt, salt, saltlen);\n\n\t/* collapse password */\n\tcrypto_hash_sha512(sha2pass, pass, passlen);\n\n\t/* generate key, sizeof(out) at a time */\n\tfor (count = 1; keylen > 0; count++) {\n\t\tcountsalt[saltlen + 0] = (count >> 24) & 0xff;\n\t\tcountsalt[saltlen + 1] = (count >> 16) & 0xff;\n\t\tcountsalt[saltlen + 2] = (count >> 8) & 0xff;\n\t\tcountsalt[saltlen + 3] = count & 0xff;\n\n\t\t/* first round, salt is salt */\n\t\tcrypto_hash_sha512(sha2salt, countsalt, saltlen + 4);\n\n\t\tbcrypt_hash(sha2pass, sha2salt, tmpout);\n\t\tmemcpy(out, tmpout, sizeof(out));\n\n\t\tfor (i = 1; i < rounds; i++) {\n\t\t\t/* subsequent rounds, salt is previous output */\n\t\t\tcrypto_hash_sha512(sha2salt, tmpout, sizeof(tmpout));\n\t\t\tbcrypt_hash(sha2pass, sha2salt, tmpout);\n\t\t\tfor (j = 0; j < sizeof(out); j++)\n\t\t\t\tout[j] ^= tmpout[j];\n\t\t}\n\n\t\t/*\n\t\t * pbkdf2 deviation: output the key material non-linearly.\n\t\t */\n\t\tamt = MINIMUM(amt, keylen);\n\t\tfor (i = 0; i < amt; i++) {\n\t\t\tsize_t dest = i * stride + (count - 1);\n\t\t\tif (dest >= origkeylen)\n\t\t\t\tbreak;\n\t\t\tkey[dest] = out[i];\n\t\t}\n\t\tkeylen -= i;\n\t}\n\n\t/* zap */\n\texplicit_bzero(out, sizeof(out));\n\tfree(countsalt);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"crypto_api.h\"",
            "# include <blf.h>",
            "#include <string.h>",
            "# include <stdlib.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define BCRYPT_HASHSIZE (BCRYPT_WORDS * 4)",
            "#define SHA512_DIGEST_LENGTH crypto_hash_sha512_BYTES"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"crypto_api.h\"\n# include <blf.h>\n#include <string.h>\n# include <stdlib.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BCRYPT_HASHSIZE (BCRYPT_WORDS * 4)\n#define SHA512_DIGEST_LENGTH crypto_hash_sha512_BYTES\n\nint\nbcrypt_pbkdf(const char *pass, size_t passlen, const u_int8_t *salt, size_t saltlen,\n    u_int8_t *key, size_t keylen, unsigned int rounds)\n{\n\tu_int8_t sha2pass[SHA512_DIGEST_LENGTH];\n\tu_int8_t sha2salt[SHA512_DIGEST_LENGTH];\n\tu_int8_t out[BCRYPT_HASHSIZE];\n\tu_int8_t tmpout[BCRYPT_HASHSIZE];\n\tu_int8_t *countsalt;\n\tsize_t i, j, amt, stride;\n\tuint32_t count;\n\tsize_t origkeylen = keylen;\n\n\t/* nothing crazy */\n\tif (rounds < 1)\n\t\treturn -1;\n\tif (passlen == 0 || saltlen == 0 || keylen == 0 ||\n\t    keylen > sizeof(out) * sizeof(out) || saltlen > 1<<20)\n\t\treturn -1;\n\tif ((countsalt = calloc(1, saltlen + 4)) == NULL)\n\t\treturn -1;\n\tstride = (keylen + sizeof(out) - 1) / sizeof(out);\n\tamt = (keylen + stride - 1) / stride;\n\n\tmemcpy(countsalt, salt, saltlen);\n\n\t/* collapse password */\n\tcrypto_hash_sha512(sha2pass, pass, passlen);\n\n\t/* generate key, sizeof(out) at a time */\n\tfor (count = 1; keylen > 0; count++) {\n\t\tcountsalt[saltlen + 0] = (count >> 24) & 0xff;\n\t\tcountsalt[saltlen + 1] = (count >> 16) & 0xff;\n\t\tcountsalt[saltlen + 2] = (count >> 8) & 0xff;\n\t\tcountsalt[saltlen + 3] = count & 0xff;\n\n\t\t/* first round, salt is salt */\n\t\tcrypto_hash_sha512(sha2salt, countsalt, saltlen + 4);\n\n\t\tbcrypt_hash(sha2pass, sha2salt, tmpout);\n\t\tmemcpy(out, tmpout, sizeof(out));\n\n\t\tfor (i = 1; i < rounds; i++) {\n\t\t\t/* subsequent rounds, salt is previous output */\n\t\t\tcrypto_hash_sha512(sha2salt, tmpout, sizeof(tmpout));\n\t\t\tbcrypt_hash(sha2pass, sha2salt, tmpout);\n\t\t\tfor (j = 0; j < sizeof(out); j++)\n\t\t\t\tout[j] ^= tmpout[j];\n\t\t}\n\n\t\t/*\n\t\t * pbkdf2 deviation: output the key material non-linearly.\n\t\t */\n\t\tamt = MINIMUM(amt, keylen);\n\t\tfor (i = 0; i < amt; i++) {\n\t\t\tsize_t dest = i * stride + (count - 1);\n\t\t\tif (dest >= origkeylen)\n\t\t\t\tbreak;\n\t\t\tkey[dest] = out[i];\n\t\t}\n\t\tkeylen -= i;\n\t}\n\n\t/* zap */\n\texplicit_bzero(out, sizeof(out));\n\tfree(countsalt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase"
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arc4random_buf",
          "args": [
            "salt",
            "SALT_LEN"
          ],
          "line": 3438
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "263-277",
          "snippet": "void\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "keylen + ivlen"
          ],
          "line": 3433
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_authlen",
          "args": [
            "cipher"
          ],
          "line": 3432
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_authlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "163-167",
          "snippet": "u_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_ivlen",
          "args": [
            "cipher"
          ],
          "line": 3431
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_ivlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "169-178",
          "snippet": "u_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t/*\n\t * Default is cipher block size, except for chacha20+poly1305 that\n\t * needs no IV. XXX make iv_len == -1 default?\n\t */\n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nu_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t/*\n\t * Default is cipher block size, except for chacha20+poly1305 that\n\t * needs no IV. XXX make iv_len == -1 default?\n\t */\n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_keylen",
          "args": [
            "cipher"
          ],
          "line": 3430
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_keylen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "149-153",
          "snippet": "u_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_blocksize",
          "args": [
            "cipher"
          ],
          "line": 3429
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "143-147",
          "snippet": "u_int\ncipher_blocksize(const struct sshcipher *c)\n{\n\treturn (c->block_size);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_blocksize(const struct sshcipher *c)\n{\n\treturn (c->block_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 3425
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_by_name",
          "args": [
            "ciphername"
          ],
          "line": 3418
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "192-200",
          "snippet": "const struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};\n\nconst struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase"
          ],
          "line": 3413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tDEFAULT_ROUNDS\t\t16\n#define DEFAULT_CIPHERNAME\t\"aes256-ctr\"\n#define SALT_LEN\t\t16\n#define AUTH_MAGIC\t\t\"openssh-key-v1\"\n#define KDFNAME\t\t\t\"bcrypt\"\n#define MARK_END_LEN\t\t(sizeof(MARK_END) - 1)\n#define MARK_BEGIN_LEN\t\t(sizeof(MARK_BEGIN) - 1)\n#define MARK_END\t\t\"-----END OPENSSH PRIVATE KEY-----\\n\"\n#define MARK_BEGIN\t\t\"-----BEGIN OPENSSH PRIVATE KEY-----\\n\"\n\nstatic int\nsshkey_private_to_blob2(const struct sshkey *prv, struct sshbuf *blob,\n    const char *passphrase, const char *comment, const char *ciphername,\n    int rounds)\n{\n\tu_char *cp, *key = NULL, *pubkeyblob = NULL;\n\tu_char salt[SALT_LEN];\n\tchar *b64 = NULL;\n\tsize_t i, pubkeylen, keylen, ivlen, blocksize, authlen;\n\tu_int check;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher;\n\tconst char *kdfname = KDFNAME;\n\tstruct sshbuf *encoded = NULL, *encrypted = NULL, *kdf = NULL;\n\n\tif (rounds <= 0)\n\t\trounds = DEFAULT_ROUNDS;\n\tif (passphrase == NULL || !strlen(passphrase)) {\n\t\tciphername = \"none\";\n\t\tkdfname = \"none\";\n\t} else if (ciphername == NULL)\n\t\tciphername = DEFAULT_CIPHERNAME;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tif ((kdf = sshbuf_new()) == NULL ||\n\t    (encoded = sshbuf_new()) == NULL ||\n\t    (encrypted = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif ((key = calloc(1, keylen + ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"bcrypt\") == 0) {\n\t\tarc4random_buf(salt, SALT_LEN);\n\t\tif (bcrypt_pbkdf(passphrase, strlen(passphrase),\n\t\t    salt, SALT_LEN, key, keylen + ivlen, rounds) < 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_string(kdf, salt, SALT_LEN)) != 0 ||\n\t\t    (r = sshbuf_put_u32(kdf, rounds)) != 0)\n\t\t\tgoto out;\n\t} else if (strcmp(kdfname, \"none\") != 0) {\n\t\t/* Unsupported KDF type */\n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif ((r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    key + keylen, ivlen, 1)) != 0)\n\t\tgoto out;\n\n\tif ((r = sshbuf_put(encoded, AUTH_MAGIC, sizeof(AUTH_MAGIC))) != 0 ||\n\t    (r = sshbuf_put_cstring(encoded, ciphername)) != 0 ||\n\t    (r = sshbuf_put_cstring(encoded, kdfname)) != 0 ||\n\t    (r = sshbuf_put_stringb(encoded, kdf)) != 0 ||\n\t    (r = sshbuf_put_u32(encoded, 1)) != 0 ||\t/* number of keys */\n\t    (r = sshkey_to_blob(prv, &pubkeyblob, &pubkeylen)) != 0 ||\n\t    (r = sshbuf_put_string(encoded, pubkeyblob, pubkeylen)) != 0)\n\t\tgoto out;\n\n\t/* set up the buffer that will be encrypted */\n\n\t/* Random check bytes */\n\tcheck = arc4random();\n\tif ((r = sshbuf_put_u32(encrypted, check)) != 0 ||\n\t    (r = sshbuf_put_u32(encrypted, check)) != 0)\n\t\tgoto out;\n\n\t/* append private key and comment*/\n\tif ((r = sshkey_private_serialize_opt(prv, encrypted,\n\t     SSHKEY_SERIALIZE_FULL)) != 0 ||\n\t    (r = sshbuf_put_cstring(encrypted, comment)) != 0)\n\t\tgoto out;\n\n\t/* padding */\n\ti = 0;\n\twhile (sshbuf_len(encrypted) % blocksize) {\n\t\tif ((r = sshbuf_put_u8(encrypted, ++i & 0xff)) != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* length in destination buffer */\n\tif ((r = sshbuf_put_u32(encoded, sshbuf_len(encrypted))) != 0)\n\t\tgoto out;\n\n\t/* encrypt */\n\tif ((r = sshbuf_reserve(encoded,\n\t    sshbuf_len(encrypted) + authlen, &cp)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(ciphercontext, 0, cp,\n\t    sshbuf_ptr(encrypted), sshbuf_len(encrypted), 0, authlen)) != 0)\n\t\tgoto out;\n\n\t/* uuencode */\n\tif ((b64 = sshbuf_dtob64(encoded)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tsshbuf_reset(blob);\n\tif ((r = sshbuf_put(blob, MARK_BEGIN, MARK_BEGIN_LEN)) != 0)\n\t\tgoto out;\n\tfor (i = 0; i < strlen(b64); i++) {\n\t\tif ((r = sshbuf_put_u8(blob, b64[i])) != 0)\n\t\t\tgoto out;\n\t\t/* insert line breaks */\n\t\tif (i % 70 == 69 && (r = sshbuf_put_u8(blob, '\\n')) != 0)\n\t\t\tgoto out;\n\t}\n\tif (i % 70 != 69 && (r = sshbuf_put_u8(blob, '\\n')) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_put(blob, MARK_END, MARK_END_LEN)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n\n out:\n\tsshbuf_free(kdf);\n\tsshbuf_free(encoded);\n\tsshbuf_free(encrypted);\n\tcipher_free(ciphercontext);\n\texplicit_bzero(salt, sizeof(salt));\n\tif (key != NULL) {\n\t\texplicit_bzero(key, keylen + ivlen);\n\t\tfree(key);\n\t}\n\tif (pubkeyblob != NULL) {\n\t\texplicit_bzero(pubkeyblob, pubkeylen);\n\t\tfree(pubkeyblob);\n\t}\n\tif (b64 != NULL) {\n\t\texplicit_bzero(b64, strlen(b64));\n\t\tfree(b64);\n\t}\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_dump_ec_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "3379-3392",
    "snippet": "void\nsshkey_dump_ec_key(const EC_KEY *key)\n{\n\tconst BIGNUM *exponent;\n\n\tsshkey_dump_ec_point(EC_KEY_get0_group(key),\n\t    EC_KEY_get0_public_key(key));\n\tfputs(\"exponent=\", stderr);\n\tif ((exponent = EC_KEY_get0_private_key(key)) == NULL)\n\t\tfputs(\"(NULL)\", stderr);\n\telse\n\t\tBN_print_fp(stderr, EC_KEY_get0_private_key(key));\n\tfputs(\"\\n\", stderr);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "\"\\n\"",
            "stderr"
          ],
          "line": 3391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_print_fp",
          "args": [
            "stderr",
            "EC_KEY_get0_private_key(key)"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_private_key",
          "args": [
            "key"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "\"(NULL)\"",
            "stderr"
          ],
          "line": 3388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_private_key",
          "args": [
            "key"
          ],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "\"exponent=\"",
            "stderr"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_dump_ec_point",
          "args": [
            "EC_KEY_get0_group(key)",
            "EC_KEY_get0_public_key(key)"
          ],
          "line": 3384
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_dump_ec_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3340-3377",
          "snippet": "void\nsshkey_dump_ec_point(const EC_GROUP *group, const EC_POINT *point)\n{\n\tBIGNUM *x, *y;\n\tBN_CTX *bnctx;\n\n\tif (point == NULL) {\n\t\tfputs(\"point=(NULL)\\n\", stderr);\n\t\treturn;\n\t}\n\tif ((bnctx = BN_CTX_new()) == NULL) {\n\t\tfprintf(stderr, \"%s: BN_CTX_new failed\\n\", __func__);\n\t\treturn;\n\t}\n\tBN_CTX_start(bnctx);\n\tif ((x = BN_CTX_get(bnctx)) == NULL ||\n\t    (y = BN_CTX_get(bnctx)) == NULL) {\n\t\tfprintf(stderr, \"%s: BN_CTX_get failed\\n\", __func__);\n\t\treturn;\n\t}\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field) {\n\t\tfprintf(stderr, \"%s: group is not a prime field\\n\", __func__);\n\t\treturn;\n\t}\n\tif (EC_POINT_get_affine_coordinates_GFp(group, point, x, y,\n\t    bnctx) != 1) {\n\t\tfprintf(stderr, \"%s: EC_POINT_get_affine_coordinates_GFp\\n\",\n\t\t    __func__);\n\t\treturn;\n\t}\n\tfputs(\"x=\", stderr);\n\tBN_print_fp(stderr, x);\n\tfputs(\"\\ny=\", stderr);\n\tBN_print_fp(stderr, y);\n\tfputs(\"\\n\", stderr);\n\tBN_CTX_free(bnctx);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_dump_ec_point(const EC_GROUP *group, const EC_POINT *point)\n{\n\tBIGNUM *x, *y;\n\tBN_CTX *bnctx;\n\n\tif (point == NULL) {\n\t\tfputs(\"point=(NULL)\\n\", stderr);\n\t\treturn;\n\t}\n\tif ((bnctx = BN_CTX_new()) == NULL) {\n\t\tfprintf(stderr, \"%s: BN_CTX_new failed\\n\", __func__);\n\t\treturn;\n\t}\n\tBN_CTX_start(bnctx);\n\tif ((x = BN_CTX_get(bnctx)) == NULL ||\n\t    (y = BN_CTX_get(bnctx)) == NULL) {\n\t\tfprintf(stderr, \"%s: BN_CTX_get failed\\n\", __func__);\n\t\treturn;\n\t}\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field) {\n\t\tfprintf(stderr, \"%s: group is not a prime field\\n\", __func__);\n\t\treturn;\n\t}\n\tif (EC_POINT_get_affine_coordinates_GFp(group, point, x, y,\n\t    bnctx) != 1) {\n\t\tfprintf(stderr, \"%s: EC_POINT_get_affine_coordinates_GFp\\n\",\n\t\t    __func__);\n\t\treturn;\n\t}\n\tfputs(\"x=\", stderr);\n\tBN_print_fp(stderr, x);\n\tfputs(\"\\ny=\", stderr);\n\tBN_print_fp(stderr, y);\n\tfputs(\"\\n\", stderr);\n\tBN_CTX_free(bnctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_public_key",
          "args": [
            "key"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "key"
          ],
          "line": 3384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_dump_ec_key(const EC_KEY *key)\n{\n\tconst BIGNUM *exponent;\n\n\tsshkey_dump_ec_point(EC_KEY_get0_group(key),\n\t    EC_KEY_get0_public_key(key));\n\tfputs(\"exponent=\", stderr);\n\tif ((exponent = EC_KEY_get0_private_key(key)) == NULL)\n\t\tfputs(\"(NULL)\", stderr);\n\telse\n\t\tBN_print_fp(stderr, EC_KEY_get0_private_key(key));\n\tfputs(\"\\n\", stderr);\n}"
  },
  {
    "function_name": "sshkey_dump_ec_point",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "3340-3377",
    "snippet": "void\nsshkey_dump_ec_point(const EC_GROUP *group, const EC_POINT *point)\n{\n\tBIGNUM *x, *y;\n\tBN_CTX *bnctx;\n\n\tif (point == NULL) {\n\t\tfputs(\"point=(NULL)\\n\", stderr);\n\t\treturn;\n\t}\n\tif ((bnctx = BN_CTX_new()) == NULL) {\n\t\tfprintf(stderr, \"%s: BN_CTX_new failed\\n\", __func__);\n\t\treturn;\n\t}\n\tBN_CTX_start(bnctx);\n\tif ((x = BN_CTX_get(bnctx)) == NULL ||\n\t    (y = BN_CTX_get(bnctx)) == NULL) {\n\t\tfprintf(stderr, \"%s: BN_CTX_get failed\\n\", __func__);\n\t\treturn;\n\t}\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field) {\n\t\tfprintf(stderr, \"%s: group is not a prime field\\n\", __func__);\n\t\treturn;\n\t}\n\tif (EC_POINT_get_affine_coordinates_GFp(group, point, x, y,\n\t    bnctx) != 1) {\n\t\tfprintf(stderr, \"%s: EC_POINT_get_affine_coordinates_GFp\\n\",\n\t\t    __func__);\n\t\treturn;\n\t}\n\tfputs(\"x=\", stderr);\n\tBN_print_fp(stderr, x);\n\tfputs(\"\\ny=\", stderr);\n\tBN_print_fp(stderr, y);\n\tfputs(\"\\n\", stderr);\n\tBN_CTX_free(bnctx);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BN_CTX_free",
          "args": [
            "bnctx"
          ],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "\"\\n\"",
            "stderr"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_print_fp",
          "args": [
            "stderr",
            "y"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "\"\\ny=\"",
            "stderr"
          ],
          "line": 3373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_print_fp",
          "args": [
            "stderr",
            "x"
          ],
          "line": 3372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "\"x=\"",
            "stderr"
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: EC_POINT_get_affine_coordinates_GFp\\n\"",
            "__func__"
          ],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_get_affine_coordinates_GFp",
          "args": [
            "group",
            "point",
            "x",
            "y",
            "bnctx"
          ],
          "line": 3365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: group is not a prime field\\n\"",
            "__func__"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_METHOD_get_field_type",
          "args": [
            "EC_GROUP_method_of(group)"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_GROUP_method_of",
          "args": [
            "group"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: BN_CTX_get failed\\n\"",
            "__func__"
          ],
          "line": 3357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "bnctx"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "bnctx"
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_start",
          "args": [
            "bnctx"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: BN_CTX_new failed\\n\"",
            "__func__"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_new",
          "args": [],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "\"point=(NULL)\\n\"",
            "stderr"
          ],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_dump_ec_point(const EC_GROUP *group, const EC_POINT *point)\n{\n\tBIGNUM *x, *y;\n\tBN_CTX *bnctx;\n\n\tif (point == NULL) {\n\t\tfputs(\"point=(NULL)\\n\", stderr);\n\t\treturn;\n\t}\n\tif ((bnctx = BN_CTX_new()) == NULL) {\n\t\tfprintf(stderr, \"%s: BN_CTX_new failed\\n\", __func__);\n\t\treturn;\n\t}\n\tBN_CTX_start(bnctx);\n\tif ((x = BN_CTX_get(bnctx)) == NULL ||\n\t    (y = BN_CTX_get(bnctx)) == NULL) {\n\t\tfprintf(stderr, \"%s: BN_CTX_get failed\\n\", __func__);\n\t\treturn;\n\t}\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field) {\n\t\tfprintf(stderr, \"%s: group is not a prime field\\n\", __func__);\n\t\treturn;\n\t}\n\tif (EC_POINT_get_affine_coordinates_GFp(group, point, x, y,\n\t    bnctx) != 1) {\n\t\tfprintf(stderr, \"%s: EC_POINT_get_affine_coordinates_GFp\\n\",\n\t\t    __func__);\n\t\treturn;\n\t}\n\tfputs(\"x=\", stderr);\n\tBN_print_fp(stderr, x);\n\tfputs(\"\\ny=\", stderr);\n\tBN_print_fp(stderr, y);\n\tfputs(\"\\n\", stderr);\n\tBN_CTX_free(bnctx);\n}"
  },
  {
    "function_name": "sshkey_ec_validate_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "3301-3338",
    "snippet": "int\nsshkey_ec_validate_private(const EC_KEY *key)\n{\n\tBN_CTX *bnctx;\n\tBIGNUM *order, *tmp;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tBN_CTX_start(bnctx);\n\n\tif ((order = BN_CTX_get(bnctx)) == NULL ||\n\t    (tmp = BN_CTX_get(bnctx)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* log2(private) > log2(order)/2 */\n\tif (EC_GROUP_get_order(EC_KEY_get0_group(key), order, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(EC_KEY_get0_private_key(key)) <=\n\t    BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t/* private < order - 1 */\n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(EC_KEY_get0_private_key(key), tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_CTX_free(bnctx);\n\treturn ret;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BN_CTX_free",
          "args": [
            "bnctx"
          ],
          "line": 3336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_cmp",
          "args": [
            "EC_KEY_get0_private_key(key)",
            "tmp"
          ],
          "line": 3332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_private_key",
          "args": [
            "key"
          ],
          "line": 3332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_sub",
          "args": [
            "tmp",
            "order",
            "BN_value_one()"
          ],
          "line": 3328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_value_one",
          "args": [],
          "line": 3328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_num_bits",
          "args": [
            "order"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_num_bits",
          "args": [
            "EC_KEY_get0_private_key(key)"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_private_key",
          "args": [
            "key"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_GROUP_get_order",
          "args": [
            "EC_KEY_get0_group(key)",
            "order",
            "bnctx"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "key"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "bnctx"
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "bnctx"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_start",
          "args": [
            "bnctx"
          ],
          "line": 3310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_new",
          "args": [],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_ec_validate_private(const EC_KEY *key)\n{\n\tBN_CTX *bnctx;\n\tBIGNUM *order, *tmp;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tBN_CTX_start(bnctx);\n\n\tif ((order = BN_CTX_get(bnctx)) == NULL ||\n\t    (tmp = BN_CTX_get(bnctx)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* log2(private) > log2(order)/2 */\n\tif (EC_GROUP_get_order(EC_KEY_get0_group(key), order, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(EC_KEY_get0_private_key(key)) <=\n\t    BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t/* private < order - 1 */\n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(EC_KEY_get0_private_key(key), tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_CTX_free(bnctx);\n\treturn ret;\n}"
  },
  {
    "function_name": "sshkey_ec_validate_public",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "3224-3299",
    "snippet": "int\nsshkey_ec_validate_public(const EC_GROUP *group, const EC_POINT *public)\n{\n\tBN_CTX *bnctx;\n\tEC_POINT *nq = NULL;\n\tBIGNUM *order, *x, *y, *tmp;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\t/*\n\t * NB. This assumes OpenSSL has already verified that the public\n\t * point lies on the curve. This is done by EC_POINT_oct2point()\n\t * implicitly calling EC_POINT_is_on_curve(). If this code is ever\n\t * reachable with public points not unmarshalled using\n\t * EC_POINT_oct2point then the caller will need to explicitly check.\n\t */\n\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tBN_CTX_start(bnctx);\n\n\t/*\n\t * We shouldn't ever hit this case because bignum_get_ecpoint()\n\t * refuses to load GF2m points.\n\t */\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field)\n\t\tgoto out;\n\n\t/* Q != infinity */\n\tif (EC_POINT_is_at_infinity(group, public))\n\t\tgoto out;\n\n\tif ((x = BN_CTX_get(bnctx)) == NULL ||\n\t    (y = BN_CTX_get(bnctx)) == NULL ||\n\t    (order = BN_CTX_get(bnctx)) == NULL ||\n\t    (tmp = BN_CTX_get(bnctx)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* log2(x) > log2(order)/2, log2(y) > log2(order)/2 */\n\tif (EC_GROUP_get_order(group, order, bnctx) != 1 ||\n\t    EC_POINT_get_affine_coordinates_GFp(group, public,\n\t    x, y, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(x) <= BN_num_bits(order) / 2 ||\n\t    BN_num_bits(y) <= BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t/* nQ == infinity (n == order of subgroup) */\n\tif ((nq = EC_POINT_new(group)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_mul(group, nq, NULL, public, order, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_is_at_infinity(group, nq) != 1)\n\t\tgoto out;\n\n\t/* x < order - 1, y < order - 1 */\n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(x, tmp) >= 0 || BN_cmp(y, tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_CTX_free(bnctx);\n\tEC_POINT_free(nq);\n\treturn ret;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EC_POINT_free",
          "args": [
            "nq"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_free",
          "args": [
            "bnctx"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_cmp",
          "args": [
            "y",
            "tmp"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_cmp",
          "args": [
            "x",
            "tmp"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_sub",
          "args": [
            "tmp",
            "order",
            "BN_value_one()"
          ],
          "line": 3288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_value_one",
          "args": [],
          "line": 3288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_is_at_infinity",
          "args": [
            "group",
            "nq"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_mul",
          "args": [
            "group",
            "nq",
            "NULL",
            "public",
            "order",
            "bnctx"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_new",
          "args": [
            "group"
          ],
          "line": 3276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_num_bits",
          "args": [
            "order"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_num_bits",
          "args": [
            "y"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_num_bits",
          "args": [
            "order"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_num_bits",
          "args": [
            "x"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_get_affine_coordinates_GFp",
          "args": [
            "group",
            "public",
            "x",
            "y",
            "bnctx"
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_GROUP_get_order",
          "args": [
            "group",
            "order",
            "bnctx"
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "bnctx"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "bnctx"
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "bnctx"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "bnctx"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_is_at_infinity",
          "args": [
            "group",
            "public"
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_METHOD_get_field_type",
          "args": [
            "EC_GROUP_method_of(group)"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_GROUP_method_of",
          "args": [
            "group"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_start",
          "args": [
            "bnctx"
          ],
          "line": 3242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_new",
          "args": [],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_ec_validate_public(const EC_GROUP *group, const EC_POINT *public)\n{\n\tBN_CTX *bnctx;\n\tEC_POINT *nq = NULL;\n\tBIGNUM *order, *x, *y, *tmp;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\t/*\n\t * NB. This assumes OpenSSL has already verified that the public\n\t * point lies on the curve. This is done by EC_POINT_oct2point()\n\t * implicitly calling EC_POINT_is_on_curve(). If this code is ever\n\t * reachable with public points not unmarshalled using\n\t * EC_POINT_oct2point then the caller will need to explicitly check.\n\t */\n\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tBN_CTX_start(bnctx);\n\n\t/*\n\t * We shouldn't ever hit this case because bignum_get_ecpoint()\n\t * refuses to load GF2m points.\n\t */\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field)\n\t\tgoto out;\n\n\t/* Q != infinity */\n\tif (EC_POINT_is_at_infinity(group, public))\n\t\tgoto out;\n\n\tif ((x = BN_CTX_get(bnctx)) == NULL ||\n\t    (y = BN_CTX_get(bnctx)) == NULL ||\n\t    (order = BN_CTX_get(bnctx)) == NULL ||\n\t    (tmp = BN_CTX_get(bnctx)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* log2(x) > log2(order)/2, log2(y) > log2(order)/2 */\n\tif (EC_GROUP_get_order(group, order, bnctx) != 1 ||\n\t    EC_POINT_get_affine_coordinates_GFp(group, public,\n\t    x, y, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(x) <= BN_num_bits(order) / 2 ||\n\t    BN_num_bits(y) <= BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t/* nQ == infinity (n == order of subgroup) */\n\tif ((nq = EC_POINT_new(group)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_mul(group, nq, NULL, public, order, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_is_at_infinity(group, nq) != 1)\n\t\tgoto out;\n\n\t/* x < order - 1, y < order - 1 */\n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(x, tmp) >= 0 || BN_cmp(y, tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_CTX_free(bnctx);\n\tEC_POINT_free(nq);\n\treturn ret;\n}"
  },
  {
    "function_name": "sshkey_private_deserialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2915-3221",
    "snippet": "int\nsshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)\n{\n\tchar *tname = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *k = NULL;\n\tsize_t pklen = 0, sklen = 0;\n\tint type, r = SSH_ERR_INTERNAL_ERROR;\n\tu_char *ed25519_pk = NULL, *ed25519_sk = NULL;\n\tu_char *xmss_pk = NULL, *xmss_sk = NULL;\n#ifdef WITH_OPENSSL\n\tBIGNUM *exponent = NULL;\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n\tBIGNUM *rsa_iqmp = NULL, *rsa_p = NULL, *rsa_q = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL;\n\tBIGNUM *dsa_pub_key = NULL, *dsa_priv_key = NULL;\n#endif /* WITH_OPENSSL */\n\n\tif (kp != NULL)\n\t\t*kp = NULL;\n\tif ((r = sshbuf_get_cstring(buf, &tname, NULL)) != 0)\n\t\tgoto out;\n\ttype = sshkey_type_from_name(tname);\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL ||\n\t\t    (dsa_priv_key = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_bignum2(buf, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tif (!DSA_set0_pqg(k->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(k->dsa, dsa_pub_key, dsa_priv_key)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = dsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa_priv_key = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tif (!DSA_set0_key(k->dsa, NULL, dsa_priv_key)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((k->ecdsa_nid = sshkey_ecdsa_nid_from_name(tname)) == -1) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(buf, &curve, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif (k->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tr = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (k->ecdsa  == NULL || (exponent = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_eckey(buf, k->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, exponent)))\n\t\t\tgoto out;\n\t\tif (EC_KEY_set_private_key(k->ecdsa, exponent) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),\n\t\t    EC_KEY_get0_public_key(k->ecdsa))) != 0 ||\n\t\t    (r = sshkey_ec_validate_private(k->ecdsa)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif ((exponent = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, exponent)) != 0)\n\t\t\tgoto out;\n\t\tif (EC_KEY_set_private_key(k->ecdsa, exponent) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),\n\t\t    EC_KEY_get0_public_key(k->ecdsa))) != 0 ||\n\t\t    (r = sshkey_ec_validate_private(k->ecdsa)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_n = BN_new()) == NULL ||\n\t\t    (rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_bignum2(buf, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tif (!RSA_set0_key(k->rsa, rsa_n, rsa_e, rsa_d)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = rsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(k->rsa, rsa_p, rsa_q)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = check_rsa_length(k->rsa)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = ssh_rsa_complete_crt_parameters(k, rsa_iqmp)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tif (!RSA_set0_key(k->rsa, NULL, NULL, rsa_d)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(k->rsa, rsa_p, rsa_q)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = check_rsa_length(k->rsa)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = ssh_rsa_complete_crt_parameters(k, rsa_iqmp)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_string(buf, &ed25519_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != ED25519_PK_SZ || sklen != ED25519_SK_SZ) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ed25519_pk = ed25519_pk;\n\t\tk->ed25519_sk = ed25519_sk;\n\t\ted25519_pk = ed25519_sk = NULL;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != ED25519_PK_SZ || sklen != ED25519_SK_SZ) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ed25519_pk = ed25519_pk;\n\t\tk->ed25519_sk = ed25519_sk;\n\t\ted25519_pk = ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(buf, &xmss_name, NULL)) != 0 ||\n\t\t    (r = sshkey_xmss_init(k, xmss_name)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != sshkey_xmss_pklen(k) ||\n\t\t    sklen != sshkey_xmss_sklen(k)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->xmss_pk = xmss_pk;\n\t\tk->xmss_sk = xmss_sk;\n\t\txmss_pk = xmss_sk = NULL;\n\t\t/* optional internal state */\n\t\tif ((r = sshkey_xmss_deserialize_state_opt(k, buf)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_cstring(buf, &xmss_name, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (strcmp(xmss_name, k->xmss_name)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (pklen != sshkey_xmss_pklen(k) ||\n\t\t    sklen != sshkey_xmss_sklen(k)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->xmss_pk = xmss_pk;\n\t\tk->xmss_sk = xmss_sk;\n\t\txmss_pk = xmss_sk = NULL;\n\t\t/* optional internal state */\n\t\tif ((r = sshkey_xmss_deserialize_state_opt(k, buf)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n#ifdef WITH_OPENSSL\n\t/* enable blinding */\n\tswitch (k->type) {\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (RSA_blinding_on(k->rsa, NULL) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n#endif /* WITH_OPENSSL */\n\t/* success */\n\tr = 0;\n\tif (kp != NULL) {\n\t\t*kp = k;\n\t\tk = NULL;\n\t}\n out:\n\tfree(tname);\n\tfree(curve);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(exponent);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n\tBN_clear_free(dsa_priv_key);\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(rsa_d);\n\tBN_clear_free(rsa_p);\n\tBN_clear_free(rsa_q);\n\tBN_clear_free(rsa_iqmp);\n#endif /* WITH_OPENSSL */\n\tsshkey_free(k);\n\tfreezero(ed25519_pk, pklen);\n\tfreezero(ed25519_sk, sklen);\n\tfree(xmss_name);\n\tfreezero(xmss_pk, pklen);\n\tfreezero(xmss_sk, sklen);\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "xmss_sk",
            "sklen"
          ],
          "line": 3219
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "xmss_name"
          ],
          "line": 3217
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "rsa_iqmp"
          ],
          "line": 3212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "rsa_q"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "rsa_p"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "rsa_d"
          ],
          "line": 3209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "rsa_e"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "rsa_n"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "dsa_priv_key"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "dsa_pub_key"
          ],
          "line": 3205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "dsa_g"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "dsa_q"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "dsa_p"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "exponent"
          ],
          "line": 3201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_blinding_on",
          "args": [
            "k->rsa",
            "NULL"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_deserialize_state_opt",
          "args": [
            "k",
            "buf"
          ],
          "line": 3171
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_deserialize_state_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "800-829",
          "snippet": "int\nsshkey_xmss_deserialize_state_opt(struct sshkey *k, struct sshbuf *b)\n{\n\tenum sshkey_serialize_rep opts;\n\tu_char have_state;\n\tint r;\n\n\tif ((r = sshbuf_get_u8(b, &have_state)) != 0)\n\t\treturn r;\n\n\topts = have_state;\n\tswitch (opts) {\n\tcase SSHKEY_SERIALIZE_DEFAULT:\n\t\tr = 0;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_STATE:\n\t\tif ((r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_FULL:\n\t\tif ((r = sshkey_xmss_deserialize_enc_key(k, b)) != 0 ||\n\t\t    (r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tbreak;\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_deserialize_state_opt(struct sshkey *k, struct sshbuf *b)\n{\n\tenum sshkey_serialize_rep opts;\n\tu_char have_state;\n\tint r;\n\n\tif ((r = sshbuf_get_u8(b, &have_state)) != 0)\n\t\treturn r;\n\n\topts = have_state;\n\tswitch (opts) {\n\tcase SSHKEY_SERIALIZE_DEFAULT:\n\t\tr = 0;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_STATE:\n\t\tif ((r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_FULL:\n\t\tif ((r = sshkey_xmss_deserialize_enc_key(k, b)) != 0 ||\n\t\t    (r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tbreak;\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_sklen",
          "args": [
            "k"
          ],
          "line": 3163
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_sklen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "255-263",
          "snippet": "size_t\nsshkey_xmss_sklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 4 + 4;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_sklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 4 + 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_pklen",
          "args": [
            "k"
          ],
          "line": 3162
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_pklen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "245-253",
          "snippet": "size_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "xmss_name",
            "k->xmss_name"
          ],
          "line": 3158
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "buf",
            "&xmss_sk",
            "&sklen"
          ],
          "line": 3156
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "buf",
            "&xmss_name",
            "NULL"
          ],
          "line": 3154
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_froms",
          "args": [
            "buf",
            "&k"
          ],
          "line": 3153
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_froms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2282-2293",
          "snippet": "int\nsshkey_froms(struct sshbuf *buf, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((r = sshbuf_froms(buf, &b)) != 0)\n\t\treturn r;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_froms(struct sshbuf *buf, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((r = sshbuf_froms(buf, &b)) != 0)\n\t\treturn r;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_init",
          "args": [
            "k",
            "xmss_name"
          ],
          "line": 3136
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_init_enc_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "265-288",
          "snippet": "int\nsshkey_xmss_init_enc_key(struct sshkey *k, const char *ciphername)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tconst struct sshcipher *cipher;\n\tsize_t keylen = 0, ivlen = 0;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((state->enc_ciphername = strdup(ciphername)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tstate->enc_keyiv_len = keylen + ivlen;\n\tif ((state->enc_keyiv = calloc(state->enc_keyiv_len, 1)) == NULL) {\n\t\tfree(state->enc_ciphername);\n\t\tstate->enc_ciphername = NULL;\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tarc4random_buf(state->enc_keyiv, state->enc_keyiv_len);\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_init_enc_key(struct sshkey *k, const char *ciphername)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tconst struct sshcipher *cipher;\n\tsize_t keylen = 0, ivlen = 0;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((state->enc_ciphername = strdup(ciphername)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tstate->enc_keyiv_len = keylen + ivlen;\n\tif ((state->enc_keyiv = calloc(state->enc_keyiv_len, 1)) == NULL) {\n\t\tfree(state->enc_ciphername);\n\t\tstate->enc_ciphername = NULL;\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tarc4random_buf(state->enc_keyiv, state->enc_keyiv_len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_new",
          "args": [
            "type"
          ],
          "line": 3131
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "485-550",
          "snippet": "struct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_rsa_complete_crt_parameters",
          "args": [
            "k",
            "rsa_iqmp"
          ],
          "line": 3096
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_rsa_complete_crt_parameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-rsa.c",
          "lines": "108-160",
          "snippet": "int\nssh_rsa_complete_crt_parameters(struct sshkey *key, const BIGNUM *iqmp)\n{\n\tconst BIGNUM *rsa_p, *rsa_q, *rsa_d;\n\tBIGNUM *aux = NULL, *d_consttime = NULL;\n\tBIGNUM *rsa_dmq1 = NULL, *rsa_dmp1 = NULL, *rsa_iqmp = NULL;\n\tBN_CTX *ctx = NULL;\n\tint r;\n\n\tif (key == NULL || key->rsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_RSA)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\n\tif ((ctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((aux = BN_new()) == NULL ||\n\t    (rsa_dmq1 = BN_new()) == NULL ||\n\t    (rsa_dmp1 = BN_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((d_consttime = BN_dup(rsa_d)) == NULL ||\n\t    (rsa_iqmp = BN_dup(iqmp)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tBN_set_flags(aux, BN_FLG_CONSTTIME);\n\tBN_set_flags(d_consttime, BN_FLG_CONSTTIME);\n\n\tif ((BN_sub(aux, rsa_q, BN_value_one()) == 0) ||\n\t    (BN_mod(rsa_dmq1, d_consttime, aux, ctx) == 0) ||\n\t    (BN_sub(aux, rsa_p, BN_value_one()) == 0) ||\n\t    (BN_mod(rsa_dmp1, d_consttime, aux, ctx) == 0)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (!RSA_set0_crt_params(key->rsa, rsa_dmp1, rsa_dmq1, rsa_iqmp)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\trsa_dmp1 = rsa_dmq1 = rsa_iqmp = NULL; /* transferred */\n\t/* success */\n\tr = 0;\n out:\n\tBN_clear_free(aux);\n\tBN_clear_free(d_consttime);\n\tBN_clear_free(rsa_dmp1);\n\tBN_clear_free(rsa_dmq1);\n\tBN_clear_free(rsa_iqmp);\n\tBN_CTX_free(ctx);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"log.h\"",
            "#include \"digest.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"log.h\"\n#include \"digest.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include <string.h>\n#include <stdarg.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_rsa_complete_crt_parameters(struct sshkey *key, const BIGNUM *iqmp)\n{\n\tconst BIGNUM *rsa_p, *rsa_q, *rsa_d;\n\tBIGNUM *aux = NULL, *d_consttime = NULL;\n\tBIGNUM *rsa_dmq1 = NULL, *rsa_dmp1 = NULL, *rsa_iqmp = NULL;\n\tBN_CTX *ctx = NULL;\n\tint r;\n\n\tif (key == NULL || key->rsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_RSA)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\n\tif ((ctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((aux = BN_new()) == NULL ||\n\t    (rsa_dmq1 = BN_new()) == NULL ||\n\t    (rsa_dmp1 = BN_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((d_consttime = BN_dup(rsa_d)) == NULL ||\n\t    (rsa_iqmp = BN_dup(iqmp)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tBN_set_flags(aux, BN_FLG_CONSTTIME);\n\tBN_set_flags(d_consttime, BN_FLG_CONSTTIME);\n\n\tif ((BN_sub(aux, rsa_q, BN_value_one()) == 0) ||\n\t    (BN_mod(rsa_dmq1, d_consttime, aux, ctx) == 0) ||\n\t    (BN_sub(aux, rsa_p, BN_value_one()) == 0) ||\n\t    (BN_mod(rsa_dmp1, d_consttime, aux, ctx) == 0)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (!RSA_set0_crt_params(key->rsa, rsa_dmp1, rsa_dmq1, rsa_iqmp)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\trsa_dmp1 = rsa_dmq1 = rsa_iqmp = NULL; /* transferred */\n\t/* success */\n\tr = 0;\n out:\n\tBN_clear_free(aux);\n\tBN_clear_free(d_consttime);\n\tBN_clear_free(rsa_dmp1);\n\tBN_clear_free(rsa_dmq1);\n\tBN_clear_free(rsa_iqmp);\n\tBN_CTX_free(ctx);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_rsa_length",
          "args": [
            "k->rsa"
          ],
          "line": 3094
        },
        "resolved": true,
        "details": {
          "function_name": "check_rsa_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1996-2005",
          "snippet": "static int\ncheck_rsa_length(const RSA *rsa)\n{\n\tconst BIGNUM *rsa_n;\n\n\tRSA_get0_key(rsa, &rsa_n, NULL, NULL);\n\tif (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncheck_rsa_length(const RSA *rsa)\n{\n\tconst BIGNUM *rsa_n;\n\n\tRSA_get0_key(rsa, &rsa_n, NULL, NULL);\n\tif (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_set0_factors",
          "args": [
            "k->rsa",
            "rsa_p",
            "rsa_q"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_set0_factors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "318-334",
          "snippet": "int\nRSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q)\n{\n\tif ((r->p == NULL && p == NULL) || (r->q == NULL && q == NULL))\n\t\treturn 0;\n\n\tif (p != NULL) {\n\t\tBN_free(r->p);\n\t\tr->p = p;\n\t}\n\tif (q != NULL) {\n\t\tBN_free(r->q);\n\t\tr->q = q;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nRSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q)\n{\n\tif ((r->p == NULL && p == NULL) || (r->q == NULL && q == NULL))\n\t\treturn 0;\n\n\tif (p != NULL) {\n\t\tBN_free(r->p);\n\t\tr->p = p;\n\t}\n\tif (q != NULL) {\n\t\tBN_free(r->q);\n\t\tr->q = q;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_set0_key",
          "args": [
            "k->rsa",
            "NULL",
            "NULL",
            "rsa_d"
          ],
          "line": 3084
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_set0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "243-263",
          "snippet": "int\nRSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d)\n{\n\tif ((r->n == NULL && n == NULL) || (r->e == NULL && e == NULL))\n\t\treturn 0;\n\n\tif (n != NULL) {\n\t\tBN_free(r->n);\n\t\tr->n = n;\n\t}\n\tif (e != NULL) {\n\t\tBN_free(r->e);\n\t\tr->e = e;\n\t}\n\tif (d != NULL) {\n\t\tBN_free(r->d);\n\t\tr->d = d;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nRSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d)\n{\n\tif ((r->n == NULL && n == NULL) || (r->e == NULL && e == NULL))\n\t\treturn 0;\n\n\tif (n != NULL) {\n\t\tBN_free(r->n);\n\t\tr->n = n;\n\t}\n\tif (e != NULL) {\n\t\tBN_free(r->e);\n\t\tr->e = e;\n\t}\n\tif (d != NULL) {\n\t\tBN_free(r->d);\n\t\tr->d = d;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_bignum2",
          "args": [
            "buf",
            "rsa_q"
          ],
          "line": 3082
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_bignum2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-crypto.c",
          "lines": "34-46",
          "snippet": "int\nsshbuf_get_bignum2(struct sshbuf *buf, BIGNUM *v)\n{\n\tconst u_char *d;\n\tsize_t len;\n\tint r;\n\n\tif ((r = sshbuf_get_bignum2_bytes_direct(buf, &d, &len)) != 0)\n\t\treturn r;\n\tif (v != NULL && BN_bin2bn(d, len, v) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n# include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_bignum2(struct sshbuf *buf, BIGNUM *v)\n{\n\tconst u_char *d;\n\tsize_t len;\n\tint r;\n\n\tif ((r = sshbuf_get_bignum2_bytes_direct(buf, &d, &len)) != 0)\n\t\treturn r;\n\tif (v != NULL && BN_bin2bn(d, len, v) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 3071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 3043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_ec_validate_private",
          "args": [
            "k->ecdsa"
          ],
          "line": 3030
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ec_validate_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3301-3338",
          "snippet": "int\nsshkey_ec_validate_private(const EC_KEY *key)\n{\n\tBN_CTX *bnctx;\n\tBIGNUM *order, *tmp;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tBN_CTX_start(bnctx);\n\n\tif ((order = BN_CTX_get(bnctx)) == NULL ||\n\t    (tmp = BN_CTX_get(bnctx)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* log2(private) > log2(order)/2 */\n\tif (EC_GROUP_get_order(EC_KEY_get0_group(key), order, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(EC_KEY_get0_private_key(key)) <=\n\t    BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t/* private < order - 1 */\n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(EC_KEY_get0_private_key(key), tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_CTX_free(bnctx);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_ec_validate_private(const EC_KEY *key)\n{\n\tBN_CTX *bnctx;\n\tBIGNUM *order, *tmp;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tBN_CTX_start(bnctx);\n\n\tif ((order = BN_CTX_get(bnctx)) == NULL ||\n\t    (tmp = BN_CTX_get(bnctx)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* log2(private) > log2(order)/2 */\n\tif (EC_GROUP_get_order(EC_KEY_get0_group(key), order, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(EC_KEY_get0_private_key(key)) <=\n\t    BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t/* private < order - 1 */\n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(EC_KEY_get0_private_key(key), tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_CTX_free(bnctx);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ec_validate_public",
          "args": [
            "EC_KEY_get0_group(k->ecdsa)",
            "EC_KEY_get0_public_key(k->ecdsa)"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ec_validate_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3224-3299",
          "snippet": "int\nsshkey_ec_validate_public(const EC_GROUP *group, const EC_POINT *public)\n{\n\tBN_CTX *bnctx;\n\tEC_POINT *nq = NULL;\n\tBIGNUM *order, *x, *y, *tmp;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\t/*\n\t * NB. This assumes OpenSSL has already verified that the public\n\t * point lies on the curve. This is done by EC_POINT_oct2point()\n\t * implicitly calling EC_POINT_is_on_curve(). If this code is ever\n\t * reachable with public points not unmarshalled using\n\t * EC_POINT_oct2point then the caller will need to explicitly check.\n\t */\n\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tBN_CTX_start(bnctx);\n\n\t/*\n\t * We shouldn't ever hit this case because bignum_get_ecpoint()\n\t * refuses to load GF2m points.\n\t */\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field)\n\t\tgoto out;\n\n\t/* Q != infinity */\n\tif (EC_POINT_is_at_infinity(group, public))\n\t\tgoto out;\n\n\tif ((x = BN_CTX_get(bnctx)) == NULL ||\n\t    (y = BN_CTX_get(bnctx)) == NULL ||\n\t    (order = BN_CTX_get(bnctx)) == NULL ||\n\t    (tmp = BN_CTX_get(bnctx)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* log2(x) > log2(order)/2, log2(y) > log2(order)/2 */\n\tif (EC_GROUP_get_order(group, order, bnctx) != 1 ||\n\t    EC_POINT_get_affine_coordinates_GFp(group, public,\n\t    x, y, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(x) <= BN_num_bits(order) / 2 ||\n\t    BN_num_bits(y) <= BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t/* nQ == infinity (n == order of subgroup) */\n\tif ((nq = EC_POINT_new(group)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_mul(group, nq, NULL, public, order, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_is_at_infinity(group, nq) != 1)\n\t\tgoto out;\n\n\t/* x < order - 1, y < order - 1 */\n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(x, tmp) >= 0 || BN_cmp(y, tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_CTX_free(bnctx);\n\tEC_POINT_free(nq);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_ec_validate_public(const EC_GROUP *group, const EC_POINT *public)\n{\n\tBN_CTX *bnctx;\n\tEC_POINT *nq = NULL;\n\tBIGNUM *order, *x, *y, *tmp;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\t/*\n\t * NB. This assumes OpenSSL has already verified that the public\n\t * point lies on the curve. This is done by EC_POINT_oct2point()\n\t * implicitly calling EC_POINT_is_on_curve(). If this code is ever\n\t * reachable with public points not unmarshalled using\n\t * EC_POINT_oct2point then the caller will need to explicitly check.\n\t */\n\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tBN_CTX_start(bnctx);\n\n\t/*\n\t * We shouldn't ever hit this case because bignum_get_ecpoint()\n\t * refuses to load GF2m points.\n\t */\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field)\n\t\tgoto out;\n\n\t/* Q != infinity */\n\tif (EC_POINT_is_at_infinity(group, public))\n\t\tgoto out;\n\n\tif ((x = BN_CTX_get(bnctx)) == NULL ||\n\t    (y = BN_CTX_get(bnctx)) == NULL ||\n\t    (order = BN_CTX_get(bnctx)) == NULL ||\n\t    (tmp = BN_CTX_get(bnctx)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* log2(x) > log2(order)/2, log2(y) > log2(order)/2 */\n\tif (EC_GROUP_get_order(group, order, bnctx) != 1 ||\n\t    EC_POINT_get_affine_coordinates_GFp(group, public,\n\t    x, y, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(x) <= BN_num_bits(order) / 2 ||\n\t    BN_num_bits(y) <= BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t/* nQ == infinity (n == order of subgroup) */\n\tif ((nq = EC_POINT_new(group)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_mul(group, nq, NULL, public, order, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_is_at_infinity(group, nq) != 1)\n\t\tgoto out;\n\n\t/* x < order - 1, y < order - 1 */\n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(x, tmp) >= 0 || BN_cmp(y, tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_CTX_free(bnctx);\n\tEC_POINT_free(nq);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_public_key",
          "args": [
            "k->ecdsa"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "k->ecdsa"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_set_private_key",
          "args": [
            "k->ecdsa",
            "exponent"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 3017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_public_key",
          "args": [
            "k->ecdsa"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "k->ecdsa"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_set_private_key",
          "args": [
            "k->ecdsa",
            "exponent"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_eckey",
          "args": [
            "buf",
            "k->ecdsa"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_eckey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-crypto.c",
          "lines": "110-143",
          "snippet": "int\nsshbuf_get_eckey(struct sshbuf *buf, EC_KEY *v)\n{\n\tEC_POINT *pt = EC_POINT_new(EC_KEY_get0_group(v));\n\tint r;\n\tconst u_char *d;\n\tsize_t len;\n\n\tif (pt == NULL) {\n\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_peek_string_direct(buf, &d, &len)) < 0) {\n\t\tEC_POINT_free(pt);\n\t\treturn r;\n\t}\n\tif ((r = get_ec(d, len, pt, EC_KEY_get0_group(v))) != 0) {\n\t\tEC_POINT_free(pt);\n\t\treturn r;\n\t}\n\tif (EC_KEY_set_public_key(v, pt) != 1) {\n\t\tEC_POINT_free(pt);\n\t\treturn SSH_ERR_ALLOC_FAIL; /* XXX assumption */\n\t}\n\tEC_POINT_free(pt);\n\t/* Skip string */\n\tif (sshbuf_get_string_direct(buf, NULL, NULL) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\t\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n# include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_eckey(struct sshbuf *buf, EC_KEY *v)\n{\n\tEC_POINT *pt = EC_POINT_new(EC_KEY_get0_group(v));\n\tint r;\n\tconst u_char *d;\n\tsize_t len;\n\n\tif (pt == NULL) {\n\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_peek_string_direct(buf, &d, &len)) < 0) {\n\t\tEC_POINT_free(pt);\n\t\treturn r;\n\t}\n\tif ((r = get_ec(d, len, pt, EC_KEY_get0_group(v))) != 0) {\n\t\tEC_POINT_free(pt);\n\t\treturn r;\n\t}\n\tif (EC_KEY_set_public_key(v, pt) != 1) {\n\t\tEC_POINT_free(pt);\n\t\treturn SSH_ERR_ALLOC_FAIL; /* XXX assumption */\n\t}\n\tEC_POINT_free(pt);\n\t/* Skip string */\n\tif (sshbuf_get_string_direct(buf, NULL, NULL) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_new_by_curve_name",
          "args": [
            "k->ecdsa_nid"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_curve_name_to_nid",
          "args": [
            "curve"
          ],
          "line": 2995
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_curve_name_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "362-375",
          "snippet": "int\nsshkey_curve_name_to_nid(const char *name)\n{\n\tif (strcmp(name, \"nistp256\") == 0)\n\t\treturn NID_X9_62_prime256v1;\n\telse if (strcmp(name, \"nistp384\") == 0)\n\t\treturn NID_secp384r1;\n# ifdef OPENSSL_HAS_NISTP521\n\telse if (strcmp(name, \"nistp521\") == 0)\n\t\treturn NID_secp521r1;\n# endif /* OPENSSL_HAS_NISTP521 */\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_curve_name_to_nid(const char *name)\n{\n\tif (strcmp(name, \"nistp256\") == 0)\n\t\treturn NID_X9_62_prime256v1;\n\telse if (strcmp(name, \"nistp384\") == 0)\n\t\treturn NID_secp384r1;\n# ifdef OPENSSL_HAS_NISTP521\n\telse if (strcmp(name, \"nistp521\") == 0)\n\t\treturn NID_secp521r1;\n# endif /* OPENSSL_HAS_NISTP521 */\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ecdsa_nid_from_name",
          "args": [
            "tname"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ecdsa_nid_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "204-216",
          "snippet": "int\nsshkey_ecdsa_nid_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type != KEY_ECDSA && kt->type != KEY_ECDSA_CERT)\n\t\t\tcontinue;\n\t\tif (kt->name != NULL && strcmp(name, kt->name) == 0)\n\t\t\treturn kt->nid;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_ecdsa_nid_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type != KEY_ECDSA && kt->type != KEY_ECDSA_CERT)\n\t\t\tcontinue;\n\t\tif (kt->name != NULL && strcmp(name, kt->name) == 0)\n\t\t\treturn kt->nid;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_set0_key",
          "args": [
            "k->dsa",
            "NULL",
            "dsa_priv_key"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_set0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "210-226",
          "snippet": "int\nDSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key)\n{\n\tif (d->pub_key == NULL && pub_key == NULL)\n\t\treturn 0;\n\n\tif (pub_key != NULL) {\n\t\tBN_free(d->pub_key);\n\t\td->pub_key = pub_key;\n\t}\n\tif (priv_key != NULL) {\n\t\tBN_free(d->priv_key);\n\t\td->priv_key = priv_key;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nDSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key)\n{\n\tif (d->pub_key == NULL && pub_key == NULL)\n\t\treturn 0;\n\n\tif (pub_key != NULL) {\n\t\tBN_free(d->pub_key);\n\t\td->pub_key = pub_key;\n\t}\n\tif (priv_key != NULL) {\n\t\tBN_free(d->priv_key);\n\t\td->priv_key = priv_key;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_set0_pqg",
          "args": [
            "k->dsa",
            "dsa_p",
            "dsa_q",
            "dsa_g"
          ],
          "line": 2958
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_set0_pqg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "174-195",
          "snippet": "int\nDSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)\n{\n\tif ((d->p == NULL && p == NULL) || (d->q == NULL && q == NULL) ||\n\t    (d->g == NULL && g == NULL))\n\t\treturn 0;\n\n\tif (p != NULL) {\n\t\tBN_free(d->p);\n\t\td->p = p;\n\t}\n\tif (q != NULL) {\n\t\tBN_free(d->q);\n\t\td->q = q;\n\t}\n\tif (g != NULL) {\n\t\tBN_free(d->g);\n\t\td->g = g;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nDSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)\n{\n\tif ((d->p == NULL && p == NULL) || (d->q == NULL && q == NULL) ||\n\t    (d->g == NULL && g == NULL))\n\t\treturn 0;\n\n\tif (p != NULL) {\n\t\tBN_free(d->p);\n\t\td->p = p;\n\t}\n\tif (q != NULL) {\n\t\tBN_free(d->q);\n\t\td->q = q;\n\t}\n\tif (g != NULL) {\n\t\tBN_free(d->g);\n\t\td->g = g;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "tname"
          ],
          "line": 2936
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)\n{\n\tchar *tname = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *k = NULL;\n\tsize_t pklen = 0, sklen = 0;\n\tint type, r = SSH_ERR_INTERNAL_ERROR;\n\tu_char *ed25519_pk = NULL, *ed25519_sk = NULL;\n\tu_char *xmss_pk = NULL, *xmss_sk = NULL;\n#ifdef WITH_OPENSSL\n\tBIGNUM *exponent = NULL;\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n\tBIGNUM *rsa_iqmp = NULL, *rsa_p = NULL, *rsa_q = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL;\n\tBIGNUM *dsa_pub_key = NULL, *dsa_priv_key = NULL;\n#endif /* WITH_OPENSSL */\n\n\tif (kp != NULL)\n\t\t*kp = NULL;\n\tif ((r = sshbuf_get_cstring(buf, &tname, NULL)) != 0)\n\t\tgoto out;\n\ttype = sshkey_type_from_name(tname);\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL ||\n\t\t    (dsa_priv_key = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_bignum2(buf, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tif (!DSA_set0_pqg(k->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(k->dsa, dsa_pub_key, dsa_priv_key)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = dsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa_priv_key = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tif (!DSA_set0_key(k->dsa, NULL, dsa_priv_key)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((k->ecdsa_nid = sshkey_ecdsa_nid_from_name(tname)) == -1) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(buf, &curve, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif (k->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tr = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (k->ecdsa  == NULL || (exponent = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_eckey(buf, k->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, exponent)))\n\t\t\tgoto out;\n\t\tif (EC_KEY_set_private_key(k->ecdsa, exponent) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),\n\t\t    EC_KEY_get0_public_key(k->ecdsa))) != 0 ||\n\t\t    (r = sshkey_ec_validate_private(k->ecdsa)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif ((exponent = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, exponent)) != 0)\n\t\t\tgoto out;\n\t\tif (EC_KEY_set_private_key(k->ecdsa, exponent) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),\n\t\t    EC_KEY_get0_public_key(k->ecdsa))) != 0 ||\n\t\t    (r = sshkey_ec_validate_private(k->ecdsa)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_n = BN_new()) == NULL ||\n\t\t    (rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_bignum2(buf, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tif (!RSA_set0_key(k->rsa, rsa_n, rsa_e, rsa_d)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = rsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(k->rsa, rsa_p, rsa_q)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = check_rsa_length(k->rsa)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = ssh_rsa_complete_crt_parameters(k, rsa_iqmp)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tif (!RSA_set0_key(k->rsa, NULL, NULL, rsa_d)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(k->rsa, rsa_p, rsa_q)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = check_rsa_length(k->rsa)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = ssh_rsa_complete_crt_parameters(k, rsa_iqmp)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_string(buf, &ed25519_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != ED25519_PK_SZ || sklen != ED25519_SK_SZ) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ed25519_pk = ed25519_pk;\n\t\tk->ed25519_sk = ed25519_sk;\n\t\ted25519_pk = ed25519_sk = NULL;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != ED25519_PK_SZ || sklen != ED25519_SK_SZ) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ed25519_pk = ed25519_pk;\n\t\tk->ed25519_sk = ed25519_sk;\n\t\ted25519_pk = ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(buf, &xmss_name, NULL)) != 0 ||\n\t\t    (r = sshkey_xmss_init(k, xmss_name)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != sshkey_xmss_pklen(k) ||\n\t\t    sklen != sshkey_xmss_sklen(k)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->xmss_pk = xmss_pk;\n\t\tk->xmss_sk = xmss_sk;\n\t\txmss_pk = xmss_sk = NULL;\n\t\t/* optional internal state */\n\t\tif ((r = sshkey_xmss_deserialize_state_opt(k, buf)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_cstring(buf, &xmss_name, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (strcmp(xmss_name, k->xmss_name)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (pklen != sshkey_xmss_pklen(k) ||\n\t\t    sklen != sshkey_xmss_sklen(k)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->xmss_pk = xmss_pk;\n\t\tk->xmss_sk = xmss_sk;\n\t\txmss_pk = xmss_sk = NULL;\n\t\t/* optional internal state */\n\t\tif ((r = sshkey_xmss_deserialize_state_opt(k, buf)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n#ifdef WITH_OPENSSL\n\t/* enable blinding */\n\tswitch (k->type) {\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (RSA_blinding_on(k->rsa, NULL) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n#endif /* WITH_OPENSSL */\n\t/* success */\n\tr = 0;\n\tif (kp != NULL) {\n\t\t*kp = k;\n\t\tk = NULL;\n\t}\n out:\n\tfree(tname);\n\tfree(curve);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(exponent);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n\tBN_clear_free(dsa_priv_key);\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(rsa_d);\n\tBN_clear_free(rsa_p);\n\tBN_clear_free(rsa_q);\n\tBN_clear_free(rsa_iqmp);\n#endif /* WITH_OPENSSL */\n\tsshkey_free(k);\n\tfreezero(ed25519_pk, pklen);\n\tfreezero(ed25519_sk, sklen);\n\tfree(xmss_name);\n\tfreezero(xmss_pk, pklen);\n\tfreezero(xmss_sk, sklen);\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_private_serialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2908-2913",
    "snippet": "int\nsshkey_private_serialize(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_private_serialize_opt(key, b,\n\t    SSHKEY_SERIALIZE_DEFAULT);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_private_serialize_opt",
          "args": [
            "key",
            "b",
            "SSHKEY_SERIALIZE_DEFAULT"
          ],
          "line": 2911
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_private_serialize_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2767-2906",
          "snippet": "int\nsshkey_private_serialize_opt(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *rsa_d, *rsa_iqmp, *rsa_p, *rsa_q;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key, *dsa_priv_key;\n#endif /* WITH_OPENSSL */\n\n\tif ((r = sshbuf_put_cstring(b, sshkey_ssh_name(key))) != 0)\n\t\tgoto out;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_bignum2(b, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tDSA_get0_key(key->dsa, NULL, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((r = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (r = sshbuf_put_eckey(b, key->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0 ||\n\t\t    key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nint\nsshkey_private_serialize_opt(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *rsa_d, *rsa_iqmp, *rsa_p, *rsa_q;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key, *dsa_priv_key;\n#endif /* WITH_OPENSSL */\n\n\tif ((r = sshbuf_put_cstring(b, sshkey_ssh_name(key))) != 0)\n\t\tgoto out;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_bignum2(b, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tDSA_get0_key(key->dsa, NULL, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((r = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (r = sshbuf_put_eckey(b, key->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0 ||\n\t\t    key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_private_serialize(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_private_serialize_opt(key, b,\n\t    SSHKEY_SERIALIZE_DEFAULT);\n}"
  },
  {
    "function_name": "sshkey_private_serialize_opt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2767-2906",
    "snippet": "int\nsshkey_private_serialize_opt(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *rsa_d, *rsa_iqmp, *rsa_p, *rsa_q;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key, *dsa_priv_key;\n#endif /* WITH_OPENSSL */\n\n\tif ((r = sshbuf_put_cstring(b, sshkey_ssh_name(key))) != 0)\n\t\tgoto out;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_bignum2(b, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tDSA_get0_key(key->dsa, NULL, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((r = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (r = sshbuf_put_eckey(b, key->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0 ||\n\t\t    key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_xmss_serialize_state_opt",
          "args": [
            "key",
            "b",
            "opts"
          ],
          "line": 2894
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_serialize_state_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "713-741",
          "snippet": "int\nsshkey_xmss_serialize_state_opt(const struct sshkey *k, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tint r = SSH_ERR_INVALID_ARGUMENT;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_put_u8(b, opts)) != 0)\n\t\treturn r;\n\tswitch (opts) {\n\tcase SSHKEY_SERIALIZE_STATE:\n\t\tr = sshkey_xmss_serialize_state(k, b);\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_FULL:\n\t\tif ((r = sshkey_xmss_serialize_enc_key(k, b)) != 0)\n\t\t\tbreak;\n\t\tr = sshkey_xmss_serialize_state(k, b);\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_DEFAULT:\n\t\tr = 0;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tbreak;\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_serialize_state_opt(const struct sshkey *k, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tint r = SSH_ERR_INVALID_ARGUMENT;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_put_u8(b, opts)) != 0)\n\t\treturn r;\n\tswitch (opts) {\n\tcase SSHKEY_SERIALIZE_STATE:\n\t\tr = sshkey_xmss_serialize_state(k, b);\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_FULL:\n\t\tif ((r = sshkey_xmss_serialize_enc_key(k, b)) != 0)\n\t\t\tbreak;\n\t\tr = sshkey_xmss_serialize_state(k, b);\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_DEFAULT:\n\t\tr = 0;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tbreak;\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "b",
            "key->xmss_sk",
            "sshkey_xmss_sklen(key)"
          ],
          "line": 2892
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_sklen",
          "args": [
            "key"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_sklen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "255-263",
          "snippet": "size_t\nsshkey_xmss_sklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 4 + 4;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_sklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 4 + 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_pklen",
          "args": [
            "key"
          ],
          "line": 2891
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_pklen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "245-253",
          "snippet": "size_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "b",
            "key->xmss_name"
          ],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "b",
            "key->cert->certblob"
          ],
          "line": 2888
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "key->cert->certblob"
          ],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_bignum2",
          "args": [
            "b",
            "EC_KEY_get0_private_key(key->ecdsa)"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_bignum2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-crypto.c",
          "lines": "146-166",
          "snippet": "int\nsshbuf_put_bignum2(struct sshbuf *buf, const BIGNUM *v)\n{\n\tu_char d[SSHBUF_MAX_BIGNUM + 1];\n\tint len = BN_num_bytes(v), prepend = 0, r;\n\n\tif (len < 0 || len > SSHBUF_MAX_BIGNUM)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*d = '\\0';\n\tif (BN_bn2bin(v, d + 1) != len)\n\t\treturn SSH_ERR_INTERNAL_ERROR; /* Shouldn't happen */\n\t/* If MSB is set, prepend a \\0 */\n\tif (len > 0 && (d[1] & 0x80) != 0)\n\t\tprepend = 1;\n\tif ((r = sshbuf_put_string(buf, d + 1 - prepend, len + prepend)) < 0) {\n\t\texplicit_bzero(d, sizeof(d));\n\t\treturn r;\n\t}\n\texplicit_bzero(d, sizeof(d));\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n# include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_bignum2(struct sshbuf *buf, const BIGNUM *v)\n{\n\tu_char d[SSHBUF_MAX_BIGNUM + 1];\n\tint len = BN_num_bytes(v), prepend = 0, r;\n\n\tif (len < 0 || len > SSHBUF_MAX_BIGNUM)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*d = '\\0';\n\tif (BN_bn2bin(v, d + 1) != len)\n\t\treturn SSH_ERR_INTERNAL_ERROR; /* Shouldn't happen */\n\t/* If MSB is set, prepend a \\0 */\n\tif (len > 0 && (d[1] & 0x80) != 0)\n\t\tprepend = 1;\n\tif ((r = sshbuf_put_string(buf, d + 1 - prepend, len + prepend)) < 0) {\n\t\texplicit_bzero(d, sizeof(d));\n\t\treturn r;\n\t}\n\texplicit_bzero(d, sizeof(d));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_private_key",
          "args": [
            "key->ecdsa"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_private_key",
          "args": [
            "key->ecdsa"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_eckey",
          "args": [
            "b",
            "key->ecdsa"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_eckey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-crypto.c",
          "lines": "217-222",
          "snippet": "int\nsshbuf_put_eckey(struct sshbuf *buf, const EC_KEY *v)\n{\n\treturn sshbuf_put_ec(buf, EC_KEY_get0_public_key(v),\n\t    EC_KEY_get0_group(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n# include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_eckey(struct sshbuf *buf, const EC_KEY *v)\n{\n\treturn sshbuf_put_ec(buf, EC_KEY_get0_public_key(v),\n\t    EC_KEY_get0_group(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_curve_nid_to_name",
          "args": [
            "key->ecdsa_nid"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_curve_nid_to_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "411-426",
          "snippet": "const char *\nsshkey_curve_nid_to_name(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn \"nistp256\";\n\tcase NID_secp384r1:\n\t\treturn \"nistp384\";\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn \"nistp521\";\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_curve_nid_to_name(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn \"nistp256\";\n\tcase NID_secp384r1:\n\t\treturn \"nistp384\";\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn \"nistp521\";\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_get0_key",
          "args": [
            "key->dsa",
            "NULL",
            "&dsa_priv_key"
          ],
          "line": 2823
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_get0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "199-206",
          "snippet": "void\nDSA_get0_key(const DSA *d, const BIGNUM **pub_key, const BIGNUM **priv_key)\n{\n\tif (pub_key != NULL)\n\t\t*pub_key = d->pub_key;\n\tif (priv_key != NULL)\n\t\t*priv_key = d->priv_key;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nDSA_get0_key(const DSA *d, const BIGNUM **pub_key, const BIGNUM **priv_key)\n{\n\tif (pub_key != NULL)\n\t\t*pub_key = d->pub_key;\n\tif (priv_key != NULL)\n\t\t*priv_key = d->priv_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_get0_pqg",
          "args": [
            "key->dsa",
            "&dsa_p",
            "&dsa_q",
            "&dsa_g"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_get0_pqg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "161-170",
          "snippet": "void\nDSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)\n{\n\tif (p != NULL)\n\t\t*p = d->p;\n\tif (q != NULL)\n\t\t*q = d->q;\n\tif (g != NULL)\n\t\t*g = d->g;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nDSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)\n{\n\tif (p != NULL)\n\t\t*p = d->p;\n\tif (q != NULL)\n\t\t*q = d->q;\n\tif (g != NULL)\n\t\t*g = d->g;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_get0_crt_params",
          "args": [
            "key->rsa",
            "NULL",
            "NULL",
            "&rsa_iqmp"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_get0_crt_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "267-277",
          "snippet": "void\nRSA_get0_crt_params(const RSA *r, const BIGNUM **dmp1, const BIGNUM **dmq1,\n    const BIGNUM **iqmp)\n{\n\tif (dmp1 != NULL)\n\t\t*dmp1 = r->dmp1;\n\tif (dmq1 != NULL)\n\t\t*dmq1 = r->dmq1;\n\tif (iqmp != NULL)\n\t\t*iqmp = r->iqmp;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nRSA_get0_crt_params(const RSA *r, const BIGNUM **dmp1, const BIGNUM **dmq1,\n    const BIGNUM **iqmp)\n{\n\tif (dmp1 != NULL)\n\t\t*dmp1 = r->dmp1;\n\tif (dmq1 != NULL)\n\t\t*dmq1 = r->dmq1;\n\tif (iqmp != NULL)\n\t\t*iqmp = r->iqmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_get0_factors",
          "args": [
            "key->rsa",
            "&rsa_p",
            "&rsa_q"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_get0_factors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "307-314",
          "snippet": "void\nRSA_get0_factors(const RSA *r, const BIGNUM **p, const BIGNUM **q)\n{\n\tif (p != NULL)\n\t\t*p = r->p;\n\tif (q != NULL)\n\t\t*q = r->q;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nRSA_get0_factors(const RSA *r, const BIGNUM **p, const BIGNUM **q)\n{\n\tif (p != NULL)\n\t\t*p = r->p;\n\tif (q != NULL)\n\t\t*q = r->q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_get0_key",
          "args": [
            "key->rsa",
            "NULL",
            "NULL",
            "&rsa_d"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_get0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "230-239",
          "snippet": "void\nRSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)\n{\n\tif (n != NULL)\n\t\t*n = r->n;\n\tif (e != NULL)\n\t\t*e = r->e;\n\tif (d != NULL)\n\t\t*d = r->d;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nRSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)\n{\n\tif (n != NULL)\n\t\t*n = r->n;\n\tif (e != NULL)\n\t\t*e = r->e;\n\tif (d != NULL)\n\t\t*d = r->d;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "key"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nint\nsshkey_private_serialize_opt(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *rsa_d, *rsa_iqmp, *rsa_p, *rsa_q;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key, *dsa_priv_key;\n#endif /* WITH_OPENSSL */\n\n\tif ((r = sshbuf_put_cstring(b, sshkey_ssh_name(key))) != 0)\n\t\tgoto out;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_bignum2(b, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\t\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\t\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tDSA_get0_key(key->dsa, NULL, &dsa_priv_key);\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((r = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (r = sshbuf_put_eckey(b, key->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b,\n\t\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_pk,\n\t\t    ED25519_PK_SZ)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->ed25519_sk,\n\t\t    ED25519_SK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0 ||\n\t\t    key->xmss_name == NULL) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t\t    sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t\t    sshkey_xmss_sklen(key))) != 0 ||\n\t\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_format_cert_validity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2730-2765",
    "snippet": "size_t\nsshkey_format_cert_validity(const struct sshkey_cert *cert, char *s, size_t l)\n{\n\tchar from[32], to[32], ret[64];\n\ttime_t tt;\n\tstruct tm *tm;\n\n\t*from = *to = '\\0';\n\tif (cert->valid_after == 0 &&\n\t    cert->valid_before == 0xffffffffffffffffULL)\n\t\treturn strlcpy(s, \"forever\", l);\n\n\tif (cert->valid_after != 0) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_after > INT_MAX ?\n\t\t    INT_MAX : cert->valid_after;\n\t\ttm = localtime(&tt);\n\t\tstrftime(from, sizeof(from), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\tif (cert->valid_before != 0xffffffffffffffffULL) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_before > INT_MAX ?\n\t\t    INT_MAX : cert->valid_before;\n\t\ttm = localtime(&tt);\n\t\tstrftime(to, sizeof(to), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\n\tif (cert->valid_after == 0)\n\t\tsnprintf(ret, sizeof(ret), \"before %s\", to);\n\telse if (cert->valid_before == 0xffffffffffffffffULL)\n\t\tsnprintf(ret, sizeof(ret), \"after %s\", from);\n\telse\n\t\tsnprintf(ret, sizeof(ret), \"from %s to %s\", from, to);\n\n\treturn strlcpy(s, ret, l);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "s",
            "ret",
            "l"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ret",
            "sizeof(ret)",
            "\"from %s to %s\"",
            "from",
            "to"
          ],
          "line": 2762
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strftime",
          "args": [
            "to",
            "sizeof(to)",
            "\"%Y-%m-%dT%H:%M:%S\"",
            "tm"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localtime",
          "args": [
            "&tt"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strftime",
          "args": [
            "from",
            "sizeof(from)",
            "\"%Y-%m-%dT%H:%M:%S\"",
            "tm"
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localtime",
          "args": [
            "&tt"
          ],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_format_cert_validity(const struct sshkey_cert *cert, char *s, size_t l)\n{\n\tchar from[32], to[32], ret[64];\n\ttime_t tt;\n\tstruct tm *tm;\n\n\t*from = *to = '\\0';\n\tif (cert->valid_after == 0 &&\n\t    cert->valid_before == 0xffffffffffffffffULL)\n\t\treturn strlcpy(s, \"forever\", l);\n\n\tif (cert->valid_after != 0) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_after > INT_MAX ?\n\t\t    INT_MAX : cert->valid_after;\n\t\ttm = localtime(&tt);\n\t\tstrftime(from, sizeof(from), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\tif (cert->valid_before != 0xffffffffffffffffULL) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_before > INT_MAX ?\n\t\t    INT_MAX : cert->valid_before;\n\t\ttm = localtime(&tt);\n\t\tstrftime(to, sizeof(to), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\n\tif (cert->valid_after == 0)\n\t\tsnprintf(ret, sizeof(ret), \"before %s\", to);\n\telse if (cert->valid_before == 0xffffffffffffffffULL)\n\t\tsnprintf(ret, sizeof(ret), \"after %s\", from);\n\telse\n\t\tsnprintf(ret, sizeof(ret), \"from %s to %s\", from, to);\n\n\treturn strlcpy(s, ret, l);\n}"
  },
  {
    "function_name": "sshkey_cert_check_authority",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2673-2728",
    "snippet": "int\nsshkey_cert_check_authority(const struct sshkey *k,\n    int want_host, int require_principal,\n    const char *name, const char **reason)\n{\n\tu_int i, principal_matches;\n\ttime_t now = time(NULL);\n\n\tif (reason != NULL)\n\t\t*reason = NULL;\n\n\tif (want_host) {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_HOST) {\n\t\t\t*reason = \"Certificate invalid: not a host certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_USER) {\n\t\t\t*reason = \"Certificate invalid: not a user certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\tif (now < 0) {\n\t\t/* yikes - system clock before epoch! */\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now < k->cert->valid_after) {\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now >= k->cert->valid_before) {\n\t\t*reason = \"Certificate invalid: expired\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif (k->cert->nprincipals == 0) {\n\t\tif (require_principal) {\n\t\t\t*reason = \"Certificate lacks principal list\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else if (name != NULL) {\n\t\tprincipal_matches = 0;\n\t\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\t\tif (strcmp(name, k->cert->principals[i]) == 0) {\n\t\t\t\tprincipal_matches = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!principal_matches) {\n\t\t\t*reason = \"Certificate invalid: name is not a listed \"\n\t\t\t    \"principal\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "k->cert->principals[i]"
          ],
          "line": 2716
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "parse_cert_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1840-1888",
          "snippet": "static void\nparse_cert_times(char *timespec)\n{\n\tchar *from, *to;\n\ttime_t now = time(NULL);\n\tint64_t secs;\n\n\t/* +timespec relative to now */\n\tif (*timespec == '+' && strchr(timespec, ':') == NULL) {\n\t\tif ((secs = convtime(timespec + 1)) == -1)\n\t\t\tfatal(\"Invalid relative certificate life %s\", timespec);\n\t\tcert_valid_to = now + secs;\n\t\t/*\n\t\t * Backdate certificate one minute to avoid problems on hosts\n\t\t * with poorly-synchronised clocks.\n\t\t */\n\t\tcert_valid_from = ((now - 59)/ 60) * 60;\n\t\treturn;\n\t}\n\n\t/*\n\t * from:to, where\n\t * from := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"always\"\n\t *   to := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"forever\"\n\t */\n\tfrom = xstrdup(timespec);\n\tto = strchr(from, ':');\n\tif (to == NULL || from == to || *(to + 1) == '\\0')\n\t\tfatal(\"Invalid certificate life specification %s\", timespec);\n\t*to++ = '\\0';\n\n\tif (*from == '-' || *from == '+')\n\t\tcert_valid_from = parse_relative_time(from, now);\n\telse if (strcmp(from, \"always\") == 0)\n\t\tcert_valid_from = 0;\n\telse if (parse_absolute_time(from, &cert_valid_from) != 0)\n\t\tfatal(\"Invalid from time \\\"%s\\\"\", from);\n\n\tif (*to == '-' || *to == '+')\n\t\tcert_valid_to = parse_relative_time(to, now);\n\telse if (strcmp(to, \"forever\") == 0)\n\t\tcert_valid_to = ~(u_int64_t)0;\n\telse if (parse_absolute_time(to, &cert_valid_to) != 0)\n\t\tfatal(\"Invalid to time \\\"%s\\\"\", to);\n\n\tif (cert_valid_to <= cert_valid_from)\n\t\tfatal(\"Empty certificate validity interval\");\n\tfree(from);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int64_t cert_valid_from = 0;",
            "u_int64_t cert_valid_to = ~0ULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int64_t cert_valid_from = 0;\nu_int64_t cert_valid_to = ~0ULL;\n\nstatic void\nparse_cert_times(char *timespec)\n{\n\tchar *from, *to;\n\ttime_t now = time(NULL);\n\tint64_t secs;\n\n\t/* +timespec relative to now */\n\tif (*timespec == '+' && strchr(timespec, ':') == NULL) {\n\t\tif ((secs = convtime(timespec + 1)) == -1)\n\t\t\tfatal(\"Invalid relative certificate life %s\", timespec);\n\t\tcert_valid_to = now + secs;\n\t\t/*\n\t\t * Backdate certificate one minute to avoid problems on hosts\n\t\t * with poorly-synchronised clocks.\n\t\t */\n\t\tcert_valid_from = ((now - 59)/ 60) * 60;\n\t\treturn;\n\t}\n\n\t/*\n\t * from:to, where\n\t * from := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"always\"\n\t *   to := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"forever\"\n\t */\n\tfrom = xstrdup(timespec);\n\tto = strchr(from, ':');\n\tif (to == NULL || from == to || *(to + 1) == '\\0')\n\t\tfatal(\"Invalid certificate life specification %s\", timespec);\n\t*to++ = '\\0';\n\n\tif (*from == '-' || *from == '+')\n\t\tcert_valid_from = parse_relative_time(from, now);\n\telse if (strcmp(from, \"always\") == 0)\n\t\tcert_valid_from = 0;\n\telse if (parse_absolute_time(from, &cert_valid_from) != 0)\n\t\tfatal(\"Invalid from time \\\"%s\\\"\", from);\n\n\tif (*to == '-' || *to == '+')\n\t\tcert_valid_to = parse_relative_time(to, now);\n\telse if (strcmp(to, \"forever\") == 0)\n\t\tcert_valid_to = ~(u_int64_t)0;\n\telse if (parse_absolute_time(to, &cert_valid_to) != 0)\n\t\tfatal(\"Invalid to time \\\"%s\\\"\", to);\n\n\tif (cert_valid_to <= cert_valid_from)\n\t\tfatal(\"Empty certificate validity interval\");\n\tfree(from);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_cert_check_authority(const struct sshkey *k,\n    int want_host, int require_principal,\n    const char *name, const char **reason)\n{\n\tu_int i, principal_matches;\n\ttime_t now = time(NULL);\n\n\tif (reason != NULL)\n\t\t*reason = NULL;\n\n\tif (want_host) {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_HOST) {\n\t\t\t*reason = \"Certificate invalid: not a host certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_USER) {\n\t\t\t*reason = \"Certificate invalid: not a user certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\tif (now < 0) {\n\t\t/* yikes - system clock before epoch! */\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now < k->cert->valid_after) {\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now >= k->cert->valid_before) {\n\t\t*reason = \"Certificate invalid: expired\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif (k->cert->nprincipals == 0) {\n\t\tif (require_principal) {\n\t\t\t*reason = \"Certificate lacks principal list\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else if (name != NULL) {\n\t\tprincipal_matches = 0;\n\t\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\t\tif (strcmp(name, k->cert->principals[i]) == 0) {\n\t\t\t\tprincipal_matches = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!principal_matches) {\n\t\t\t*reason = \"Certificate invalid: name is not a listed \"\n\t\t\t    \"principal\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_certify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2667-2671",
    "snippet": "int\nsshkey_certify(struct sshkey *k, struct sshkey *ca, const char *alg)\n{\n\treturn sshkey_certify_custom(k, ca, alg, default_key_sign, NULL);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_certify_custom",
          "args": [
            "k",
            "ca",
            "alg",
            "default_key_sign",
            "NULL"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_certify_custom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2509-2655",
          "snippet": "int\nsshkey_certify_custom(struct sshkey *k, struct sshkey *ca, const char *alg,\n    sshkey_certify_signer *signer, void *signer_ctx)\n{\n\tstruct sshbuf *principals = NULL;\n\tu_char *ca_blob = NULL, *sig_blob = NULL, nonce[32];\n\tsize_t i, ca_len, sig_len;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *cert = NULL;\n\tchar *sigtype = NULL;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (k == NULL || k->cert == NULL ||\n\t    k->cert->certblob == NULL || ca == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_is_cert(k))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tif (!sshkey_type_is_valid_ca(ca->type))\n\t\treturn SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\n\t/*\n\t * If no alg specified as argument but a signature_type was set,\n\t * then prefer that. If both were specified, then they must match.\n\t */\n\tif (alg == NULL)\n\t\talg = k->cert->signature_type;\n\telse if (k->cert->signature_type != NULL &&\n\t    strcmp(alg, k->cert->signature_type) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((ret = sshkey_to_blob(ca, &ca_blob, &ca_len)) != 0)\n\t\treturn SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\n\tcert = k->cert->certblob; /* for readability */\n\tsshbuf_reset(cert);\n\tif ((ret = sshbuf_put_cstring(cert, sshkey_ssh_name(k))) != 0)\n\t\tgoto out;\n\n\t/* -v01 certs put nonce first */\n\tarc4random_buf(&nonce, sizeof(nonce));\n\tif ((ret = sshbuf_put_string(cert, nonce, sizeof(nonce))) != 0)\n\t\tgoto out;\n\n\t/* XXX this substantially duplicates to_blob(); refactor */\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_bignum2(cert, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_pub_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\t\tif ((ret = sshbuf_put_cstring(cert,\n\t\t    sshkey_curve_nid_to_name(k->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_ec(cert,\n\t\t    EC_KEY_get0_public_key(k->ecdsa),\n\t\t    EC_KEY_get0_group(k->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_bignum2(cert, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, rsa_n)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\tif ((ret = sshbuf_put_string(cert,\n\t\t    k->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\tif (k->xmss_name == NULL) {\n\t\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshbuf_put_cstring(cert, k->xmss_name)) ||\n\t\t    (ret = sshbuf_put_string(cert,\n\t\t    k->xmss_pk, sshkey_xmss_pklen(k))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tif ((ret = sshbuf_put_u64(cert, k->cert->serial)) != 0 ||\n\t    (ret = sshbuf_put_u32(cert, k->cert->type)) != 0 ||\n\t    (ret = sshbuf_put_cstring(cert, k->cert->key_id)) != 0)\n\t\tgoto out;\n\n\tif ((principals = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\tif ((ret = sshbuf_put_cstring(principals,\n\t\t    k->cert->principals[i])) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((ret = sshbuf_put_stringb(cert, principals)) != 0 ||\n\t    (ret = sshbuf_put_u64(cert, k->cert->valid_after)) != 0 ||\n\t    (ret = sshbuf_put_u64(cert, k->cert->valid_before)) != 0 ||\n\t    (ret = sshbuf_put_stringb(cert, k->cert->critical)) != 0 ||\n\t    (ret = sshbuf_put_stringb(cert, k->cert->extensions)) != 0 ||\n\t    (ret = sshbuf_put_string(cert, NULL, 0)) != 0 || /* Reserved */\n\t    (ret = sshbuf_put_string(cert, ca_blob, ca_len)) != 0)\n\t\tgoto out;\n\n\t/* Sign the whole mess */\n\tif ((ret = signer(ca, &sig_blob, &sig_len, sshbuf_ptr(cert),\n\t    sshbuf_len(cert), alg, 0, signer_ctx)) != 0)\n\t\tgoto out;\n\t/* Check and update signature_type against what was actually used */\n\tif ((ret = get_sigtype(sig_blob, sig_len, &sigtype)) != 0)\n\t\tgoto out;\n\tif (alg != NULL && strcmp(alg, sigtype) != 0) {\n\t\tret = SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tif (k->cert->signature_type == NULL) {\n\t\tk->cert->signature_type = sigtype;\n\t\tsigtype = NULL;\n\t}\n\t/* Append signature and we are done */\n\tif ((ret = sshbuf_put_string(cert, sig_blob, sig_len)) != 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tif (ret != 0)\n\t\tsshbuf_reset(cert);\n\tfree(sig_blob);\n\tfree(ca_blob);\n\tfree(sigtype);\n\tsshbuf_free(principals);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_certify_custom(struct sshkey *k, struct sshkey *ca, const char *alg,\n    sshkey_certify_signer *signer, void *signer_ctx)\n{\n\tstruct sshbuf *principals = NULL;\n\tu_char *ca_blob = NULL, *sig_blob = NULL, nonce[32];\n\tsize_t i, ca_len, sig_len;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *cert = NULL;\n\tchar *sigtype = NULL;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (k == NULL || k->cert == NULL ||\n\t    k->cert->certblob == NULL || ca == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_is_cert(k))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tif (!sshkey_type_is_valid_ca(ca->type))\n\t\treturn SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\n\t/*\n\t * If no alg specified as argument but a signature_type was set,\n\t * then prefer that. If both were specified, then they must match.\n\t */\n\tif (alg == NULL)\n\t\talg = k->cert->signature_type;\n\telse if (k->cert->signature_type != NULL &&\n\t    strcmp(alg, k->cert->signature_type) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((ret = sshkey_to_blob(ca, &ca_blob, &ca_len)) != 0)\n\t\treturn SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\n\tcert = k->cert->certblob; /* for readability */\n\tsshbuf_reset(cert);\n\tif ((ret = sshbuf_put_cstring(cert, sshkey_ssh_name(k))) != 0)\n\t\tgoto out;\n\n\t/* -v01 certs put nonce first */\n\tarc4random_buf(&nonce, sizeof(nonce));\n\tif ((ret = sshbuf_put_string(cert, nonce, sizeof(nonce))) != 0)\n\t\tgoto out;\n\n\t/* XXX this substantially duplicates to_blob(); refactor */\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_bignum2(cert, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_pub_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\t\tif ((ret = sshbuf_put_cstring(cert,\n\t\t    sshkey_curve_nid_to_name(k->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_ec(cert,\n\t\t    EC_KEY_get0_public_key(k->ecdsa),\n\t\t    EC_KEY_get0_group(k->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_bignum2(cert, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, rsa_n)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\tif ((ret = sshbuf_put_string(cert,\n\t\t    k->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\tif (k->xmss_name == NULL) {\n\t\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshbuf_put_cstring(cert, k->xmss_name)) ||\n\t\t    (ret = sshbuf_put_string(cert,\n\t\t    k->xmss_pk, sshkey_xmss_pklen(k))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tif ((ret = sshbuf_put_u64(cert, k->cert->serial)) != 0 ||\n\t    (ret = sshbuf_put_u32(cert, k->cert->type)) != 0 ||\n\t    (ret = sshbuf_put_cstring(cert, k->cert->key_id)) != 0)\n\t\tgoto out;\n\n\tif ((principals = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\tif ((ret = sshbuf_put_cstring(principals,\n\t\t    k->cert->principals[i])) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((ret = sshbuf_put_stringb(cert, principals)) != 0 ||\n\t    (ret = sshbuf_put_u64(cert, k->cert->valid_after)) != 0 ||\n\t    (ret = sshbuf_put_u64(cert, k->cert->valid_before)) != 0 ||\n\t    (ret = sshbuf_put_stringb(cert, k->cert->critical)) != 0 ||\n\t    (ret = sshbuf_put_stringb(cert, k->cert->extensions)) != 0 ||\n\t    (ret = sshbuf_put_string(cert, NULL, 0)) != 0 || /* Reserved */\n\t    (ret = sshbuf_put_string(cert, ca_blob, ca_len)) != 0)\n\t\tgoto out;\n\n\t/* Sign the whole mess */\n\tif ((ret = signer(ca, &sig_blob, &sig_len, sshbuf_ptr(cert),\n\t    sshbuf_len(cert), alg, 0, signer_ctx)) != 0)\n\t\tgoto out;\n\t/* Check and update signature_type against what was actually used */\n\tif ((ret = get_sigtype(sig_blob, sig_len, &sigtype)) != 0)\n\t\tgoto out;\n\tif (alg != NULL && strcmp(alg, sigtype) != 0) {\n\t\tret = SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tif (k->cert->signature_type == NULL) {\n\t\tk->cert->signature_type = sigtype;\n\t\tsigtype = NULL;\n\t}\n\t/* Append signature and we are done */\n\tif ((ret = sshbuf_put_string(cert, sig_blob, sig_len)) != 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tif (ret != 0)\n\t\tsshbuf_reset(cert);\n\tfree(sig_blob);\n\tfree(ca_blob);\n\tfree(sigtype);\n\tsshbuf_free(principals);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_certify(struct sshkey *k, struct sshkey *ca, const char *alg)\n{\n\treturn sshkey_certify_custom(k, ca, alg, default_key_sign, NULL);\n}"
  },
  {
    "function_name": "default_key_sign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2657-2665",
    "snippet": "static int\ndefault_key_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen,\n    const char *alg, u_int compat, void *ctx)\n{\n\tif (ctx != NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\treturn sshkey_sign(key, sigp, lenp, data, datalen, alg, compat);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_sign",
          "args": [
            "key",
            "sigp",
            "lenp",
            "data",
            "datalen",
            "alg",
            "compat"
          ],
          "line": 2664
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2385-2421",
          "snippet": "int\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndefault_key_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen,\n    const char *alg, u_int compat, void *ctx)\n{\n\tif (ctx != NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\treturn sshkey_sign(key, sigp, lenp, data, datalen, alg, compat);\n}"
  },
  {
    "function_name": "sshkey_certify_custom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2509-2655",
    "snippet": "int\nsshkey_certify_custom(struct sshkey *k, struct sshkey *ca, const char *alg,\n    sshkey_certify_signer *signer, void *signer_ctx)\n{\n\tstruct sshbuf *principals = NULL;\n\tu_char *ca_blob = NULL, *sig_blob = NULL, nonce[32];\n\tsize_t i, ca_len, sig_len;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *cert = NULL;\n\tchar *sigtype = NULL;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (k == NULL || k->cert == NULL ||\n\t    k->cert->certblob == NULL || ca == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_is_cert(k))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tif (!sshkey_type_is_valid_ca(ca->type))\n\t\treturn SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\n\t/*\n\t * If no alg specified as argument but a signature_type was set,\n\t * then prefer that. If both were specified, then they must match.\n\t */\n\tif (alg == NULL)\n\t\talg = k->cert->signature_type;\n\telse if (k->cert->signature_type != NULL &&\n\t    strcmp(alg, k->cert->signature_type) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((ret = sshkey_to_blob(ca, &ca_blob, &ca_len)) != 0)\n\t\treturn SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\n\tcert = k->cert->certblob; /* for readability */\n\tsshbuf_reset(cert);\n\tif ((ret = sshbuf_put_cstring(cert, sshkey_ssh_name(k))) != 0)\n\t\tgoto out;\n\n\t/* -v01 certs put nonce first */\n\tarc4random_buf(&nonce, sizeof(nonce));\n\tif ((ret = sshbuf_put_string(cert, nonce, sizeof(nonce))) != 0)\n\t\tgoto out;\n\n\t/* XXX this substantially duplicates to_blob(); refactor */\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_bignum2(cert, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_pub_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\t\tif ((ret = sshbuf_put_cstring(cert,\n\t\t    sshkey_curve_nid_to_name(k->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_ec(cert,\n\t\t    EC_KEY_get0_public_key(k->ecdsa),\n\t\t    EC_KEY_get0_group(k->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_bignum2(cert, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, rsa_n)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\tif ((ret = sshbuf_put_string(cert,\n\t\t    k->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\tif (k->xmss_name == NULL) {\n\t\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshbuf_put_cstring(cert, k->xmss_name)) ||\n\t\t    (ret = sshbuf_put_string(cert,\n\t\t    k->xmss_pk, sshkey_xmss_pklen(k))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tif ((ret = sshbuf_put_u64(cert, k->cert->serial)) != 0 ||\n\t    (ret = sshbuf_put_u32(cert, k->cert->type)) != 0 ||\n\t    (ret = sshbuf_put_cstring(cert, k->cert->key_id)) != 0)\n\t\tgoto out;\n\n\tif ((principals = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\tif ((ret = sshbuf_put_cstring(principals,\n\t\t    k->cert->principals[i])) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((ret = sshbuf_put_stringb(cert, principals)) != 0 ||\n\t    (ret = sshbuf_put_u64(cert, k->cert->valid_after)) != 0 ||\n\t    (ret = sshbuf_put_u64(cert, k->cert->valid_before)) != 0 ||\n\t    (ret = sshbuf_put_stringb(cert, k->cert->critical)) != 0 ||\n\t    (ret = sshbuf_put_stringb(cert, k->cert->extensions)) != 0 ||\n\t    (ret = sshbuf_put_string(cert, NULL, 0)) != 0 || /* Reserved */\n\t    (ret = sshbuf_put_string(cert, ca_blob, ca_len)) != 0)\n\t\tgoto out;\n\n\t/* Sign the whole mess */\n\tif ((ret = signer(ca, &sig_blob, &sig_len, sshbuf_ptr(cert),\n\t    sshbuf_len(cert), alg, 0, signer_ctx)) != 0)\n\t\tgoto out;\n\t/* Check and update signature_type against what was actually used */\n\tif ((ret = get_sigtype(sig_blob, sig_len, &sigtype)) != 0)\n\t\tgoto out;\n\tif (alg != NULL && strcmp(alg, sigtype) != 0) {\n\t\tret = SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tif (k->cert->signature_type == NULL) {\n\t\tk->cert->signature_type = sigtype;\n\t\tsigtype = NULL;\n\t}\n\t/* Append signature and we are done */\n\tif ((ret = sshbuf_put_string(cert, sig_blob, sig_len)) != 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tif (ret != 0)\n\t\tsshbuf_reset(cert);\n\tfree(sig_blob);\n\tfree(ca_blob);\n\tfree(sigtype);\n\tsshbuf_free(principals);\n\treturn ret;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "principals"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sigtype"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "cert"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "cert",
            "sig_blob",
            "sig_len"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "alg",
            "sigtype"
          ],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_sigtype",
          "args": [
            "sig_blob",
            "sig_len",
            "&sigtype"
          ],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "get_sigtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2295-2318",
          "snippet": "static int\nget_sigtype(const u_char *sig, size_t siglen, char **sigtypep)\n{\n\tint r;\n\tstruct sshbuf *b = NULL;\n\tchar *sigtype = NULL;\n\n\tif (sigtypep != NULL)\n\t\t*sigtypep = NULL;\n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &sigtype, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (sigtypep != NULL) {\n\t\t*sigtypep = sigtype;\n\t\tsigtype = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(sigtype);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int get_sigtype(const u_char *sig, size_t siglen, char **sigtypep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int get_sigtype(const u_char *sig, size_t siglen, char **sigtypep);\n\nstatic int\nget_sigtype(const u_char *sig, size_t siglen, char **sigtypep)\n{\n\tint r;\n\tstruct sshbuf *b = NULL;\n\tchar *sigtype = NULL;\n\n\tif (sigtypep != NULL)\n\t\t*sigtypep = NULL;\n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &sigtype, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (sigtypep != NULL) {\n\t\t*sigtypep = sigtype;\n\t\tsigtype = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(sigtype);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signer",
          "args": [
            "ca",
            "&sig_blob",
            "&sig_len",
            "sshbuf_ptr(cert)",
            "sshbuf_len(cert)",
            "alg",
            "0",
            "signer_ctx"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "agent_signer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1667-1676",
          "snippet": "static int\nagent_signer(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen,\n    const char *alg, u_int compat, void *ctx)\n{\n\tint *agent_fdp = (int *)ctx;\n\n\treturn ssh_agent_sign(*agent_fdp, key, sigp, lenp,\n\t    data, datalen, alg, compat);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nagent_signer(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen,\n    const char *alg, u_int compat, void *ctx)\n{\n\tint *agent_fdp = (int *)ctx;\n\n\treturn ssh_agent_sign(*agent_fdp, key, sigp, lenp,\n\t    data, datalen, alg, compat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "cert"
          ],
          "line": 2630
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "cert"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "cert",
            "k->cert->extensions"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u64",
          "args": [
            "cert",
            "k->cert->valid_before"
          ],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "299-309",
          "snippet": "int\nsshbuf_put_u64(struct sshbuf *buf, u_int64_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 8, &p)) < 0)\n\t\treturn r;\n\tPOKE_U64(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u64(struct sshbuf *buf, u_int64_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 8, &p)) < 0)\n\t\treturn r;\n\tPOKE_U64(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "principals",
            "k->cert->principals[i]"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 2610
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "cert",
            "k->cert->type"
          ],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_pklen",
          "args": [
            "k"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_pklen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "245-253",
          "snippet": "size_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_bignum2",
          "args": [
            "cert",
            "rsa_n"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_bignum2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-crypto.c",
          "lines": "146-166",
          "snippet": "int\nsshbuf_put_bignum2(struct sshbuf *buf, const BIGNUM *v)\n{\n\tu_char d[SSHBUF_MAX_BIGNUM + 1];\n\tint len = BN_num_bytes(v), prepend = 0, r;\n\n\tif (len < 0 || len > SSHBUF_MAX_BIGNUM)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*d = '\\0';\n\tif (BN_bn2bin(v, d + 1) != len)\n\t\treturn SSH_ERR_INTERNAL_ERROR; /* Shouldn't happen */\n\t/* If MSB is set, prepend a \\0 */\n\tif (len > 0 && (d[1] & 0x80) != 0)\n\t\tprepend = 1;\n\tif ((r = sshbuf_put_string(buf, d + 1 - prepend, len + prepend)) < 0) {\n\t\texplicit_bzero(d, sizeof(d));\n\t\treturn r;\n\t}\n\texplicit_bzero(d, sizeof(d));\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n# include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_bignum2(struct sshbuf *buf, const BIGNUM *v)\n{\n\tu_char d[SSHBUF_MAX_BIGNUM + 1];\n\tint len = BN_num_bytes(v), prepend = 0, r;\n\n\tif (len < 0 || len > SSHBUF_MAX_BIGNUM)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*d = '\\0';\n\tif (BN_bn2bin(v, d + 1) != len)\n\t\treturn SSH_ERR_INTERNAL_ERROR; /* Shouldn't happen */\n\t/* If MSB is set, prepend a \\0 */\n\tif (len > 0 && (d[1] & 0x80) != 0)\n\t\tprepend = 1;\n\tif ((r = sshbuf_put_string(buf, d + 1 - prepend, len + prepend)) < 0) {\n\t\texplicit_bzero(d, sizeof(d));\n\t\treturn r;\n\t}\n\texplicit_bzero(d, sizeof(d));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_get0_key",
          "args": [
            "k->rsa",
            "&rsa_n",
            "&rsa_e",
            "NULL"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_get0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "230-239",
          "snippet": "void\nRSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)\n{\n\tif (n != NULL)\n\t\t*n = r->n;\n\tif (e != NULL)\n\t\t*e = r->e;\n\tif (d != NULL)\n\t\t*d = r->d;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nRSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)\n{\n\tif (n != NULL)\n\t\t*n = r->n;\n\tif (e != NULL)\n\t\t*e = r->e;\n\tif (d != NULL)\n\t\t*d = r->d;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_ec",
          "args": [
            "cert",
            "EC_KEY_get0_public_key(k->ecdsa)",
            "EC_KEY_get0_group(k->ecdsa)"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_ec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-crypto.c",
          "lines": "191-215",
          "snippet": "int\nsshbuf_put_ec(struct sshbuf *buf, const EC_POINT *v, const EC_GROUP *g)\n{\n\tu_char d[SSHBUF_MAX_ECPOINT];\n\tBN_CTX *bn_ctx;\n\tsize_t len;\n\tint ret;\n\n\tif ((bn_ctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((len = EC_POINT_point2oct(g, v, POINT_CONVERSION_UNCOMPRESSED,\n\t    NULL, 0, bn_ctx)) > SSHBUF_MAX_ECPOINT) {\n\t\tBN_CTX_free(bn_ctx);\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (EC_POINT_point2oct(g, v, POINT_CONVERSION_UNCOMPRESSED,\n\t    d, len, bn_ctx) != len) {\n\t\tBN_CTX_free(bn_ctx);\n\t\treturn SSH_ERR_INTERNAL_ERROR; /* Shouldn't happen */\n\t}\n\tBN_CTX_free(bn_ctx);\n\tret = sshbuf_put_string(buf, d, len);\n\texplicit_bzero(d, len);\n\treturn ret;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n# include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_ec(struct sshbuf *buf, const EC_POINT *v, const EC_GROUP *g)\n{\n\tu_char d[SSHBUF_MAX_ECPOINT];\n\tBN_CTX *bn_ctx;\n\tsize_t len;\n\tint ret;\n\n\tif ((bn_ctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((len = EC_POINT_point2oct(g, v, POINT_CONVERSION_UNCOMPRESSED,\n\t    NULL, 0, bn_ctx)) > SSHBUF_MAX_ECPOINT) {\n\t\tBN_CTX_free(bn_ctx);\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (EC_POINT_point2oct(g, v, POINT_CONVERSION_UNCOMPRESSED,\n\t    d, len, bn_ctx) != len) {\n\t\tBN_CTX_free(bn_ctx);\n\t\treturn SSH_ERR_INTERNAL_ERROR; /* Shouldn't happen */\n\t}\n\tBN_CTX_free(bn_ctx);\n\tret = sshbuf_put_string(buf, d, len);\n\texplicit_bzero(d, len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "k->ecdsa"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_public_key",
          "args": [
            "k->ecdsa"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_curve_nid_to_name",
          "args": [
            "k->ecdsa_nid"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_curve_nid_to_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "411-426",
          "snippet": "const char *\nsshkey_curve_nid_to_name(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn \"nistp256\";\n\tcase NID_secp384r1:\n\t\treturn \"nistp384\";\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn \"nistp521\";\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_curve_nid_to_name(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn \"nistp256\";\n\tcase NID_secp384r1:\n\t\treturn \"nistp384\";\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn \"nistp521\";\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_get0_key",
          "args": [
            "k->dsa",
            "&dsa_pub_key",
            "NULL"
          ],
          "line": 2559
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_get0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "199-206",
          "snippet": "void\nDSA_get0_key(const DSA *d, const BIGNUM **pub_key, const BIGNUM **priv_key)\n{\n\tif (pub_key != NULL)\n\t\t*pub_key = d->pub_key;\n\tif (priv_key != NULL)\n\t\t*priv_key = d->priv_key;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nDSA_get0_key(const DSA *d, const BIGNUM **pub_key, const BIGNUM **priv_key)\n{\n\tif (pub_key != NULL)\n\t\t*pub_key = d->pub_key;\n\tif (priv_key != NULL)\n\t\t*priv_key = d->priv_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_get0_pqg",
          "args": [
            "k->dsa",
            "&dsa_p",
            "&dsa_q",
            "&dsa_g"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_get0_pqg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "161-170",
          "snippet": "void\nDSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)\n{\n\tif (p != NULL)\n\t\t*p = d->p;\n\tif (q != NULL)\n\t\t*q = d->q;\n\tif (g != NULL)\n\t\t*g = d->g;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nDSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)\n{\n\tif (p != NULL)\n\t\t*p = d->p;\n\tif (q != NULL)\n\t\t*q = d->q;\n\tif (g != NULL)\n\t\t*g = d->g;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4random_buf",
          "args": [
            "&nonce",
            "sizeof(nonce)"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "263-277",
          "snippet": "void\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "k"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_to_blob",
          "args": [
            "ca",
            "&ca_blob",
            "&ca_len"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "880-884",
          "snippet": "int\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_is_valid_ca",
          "args": [
            "ca->type"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_is_valid_ca",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "317-330",
          "snippet": "static int\nsshkey_type_is_valid_ca(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_XMSS:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nsshkey_type_is_valid_ca(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_XMSS:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "k"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_certify_custom(struct sshkey *k, struct sshkey *ca, const char *alg,\n    sshkey_certify_signer *signer, void *signer_ctx)\n{\n\tstruct sshbuf *principals = NULL;\n\tu_char *ca_blob = NULL, *sig_blob = NULL, nonce[32];\n\tsize_t i, ca_len, sig_len;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *cert = NULL;\n\tchar *sigtype = NULL;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (k == NULL || k->cert == NULL ||\n\t    k->cert->certblob == NULL || ca == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_is_cert(k))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tif (!sshkey_type_is_valid_ca(ca->type))\n\t\treturn SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\n\t/*\n\t * If no alg specified as argument but a signature_type was set,\n\t * then prefer that. If both were specified, then they must match.\n\t */\n\tif (alg == NULL)\n\t\talg = k->cert->signature_type;\n\telse if (k->cert->signature_type != NULL &&\n\t    strcmp(alg, k->cert->signature_type) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((ret = sshkey_to_blob(ca, &ca_blob, &ca_len)) != 0)\n\t\treturn SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\n\tcert = k->cert->certblob; /* for readability */\n\tsshbuf_reset(cert);\n\tif ((ret = sshbuf_put_cstring(cert, sshkey_ssh_name(k))) != 0)\n\t\tgoto out;\n\n\t/* -v01 certs put nonce first */\n\tarc4random_buf(&nonce, sizeof(nonce));\n\tif ((ret = sshbuf_put_string(cert, nonce, sizeof(nonce))) != 0)\n\t\tgoto out;\n\n\t/* XXX this substantially duplicates to_blob(); refactor */\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_bignum2(cert, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_pub_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\t\tif ((ret = sshbuf_put_cstring(cert,\n\t\t    sshkey_curve_nid_to_name(k->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_ec(cert,\n\t\t    EC_KEY_get0_public_key(k->ecdsa),\n\t\t    EC_KEY_get0_group(k->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_bignum2(cert, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, rsa_n)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\tif ((ret = sshbuf_put_string(cert,\n\t\t    k->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\tif (k->xmss_name == NULL) {\n\t\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshbuf_put_cstring(cert, k->xmss_name)) ||\n\t\t    (ret = sshbuf_put_string(cert,\n\t\t    k->xmss_pk, sshkey_xmss_pklen(k))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tif ((ret = sshbuf_put_u64(cert, k->cert->serial)) != 0 ||\n\t    (ret = sshbuf_put_u32(cert, k->cert->type)) != 0 ||\n\t    (ret = sshbuf_put_cstring(cert, k->cert->key_id)) != 0)\n\t\tgoto out;\n\n\tif ((principals = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\tif ((ret = sshbuf_put_cstring(principals,\n\t\t    k->cert->principals[i])) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((ret = sshbuf_put_stringb(cert, principals)) != 0 ||\n\t    (ret = sshbuf_put_u64(cert, k->cert->valid_after)) != 0 ||\n\t    (ret = sshbuf_put_u64(cert, k->cert->valid_before)) != 0 ||\n\t    (ret = sshbuf_put_stringb(cert, k->cert->critical)) != 0 ||\n\t    (ret = sshbuf_put_stringb(cert, k->cert->extensions)) != 0 ||\n\t    (ret = sshbuf_put_string(cert, NULL, 0)) != 0 || /* Reserved */\n\t    (ret = sshbuf_put_string(cert, ca_blob, ca_len)) != 0)\n\t\tgoto out;\n\n\t/* Sign the whole mess */\n\tif ((ret = signer(ca, &sig_blob, &sig_len, sshbuf_ptr(cert),\n\t    sshbuf_len(cert), alg, 0, signer_ctx)) != 0)\n\t\tgoto out;\n\t/* Check and update signature_type against what was actually used */\n\tif ((ret = get_sigtype(sig_blob, sig_len, &sigtype)) != 0)\n\t\tgoto out;\n\tif (alg != NULL && strcmp(alg, sigtype) != 0) {\n\t\tret = SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tif (k->cert->signature_type == NULL) {\n\t\tk->cert->signature_type = sigtype;\n\t\tsigtype = NULL;\n\t}\n\t/* Append signature and we are done */\n\tif ((ret = sshbuf_put_string(cert, sig_blob, sig_len)) != 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tif (ret != 0)\n\t\tsshbuf_reset(cert);\n\tfree(sig_blob);\n\tfree(ca_blob);\n\tfree(sigtype);\n\tsshbuf_free(principals);\n\treturn ret;\n}"
  },
  {
    "function_name": "sshkey_drop_cert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2497-2506",
    "snippet": "int\nsshkey_drop_cert(struct sshkey *k)\n{\n\tif (!sshkey_type_is_cert(k->type))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tcert_free(k->cert);\n\tk->cert = NULL;\n\tk->type = sshkey_type_plain(k->type);\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "k->type"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cert_free",
          "args": [
            "k->cert"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "cert_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "446-463",
          "snippet": "static void\ncert_free(struct sshkey_cert *cert)\n{\n\tu_int i;\n\n\tif (cert == NULL)\n\t\treturn;\n\tsshbuf_free(cert->certblob);\n\tsshbuf_free(cert->critical);\n\tsshbuf_free(cert->extensions);\n\tfree(cert->key_id);\n\tfor (i = 0; i < cert->nprincipals; i++)\n\t\tfree(cert->principals[i]);\n\tfree(cert->principals);\n\tsshkey_free(cert->signature_key);\n\tfree(cert->signature_type);\n\tfreezero(cert, sizeof(*cert));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncert_free(struct sshkey_cert *cert)\n{\n\tu_int i;\n\n\tif (cert == NULL)\n\t\treturn;\n\tsshbuf_free(cert->certblob);\n\tsshbuf_free(cert->critical);\n\tsshbuf_free(cert->extensions);\n\tfree(cert->key_id);\n\tfor (i = 0; i < cert->nprincipals; i++)\n\t\tfree(cert->principals[i]);\n\tfree(cert->principals);\n\tsshkey_free(cert->signature_key);\n\tfree(cert->signature_type);\n\tfreezero(cert, sizeof(*cert));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_is_cert",
          "args": [
            "k->type"
          ],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "165-175",
          "snippet": "int\nsshkey_type_is_cert(int type)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type)\n\t\t\treturn kt->cert;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_is_cert(int type)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type)\n\t\t\treturn kt->cert;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_drop_cert(struct sshkey *k)\n{\n\tif (!sshkey_type_is_cert(k->type))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tcert_free(k->cert);\n\tk->cert = NULL;\n\tk->type = sshkey_type_plain(k->type);\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_to_certified",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2462-2494",
    "snippet": "int\nsshkey_to_certified(struct sshkey *k)\n{\n\tint newtype;\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tnewtype = KEY_RSA_CERT;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tnewtype = KEY_DSA_CERT;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tnewtype = KEY_ECDSA_CERT;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tnewtype = KEY_ED25519_CERT;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tnewtype = KEY_XMSS_CERT;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif ((k->cert = cert_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tk->type = newtype;\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cert_new",
          "args": [],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "cert_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "465-483",
          "snippet": "static struct sshkey_cert *\ncert_new(void)\n{\n\tstruct sshkey_cert *cert;\n\n\tif ((cert = calloc(1, sizeof(*cert))) == NULL)\n\t\treturn NULL;\n\tif ((cert->certblob = sshbuf_new()) == NULL ||\n\t    (cert->critical = sshbuf_new()) == NULL ||\n\t    (cert->extensions = sshbuf_new()) == NULL) {\n\t\tcert_free(cert);\n\t\treturn NULL;\n\t}\n\tcert->key_id = NULL;\n\tcert->principals = NULL;\n\tcert->signature_key = NULL;\n\tcert->signature_type = NULL;\n\treturn cert;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshkey_cert *\ncert_new(void)\n{\n\tstruct sshkey_cert *cert;\n\n\tif ((cert = calloc(1, sizeof(*cert))) == NULL)\n\t\treturn NULL;\n\tif ((cert->certblob = sshbuf_new()) == NULL ||\n\t    (cert->critical = sshbuf_new()) == NULL ||\n\t    (cert->extensions = sshbuf_new()) == NULL) {\n\t\tcert_free(cert);\n\t\treturn NULL;\n\t}\n\tcert->key_id = NULL;\n\tcert->principals = NULL;\n\tcert->signature_key = NULL;\n\tcert->signature_type = NULL;\n\treturn cert;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_certified(struct sshkey *k)\n{\n\tint newtype;\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tnewtype = KEY_RSA_CERT;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tnewtype = KEY_DSA_CERT;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tnewtype = KEY_ECDSA_CERT;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tnewtype = KEY_ED25519_CERT;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tnewtype = KEY_XMSS_CERT;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif ((k->cert = cert_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tk->type = newtype;\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2427-2459",
    "snippet": "int\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_xmss_verify",
          "args": [
            "key",
            "sig",
            "siglen",
            "data",
            "dlen",
            "compat"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_xmss_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-xmss.c",
          "lines": "114-191",
          "snippet": "int\nssh_xmss_verify(const struct sshkey *key,\n    const u_char *signature, size_t signaturelen,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tstruct sshbuf *b = NULL;\n\tchar *ktype = NULL;\n\tconst u_char *sigblob;\n\tu_char *sm = NULL, *m = NULL;\n\tsize_t len, required_siglen;\n\tunsigned long long smlen = 0, mlen = 0;\n\tint r, ret;\n\n\tif (key == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_XMSS ||\n\t    key->xmss_pk == NULL ||\n\t    sshkey_xmss_params(key) == NULL ||\n\t    signature == NULL || signaturelen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(key, &required_siglen)) != 0)\n\t\treturn r;\n\tif (datalen >= INT_MAX - required_siglen)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((b = sshbuf_from(signature, signaturelen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &ktype, NULL)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &sigblob, &len)) != 0)\n\t\tgoto out;\n\tif (strcmp(\"ssh-xmss@openssh.com\", ktype) != 0) {\n\t\tr = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\tif (len != required_siglen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (datalen >= SIZE_MAX - len) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tsmlen = len + datalen;\n\tmlen = smlen;\n\tif ((sm = malloc(smlen)) == NULL || (m = malloc(mlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tmemcpy(sm, sigblob, len);\n\tmemcpy(sm+len, data, datalen);\n\tif ((ret = xmss_sign_open(m, &mlen, sm, smlen,\n\t    key->xmss_pk, sshkey_xmss_params(key))) != 0) {\n\t\tdebug2(\"%s: crypto_sign_xmss_open failed: %d\",\n\t\t    __func__, ret);\n\t}\n\tif (ret != 0 || mlen != datalen) {\n\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto out;\n\t}\n\t/* XXX compare 'm' and 'data' ? */\n\t/* success */\n\tr = 0;\n out:\n\tif (sm != NULL) {\n\t\texplicit_bzero(sm, smlen);\n\t\tfree(sm);\n\t}\n\tif (m != NULL) {\n\t\texplicit_bzero(m, smlen); /* NB mlen may be invalid if r != 0 */\n\t\tfree(m);\n\t}\n\tsshbuf_free(b);\n\tfree(ktype);\n\treturn r;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"ssh.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"ssh.h\"\n#include \"ssherr.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_xmss_verify(const struct sshkey *key,\n    const u_char *signature, size_t signaturelen,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tstruct sshbuf *b = NULL;\n\tchar *ktype = NULL;\n\tconst u_char *sigblob;\n\tu_char *sm = NULL, *m = NULL;\n\tsize_t len, required_siglen;\n\tunsigned long long smlen = 0, mlen = 0;\n\tint r, ret;\n\n\tif (key == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_XMSS ||\n\t    key->xmss_pk == NULL ||\n\t    sshkey_xmss_params(key) == NULL ||\n\t    signature == NULL || signaturelen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(key, &required_siglen)) != 0)\n\t\treturn r;\n\tif (datalen >= INT_MAX - required_siglen)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((b = sshbuf_from(signature, signaturelen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &ktype, NULL)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &sigblob, &len)) != 0)\n\t\tgoto out;\n\tif (strcmp(\"ssh-xmss@openssh.com\", ktype) != 0) {\n\t\tr = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\tif (len != required_siglen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (datalen >= SIZE_MAX - len) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tsmlen = len + datalen;\n\tmlen = smlen;\n\tif ((sm = malloc(smlen)) == NULL || (m = malloc(mlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tmemcpy(sm, sigblob, len);\n\tmemcpy(sm+len, data, datalen);\n\tif ((ret = xmss_sign_open(m, &mlen, sm, smlen,\n\t    key->xmss_pk, sshkey_xmss_params(key))) != 0) {\n\t\tdebug2(\"%s: crypto_sign_xmss_open failed: %d\",\n\t\t    __func__, ret);\n\t}\n\tif (ret != 0 || mlen != datalen) {\n\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto out;\n\t}\n\t/* XXX compare 'm' and 'data' ? */\n\t/* success */\n\tr = 0;\n out:\n\tif (sm != NULL) {\n\t\texplicit_bzero(sm, smlen);\n\t\tfree(sm);\n\t}\n\tif (m != NULL) {\n\t\texplicit_bzero(m, smlen); /* NB mlen may be invalid if r != 0 */\n\t\tfree(m);\n\t}\n\tsshbuf_free(b);\n\tfree(ktype);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_ed25519_verify",
          "args": [
            "key",
            "sig",
            "siglen",
            "data",
            "dlen",
            "compat"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_ed25519_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-ed25519.c",
          "lines": "94-167",
          "snippet": "int\nssh_ed25519_verify(const struct sshkey *key,\n    const u_char *signature, size_t signaturelen,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tstruct sshbuf *b = NULL;\n\tchar *ktype = NULL;\n\tconst u_char *sigblob;\n\tu_char *sm = NULL, *m = NULL;\n\tsize_t len;\n\tunsigned long long smlen = 0, mlen = 0;\n\tint r, ret;\n\n\tif (key == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_ED25519 ||\n\t    key->ed25519_pk == NULL ||\n\t    datalen >= INT_MAX - crypto_sign_ed25519_BYTES ||\n\t    signature == NULL || signaturelen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((b = sshbuf_from(signature, signaturelen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &ktype, NULL)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &sigblob, &len)) != 0)\n\t\tgoto out;\n\tif (strcmp(\"ssh-ed25519\", ktype) != 0) {\n\t\tr = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\tif (len > crypto_sign_ed25519_BYTES) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (datalen >= SIZE_MAX - len) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tsmlen = len + datalen;\n\tmlen = smlen;\n\tif ((sm = malloc(smlen)) == NULL || (m = malloc(mlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tmemcpy(sm, sigblob, len);\n\tmemcpy(sm+len, data, datalen);\n\tif ((ret = crypto_sign_ed25519_open(m, &mlen, sm, smlen,\n\t    key->ed25519_pk)) != 0) {\n\t\tdebug2(\"%s: crypto_sign_ed25519_open failed: %d\",\n\t\t    __func__, ret);\n\t}\n\tif (ret != 0 || mlen != datalen) {\n\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto out;\n\t}\n\t/* XXX compare 'm' and 'data' ? */\n\t/* success */\n\tr = 0;\n out:\n\tif (sm != NULL) {\n\t\texplicit_bzero(sm, smlen);\n\t\tfree(sm);\n\t}\n\tif (m != NULL) {\n\t\texplicit_bzero(m, smlen); /* NB mlen may be invalid if r != 0 */\n\t\tfree(m);\n\t}\n\tsshbuf_free(b);\n\tfree(ktype);\n\treturn r;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include \"crypto_api.h\"",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include \"crypto_api.h\"\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_ed25519_verify(const struct sshkey *key,\n    const u_char *signature, size_t signaturelen,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tstruct sshbuf *b = NULL;\n\tchar *ktype = NULL;\n\tconst u_char *sigblob;\n\tu_char *sm = NULL, *m = NULL;\n\tsize_t len;\n\tunsigned long long smlen = 0, mlen = 0;\n\tint r, ret;\n\n\tif (key == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_ED25519 ||\n\t    key->ed25519_pk == NULL ||\n\t    datalen >= INT_MAX - crypto_sign_ed25519_BYTES ||\n\t    signature == NULL || signaturelen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((b = sshbuf_from(signature, signaturelen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &ktype, NULL)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &sigblob, &len)) != 0)\n\t\tgoto out;\n\tif (strcmp(\"ssh-ed25519\", ktype) != 0) {\n\t\tr = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\tif (len > crypto_sign_ed25519_BYTES) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (datalen >= SIZE_MAX - len) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tsmlen = len + datalen;\n\tmlen = smlen;\n\tif ((sm = malloc(smlen)) == NULL || (m = malloc(mlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tmemcpy(sm, sigblob, len);\n\tmemcpy(sm+len, data, datalen);\n\tif ((ret = crypto_sign_ed25519_open(m, &mlen, sm, smlen,\n\t    key->ed25519_pk)) != 0) {\n\t\tdebug2(\"%s: crypto_sign_ed25519_open failed: %d\",\n\t\t    __func__, ret);\n\t}\n\tif (ret != 0 || mlen != datalen) {\n\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto out;\n\t}\n\t/* XXX compare 'm' and 'data' ? */\n\t/* success */\n\tr = 0;\n out:\n\tif (sm != NULL) {\n\t\texplicit_bzero(sm, smlen);\n\t\tfree(sm);\n\t}\n\tif (m != NULL) {\n\t\texplicit_bzero(m, smlen); /* NB mlen may be invalid if r != 0 */\n\t\tfree(m);\n\t}\n\tsshbuf_free(b);\n\tfree(ktype);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_rsa_verify",
          "args": [
            "key",
            "sig",
            "siglen",
            "data",
            "dlen",
            "alg"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_rsa_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-rsa.c",
          "lines": "244-329",
          "snippet": "int\nssh_rsa_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen, const u_char *data, size_t datalen,\n    const char *alg)\n{\n\tconst BIGNUM *rsa_n;\n\tchar *sigtype = NULL;\n\tint hash_alg, want_alg, ret = SSH_ERR_INTERNAL_ERROR;\n\tsize_t len = 0, diff, modlen, dlen;\n\tstruct sshbuf *b = NULL;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH], *osigblob, *sigblob = NULL;\n\n\tif (key == NULL || key->rsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_RSA ||\n\t    sig == NULL || siglen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tRSA_get0_key(key->rsa, &rsa_n, NULL, NULL);\n\tif (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (sshbuf_get_cstring(b, &sigtype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((hash_alg = rsa_hash_id_from_ident(sigtype)) == -1) {\n\t\tret = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\t/*\n\t * Allow ssh-rsa-cert-v01 certs to generate SHA2 signatures for\n\t * legacy reasons, but otherwise the signature type should match.\n\t */\n\tif (alg != NULL && strcmp(alg, \"ssh-rsa-cert-v01@openssh.com\") != 0) {\n\t\tif ((want_alg = rsa_hash_id_from_keyname(alg)) == -1) {\n\t\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (hash_alg != want_alg) {\n\t\t\tret = SSH_ERR_SIGNATURE_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (sshbuf_get_string(b, &sigblob, &len) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\t/* RSA_verify expects a signature of RSA_size */\n\tmodlen = RSA_size(key->rsa);\n\tif (len > modlen) {\n\t\tret = SSH_ERR_KEY_BITS_MISMATCH;\n\t\tgoto out;\n\t} else if (len < modlen) {\n\t\tdiff = modlen - len;\n\t\tosigblob = sigblob;\n\t\tif ((sigblob = realloc(sigblob, modlen)) == NULL) {\n\t\t\tsigblob = osigblob; /* put it back for clear/free */\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemmove(sigblob + diff, sigblob, len);\n\t\texplicit_bzero(sigblob, diff);\n\t\tlen = modlen;\n\t}\n\tif ((dlen = ssh_digest_bytes(hash_alg)) == 0) {\n\t\tret = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tif ((ret = ssh_digest_memory(hash_alg, data, datalen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tret = openssh_RSA_verify(hash_alg, digest, dlen, sigblob, len,\n\t    key->rsa);\n out:\n\tfreezero(sigblob, len);\n\tfree(sigtype);\n\tsshbuf_free(b);\n\texplicit_bzero(digest, sizeof(digest));\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"log.h\"",
            "#include \"digest.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"log.h\"\n#include \"digest.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include <string.h>\n#include <stdarg.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_rsa_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen, const u_char *data, size_t datalen,\n    const char *alg)\n{\n\tconst BIGNUM *rsa_n;\n\tchar *sigtype = NULL;\n\tint hash_alg, want_alg, ret = SSH_ERR_INTERNAL_ERROR;\n\tsize_t len = 0, diff, modlen, dlen;\n\tstruct sshbuf *b = NULL;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH], *osigblob, *sigblob = NULL;\n\n\tif (key == NULL || key->rsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_RSA ||\n\t    sig == NULL || siglen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tRSA_get0_key(key->rsa, &rsa_n, NULL, NULL);\n\tif (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (sshbuf_get_cstring(b, &sigtype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((hash_alg = rsa_hash_id_from_ident(sigtype)) == -1) {\n\t\tret = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\t/*\n\t * Allow ssh-rsa-cert-v01 certs to generate SHA2 signatures for\n\t * legacy reasons, but otherwise the signature type should match.\n\t */\n\tif (alg != NULL && strcmp(alg, \"ssh-rsa-cert-v01@openssh.com\") != 0) {\n\t\tif ((want_alg = rsa_hash_id_from_keyname(alg)) == -1) {\n\t\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (hash_alg != want_alg) {\n\t\t\tret = SSH_ERR_SIGNATURE_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (sshbuf_get_string(b, &sigblob, &len) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\t/* RSA_verify expects a signature of RSA_size */\n\tmodlen = RSA_size(key->rsa);\n\tif (len > modlen) {\n\t\tret = SSH_ERR_KEY_BITS_MISMATCH;\n\t\tgoto out;\n\t} else if (len < modlen) {\n\t\tdiff = modlen - len;\n\t\tosigblob = sigblob;\n\t\tif ((sigblob = realloc(sigblob, modlen)) == NULL) {\n\t\t\tsigblob = osigblob; /* put it back for clear/free */\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemmove(sigblob + diff, sigblob, len);\n\t\texplicit_bzero(sigblob, diff);\n\t\tlen = modlen;\n\t}\n\tif ((dlen = ssh_digest_bytes(hash_alg)) == 0) {\n\t\tret = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tif ((ret = ssh_digest_memory(hash_alg, data, datalen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tret = openssh_RSA_verify(hash_alg, digest, dlen, sigblob, len,\n\t    key->rsa);\n out:\n\tfreezero(sigblob, len);\n\tfree(sigtype);\n\tsshbuf_free(b);\n\texplicit_bzero(digest, sizeof(digest));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_ecdsa_verify",
          "args": [
            "key",
            "sig",
            "siglen",
            "data",
            "dlen",
            "compat"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_ecdsa_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-ecdsa.c",
          "lines": "113-200",
          "snippet": "int\nssh_ecdsa_verify(const struct sshkey *key,\n    const u_char *signature, size_t signaturelen,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tECDSA_SIG *sig = NULL;\n\tBIGNUM *sig_r = NULL, *sig_s = NULL;\n\tint hash_alg;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH];\n\tsize_t dlen;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL, *sigbuf = NULL;\n\tchar *ktype = NULL;\n\n\tif (key == NULL || key->ecdsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_ECDSA ||\n\t    signature == NULL || signaturelen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((hash_alg = sshkey_ec_nid_to_hash_alg(key->ecdsa_nid)) == -1 ||\n\t    (dlen = ssh_digest_bytes(hash_alg)) == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\t/* fetch signature */\n\tif ((b = sshbuf_from(signature, signaturelen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0 ||\n\t    sshbuf_froms(b, &sigbuf) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (strcmp(sshkey_ssh_name_plain(key), ktype) != 0) {\n\t\tret = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\n\t/* parse signature */\n\tif ((sig = ECDSA_SIG_new()) == NULL ||\n\t    (sig_r = BN_new()) == NULL ||\n\t    (sig_s = BN_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshbuf_get_bignum2(sigbuf, sig_r) != 0 ||\n\t    sshbuf_get_bignum2(sigbuf, sig_s) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (!ECDSA_SIG_set0(sig, sig_r, sig_s)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tsig_r = sig_s = NULL; /* transferred */\n\n\tif (sshbuf_len(sigbuf) != 0) {\n\t\tret = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\tif ((ret = ssh_digest_memory(hash_alg, data, datalen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tswitch (ECDSA_do_verify(digest, dlen, sig, key->ecdsa)) {\n\tcase 1:\n\t\tret = 0;\n\t\tbreak;\n\tcase 0:\n\t\tret = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto out;\n\tdefault:\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tsshbuf_free(sigbuf);\n\tsshbuf_free(b);\n\tECDSA_SIG_free(sig);\n\tBN_clear_free(sig_r);\n\tBN_clear_free(sig_s);\n\tfree(ktype);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <string.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <string.h>\n#include <openssl/evp.h>\n#include <openssl/ecdsa.h>\n#include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_ecdsa_verify(const struct sshkey *key,\n    const u_char *signature, size_t signaturelen,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tECDSA_SIG *sig = NULL;\n\tBIGNUM *sig_r = NULL, *sig_s = NULL;\n\tint hash_alg;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH];\n\tsize_t dlen;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL, *sigbuf = NULL;\n\tchar *ktype = NULL;\n\n\tif (key == NULL || key->ecdsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_ECDSA ||\n\t    signature == NULL || signaturelen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((hash_alg = sshkey_ec_nid_to_hash_alg(key->ecdsa_nid)) == -1 ||\n\t    (dlen = ssh_digest_bytes(hash_alg)) == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\t/* fetch signature */\n\tif ((b = sshbuf_from(signature, signaturelen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0 ||\n\t    sshbuf_froms(b, &sigbuf) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (strcmp(sshkey_ssh_name_plain(key), ktype) != 0) {\n\t\tret = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\n\t/* parse signature */\n\tif ((sig = ECDSA_SIG_new()) == NULL ||\n\t    (sig_r = BN_new()) == NULL ||\n\t    (sig_s = BN_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshbuf_get_bignum2(sigbuf, sig_r) != 0 ||\n\t    sshbuf_get_bignum2(sigbuf, sig_s) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (!ECDSA_SIG_set0(sig, sig_r, sig_s)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tsig_r = sig_s = NULL; /* transferred */\n\n\tif (sshbuf_len(sigbuf) != 0) {\n\t\tret = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\tif ((ret = ssh_digest_memory(hash_alg, data, datalen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tswitch (ECDSA_do_verify(digest, dlen, sig, key->ecdsa)) {\n\tcase 1:\n\t\tret = 0;\n\t\tbreak;\n\tcase 0:\n\t\tret = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto out;\n\tdefault:\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tsshbuf_free(sigbuf);\n\tsshbuf_free(b);\n\tECDSA_SIG_free(sig);\n\tBN_clear_free(sig_r);\n\tBN_clear_free(sig_s);\n\tfree(ktype);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_dss_verify",
          "args": [
            "key",
            "sig",
            "siglen",
            "data",
            "dlen",
            "compat"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dss_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-dss.c",
          "lines": "119-208",
          "snippet": "int\nssh_dss_verify(const struct sshkey *key,\n    const u_char *signature, size_t signaturelen,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tDSA_SIG *sig = NULL;\n\tBIGNUM *sig_r = NULL, *sig_s = NULL;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH], *sigblob = NULL;\n\tsize_t len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\tchar *ktype = NULL;\n\n\tif (key == NULL || key->dsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_DSA ||\n\t    signature == NULL || signaturelen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (dlen == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\t/* fetch signature */\n\tif ((b = sshbuf_from(signature, signaturelen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0 ||\n\t    sshbuf_get_string(b, &sigblob, &len) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (strcmp(\"ssh-dss\", ktype) != 0) {\n\t\tret = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\n\tif (len != SIGBLOB_LEN) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* parse signature */\n\tif ((sig = DSA_SIG_new()) == NULL ||\n\t    (sig_r = BN_new()) == NULL ||\n\t    (sig_s = BN_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((BN_bin2bn(sigblob, INTBLOB_LEN, sig_r) == NULL) ||\n\t    (BN_bin2bn(sigblob + INTBLOB_LEN, INTBLOB_LEN, sig_s) == NULL)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (!DSA_SIG_set0(sig, sig_r, sig_s)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tsig_r = sig_s = NULL; /* transferred */\n\n\t/* sha1 the data */\n\tif ((ret = ssh_digest_memory(SSH_DIGEST_SHA1, data, datalen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tswitch (DSA_do_verify(digest, dlen, sig, key->dsa)) {\n\tcase 1:\n\t\tret = 0;\n\t\tbreak;\n\tcase 0:\n\t\tret = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto out;\n\tdefault:\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tDSA_SIG_free(sig);\n\tBN_clear_free(sig_r);\n\tBN_clear_free(sig_s);\n\tsshbuf_free(b);\n\tfree(ktype);\n\tif (sigblob != NULL) {\n\t\texplicit_bzero(sigblob, len);\n\t\tfree(sigblob);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SIGBLOB_LEN\t(2*INTBLOB_LEN)",
            "#define INTBLOB_LEN\t20"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include <string.h>\n#include <stdarg.h>\n#include <openssl/evp.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SIGBLOB_LEN\t(2*INTBLOB_LEN)\n#define INTBLOB_LEN\t20\n\nint\nssh_dss_verify(const struct sshkey *key,\n    const u_char *signature, size_t signaturelen,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tDSA_SIG *sig = NULL;\n\tBIGNUM *sig_r = NULL, *sig_s = NULL;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH], *sigblob = NULL;\n\tsize_t len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\tchar *ktype = NULL;\n\n\tif (key == NULL || key->dsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_DSA ||\n\t    signature == NULL || signaturelen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (dlen == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\t/* fetch signature */\n\tif ((b = sshbuf_from(signature, signaturelen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0 ||\n\t    sshbuf_get_string(b, &sigblob, &len) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (strcmp(\"ssh-dss\", ktype) != 0) {\n\t\tret = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\n\tif (len != SIGBLOB_LEN) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* parse signature */\n\tif ((sig = DSA_SIG_new()) == NULL ||\n\t    (sig_r = BN_new()) == NULL ||\n\t    (sig_s = BN_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((BN_bin2bn(sigblob, INTBLOB_LEN, sig_r) == NULL) ||\n\t    (BN_bin2bn(sigblob + INTBLOB_LEN, INTBLOB_LEN, sig_s) == NULL)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (!DSA_SIG_set0(sig, sig_r, sig_s)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tsig_r = sig_s = NULL; /* transferred */\n\n\t/* sha1 the data */\n\tif ((ret = ssh_digest_memory(SSH_DIGEST_SHA1, data, datalen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tswitch (DSA_do_verify(digest, dlen, sig, key->dsa)) {\n\tcase 1:\n\t\tret = 0;\n\t\tbreak;\n\tcase 0:\n\t\tret = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto out;\n\tdefault:\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tDSA_SIG_free(sig);\n\tBN_clear_free(sig_r);\n\tBN_clear_free(sig_s);\n\tsshbuf_free(b);\n\tfree(ktype);\n\tif (sigblob != NULL) {\n\t\texplicit_bzero(sigblob, len);\n\t\tfree(sigblob);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
  },
  {
    "function_name": "sshkey_sign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2385-2421",
    "snippet": "int\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_xmss_sign",
          "args": [
            "key",
            "sigp",
            "lenp",
            "data",
            "datalen",
            "compat"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_xmss_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-xmss.c",
          "lines": "38-112",
          "snippet": "int\nssh_xmss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tu_char *sig = NULL;\n\tsize_t slen = 0, len = 0, required_siglen;\n\tunsigned long long smlen;\n\tint r, ret;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (key == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_XMSS ||\n\t    key->xmss_sk == NULL ||\n\t    sshkey_xmss_params(key) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(key, &required_siglen)) != 0)\n\t\treturn r;\n\tif (datalen >= INT_MAX - required_siglen)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tsmlen = slen = datalen + required_siglen;\n\tif ((sig = malloc(slen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_xmss_get_state(key, error)) != 0)\n\t\tgoto out;\n\tif ((ret = xmss_sign(key->xmss_sk, sshkey_xmss_bds_state(key), sig, &smlen,\n\t    data, datalen, sshkey_xmss_params(key))) != 0 || smlen <= datalen) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT; /* XXX better error? */\n\t\tgoto out;\n\t}\n\t/* encode signature */\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_cstring(b, \"ssh-xmss@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_string(b, sig, smlen - datalen)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\t/* success */\n\tr = 0;\n out:\n\tif ((ret = sshkey_xmss_update_state(key, error)) != 0) {\n\t\t/* discard signature since we cannot update the state */\n\t\tif (r == 0 && sigp != NULL && *sigp != NULL) {\n\t\t\texplicit_bzero(*sigp, len);\n\t\t\tfree(*sigp);\n\t\t}\n\t\tif (sigp != NULL)\n\t\t\t*sigp = NULL;\n\t\tif (lenp != NULL)\n\t\t\t*lenp = 0;\n\t\tr = ret;\n\t}\n\tsshbuf_free(b);\n\tif (sig != NULL) {\n\t\texplicit_bzero(sig, slen);\n\t\tfree(sig);\n\t}\n\n\treturn r;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"ssh.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"ssh.h\"\n#include \"ssherr.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_xmss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tu_char *sig = NULL;\n\tsize_t slen = 0, len = 0, required_siglen;\n\tunsigned long long smlen;\n\tint r, ret;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (key == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_XMSS ||\n\t    key->xmss_sk == NULL ||\n\t    sshkey_xmss_params(key) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(key, &required_siglen)) != 0)\n\t\treturn r;\n\tif (datalen >= INT_MAX - required_siglen)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tsmlen = slen = datalen + required_siglen;\n\tif ((sig = malloc(slen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_xmss_get_state(key, error)) != 0)\n\t\tgoto out;\n\tif ((ret = xmss_sign(key->xmss_sk, sshkey_xmss_bds_state(key), sig, &smlen,\n\t    data, datalen, sshkey_xmss_params(key))) != 0 || smlen <= datalen) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT; /* XXX better error? */\n\t\tgoto out;\n\t}\n\t/* encode signature */\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_cstring(b, \"ssh-xmss@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_string(b, sig, smlen - datalen)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\t/* success */\n\tr = 0;\n out:\n\tif ((ret = sshkey_xmss_update_state(key, error)) != 0) {\n\t\t/* discard signature since we cannot update the state */\n\t\tif (r == 0 && sigp != NULL && *sigp != NULL) {\n\t\t\texplicit_bzero(*sigp, len);\n\t\t\tfree(*sigp);\n\t\t}\n\t\tif (sigp != NULL)\n\t\t\t*sigp = NULL;\n\t\tif (lenp != NULL)\n\t\t\t*lenp = 0;\n\t\tr = ret;\n\t}\n\tsshbuf_free(b);\n\tif (sig != NULL) {\n\t\texplicit_bzero(sig, slen);\n\t\tfree(sig);\n\t}\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_ed25519_sign",
          "args": [
            "key",
            "sigp",
            "lenp",
            "data",
            "datalen",
            "compat"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_ed25519_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-ed25519.c",
          "lines": "35-92",
          "snippet": "int\nssh_ed25519_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tu_char *sig = NULL;\n\tsize_t slen = 0, len;\n\tunsigned long long smlen;\n\tint r, ret;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (key == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_ED25519 ||\n\t    key->ed25519_sk == NULL ||\n\t    datalen >= INT_MAX - crypto_sign_ed25519_BYTES)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tsmlen = slen = datalen + crypto_sign_ed25519_BYTES;\n\tif ((sig = malloc(slen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((ret = crypto_sign_ed25519(sig, &smlen, data, datalen,\n\t    key->ed25519_sk)) != 0 || smlen <= datalen) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT; /* XXX better error? */\n\t\tgoto out;\n\t}\n\t/* encode signature */\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_cstring(b, \"ssh-ed25519\")) != 0 ||\n\t    (r = sshbuf_put_string(b, sig, smlen - datalen)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\t/* success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tif (sig != NULL) {\n\t\texplicit_bzero(sig, slen);\n\t\tfree(sig);\n\t}\n\n\treturn r;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include \"crypto_api.h\"",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include \"crypto_api.h\"\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_ed25519_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tu_char *sig = NULL;\n\tsize_t slen = 0, len;\n\tunsigned long long smlen;\n\tint r, ret;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (key == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_ED25519 ||\n\t    key->ed25519_sk == NULL ||\n\t    datalen >= INT_MAX - crypto_sign_ed25519_BYTES)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tsmlen = slen = datalen + crypto_sign_ed25519_BYTES;\n\tif ((sig = malloc(slen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((ret = crypto_sign_ed25519(sig, &smlen, data, datalen,\n\t    key->ed25519_sk)) != 0 || smlen <= datalen) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT; /* XXX better error? */\n\t\tgoto out;\n\t}\n\t/* encode signature */\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_cstring(b, \"ssh-ed25519\")) != 0 ||\n\t    (r = sshbuf_put_string(b, sig, smlen - datalen)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\t/* success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tif (sig != NULL) {\n\t\texplicit_bzero(sig, slen);\n\t\tfree(sig);\n\t}\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_rsa_sign",
          "args": [
            "key",
            "sigp",
            "lenp",
            "data",
            "datalen",
            "alg"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_rsa_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-rsa.c",
          "lines": "163-242",
          "snippet": "int\nssh_rsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg_ident)\n{\n\tconst BIGNUM *rsa_n;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH], *sig = NULL;\n\tsize_t slen = 0;\n\tu_int dlen, len;\n\tint nid, hash_alg, ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (alg_ident == NULL || strlen(alg_ident) == 0)\n\t\thash_alg = SSH_DIGEST_SHA1;\n\telse\n\t\thash_alg = rsa_hash_id_from_keyname(alg_ident);\n\tif (key == NULL || key->rsa == NULL || hash_alg == -1 ||\n\t    sshkey_type_plain(key->type) != KEY_RSA)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tRSA_get0_key(key->rsa, &rsa_n, NULL, NULL);\n\tif (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\tslen = RSA_size(key->rsa);\n\tif (slen <= 0 || slen > SSHBUF_MAX_BIGNUM)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\t/* hash the data */\n\tnid = rsa_hash_alg_nid(hash_alg);\n\tif ((dlen = ssh_digest_bytes(hash_alg)) == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((ret = ssh_digest_memory(hash_alg, data, datalen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tif ((sig = malloc(slen)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tif (RSA_sign(nid, digest, dlen, sig, &len, key->rsa) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (len < slen) {\n\t\tsize_t diff = slen - len;\n\t\tmemmove(sig + diff, sig, len);\n\t\texplicit_bzero(sig, diff);\n\t} else if (len > slen) {\n\t\tret = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\t/* encode signature */\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((ret = sshbuf_put_cstring(b, rsa_hash_alg_ident(hash_alg))) != 0 ||\n\t    (ret = sshbuf_put_string(b, sig, slen)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tret = 0;\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tfreezero(sig, slen);\n\tsshbuf_free(b);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"log.h\"",
            "#include \"digest.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"log.h\"\n#include \"digest.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include <string.h>\n#include <stdarg.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_rsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg_ident)\n{\n\tconst BIGNUM *rsa_n;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH], *sig = NULL;\n\tsize_t slen = 0;\n\tu_int dlen, len;\n\tint nid, hash_alg, ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (alg_ident == NULL || strlen(alg_ident) == 0)\n\t\thash_alg = SSH_DIGEST_SHA1;\n\telse\n\t\thash_alg = rsa_hash_id_from_keyname(alg_ident);\n\tif (key == NULL || key->rsa == NULL || hash_alg == -1 ||\n\t    sshkey_type_plain(key->type) != KEY_RSA)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tRSA_get0_key(key->rsa, &rsa_n, NULL, NULL);\n\tif (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\tslen = RSA_size(key->rsa);\n\tif (slen <= 0 || slen > SSHBUF_MAX_BIGNUM)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\t/* hash the data */\n\tnid = rsa_hash_alg_nid(hash_alg);\n\tif ((dlen = ssh_digest_bytes(hash_alg)) == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((ret = ssh_digest_memory(hash_alg, data, datalen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tif ((sig = malloc(slen)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tif (RSA_sign(nid, digest, dlen, sig, &len, key->rsa) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (len < slen) {\n\t\tsize_t diff = slen - len;\n\t\tmemmove(sig + diff, sig, len);\n\t\texplicit_bzero(sig, diff);\n\t} else if (len > slen) {\n\t\tret = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\t/* encode signature */\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((ret = sshbuf_put_cstring(b, rsa_hash_alg_ident(hash_alg))) != 0 ||\n\t    (ret = sshbuf_put_string(b, sig, slen)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tret = 0;\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tfreezero(sig, slen);\n\tsshbuf_free(b);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_ecdsa_sign",
          "args": [
            "key",
            "sigp",
            "lenp",
            "data",
            "datalen",
            "compat"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_ecdsa_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-ecdsa.c",
          "lines": "49-110",
          "snippet": "int\nssh_ecdsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tECDSA_SIG *sig = NULL;\n\tconst BIGNUM *sig_r, *sig_s;\n\tint hash_alg;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH];\n\tsize_t len, dlen;\n\tstruct sshbuf *b = NULL, *bb = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (key == NULL || key->ecdsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_ECDSA)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((hash_alg = sshkey_ec_nid_to_hash_alg(key->ecdsa_nid)) == -1 ||\n\t    (dlen = ssh_digest_bytes(hash_alg)) == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((ret = ssh_digest_memory(hash_alg, data, datalen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tif ((sig = ECDSA_do_sign(digest, dlen, key->ecdsa)) == NULL) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n\tif ((bb = sshbuf_new()) == NULL || (b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tECDSA_SIG_get0(sig, &sig_r, &sig_s);\n\tif ((ret = sshbuf_put_bignum2(bb, sig_r)) != 0 ||\n\t    (ret = sshbuf_put_bignum2(bb, sig_s)) != 0)\n\t\tgoto out;\n\tif ((ret = sshbuf_put_cstring(b, sshkey_ssh_name_plain(key))) != 0 ||\n\t    (ret = sshbuf_put_stringb(b, bb)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tret = 0;\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tsshbuf_free(b);\n\tsshbuf_free(bb);\n\tECDSA_SIG_free(sig);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <string.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <string.h>\n#include <openssl/evp.h>\n#include <openssl/ecdsa.h>\n#include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_ecdsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tECDSA_SIG *sig = NULL;\n\tconst BIGNUM *sig_r, *sig_s;\n\tint hash_alg;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH];\n\tsize_t len, dlen;\n\tstruct sshbuf *b = NULL, *bb = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (key == NULL || key->ecdsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_ECDSA)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((hash_alg = sshkey_ec_nid_to_hash_alg(key->ecdsa_nid)) == -1 ||\n\t    (dlen = ssh_digest_bytes(hash_alg)) == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((ret = ssh_digest_memory(hash_alg, data, datalen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tif ((sig = ECDSA_do_sign(digest, dlen, key->ecdsa)) == NULL) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n\tif ((bb = sshbuf_new()) == NULL || (b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tECDSA_SIG_get0(sig, &sig_r, &sig_s);\n\tif ((ret = sshbuf_put_bignum2(bb, sig_r)) != 0 ||\n\t    (ret = sshbuf_put_bignum2(bb, sig_s)) != 0)\n\t\tgoto out;\n\tif ((ret = sshbuf_put_cstring(b, sshkey_ssh_name_plain(key))) != 0 ||\n\t    (ret = sshbuf_put_stringb(b, bb)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tret = 0;\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tsshbuf_free(b);\n\tsshbuf_free(bb);\n\tECDSA_SIG_free(sig);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_dss_sign",
          "args": [
            "key",
            "sigp",
            "lenp",
            "data",
            "datalen",
            "compat"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dss_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-dss.c",
          "lines": "51-117",
          "snippet": "int\nssh_dss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tDSA_SIG *sig = NULL;\n\tconst BIGNUM *sig_r, *sig_s;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH], sigblob[SIGBLOB_LEN];\n\tsize_t rlen, slen, len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);\n\tstruct sshbuf *b = NULL;\n\tint ret = SSH_ERR_INVALID_ARGUMENT;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (key == NULL || key->dsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_DSA)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (dlen == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\tif ((ret = ssh_digest_memory(SSH_DIGEST_SHA1, data, datalen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tif ((sig = DSA_do_sign(digest, dlen, key->dsa)) == NULL) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n\tDSA_SIG_get0(sig, &sig_r, &sig_s);\n\trlen = BN_num_bytes(sig_r);\n\tslen = BN_num_bytes(sig_s);\n\tif (rlen > INTBLOB_LEN || slen > INTBLOB_LEN) {\n\t\tret = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\texplicit_bzero(sigblob, SIGBLOB_LEN);\n\tBN_bn2bin(sig_r, sigblob + SIGBLOB_LEN - INTBLOB_LEN - rlen);\n\tBN_bn2bin(sig_s, sigblob + SIGBLOB_LEN - slen);\n\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((ret = sshbuf_put_cstring(b, \"ssh-dss\")) != 0 ||\n\t    (ret = sshbuf_put_string(b, sigblob, SIGBLOB_LEN)) != 0)\n\t\tgoto out;\n\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tret = 0;\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tDSA_SIG_free(sig);\n\tsshbuf_free(b);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SIGBLOB_LEN\t(2*INTBLOB_LEN)",
            "#define INTBLOB_LEN\t20"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include <string.h>\n#include <stdarg.h>\n#include <openssl/evp.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SIGBLOB_LEN\t(2*INTBLOB_LEN)\n#define INTBLOB_LEN\t20\n\nint\nssh_dss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tDSA_SIG *sig = NULL;\n\tconst BIGNUM *sig_r, *sig_s;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH], sigblob[SIGBLOB_LEN];\n\tsize_t rlen, slen, len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);\n\tstruct sshbuf *b = NULL;\n\tint ret = SSH_ERR_INVALID_ARGUMENT;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (key == NULL || key->dsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_DSA)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (dlen == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\tif ((ret = ssh_digest_memory(SSH_DIGEST_SHA1, data, datalen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tif ((sig = DSA_do_sign(digest, dlen, key->dsa)) == NULL) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n\tDSA_SIG_get0(sig, &sig_r, &sig_s);\n\trlen = BN_num_bytes(sig_r);\n\tslen = BN_num_bytes(sig_s);\n\tif (rlen > INTBLOB_LEN || slen > INTBLOB_LEN) {\n\t\tret = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\texplicit_bzero(sigblob, SIGBLOB_LEN);\n\tBN_bn2bin(sig_r, sigblob + SIGBLOB_LEN - INTBLOB_LEN - rlen);\n\tBN_bn2bin(sig_s, sigblob + SIGBLOB_LEN - slen);\n\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((ret = sshbuf_put_cstring(b, \"ssh-dss\")) != 0 ||\n\t    (ret = sshbuf_put_string(b, sigblob, SIGBLOB_LEN)) != 0)\n\t\tgoto out;\n\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tret = 0;\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tDSA_SIG_free(sig);\n\tsshbuf_free(b);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
  },
  {
    "function_name": "sshkey_check_sigtype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2366-2383",
    "snippet": "int\nsshkey_check_sigtype(const u_char *sig, size_t siglen,\n    const char *requested_alg)\n{\n\tconst char *expected_alg;\n\tchar *sigtype = NULL;\n\tint r;\n\n\tif (requested_alg == NULL)\n\t\treturn 0;\n\tif ((expected_alg = sshkey_sigalg_by_name(requested_alg)) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = get_sigtype(sig, siglen, &sigtype)) != 0)\n\t\treturn r;\n\tr = strcmp(expected_alg, sigtype) == 0;\n\tfree(sigtype);\n\treturn r ? 0 : SSH_ERR_SIGN_ALG_UNSUPPORTED;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sigtype"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "expected_alg",
            "sigtype"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_sigtype",
          "args": [
            "sig",
            "siglen",
            "&sigtype"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "get_sigtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2295-2318",
          "snippet": "static int\nget_sigtype(const u_char *sig, size_t siglen, char **sigtypep)\n{\n\tint r;\n\tstruct sshbuf *b = NULL;\n\tchar *sigtype = NULL;\n\n\tif (sigtypep != NULL)\n\t\t*sigtypep = NULL;\n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &sigtype, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (sigtypep != NULL) {\n\t\t*sigtypep = sigtype;\n\t\tsigtype = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(sigtype);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int get_sigtype(const u_char *sig, size_t siglen, char **sigtypep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int get_sigtype(const u_char *sig, size_t siglen, char **sigtypep);\n\nstatic int\nget_sigtype(const u_char *sig, size_t siglen, char **sigtypep)\n{\n\tint r;\n\tstruct sshbuf *b = NULL;\n\tchar *sigtype = NULL;\n\n\tif (sigtypep != NULL)\n\t\t*sigtypep = NULL;\n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &sigtype, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (sigtypep != NULL) {\n\t\t*sigtypep = sigtype;\n\t\tsigtype = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(sigtype);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_sigalg_by_name",
          "args": [
            "requested_alg"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_sigalg_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2344-2360",
          "snippet": "const char *\nsshkey_sigalg_by_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (strcmp(kt->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (kt->sigalg != NULL)\n\t\t\treturn kt->sigalg;\n\t\tif (!kt->cert)\n\t\t\treturn kt->name;\n\t\treturn sshkey_ssh_name_from_type_nid(\n\t\t    sshkey_type_plain(kt->type), kt->nid);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nconst char *\nsshkey_sigalg_by_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (strcmp(kt->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (kt->sigalg != NULL)\n\t\t\treturn kt->sigalg;\n\t\tif (!kt->cert)\n\t\t\treturn kt->name;\n\t\treturn sshkey_ssh_name_from_type_nid(\n\t\t    sshkey_type_plain(kt->type), kt->nid);\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_check_sigtype(const u_char *sig, size_t siglen,\n    const char *requested_alg)\n{\n\tconst char *expected_alg;\n\tchar *sigtype = NULL;\n\tint r;\n\n\tif (requested_alg == NULL)\n\t\treturn 0;\n\tif ((expected_alg = sshkey_sigalg_by_name(requested_alg)) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = get_sigtype(sig, siglen, &sigtype)) != 0)\n\t\treturn r;\n\tr = strcmp(expected_alg, sigtype) == 0;\n\tfree(sigtype);\n\treturn r ? 0 : SSH_ERR_SIGN_ALG_UNSUPPORTED;\n}"
  },
  {
    "function_name": "sshkey_sigalg_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2344-2360",
    "snippet": "const char *\nsshkey_sigalg_by_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (strcmp(kt->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (kt->sigalg != NULL)\n\t\t\treturn kt->sigalg;\n\t\tif (!kt->cert)\n\t\t\treturn kt->name;\n\t\treturn sshkey_ssh_name_from_type_nid(\n\t\t    sshkey_type_plain(kt->type), kt->nid);\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_ssh_name_from_type_nid",
          "args": [
            "sshkey_type_plain(kt->type)",
            "kt->nid"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_from_type_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "153-163",
          "snippet": "static const char *\nsshkey_ssh_name_from_type_nid(int type, int nid)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type && (kt->nid == 0 || kt->nid == nid))\n\t\t\treturn kt->name;\n\t}\n\treturn \"ssh-unknown\";\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nstatic const char *\nsshkey_ssh_name_from_type_nid(int type, int nid)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type && (kt->nid == 0 || kt->nid == nid))\n\t\t\treturn kt->name;\n\t}\n\treturn \"ssh-unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "kt->type"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kt->name",
            "name"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nconst char *\nsshkey_sigalg_by_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (strcmp(kt->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (kt->sigalg != NULL)\n\t\t\treturn kt->sigalg;\n\t\tif (!kt->cert)\n\t\t\treturn kt->name;\n\t\treturn sshkey_ssh_name_from_type_nid(\n\t\t    sshkey_type_plain(kt->type), kt->nid);\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "sshkey_check_cert_sigtype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2327-2339",
    "snippet": "int\nsshkey_check_cert_sigtype(const struct sshkey *key, const char *allowed)\n{\n\tif (key == NULL || allowed == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_type_is_cert(key->type))\n\t\treturn 0;\n\tif (key->cert == NULL || key->cert->signature_type == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (match_pattern_list(key->cert->signature_type, allowed, 0) != 1)\n\t\treturn SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "key->cert->signature_type",
            "allowed",
            "0"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_is_cert",
          "args": [
            "key->type"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "165-175",
          "snippet": "int\nsshkey_type_is_cert(int type)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type)\n\t\t\treturn kt->cert;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_is_cert(int type)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type)\n\t\t\treturn kt->cert;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_check_cert_sigtype(const struct sshkey *key, const char *allowed)\n{\n\tif (key == NULL || allowed == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_type_is_cert(key->type))\n\t\treturn 0;\n\tif (key->cert == NULL || key->cert->signature_type == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (match_pattern_list(key->cert->signature_type, allowed, 0) != 1)\n\t\treturn SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_sigtype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2295-2318",
    "snippet": "static int\nget_sigtype(const u_char *sig, size_t siglen, char **sigtypep)\n{\n\tint r;\n\tstruct sshbuf *b = NULL;\n\tchar *sigtype = NULL;\n\n\tif (sigtypep != NULL)\n\t\t*sigtypep = NULL;\n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &sigtype, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (sigtypep != NULL) {\n\t\t*sigtypep = sigtype;\n\t\tsigtype = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(sigtype);\n\tsshbuf_free(b);\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int get_sigtype(const u_char *sig, size_t siglen, char **sigtypep);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sigtype"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "b",
            "&sigtype",
            "NULL"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_from",
          "args": [
            "sig",
            "siglen"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "87-102",
          "snippet": "struct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int get_sigtype(const u_char *sig, size_t siglen, char **sigtypep);\n\nstatic int\nget_sigtype(const u_char *sig, size_t siglen, char **sigtypep)\n{\n\tint r;\n\tstruct sshbuf *b = NULL;\n\tchar *sigtype = NULL;\n\n\tif (sigtypep != NULL)\n\t\t*sigtypep = NULL;\n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &sigtype, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (sigtypep != NULL) {\n\t\t*sigtypep = sigtype;\n\t\tsigtype = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(sigtype);\n\tsshbuf_free(b);\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_froms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2282-2293",
    "snippet": "int\nsshkey_froms(struct sshbuf *buf, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((r = sshbuf_froms(buf, &b)) != 0)\n\t\treturn r;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob_internal",
          "args": [
            "b",
            "keyp",
            "1"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2008-2261",
          "snippet": "static int\nsshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,\n    int allow_cert)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tchar *ktype = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *key = NULL;\n\tsize_t len;\n\tu_char *pk = NULL;\n\tstruct sshbuf *copy;\n#if defined(WITH_OPENSSL)\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_pub_key = NULL;\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT *q = NULL;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n#ifdef DEBUG_PK /* XXX */\n\tsshbuf_dump(b, stderr);\n#endif\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((copy = sshbuf_fromb(b)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\ttype = sshkey_type_from_name(ktype);\n\tif (!allow_cert && sshkey_type_is_cert(type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_RSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_n = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, rsa_e) != 0 ||\n\t\t    sshbuf_get_bignum2(b, rsa_n) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = NULL; /* transferred */\n\t\tif ((ret = check_rsa_length(key->rsa)) != 0)\n\t\t\tgoto out;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, key->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_DSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, dsa_p) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_q) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_g) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_pub_key) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = NULL; /* transferred */\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, key->dsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ecdsa_nid = sshkey_ecdsa_nid_from_name(ktype);\n\t\tif (sshbuf_get_cstring(b, &curve, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (key->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tret = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tEC_KEY_free(key->ecdsa);\n\t\tif ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid))\n\t\t    == NULL) {\n\t\t\tret = SSH_ERR_EC_CURVE_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((q = EC_POINT_new(EC_KEY_get0_group(key->ecdsa))) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_ec(b, q, EC_KEY_get0_group(key->ecdsa)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshkey_ec_validate_public(EC_KEY_get0_group(key->ecdsa),\n\t\t    q) != 0) {\n\t\t\tret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(key->ecdsa, q) != 1) {\n\t\t\t/* XXX assume it is a allocation error */\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_point(EC_KEY_get0_group(key->ecdsa), q);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_ED25519:\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len != ED25519_PK_SZ) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ed25519_pk = pk;\n\t\tpk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_XMSS:\n\t\tif ((ret = sshbuf_get_cstring(b, &xmss_name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshkey_xmss_init(key, xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len == 0 || len != sshkey_xmss_pklen(key)) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->xmss_pk = pk;\n\t\tpk = NULL;\n\t\tif (type != KEY_XMSS_CERT &&\n\t\t    (ret = sshkey_xmss_deserialize_pk_info(key, b)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\tdefault:\n\t\tret = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\n\t/* Parse certificate potion */\n\tif (sshkey_is_cert(key) && (ret = cert_parse(b, key, copy)) != 0)\n\t\tgoto out;\n\n\tif (key != NULL && sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tret = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshbuf_free(copy);\n\tsshkey_free(key);\n\tfree(xmss_name);\n\tfree(ktype);\n\tfree(curve);\n\tfree(pk);\n#if defined(WITH_OPENSSL)\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT_free(q);\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int sshkey_from_blob_internal(struct sshbuf *buf,\n    struct sshkey **keyp, int allow_cert);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int sshkey_from_blob_internal(struct sshbuf *buf,\n    struct sshkey **keyp, int allow_cert);\n\nstatic int\nsshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,\n    int allow_cert)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tchar *ktype = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *key = NULL;\n\tsize_t len;\n\tu_char *pk = NULL;\n\tstruct sshbuf *copy;\n#if defined(WITH_OPENSSL)\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_pub_key = NULL;\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT *q = NULL;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n#ifdef DEBUG_PK /* XXX */\n\tsshbuf_dump(b, stderr);\n#endif\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((copy = sshbuf_fromb(b)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\ttype = sshkey_type_from_name(ktype);\n\tif (!allow_cert && sshkey_type_is_cert(type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_RSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_n = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, rsa_e) != 0 ||\n\t\t    sshbuf_get_bignum2(b, rsa_n) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = NULL; /* transferred */\n\t\tif ((ret = check_rsa_length(key->rsa)) != 0)\n\t\t\tgoto out;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, key->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_DSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, dsa_p) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_q) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_g) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_pub_key) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = NULL; /* transferred */\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, key->dsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ecdsa_nid = sshkey_ecdsa_nid_from_name(ktype);\n\t\tif (sshbuf_get_cstring(b, &curve, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (key->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tret = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tEC_KEY_free(key->ecdsa);\n\t\tif ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid))\n\t\t    == NULL) {\n\t\t\tret = SSH_ERR_EC_CURVE_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((q = EC_POINT_new(EC_KEY_get0_group(key->ecdsa))) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_ec(b, q, EC_KEY_get0_group(key->ecdsa)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshkey_ec_validate_public(EC_KEY_get0_group(key->ecdsa),\n\t\t    q) != 0) {\n\t\t\tret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(key->ecdsa, q) != 1) {\n\t\t\t/* XXX assume it is a allocation error */\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_point(EC_KEY_get0_group(key->ecdsa), q);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_ED25519:\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len != ED25519_PK_SZ) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ed25519_pk = pk;\n\t\tpk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_XMSS:\n\t\tif ((ret = sshbuf_get_cstring(b, &xmss_name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshkey_xmss_init(key, xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len == 0 || len != sshkey_xmss_pklen(key)) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->xmss_pk = pk;\n\t\tpk = NULL;\n\t\tif (type != KEY_XMSS_CERT &&\n\t\t    (ret = sshkey_xmss_deserialize_pk_info(key, b)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\tdefault:\n\t\tret = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\n\t/* Parse certificate potion */\n\tif (sshkey_is_cert(key) && (ret = cert_parse(b, key, copy)) != 0)\n\t\tgoto out;\n\n\tif (key != NULL && sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tret = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshbuf_free(copy);\n\tsshkey_free(key);\n\tfree(xmss_name);\n\tfree(ktype);\n\tfree(curve);\n\tfree(pk);\n#if defined(WITH_OPENSSL)\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT_free(q);\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_froms",
          "args": [
            "buf",
            "&b"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_froms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "377-399",
          "snippet": "int\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_froms(struct sshbuf *buf, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((r = sshbuf_froms(buf, &b)) != 0)\n\t\treturn r;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_fromb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2276-2280",
    "snippet": "int\nsshkey_fromb(struct sshbuf *b, struct sshkey **keyp)\n{\n\treturn sshkey_from_blob_internal(b, keyp, 1);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_from_blob_internal",
          "args": [
            "b",
            "keyp",
            "1"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2008-2261",
          "snippet": "static int\nsshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,\n    int allow_cert)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tchar *ktype = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *key = NULL;\n\tsize_t len;\n\tu_char *pk = NULL;\n\tstruct sshbuf *copy;\n#if defined(WITH_OPENSSL)\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_pub_key = NULL;\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT *q = NULL;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n#ifdef DEBUG_PK /* XXX */\n\tsshbuf_dump(b, stderr);\n#endif\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((copy = sshbuf_fromb(b)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\ttype = sshkey_type_from_name(ktype);\n\tif (!allow_cert && sshkey_type_is_cert(type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_RSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_n = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, rsa_e) != 0 ||\n\t\t    sshbuf_get_bignum2(b, rsa_n) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = NULL; /* transferred */\n\t\tif ((ret = check_rsa_length(key->rsa)) != 0)\n\t\t\tgoto out;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, key->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_DSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, dsa_p) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_q) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_g) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_pub_key) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = NULL; /* transferred */\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, key->dsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ecdsa_nid = sshkey_ecdsa_nid_from_name(ktype);\n\t\tif (sshbuf_get_cstring(b, &curve, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (key->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tret = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tEC_KEY_free(key->ecdsa);\n\t\tif ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid))\n\t\t    == NULL) {\n\t\t\tret = SSH_ERR_EC_CURVE_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((q = EC_POINT_new(EC_KEY_get0_group(key->ecdsa))) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_ec(b, q, EC_KEY_get0_group(key->ecdsa)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshkey_ec_validate_public(EC_KEY_get0_group(key->ecdsa),\n\t\t    q) != 0) {\n\t\t\tret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(key->ecdsa, q) != 1) {\n\t\t\t/* XXX assume it is a allocation error */\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_point(EC_KEY_get0_group(key->ecdsa), q);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_ED25519:\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len != ED25519_PK_SZ) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ed25519_pk = pk;\n\t\tpk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_XMSS:\n\t\tif ((ret = sshbuf_get_cstring(b, &xmss_name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshkey_xmss_init(key, xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len == 0 || len != sshkey_xmss_pklen(key)) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->xmss_pk = pk;\n\t\tpk = NULL;\n\t\tif (type != KEY_XMSS_CERT &&\n\t\t    (ret = sshkey_xmss_deserialize_pk_info(key, b)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\tdefault:\n\t\tret = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\n\t/* Parse certificate potion */\n\tif (sshkey_is_cert(key) && (ret = cert_parse(b, key, copy)) != 0)\n\t\tgoto out;\n\n\tif (key != NULL && sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tret = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshbuf_free(copy);\n\tsshkey_free(key);\n\tfree(xmss_name);\n\tfree(ktype);\n\tfree(curve);\n\tfree(pk);\n#if defined(WITH_OPENSSL)\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT_free(q);\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int sshkey_from_blob_internal(struct sshbuf *buf,\n    struct sshkey **keyp, int allow_cert);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int sshkey_from_blob_internal(struct sshbuf *buf,\n    struct sshkey **keyp, int allow_cert);\n\nstatic int\nsshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,\n    int allow_cert)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tchar *ktype = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *key = NULL;\n\tsize_t len;\n\tu_char *pk = NULL;\n\tstruct sshbuf *copy;\n#if defined(WITH_OPENSSL)\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_pub_key = NULL;\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT *q = NULL;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n#ifdef DEBUG_PK /* XXX */\n\tsshbuf_dump(b, stderr);\n#endif\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((copy = sshbuf_fromb(b)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\ttype = sshkey_type_from_name(ktype);\n\tif (!allow_cert && sshkey_type_is_cert(type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_RSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_n = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, rsa_e) != 0 ||\n\t\t    sshbuf_get_bignum2(b, rsa_n) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = NULL; /* transferred */\n\t\tif ((ret = check_rsa_length(key->rsa)) != 0)\n\t\t\tgoto out;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, key->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_DSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, dsa_p) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_q) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_g) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_pub_key) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = NULL; /* transferred */\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, key->dsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ecdsa_nid = sshkey_ecdsa_nid_from_name(ktype);\n\t\tif (sshbuf_get_cstring(b, &curve, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (key->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tret = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tEC_KEY_free(key->ecdsa);\n\t\tif ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid))\n\t\t    == NULL) {\n\t\t\tret = SSH_ERR_EC_CURVE_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((q = EC_POINT_new(EC_KEY_get0_group(key->ecdsa))) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_ec(b, q, EC_KEY_get0_group(key->ecdsa)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshkey_ec_validate_public(EC_KEY_get0_group(key->ecdsa),\n\t\t    q) != 0) {\n\t\t\tret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(key->ecdsa, q) != 1) {\n\t\t\t/* XXX assume it is a allocation error */\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_point(EC_KEY_get0_group(key->ecdsa), q);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_ED25519:\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len != ED25519_PK_SZ) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ed25519_pk = pk;\n\t\tpk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_XMSS:\n\t\tif ((ret = sshbuf_get_cstring(b, &xmss_name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshkey_xmss_init(key, xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len == 0 || len != sshkey_xmss_pklen(key)) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->xmss_pk = pk;\n\t\tpk = NULL;\n\t\tif (type != KEY_XMSS_CERT &&\n\t\t    (ret = sshkey_xmss_deserialize_pk_info(key, b)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\tdefault:\n\t\tret = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\n\t/* Parse certificate potion */\n\tif (sshkey_is_cert(key) && (ret = cert_parse(b, key, copy)) != 0)\n\t\tgoto out;\n\n\tif (key != NULL && sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tret = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshbuf_free(copy);\n\tsshkey_free(key);\n\tfree(xmss_name);\n\tfree(ktype);\n\tfree(curve);\n\tfree(pk);\n#if defined(WITH_OPENSSL)\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT_free(q);\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_fromb(struct sshbuf *b, struct sshkey **keyp)\n{\n\treturn sshkey_from_blob_internal(b, keyp, 1);\n}"
  },
  {
    "function_name": "sshkey_from_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2263-2274",
    "snippet": "int\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob_internal",
          "args": [
            "b",
            "keyp",
            "1"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2008-2261",
          "snippet": "static int\nsshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,\n    int allow_cert)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tchar *ktype = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *key = NULL;\n\tsize_t len;\n\tu_char *pk = NULL;\n\tstruct sshbuf *copy;\n#if defined(WITH_OPENSSL)\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_pub_key = NULL;\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT *q = NULL;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n#ifdef DEBUG_PK /* XXX */\n\tsshbuf_dump(b, stderr);\n#endif\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((copy = sshbuf_fromb(b)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\ttype = sshkey_type_from_name(ktype);\n\tif (!allow_cert && sshkey_type_is_cert(type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_RSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_n = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, rsa_e) != 0 ||\n\t\t    sshbuf_get_bignum2(b, rsa_n) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = NULL; /* transferred */\n\t\tif ((ret = check_rsa_length(key->rsa)) != 0)\n\t\t\tgoto out;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, key->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_DSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, dsa_p) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_q) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_g) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_pub_key) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = NULL; /* transferred */\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, key->dsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ecdsa_nid = sshkey_ecdsa_nid_from_name(ktype);\n\t\tif (sshbuf_get_cstring(b, &curve, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (key->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tret = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tEC_KEY_free(key->ecdsa);\n\t\tif ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid))\n\t\t    == NULL) {\n\t\t\tret = SSH_ERR_EC_CURVE_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((q = EC_POINT_new(EC_KEY_get0_group(key->ecdsa))) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_ec(b, q, EC_KEY_get0_group(key->ecdsa)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshkey_ec_validate_public(EC_KEY_get0_group(key->ecdsa),\n\t\t    q) != 0) {\n\t\t\tret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(key->ecdsa, q) != 1) {\n\t\t\t/* XXX assume it is a allocation error */\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_point(EC_KEY_get0_group(key->ecdsa), q);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_ED25519:\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len != ED25519_PK_SZ) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ed25519_pk = pk;\n\t\tpk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_XMSS:\n\t\tif ((ret = sshbuf_get_cstring(b, &xmss_name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshkey_xmss_init(key, xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len == 0 || len != sshkey_xmss_pklen(key)) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->xmss_pk = pk;\n\t\tpk = NULL;\n\t\tif (type != KEY_XMSS_CERT &&\n\t\t    (ret = sshkey_xmss_deserialize_pk_info(key, b)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\tdefault:\n\t\tret = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\n\t/* Parse certificate potion */\n\tif (sshkey_is_cert(key) && (ret = cert_parse(b, key, copy)) != 0)\n\t\tgoto out;\n\n\tif (key != NULL && sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tret = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshbuf_free(copy);\n\tsshkey_free(key);\n\tfree(xmss_name);\n\tfree(ktype);\n\tfree(curve);\n\tfree(pk);\n#if defined(WITH_OPENSSL)\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT_free(q);\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int sshkey_from_blob_internal(struct sshbuf *buf,\n    struct sshkey **keyp, int allow_cert);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int sshkey_from_blob_internal(struct sshbuf *buf,\n    struct sshkey **keyp, int allow_cert);\n\nstatic int\nsshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,\n    int allow_cert)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tchar *ktype = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *key = NULL;\n\tsize_t len;\n\tu_char *pk = NULL;\n\tstruct sshbuf *copy;\n#if defined(WITH_OPENSSL)\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_pub_key = NULL;\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT *q = NULL;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n#ifdef DEBUG_PK /* XXX */\n\tsshbuf_dump(b, stderr);\n#endif\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((copy = sshbuf_fromb(b)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\ttype = sshkey_type_from_name(ktype);\n\tif (!allow_cert && sshkey_type_is_cert(type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_RSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_n = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, rsa_e) != 0 ||\n\t\t    sshbuf_get_bignum2(b, rsa_n) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = NULL; /* transferred */\n\t\tif ((ret = check_rsa_length(key->rsa)) != 0)\n\t\t\tgoto out;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, key->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_DSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, dsa_p) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_q) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_g) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_pub_key) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = NULL; /* transferred */\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, key->dsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ecdsa_nid = sshkey_ecdsa_nid_from_name(ktype);\n\t\tif (sshbuf_get_cstring(b, &curve, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (key->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tret = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tEC_KEY_free(key->ecdsa);\n\t\tif ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid))\n\t\t    == NULL) {\n\t\t\tret = SSH_ERR_EC_CURVE_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((q = EC_POINT_new(EC_KEY_get0_group(key->ecdsa))) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_ec(b, q, EC_KEY_get0_group(key->ecdsa)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshkey_ec_validate_public(EC_KEY_get0_group(key->ecdsa),\n\t\t    q) != 0) {\n\t\t\tret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(key->ecdsa, q) != 1) {\n\t\t\t/* XXX assume it is a allocation error */\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_point(EC_KEY_get0_group(key->ecdsa), q);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_ED25519:\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len != ED25519_PK_SZ) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ed25519_pk = pk;\n\t\tpk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_XMSS:\n\t\tif ((ret = sshbuf_get_cstring(b, &xmss_name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshkey_xmss_init(key, xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len == 0 || len != sshkey_xmss_pklen(key)) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->xmss_pk = pk;\n\t\tpk = NULL;\n\t\tif (type != KEY_XMSS_CERT &&\n\t\t    (ret = sshkey_xmss_deserialize_pk_info(key, b)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\tdefault:\n\t\tret = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\n\t/* Parse certificate potion */\n\tif (sshkey_is_cert(key) && (ret = cert_parse(b, key, copy)) != 0)\n\t\tgoto out;\n\n\tif (key != NULL && sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tret = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshbuf_free(copy);\n\tsshkey_free(key);\n\tfree(xmss_name);\n\tfree(ktype);\n\tfree(curve);\n\tfree(pk);\n#if defined(WITH_OPENSSL)\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT_free(q);\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_from",
          "args": [
            "blob",
            "blen"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "87-102",
          "snippet": "struct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_from_blob_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "2008-2261",
    "snippet": "static int\nsshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,\n    int allow_cert)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tchar *ktype = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *key = NULL;\n\tsize_t len;\n\tu_char *pk = NULL;\n\tstruct sshbuf *copy;\n#if defined(WITH_OPENSSL)\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_pub_key = NULL;\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT *q = NULL;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n#ifdef DEBUG_PK /* XXX */\n\tsshbuf_dump(b, stderr);\n#endif\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((copy = sshbuf_fromb(b)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\ttype = sshkey_type_from_name(ktype);\n\tif (!allow_cert && sshkey_type_is_cert(type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_RSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_n = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, rsa_e) != 0 ||\n\t\t    sshbuf_get_bignum2(b, rsa_n) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = NULL; /* transferred */\n\t\tif ((ret = check_rsa_length(key->rsa)) != 0)\n\t\t\tgoto out;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, key->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_DSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, dsa_p) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_q) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_g) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_pub_key) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = NULL; /* transferred */\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, key->dsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ecdsa_nid = sshkey_ecdsa_nid_from_name(ktype);\n\t\tif (sshbuf_get_cstring(b, &curve, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (key->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tret = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tEC_KEY_free(key->ecdsa);\n\t\tif ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid))\n\t\t    == NULL) {\n\t\t\tret = SSH_ERR_EC_CURVE_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((q = EC_POINT_new(EC_KEY_get0_group(key->ecdsa))) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_ec(b, q, EC_KEY_get0_group(key->ecdsa)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshkey_ec_validate_public(EC_KEY_get0_group(key->ecdsa),\n\t\t    q) != 0) {\n\t\t\tret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(key->ecdsa, q) != 1) {\n\t\t\t/* XXX assume it is a allocation error */\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_point(EC_KEY_get0_group(key->ecdsa), q);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_ED25519:\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len != ED25519_PK_SZ) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ed25519_pk = pk;\n\t\tpk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_XMSS:\n\t\tif ((ret = sshbuf_get_cstring(b, &xmss_name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshkey_xmss_init(key, xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len == 0 || len != sshkey_xmss_pklen(key)) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->xmss_pk = pk;\n\t\tpk = NULL;\n\t\tif (type != KEY_XMSS_CERT &&\n\t\t    (ret = sshkey_xmss_deserialize_pk_info(key, b)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\tdefault:\n\t\tret = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\n\t/* Parse certificate potion */\n\tif (sshkey_is_cert(key) && (ret = cert_parse(b, key, copy)) != 0)\n\t\tgoto out;\n\n\tif (key != NULL && sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tret = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshbuf_free(copy);\n\tsshkey_free(key);\n\tfree(xmss_name);\n\tfree(ktype);\n\tfree(curve);\n\tfree(pk);\n#if defined(WITH_OPENSSL)\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT_free(q);\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\treturn ret;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int sshkey_from_blob_internal(struct sshbuf *buf,\n    struct sshkey **keyp, int allow_cert);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EC_POINT_free",
          "args": [
            "q"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "dsa_pub_key"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "dsa_g"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "dsa_q"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "dsa_p"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "rsa_e"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "rsa_n"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pk"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "copy"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cert_parse",
          "args": [
            "b",
            "key",
            "copy"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "cert_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1870-1993",
          "snippet": "static int\ncert_parse(struct sshbuf *b, struct sshkey *key, struct sshbuf *certbuf)\n{\n\tstruct sshbuf *principals = NULL, *crit = NULL;\n\tstruct sshbuf *exts = NULL, *ca = NULL;\n\tu_char *sig = NULL;\n\tsize_t signed_len = 0, slen = 0, kidlen = 0;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\t/* Copy the entire key blob for verification and later serialisation */\n\tif ((ret = sshbuf_putb(key->cert->certblob, certbuf)) != 0)\n\t\treturn ret;\n\n\t/* Parse body of certificate up to signature */\n\tif ((ret = sshbuf_get_u64(b, &key->cert->serial)) != 0 ||\n\t    (ret = sshbuf_get_u32(b, &key->cert->type)) != 0 ||\n\t    (ret = sshbuf_get_cstring(b, &key->cert->key_id, &kidlen)) != 0 ||\n\t    (ret = sshbuf_froms(b, &principals)) != 0 ||\n\t    (ret = sshbuf_get_u64(b, &key->cert->valid_after)) != 0 ||\n\t    (ret = sshbuf_get_u64(b, &key->cert->valid_before)) != 0 ||\n\t    (ret = sshbuf_froms(b, &crit)) != 0 ||\n\t    (ret = sshbuf_froms(b, &exts)) != 0 ||\n\t    (ret = sshbuf_get_string_direct(b, NULL, NULL)) != 0 ||\n\t    (ret = sshbuf_froms(b, &ca)) != 0) {\n\t\t/* XXX debug print error for ret */\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* Signature is left in the buffer so we can calculate this length */\n\tsigned_len = sshbuf_len(key->cert->certblob) - sshbuf_len(b);\n\n\tif ((ret = sshbuf_get_string(b, &sig, &slen)) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\tif (key->cert->type != SSH2_CERT_TYPE_USER &&\n\t    key->cert->type != SSH2_CERT_TYPE_HOST) {\n\t\tret = SSH_ERR_KEY_CERT_UNKNOWN_TYPE;\n\t\tgoto out;\n\t}\n\n\t/* Parse principals section */\n\twhile (sshbuf_len(principals) > 0) {\n\t\tchar *principal = NULL;\n\t\tchar **oprincipals = NULL;\n\n\t\tif (key->cert->nprincipals >= SSHKEY_CERT_MAX_PRINCIPALS) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshbuf_get_cstring(principals, &principal,\n\t\t    NULL)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\toprincipals = key->cert->principals;\n\t\tkey->cert->principals = recallocarray(key->cert->principals,\n\t\t    key->cert->nprincipals, key->cert->nprincipals + 1,\n\t\t    sizeof(*key->cert->principals));\n\t\tif (key->cert->principals == NULL) {\n\t\t\tfree(principal);\n\t\t\tkey->cert->principals = oprincipals;\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->cert->principals[key->cert->nprincipals++] = principal;\n\t}\n\n\t/*\n\t * Stash a copies of the critical options and extensions sections\n\t * for later use.\n\t */\n\tif ((ret = sshbuf_putb(key->cert->critical, crit)) != 0 ||\n\t    (exts != NULL &&\n\t    (ret = sshbuf_putb(key->cert->extensions, exts)) != 0))\n\t\tgoto out;\n\n\t/*\n\t * Validate critical options and extensions sections format.\n\t */\n\twhile (sshbuf_len(crit) != 0) {\n\t\tif ((ret = sshbuf_get_string_direct(crit, NULL, NULL)) != 0 ||\n\t\t    (ret = sshbuf_get_string_direct(crit, NULL, NULL)) != 0) {\n\t\t\tsshbuf_reset(key->cert->critical);\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\twhile (exts != NULL && sshbuf_len(exts) != 0) {\n\t\tif ((ret = sshbuf_get_string_direct(exts, NULL, NULL)) != 0 ||\n\t\t    (ret = sshbuf_get_string_direct(exts, NULL, NULL)) != 0) {\n\t\t\tsshbuf_reset(key->cert->extensions);\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Parse CA key and check signature */\n\tif (sshkey_from_blob_internal(ca, &key->cert->signature_key, 0) != 0) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tif (!sshkey_type_is_valid_ca(key->cert->signature_key->type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tif ((ret = sshkey_verify(key->cert->signature_key, sig, slen,\n\t    sshbuf_ptr(key->cert->certblob), signed_len, NULL, 0)) != 0)\n\t\tgoto out;\n\tif ((ret = get_sigtype(sig, slen, &key->cert->signature_type)) != 0)\n\t\tgoto out;\n\n\t/* Success */\n\tret = 0;\n out:\n\tsshbuf_free(ca);\n\tsshbuf_free(crit);\n\tsshbuf_free(exts);\n\tsshbuf_free(principals);\n\tfree(sig);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncert_parse(struct sshbuf *b, struct sshkey *key, struct sshbuf *certbuf)\n{\n\tstruct sshbuf *principals = NULL, *crit = NULL;\n\tstruct sshbuf *exts = NULL, *ca = NULL;\n\tu_char *sig = NULL;\n\tsize_t signed_len = 0, slen = 0, kidlen = 0;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\t/* Copy the entire key blob for verification and later serialisation */\n\tif ((ret = sshbuf_putb(key->cert->certblob, certbuf)) != 0)\n\t\treturn ret;\n\n\t/* Parse body of certificate up to signature */\n\tif ((ret = sshbuf_get_u64(b, &key->cert->serial)) != 0 ||\n\t    (ret = sshbuf_get_u32(b, &key->cert->type)) != 0 ||\n\t    (ret = sshbuf_get_cstring(b, &key->cert->key_id, &kidlen)) != 0 ||\n\t    (ret = sshbuf_froms(b, &principals)) != 0 ||\n\t    (ret = sshbuf_get_u64(b, &key->cert->valid_after)) != 0 ||\n\t    (ret = sshbuf_get_u64(b, &key->cert->valid_before)) != 0 ||\n\t    (ret = sshbuf_froms(b, &crit)) != 0 ||\n\t    (ret = sshbuf_froms(b, &exts)) != 0 ||\n\t    (ret = sshbuf_get_string_direct(b, NULL, NULL)) != 0 ||\n\t    (ret = sshbuf_froms(b, &ca)) != 0) {\n\t\t/* XXX debug print error for ret */\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* Signature is left in the buffer so we can calculate this length */\n\tsigned_len = sshbuf_len(key->cert->certblob) - sshbuf_len(b);\n\n\tif ((ret = sshbuf_get_string(b, &sig, &slen)) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\tif (key->cert->type != SSH2_CERT_TYPE_USER &&\n\t    key->cert->type != SSH2_CERT_TYPE_HOST) {\n\t\tret = SSH_ERR_KEY_CERT_UNKNOWN_TYPE;\n\t\tgoto out;\n\t}\n\n\t/* Parse principals section */\n\twhile (sshbuf_len(principals) > 0) {\n\t\tchar *principal = NULL;\n\t\tchar **oprincipals = NULL;\n\n\t\tif (key->cert->nprincipals >= SSHKEY_CERT_MAX_PRINCIPALS) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshbuf_get_cstring(principals, &principal,\n\t\t    NULL)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\toprincipals = key->cert->principals;\n\t\tkey->cert->principals = recallocarray(key->cert->principals,\n\t\t    key->cert->nprincipals, key->cert->nprincipals + 1,\n\t\t    sizeof(*key->cert->principals));\n\t\tif (key->cert->principals == NULL) {\n\t\t\tfree(principal);\n\t\t\tkey->cert->principals = oprincipals;\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->cert->principals[key->cert->nprincipals++] = principal;\n\t}\n\n\t/*\n\t * Stash a copies of the critical options and extensions sections\n\t * for later use.\n\t */\n\tif ((ret = sshbuf_putb(key->cert->critical, crit)) != 0 ||\n\t    (exts != NULL &&\n\t    (ret = sshbuf_putb(key->cert->extensions, exts)) != 0))\n\t\tgoto out;\n\n\t/*\n\t * Validate critical options and extensions sections format.\n\t */\n\twhile (sshbuf_len(crit) != 0) {\n\t\tif ((ret = sshbuf_get_string_direct(crit, NULL, NULL)) != 0 ||\n\t\t    (ret = sshbuf_get_string_direct(crit, NULL, NULL)) != 0) {\n\t\t\tsshbuf_reset(key->cert->critical);\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\twhile (exts != NULL && sshbuf_len(exts) != 0) {\n\t\tif ((ret = sshbuf_get_string_direct(exts, NULL, NULL)) != 0 ||\n\t\t    (ret = sshbuf_get_string_direct(exts, NULL, NULL)) != 0) {\n\t\t\tsshbuf_reset(key->cert->extensions);\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Parse CA key and check signature */\n\tif (sshkey_from_blob_internal(ca, &key->cert->signature_key, 0) != 0) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tif (!sshkey_type_is_valid_ca(key->cert->signature_key->type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tif ((ret = sshkey_verify(key->cert->signature_key, sig, slen,\n\t    sshbuf_ptr(key->cert->certblob), signed_len, NULL, 0)) != 0)\n\t\tgoto out;\n\tif ((ret = get_sigtype(sig, slen, &key->cert->signature_type)) != 0)\n\t\tgoto out;\n\n\t/* Success */\n\tret = 0;\n out:\n\tsshbuf_free(ca);\n\tsshbuf_free(crit);\n\tsshbuf_free(exts);\n\tsshbuf_free(principals);\n\tfree(sig);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_deserialize_pk_info",
          "args": [
            "key",
            "b"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_deserialize_pk_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "343-363",
          "snippet": "int\nsshkey_xmss_deserialize_pk_info(struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char have_info;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t/* optional */\n\tif (sshbuf_len(b) == 0)\n\t\treturn 0;\n\tif ((r = sshbuf_get_u8(b, &have_info)) != 0)\n\t\treturn r;\n\tif (have_info != 1)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_get_u32(b, &state->idx)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &state->maxidx)) != 0)\n\t\treturn r;\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_deserialize_pk_info(struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char have_info;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t/* optional */\n\tif (sshbuf_len(b) == 0)\n\t\treturn 0;\n\tif ((r = sshbuf_get_u8(b, &have_info)) != 0)\n\t\treturn r;\n\tif (have_info != 1)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_get_u32(b, &state->idx)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &state->maxidx)) != 0)\n\t\treturn r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_pklen",
          "args": [
            "key"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_pklen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "245-253",
          "snippet": "size_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "b",
            "&pk",
            "&len"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_init",
          "args": [
            "key",
            "xmss_name"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_init_enc_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "265-288",
          "snippet": "int\nsshkey_xmss_init_enc_key(struct sshkey *k, const char *ciphername)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tconst struct sshcipher *cipher;\n\tsize_t keylen = 0, ivlen = 0;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((state->enc_ciphername = strdup(ciphername)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tstate->enc_keyiv_len = keylen + ivlen;\n\tif ((state->enc_keyiv = calloc(state->enc_keyiv_len, 1)) == NULL) {\n\t\tfree(state->enc_ciphername);\n\t\tstate->enc_ciphername = NULL;\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tarc4random_buf(state->enc_keyiv, state->enc_keyiv_len);\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_init_enc_key(struct sshkey *k, const char *ciphername)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tconst struct sshcipher *cipher;\n\tsize_t keylen = 0, ivlen = 0;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((state->enc_ciphername = strdup(ciphername)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tstate->enc_keyiv_len = keylen + ivlen;\n\tif ((state->enc_keyiv = calloc(state->enc_keyiv_len, 1)) == NULL) {\n\t\tfree(state->enc_ciphername);\n\t\tstate->enc_ciphername = NULL;\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tarc4random_buf(state->enc_keyiv, state->enc_keyiv_len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_new",
          "args": [
            "type"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "485-550",
          "snippet": "struct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "b",
            "&xmss_name",
            "NULL"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_dump_ec_point",
          "args": [
            "EC_KEY_get0_group(key->ecdsa)",
            "q"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_dump_ec_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3340-3377",
          "snippet": "void\nsshkey_dump_ec_point(const EC_GROUP *group, const EC_POINT *point)\n{\n\tBIGNUM *x, *y;\n\tBN_CTX *bnctx;\n\n\tif (point == NULL) {\n\t\tfputs(\"point=(NULL)\\n\", stderr);\n\t\treturn;\n\t}\n\tif ((bnctx = BN_CTX_new()) == NULL) {\n\t\tfprintf(stderr, \"%s: BN_CTX_new failed\\n\", __func__);\n\t\treturn;\n\t}\n\tBN_CTX_start(bnctx);\n\tif ((x = BN_CTX_get(bnctx)) == NULL ||\n\t    (y = BN_CTX_get(bnctx)) == NULL) {\n\t\tfprintf(stderr, \"%s: BN_CTX_get failed\\n\", __func__);\n\t\treturn;\n\t}\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field) {\n\t\tfprintf(stderr, \"%s: group is not a prime field\\n\", __func__);\n\t\treturn;\n\t}\n\tif (EC_POINT_get_affine_coordinates_GFp(group, point, x, y,\n\t    bnctx) != 1) {\n\t\tfprintf(stderr, \"%s: EC_POINT_get_affine_coordinates_GFp\\n\",\n\t\t    __func__);\n\t\treturn;\n\t}\n\tfputs(\"x=\", stderr);\n\tBN_print_fp(stderr, x);\n\tfputs(\"\\ny=\", stderr);\n\tBN_print_fp(stderr, y);\n\tfputs(\"\\n\", stderr);\n\tBN_CTX_free(bnctx);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_dump_ec_point(const EC_GROUP *group, const EC_POINT *point)\n{\n\tBIGNUM *x, *y;\n\tBN_CTX *bnctx;\n\n\tif (point == NULL) {\n\t\tfputs(\"point=(NULL)\\n\", stderr);\n\t\treturn;\n\t}\n\tif ((bnctx = BN_CTX_new()) == NULL) {\n\t\tfprintf(stderr, \"%s: BN_CTX_new failed\\n\", __func__);\n\t\treturn;\n\t}\n\tBN_CTX_start(bnctx);\n\tif ((x = BN_CTX_get(bnctx)) == NULL ||\n\t    (y = BN_CTX_get(bnctx)) == NULL) {\n\t\tfprintf(stderr, \"%s: BN_CTX_get failed\\n\", __func__);\n\t\treturn;\n\t}\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field) {\n\t\tfprintf(stderr, \"%s: group is not a prime field\\n\", __func__);\n\t\treturn;\n\t}\n\tif (EC_POINT_get_affine_coordinates_GFp(group, point, x, y,\n\t    bnctx) != 1) {\n\t\tfprintf(stderr, \"%s: EC_POINT_get_affine_coordinates_GFp\\n\",\n\t\t    __func__);\n\t\treturn;\n\t}\n\tfputs(\"x=\", stderr);\n\tBN_print_fp(stderr, x);\n\tfputs(\"\\ny=\", stderr);\n\tBN_print_fp(stderr, y);\n\tfputs(\"\\n\", stderr);\n\tBN_CTX_free(bnctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "key->ecdsa"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_set_public_key",
          "args": [
            "key->ecdsa",
            "q"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_ec_validate_public",
          "args": [
            "EC_KEY_get0_group(key->ecdsa)",
            "q"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ec_validate_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3224-3299",
          "snippet": "int\nsshkey_ec_validate_public(const EC_GROUP *group, const EC_POINT *public)\n{\n\tBN_CTX *bnctx;\n\tEC_POINT *nq = NULL;\n\tBIGNUM *order, *x, *y, *tmp;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\t/*\n\t * NB. This assumes OpenSSL has already verified that the public\n\t * point lies on the curve. This is done by EC_POINT_oct2point()\n\t * implicitly calling EC_POINT_is_on_curve(). If this code is ever\n\t * reachable with public points not unmarshalled using\n\t * EC_POINT_oct2point then the caller will need to explicitly check.\n\t */\n\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tBN_CTX_start(bnctx);\n\n\t/*\n\t * We shouldn't ever hit this case because bignum_get_ecpoint()\n\t * refuses to load GF2m points.\n\t */\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field)\n\t\tgoto out;\n\n\t/* Q != infinity */\n\tif (EC_POINT_is_at_infinity(group, public))\n\t\tgoto out;\n\n\tif ((x = BN_CTX_get(bnctx)) == NULL ||\n\t    (y = BN_CTX_get(bnctx)) == NULL ||\n\t    (order = BN_CTX_get(bnctx)) == NULL ||\n\t    (tmp = BN_CTX_get(bnctx)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* log2(x) > log2(order)/2, log2(y) > log2(order)/2 */\n\tif (EC_GROUP_get_order(group, order, bnctx) != 1 ||\n\t    EC_POINT_get_affine_coordinates_GFp(group, public,\n\t    x, y, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(x) <= BN_num_bits(order) / 2 ||\n\t    BN_num_bits(y) <= BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t/* nQ == infinity (n == order of subgroup) */\n\tif ((nq = EC_POINT_new(group)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_mul(group, nq, NULL, public, order, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_is_at_infinity(group, nq) != 1)\n\t\tgoto out;\n\n\t/* x < order - 1, y < order - 1 */\n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(x, tmp) >= 0 || BN_cmp(y, tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_CTX_free(bnctx);\n\tEC_POINT_free(nq);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_ec_validate_public(const EC_GROUP *group, const EC_POINT *public)\n{\n\tBN_CTX *bnctx;\n\tEC_POINT *nq = NULL;\n\tBIGNUM *order, *x, *y, *tmp;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\t/*\n\t * NB. This assumes OpenSSL has already verified that the public\n\t * point lies on the curve. This is done by EC_POINT_oct2point()\n\t * implicitly calling EC_POINT_is_on_curve(). If this code is ever\n\t * reachable with public points not unmarshalled using\n\t * EC_POINT_oct2point then the caller will need to explicitly check.\n\t */\n\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tBN_CTX_start(bnctx);\n\n\t/*\n\t * We shouldn't ever hit this case because bignum_get_ecpoint()\n\t * refuses to load GF2m points.\n\t */\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field)\n\t\tgoto out;\n\n\t/* Q != infinity */\n\tif (EC_POINT_is_at_infinity(group, public))\n\t\tgoto out;\n\n\tif ((x = BN_CTX_get(bnctx)) == NULL ||\n\t    (y = BN_CTX_get(bnctx)) == NULL ||\n\t    (order = BN_CTX_get(bnctx)) == NULL ||\n\t    (tmp = BN_CTX_get(bnctx)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* log2(x) > log2(order)/2, log2(y) > log2(order)/2 */\n\tif (EC_GROUP_get_order(group, order, bnctx) != 1 ||\n\t    EC_POINT_get_affine_coordinates_GFp(group, public,\n\t    x, y, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(x) <= BN_num_bits(order) / 2 ||\n\t    BN_num_bits(y) <= BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t/* nQ == infinity (n == order of subgroup) */\n\tif ((nq = EC_POINT_new(group)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_mul(group, nq, NULL, public, order, bnctx) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_is_at_infinity(group, nq) != 1)\n\t\tgoto out;\n\n\t/* x < order - 1, y < order - 1 */\n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(x, tmp) >= 0 || BN_cmp(y, tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_CTX_free(bnctx);\n\tEC_POINT_free(nq);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "key->ecdsa"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_ec",
          "args": [
            "b",
            "q",
            "EC_KEY_get0_group(key->ecdsa)"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_ec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-crypto.c",
          "lines": "89-108",
          "snippet": "int\nsshbuf_get_ec(struct sshbuf *buf, EC_POINT *v, const EC_GROUP *g)\n{\n\tconst u_char *d;\n\tsize_t len;\n\tint r;\n\n\tif ((r = sshbuf_peek_string_direct(buf, &d, &len)) < 0)\n\t\treturn r;\n\tif ((r = get_ec(d, len, v, g)) != 0)\n\t\treturn r;\n\t/* Skip string */\n\tif (sshbuf_get_string_direct(buf, NULL, NULL) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n# include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_ec(struct sshbuf *buf, EC_POINT *v, const EC_GROUP *g)\n{\n\tconst u_char *d;\n\tsize_t len;\n\tint r;\n\n\tif ((r = sshbuf_peek_string_direct(buf, &d, &len)) < 0)\n\t\treturn r;\n\tif ((r = get_ec(d, len, v, g)) != 0)\n\t\treturn r;\n\t/* Skip string */\n\tif (sshbuf_get_string_direct(buf, NULL, NULL) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "key->ecdsa"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_new",
          "args": [
            "EC_KEY_get0_group(key->ecdsa)"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "key->ecdsa"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_new_by_curve_name",
          "args": [
            "key->ecdsa_nid"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_free",
          "args": [
            "key->ecdsa"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_curve_name_to_nid",
          "args": [
            "curve"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_curve_name_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "362-375",
          "snippet": "int\nsshkey_curve_name_to_nid(const char *name)\n{\n\tif (strcmp(name, \"nistp256\") == 0)\n\t\treturn NID_X9_62_prime256v1;\n\telse if (strcmp(name, \"nistp384\") == 0)\n\t\treturn NID_secp384r1;\n# ifdef OPENSSL_HAS_NISTP521\n\telse if (strcmp(name, \"nistp521\") == 0)\n\t\treturn NID_secp521r1;\n# endif /* OPENSSL_HAS_NISTP521 */\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_curve_name_to_nid(const char *name)\n{\n\tif (strcmp(name, \"nistp256\") == 0)\n\t\treturn NID_X9_62_prime256v1;\n\telse if (strcmp(name, \"nistp384\") == 0)\n\t\treturn NID_secp384r1;\n# ifdef OPENSSL_HAS_NISTP521\n\telse if (strcmp(name, \"nistp521\") == 0)\n\t\treturn NID_secp521r1;\n# endif /* OPENSSL_HAS_NISTP521 */\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ecdsa_nid_from_name",
          "args": [
            "ktype"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ecdsa_nid_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "204-216",
          "snippet": "int\nsshkey_ecdsa_nid_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type != KEY_ECDSA && kt->type != KEY_ECDSA_CERT)\n\t\t\tcontinue;\n\t\tif (kt->name != NULL && strcmp(name, kt->name) == 0)\n\t\t\treturn kt->nid;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_ecdsa_nid_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type != KEY_ECDSA && kt->type != KEY_ECDSA_CERT)\n\t\t\tcontinue;\n\t\tif (kt->name != NULL && strcmp(name, kt->name) == 0)\n\t\t\treturn kt->nid;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_print_fp",
          "args": [
            "stderr",
            "key->dsa",
            "8"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_set0_key",
          "args": [
            "key->dsa",
            "dsa_pub_key",
            "NULL"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_set0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "210-226",
          "snippet": "int\nDSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key)\n{\n\tif (d->pub_key == NULL && pub_key == NULL)\n\t\treturn 0;\n\n\tif (pub_key != NULL) {\n\t\tBN_free(d->pub_key);\n\t\td->pub_key = pub_key;\n\t}\n\tif (priv_key != NULL) {\n\t\tBN_free(d->priv_key);\n\t\td->priv_key = priv_key;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nDSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key)\n{\n\tif (d->pub_key == NULL && pub_key == NULL)\n\t\treturn 0;\n\n\tif (pub_key != NULL) {\n\t\tBN_free(d->pub_key);\n\t\td->pub_key = pub_key;\n\t}\n\tif (priv_key != NULL) {\n\t\tBN_free(d->priv_key);\n\t\td->priv_key = priv_key;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_set0_pqg",
          "args": [
            "key->dsa",
            "dsa_p",
            "dsa_q",
            "dsa_g"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_set0_pqg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "174-195",
          "snippet": "int\nDSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)\n{\n\tif ((d->p == NULL && p == NULL) || (d->q == NULL && q == NULL) ||\n\t    (d->g == NULL && g == NULL))\n\t\treturn 0;\n\n\tif (p != NULL) {\n\t\tBN_free(d->p);\n\t\td->p = p;\n\t}\n\tif (q != NULL) {\n\t\tBN_free(d->q);\n\t\td->q = q;\n\t}\n\tif (g != NULL) {\n\t\tBN_free(d->g);\n\t\td->g = g;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nDSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)\n{\n\tif ((d->p == NULL && p == NULL) || (d->q == NULL && q == NULL) ||\n\t    (d->g == NULL && g == NULL))\n\t\treturn 0;\n\n\tif (p != NULL) {\n\t\tBN_free(d->p);\n\t\td->p = p;\n\t}\n\tif (q != NULL) {\n\t\tBN_free(d->q);\n\t\td->q = q;\n\t}\n\tif (g != NULL) {\n\t\tBN_free(d->g);\n\t\td->g = g;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_bignum2",
          "args": [
            "b",
            "dsa_pub_key"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_bignum2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-crypto.c",
          "lines": "34-46",
          "snippet": "int\nsshbuf_get_bignum2(struct sshbuf *buf, BIGNUM *v)\n{\n\tconst u_char *d;\n\tsize_t len;\n\tint r;\n\n\tif ((r = sshbuf_get_bignum2_bytes_direct(buf, &d, &len)) != 0)\n\t\treturn r;\n\tif (v != NULL && BN_bin2bn(d, len, v) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n# include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_bignum2(struct sshbuf *buf, BIGNUM *v)\n{\n\tconst u_char *d;\n\tsize_t len;\n\tint r;\n\n\tif ((r = sshbuf_get_bignum2_bytes_direct(buf, &d, &len)) != 0)\n\t\treturn r;\n\tif (v != NULL && BN_bin2bn(d, len, v) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_print_fp",
          "args": [
            "stderr",
            "key->rsa",
            "8"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_rsa_length",
          "args": [
            "key->rsa"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "check_rsa_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1996-2005",
          "snippet": "static int\ncheck_rsa_length(const RSA *rsa)\n{\n\tconst BIGNUM *rsa_n;\n\n\tRSA_get0_key(rsa, &rsa_n, NULL, NULL);\n\tif (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncheck_rsa_length(const RSA *rsa)\n{\n\tconst BIGNUM *rsa_n;\n\n\tRSA_get0_key(rsa, &rsa_n, NULL, NULL);\n\tif (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_set0_key",
          "args": [
            "key->rsa",
            "rsa_n",
            "rsa_e",
            "NULL"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_set0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "243-263",
          "snippet": "int\nRSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d)\n{\n\tif ((r->n == NULL && n == NULL) || (r->e == NULL && e == NULL))\n\t\treturn 0;\n\n\tif (n != NULL) {\n\t\tBN_free(r->n);\n\t\tr->n = n;\n\t}\n\tif (e != NULL) {\n\t\tBN_free(r->e);\n\t\tr->e = e;\n\t}\n\tif (d != NULL) {\n\t\tBN_free(r->d);\n\t\tr->d = d;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nRSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d)\n{\n\tif ((r->n == NULL && n == NULL) || (r->e == NULL && e == NULL))\n\t\treturn 0;\n\n\tif (n != NULL) {\n\t\tBN_free(r->n);\n\t\tr->n = n;\n\t}\n\tif (e != NULL) {\n\t\tBN_free(r->e);\n\t\tr->e = e;\n\t}\n\tif (d != NULL) {\n\t\tBN_free(r->d);\n\t\tr->d = d;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_type_is_cert",
          "args": [
            "type"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "165-175",
          "snippet": "int\nsshkey_type_is_cert(int type)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type)\n\t\t\treturn kt->cert;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_is_cert(int type)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type)\n\t\t\treturn kt->cert;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "ktype"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_fromb",
          "args": [
            "b"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_fromb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "117-131",
          "snippet": "struct sshbuf *\nsshbuf_fromb(struct sshbuf *buf)\n{\n\tstruct sshbuf *ret;\n\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\tif ((ret = sshbuf_from(sshbuf_ptr(buf), sshbuf_len(buf))) == NULL)\n\t\treturn NULL;\n\tif (sshbuf_set_parent(ret, buf) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_fromb(struct sshbuf *buf)\n{\n\tstruct sshbuf *ret;\n\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\tif ((ret = sshbuf_from(sshbuf_ptr(buf), sshbuf_len(buf))) == NULL)\n\t\treturn NULL;\n\tif (sshbuf_set_parent(ret, buf) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_dump",
          "args": [
            "b",
            "stderr"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "65-70",
          "snippet": "void\nsshbuf_dump(struct sshbuf *buf, FILE *f)\n{\n\tfprintf(f, \"buffer %p len = %zu\\n\", buf, sshbuf_len(buf));\n\tsshbuf_dump_data(sshbuf_ptr(buf), sshbuf_len(buf), f);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_dump(struct sshbuf *buf, FILE *f)\n{\n\tfprintf(f, \"buffer %p len = %zu\\n\", buf, sshbuf_len(buf));\n\tsshbuf_dump_data(sshbuf_ptr(buf), sshbuf_len(buf), f);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int sshkey_from_blob_internal(struct sshbuf *buf,\n    struct sshkey **keyp, int allow_cert);\n\nstatic int\nsshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,\n    int allow_cert)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tchar *ktype = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *key = NULL;\n\tsize_t len;\n\tu_char *pk = NULL;\n\tstruct sshbuf *copy;\n#if defined(WITH_OPENSSL)\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_pub_key = NULL;\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT *q = NULL;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n#ifdef DEBUG_PK /* XXX */\n\tsshbuf_dump(b, stderr);\n#endif\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((copy = sshbuf_fromb(b)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\ttype = sshkey_type_from_name(ktype);\n\tif (!allow_cert && sshkey_type_is_cert(type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_RSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_n = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, rsa_e) != 0 ||\n\t\t    sshbuf_get_bignum2(b, rsa_n) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = NULL; /* transferred */\n\t\tif ((ret = check_rsa_length(key->rsa)) != 0)\n\t\t\tgoto out;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, key->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_DSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, dsa_p) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_q) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_g) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_pub_key) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = NULL; /* transferred */\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, key->dsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ecdsa_nid = sshkey_ecdsa_nid_from_name(ktype);\n\t\tif (sshbuf_get_cstring(b, &curve, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (key->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tret = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tEC_KEY_free(key->ecdsa);\n\t\tif ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid))\n\t\t    == NULL) {\n\t\t\tret = SSH_ERR_EC_CURVE_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((q = EC_POINT_new(EC_KEY_get0_group(key->ecdsa))) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_ec(b, q, EC_KEY_get0_group(key->ecdsa)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshkey_ec_validate_public(EC_KEY_get0_group(key->ecdsa),\n\t\t    q) != 0) {\n\t\t\tret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(key->ecdsa, q) != 1) {\n\t\t\t/* XXX assume it is a allocation error */\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_point(EC_KEY_get0_group(key->ecdsa), q);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_ED25519:\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len != ED25519_PK_SZ) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ed25519_pk = pk;\n\t\tpk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_XMSS:\n\t\tif ((ret = sshbuf_get_cstring(b, &xmss_name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshkey_xmss_init(key, xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len == 0 || len != sshkey_xmss_pklen(key)) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->xmss_pk = pk;\n\t\tpk = NULL;\n\t\tif (type != KEY_XMSS_CERT &&\n\t\t    (ret = sshkey_xmss_deserialize_pk_info(key, b)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\tdefault:\n\t\tret = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\n\t/* Parse certificate potion */\n\tif (sshkey_is_cert(key) && (ret = cert_parse(b, key, copy)) != 0)\n\t\tgoto out;\n\n\tif (key != NULL && sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tret = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshbuf_free(copy);\n\tsshkey_free(key);\n\tfree(xmss_name);\n\tfree(ktype);\n\tfree(curve);\n\tfree(pk);\n#if defined(WITH_OPENSSL)\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT_free(q);\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\treturn ret;\n}"
  },
  {
    "function_name": "check_rsa_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1996-2005",
    "snippet": "static int\ncheck_rsa_length(const RSA *rsa)\n{\n\tconst BIGNUM *rsa_n;\n\n\tRSA_get0_key(rsa, &rsa_n, NULL, NULL);\n\tif (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BN_num_bits",
          "args": [
            "rsa_n"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_get0_key",
          "args": [
            "rsa",
            "&rsa_n",
            "NULL",
            "NULL"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_get0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "230-239",
          "snippet": "void\nRSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)\n{\n\tif (n != NULL)\n\t\t*n = r->n;\n\tif (e != NULL)\n\t\t*e = r->e;\n\tif (d != NULL)\n\t\t*d = r->d;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nRSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)\n{\n\tif (n != NULL)\n\t\t*n = r->n;\n\tif (e != NULL)\n\t\t*e = r->e;\n\tif (d != NULL)\n\t\t*d = r->d;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncheck_rsa_length(const RSA *rsa)\n{\n\tconst BIGNUM *rsa_n;\n\n\tRSA_get0_key(rsa, &rsa_n, NULL, NULL);\n\tif (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\treturn 0;\n}"
  },
  {
    "function_name": "cert_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1870-1993",
    "snippet": "static int\ncert_parse(struct sshbuf *b, struct sshkey *key, struct sshbuf *certbuf)\n{\n\tstruct sshbuf *principals = NULL, *crit = NULL;\n\tstruct sshbuf *exts = NULL, *ca = NULL;\n\tu_char *sig = NULL;\n\tsize_t signed_len = 0, slen = 0, kidlen = 0;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\t/* Copy the entire key blob for verification and later serialisation */\n\tif ((ret = sshbuf_putb(key->cert->certblob, certbuf)) != 0)\n\t\treturn ret;\n\n\t/* Parse body of certificate up to signature */\n\tif ((ret = sshbuf_get_u64(b, &key->cert->serial)) != 0 ||\n\t    (ret = sshbuf_get_u32(b, &key->cert->type)) != 0 ||\n\t    (ret = sshbuf_get_cstring(b, &key->cert->key_id, &kidlen)) != 0 ||\n\t    (ret = sshbuf_froms(b, &principals)) != 0 ||\n\t    (ret = sshbuf_get_u64(b, &key->cert->valid_after)) != 0 ||\n\t    (ret = sshbuf_get_u64(b, &key->cert->valid_before)) != 0 ||\n\t    (ret = sshbuf_froms(b, &crit)) != 0 ||\n\t    (ret = sshbuf_froms(b, &exts)) != 0 ||\n\t    (ret = sshbuf_get_string_direct(b, NULL, NULL)) != 0 ||\n\t    (ret = sshbuf_froms(b, &ca)) != 0) {\n\t\t/* XXX debug print error for ret */\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* Signature is left in the buffer so we can calculate this length */\n\tsigned_len = sshbuf_len(key->cert->certblob) - sshbuf_len(b);\n\n\tif ((ret = sshbuf_get_string(b, &sig, &slen)) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\tif (key->cert->type != SSH2_CERT_TYPE_USER &&\n\t    key->cert->type != SSH2_CERT_TYPE_HOST) {\n\t\tret = SSH_ERR_KEY_CERT_UNKNOWN_TYPE;\n\t\tgoto out;\n\t}\n\n\t/* Parse principals section */\n\twhile (sshbuf_len(principals) > 0) {\n\t\tchar *principal = NULL;\n\t\tchar **oprincipals = NULL;\n\n\t\tif (key->cert->nprincipals >= SSHKEY_CERT_MAX_PRINCIPALS) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshbuf_get_cstring(principals, &principal,\n\t\t    NULL)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\toprincipals = key->cert->principals;\n\t\tkey->cert->principals = recallocarray(key->cert->principals,\n\t\t    key->cert->nprincipals, key->cert->nprincipals + 1,\n\t\t    sizeof(*key->cert->principals));\n\t\tif (key->cert->principals == NULL) {\n\t\t\tfree(principal);\n\t\t\tkey->cert->principals = oprincipals;\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->cert->principals[key->cert->nprincipals++] = principal;\n\t}\n\n\t/*\n\t * Stash a copies of the critical options and extensions sections\n\t * for later use.\n\t */\n\tif ((ret = sshbuf_putb(key->cert->critical, crit)) != 0 ||\n\t    (exts != NULL &&\n\t    (ret = sshbuf_putb(key->cert->extensions, exts)) != 0))\n\t\tgoto out;\n\n\t/*\n\t * Validate critical options and extensions sections format.\n\t */\n\twhile (sshbuf_len(crit) != 0) {\n\t\tif ((ret = sshbuf_get_string_direct(crit, NULL, NULL)) != 0 ||\n\t\t    (ret = sshbuf_get_string_direct(crit, NULL, NULL)) != 0) {\n\t\t\tsshbuf_reset(key->cert->critical);\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\twhile (exts != NULL && sshbuf_len(exts) != 0) {\n\t\tif ((ret = sshbuf_get_string_direct(exts, NULL, NULL)) != 0 ||\n\t\t    (ret = sshbuf_get_string_direct(exts, NULL, NULL)) != 0) {\n\t\t\tsshbuf_reset(key->cert->extensions);\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Parse CA key and check signature */\n\tif (sshkey_from_blob_internal(ca, &key->cert->signature_key, 0) != 0) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tif (!sshkey_type_is_valid_ca(key->cert->signature_key->type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tif ((ret = sshkey_verify(key->cert->signature_key, sig, slen,\n\t    sshbuf_ptr(key->cert->certblob), signed_len, NULL, 0)) != 0)\n\t\tgoto out;\n\tif ((ret = get_sigtype(sig, slen, &key->cert->signature_type)) != 0)\n\t\tgoto out;\n\n\t/* Success */\n\tret = 0;\n out:\n\tsshbuf_free(ca);\n\tsshbuf_free(crit);\n\tsshbuf_free(exts);\n\tsshbuf_free(principals);\n\tfree(sig);\n\treturn ret;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sig"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "principals"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_sigtype",
          "args": [
            "sig",
            "slen",
            "&key->cert->signature_type"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "get_sigtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2295-2318",
          "snippet": "static int\nget_sigtype(const u_char *sig, size_t siglen, char **sigtypep)\n{\n\tint r;\n\tstruct sshbuf *b = NULL;\n\tchar *sigtype = NULL;\n\n\tif (sigtypep != NULL)\n\t\t*sigtypep = NULL;\n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &sigtype, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (sigtypep != NULL) {\n\t\t*sigtypep = sigtype;\n\t\tsigtype = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(sigtype);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int get_sigtype(const u_char *sig, size_t siglen, char **sigtypep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int get_sigtype(const u_char *sig, size_t siglen, char **sigtypep);\n\nstatic int\nget_sigtype(const u_char *sig, size_t siglen, char **sigtypep)\n{\n\tint r;\n\tstruct sshbuf *b = NULL;\n\tchar *sigtype = NULL;\n\n\tif (sigtypep != NULL)\n\t\t*sigtypep = NULL;\n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &sigtype, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (sigtypep != NULL) {\n\t\t*sigtypep = sigtype;\n\t\tsigtype = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(sigtype);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_verify",
          "args": [
            "key->cert->signature_key",
            "sig",
            "slen",
            "sshbuf_ptr(key->cert->certblob)",
            "signed_len",
            "NULL",
            "0"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2427-2459",
          "snippet": "int\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "key->cert->certblob"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_is_valid_ca",
          "args": [
            "key->cert->signature_key->type"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_is_valid_ca",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "317-330",
          "snippet": "static int\nsshkey_type_is_valid_ca(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_XMSS:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nsshkey_type_is_valid_ca(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_XMSS:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob_internal",
          "args": [
            "ca",
            "&key->cert->signature_key",
            "0"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2008-2261",
          "snippet": "static int\nsshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,\n    int allow_cert)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tchar *ktype = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *key = NULL;\n\tsize_t len;\n\tu_char *pk = NULL;\n\tstruct sshbuf *copy;\n#if defined(WITH_OPENSSL)\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_pub_key = NULL;\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT *q = NULL;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n#ifdef DEBUG_PK /* XXX */\n\tsshbuf_dump(b, stderr);\n#endif\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((copy = sshbuf_fromb(b)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\ttype = sshkey_type_from_name(ktype);\n\tif (!allow_cert && sshkey_type_is_cert(type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_RSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_n = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, rsa_e) != 0 ||\n\t\t    sshbuf_get_bignum2(b, rsa_n) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = NULL; /* transferred */\n\t\tif ((ret = check_rsa_length(key->rsa)) != 0)\n\t\t\tgoto out;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, key->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_DSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, dsa_p) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_q) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_g) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_pub_key) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = NULL; /* transferred */\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, key->dsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ecdsa_nid = sshkey_ecdsa_nid_from_name(ktype);\n\t\tif (sshbuf_get_cstring(b, &curve, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (key->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tret = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tEC_KEY_free(key->ecdsa);\n\t\tif ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid))\n\t\t    == NULL) {\n\t\t\tret = SSH_ERR_EC_CURVE_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((q = EC_POINT_new(EC_KEY_get0_group(key->ecdsa))) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_ec(b, q, EC_KEY_get0_group(key->ecdsa)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshkey_ec_validate_public(EC_KEY_get0_group(key->ecdsa),\n\t\t    q) != 0) {\n\t\t\tret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(key->ecdsa, q) != 1) {\n\t\t\t/* XXX assume it is a allocation error */\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_point(EC_KEY_get0_group(key->ecdsa), q);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_ED25519:\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len != ED25519_PK_SZ) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ed25519_pk = pk;\n\t\tpk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_XMSS:\n\t\tif ((ret = sshbuf_get_cstring(b, &xmss_name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshkey_xmss_init(key, xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len == 0 || len != sshkey_xmss_pklen(key)) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->xmss_pk = pk;\n\t\tpk = NULL;\n\t\tif (type != KEY_XMSS_CERT &&\n\t\t    (ret = sshkey_xmss_deserialize_pk_info(key, b)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\tdefault:\n\t\tret = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\n\t/* Parse certificate potion */\n\tif (sshkey_is_cert(key) && (ret = cert_parse(b, key, copy)) != 0)\n\t\tgoto out;\n\n\tif (key != NULL && sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tret = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshbuf_free(copy);\n\tsshkey_free(key);\n\tfree(xmss_name);\n\tfree(ktype);\n\tfree(curve);\n\tfree(pk);\n#if defined(WITH_OPENSSL)\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT_free(q);\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int sshkey_from_blob_internal(struct sshbuf *buf,\n    struct sshkey **keyp, int allow_cert);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int sshkey_from_blob_internal(struct sshbuf *buf,\n    struct sshkey **keyp, int allow_cert);\n\nstatic int\nsshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,\n    int allow_cert)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tchar *ktype = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *key = NULL;\n\tsize_t len;\n\tu_char *pk = NULL;\n\tstruct sshbuf *copy;\n#if defined(WITH_OPENSSL)\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_pub_key = NULL;\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT *q = NULL;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n#ifdef DEBUG_PK /* XXX */\n\tsshbuf_dump(b, stderr);\n#endif\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((copy = sshbuf_fromb(b)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\ttype = sshkey_type_from_name(ktype);\n\tif (!allow_cert && sshkey_type_is_cert(type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_RSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_n = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, rsa_e) != 0 ||\n\t\t    sshbuf_get_bignum2(b, rsa_n) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = NULL; /* transferred */\n\t\tif ((ret = check_rsa_length(key->rsa)) != 0)\n\t\t\tgoto out;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, key->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_DSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_bignum2(b, dsa_p) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_q) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_g) != 0 ||\n\t\t    sshbuf_get_bignum2(b, dsa_pub_key) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, NULL)) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = NULL; /* transferred */\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, key->dsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ecdsa_nid = sshkey_ecdsa_nid_from_name(ktype);\n\t\tif (sshbuf_get_cstring(b, &curve, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (key->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tret = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tEC_KEY_free(key->ecdsa);\n\t\tif ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid))\n\t\t    == NULL) {\n\t\t\tret = SSH_ERR_EC_CURVE_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((q = EC_POINT_new(EC_KEY_get0_group(key->ecdsa))) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_get_ec(b, q, EC_KEY_get0_group(key->ecdsa)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshkey_ec_validate_public(EC_KEY_get0_group(key->ecdsa),\n\t\t    q) != 0) {\n\t\t\tret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(key->ecdsa, q) != 1) {\n\t\t\t/* XXX assume it is a allocation error */\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_point(EC_KEY_get0_group(key->ecdsa), q);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_ED25519:\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len != ED25519_PK_SZ) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->ed25519_pk = pk;\n\t\tpk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\t/* Skip nonce */\n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase KEY_XMSS:\n\t\tif ((ret = sshbuf_get_cstring(b, &xmss_name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((key = sshkey_new(type)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshkey_xmss_init(key, xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\t\tgoto out;\n\t\tif (len == 0 || len != sshkey_xmss_pklen(key)) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->xmss_pk = pk;\n\t\tpk = NULL;\n\t\tif (type != KEY_XMSS_CERT &&\n\t\t    (ret = sshkey_xmss_deserialize_pk_info(key, b)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\tdefault:\n\t\tret = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\n\t/* Parse certificate potion */\n\tif (sshkey_is_cert(key) && (ret = cert_parse(b, key, copy)) != 0)\n\t\tgoto out;\n\n\tif (key != NULL && sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tret = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshbuf_free(copy);\n\tsshkey_free(key);\n\tfree(xmss_name);\n\tfree(ktype);\n\tfree(curve);\n\tfree(pk);\n#if defined(WITH_OPENSSL)\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n# if defined(OPENSSL_HAS_ECC)\n\tEC_POINT_free(q);\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "key->cert->extensions"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string_direct",
          "args": [
            "exts",
            "NULL",
            "NULL"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "exts"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putb",
          "args": [
            "key->cert->extensions",
            "exts"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "248-252",
          "snippet": "int\nsshbuf_putb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "recallocarray",
          "args": [
            "key->cert->principals",
            "key->cert->nprincipals",
            "key->cert->nprincipals + 1",
            "sizeof(*key->cert->principals)"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "principals",
            "&principal",
            "NULL"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_froms",
          "args": [
            "b",
            "&ca"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_froms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "377-399",
          "snippet": "int\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u64",
          "args": [
            "b",
            "&key->cert->valid_before"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "44-55",
          "snippet": "int\nsshbuf_get_u64(struct sshbuf *buf, u_int64_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 8)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U64(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u64(struct sshbuf *buf, u_int64_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 8)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U64(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "b",
            "&key->cert->type"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncert_parse(struct sshbuf *b, struct sshkey *key, struct sshbuf *certbuf)\n{\n\tstruct sshbuf *principals = NULL, *crit = NULL;\n\tstruct sshbuf *exts = NULL, *ca = NULL;\n\tu_char *sig = NULL;\n\tsize_t signed_len = 0, slen = 0, kidlen = 0;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\t/* Copy the entire key blob for verification and later serialisation */\n\tif ((ret = sshbuf_putb(key->cert->certblob, certbuf)) != 0)\n\t\treturn ret;\n\n\t/* Parse body of certificate up to signature */\n\tif ((ret = sshbuf_get_u64(b, &key->cert->serial)) != 0 ||\n\t    (ret = sshbuf_get_u32(b, &key->cert->type)) != 0 ||\n\t    (ret = sshbuf_get_cstring(b, &key->cert->key_id, &kidlen)) != 0 ||\n\t    (ret = sshbuf_froms(b, &principals)) != 0 ||\n\t    (ret = sshbuf_get_u64(b, &key->cert->valid_after)) != 0 ||\n\t    (ret = sshbuf_get_u64(b, &key->cert->valid_before)) != 0 ||\n\t    (ret = sshbuf_froms(b, &crit)) != 0 ||\n\t    (ret = sshbuf_froms(b, &exts)) != 0 ||\n\t    (ret = sshbuf_get_string_direct(b, NULL, NULL)) != 0 ||\n\t    (ret = sshbuf_froms(b, &ca)) != 0) {\n\t\t/* XXX debug print error for ret */\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* Signature is left in the buffer so we can calculate this length */\n\tsigned_len = sshbuf_len(key->cert->certblob) - sshbuf_len(b);\n\n\tif ((ret = sshbuf_get_string(b, &sig, &slen)) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\tif (key->cert->type != SSH2_CERT_TYPE_USER &&\n\t    key->cert->type != SSH2_CERT_TYPE_HOST) {\n\t\tret = SSH_ERR_KEY_CERT_UNKNOWN_TYPE;\n\t\tgoto out;\n\t}\n\n\t/* Parse principals section */\n\twhile (sshbuf_len(principals) > 0) {\n\t\tchar *principal = NULL;\n\t\tchar **oprincipals = NULL;\n\n\t\tif (key->cert->nprincipals >= SSHKEY_CERT_MAX_PRINCIPALS) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshbuf_get_cstring(principals, &principal,\n\t\t    NULL)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\toprincipals = key->cert->principals;\n\t\tkey->cert->principals = recallocarray(key->cert->principals,\n\t\t    key->cert->nprincipals, key->cert->nprincipals + 1,\n\t\t    sizeof(*key->cert->principals));\n\t\tif (key->cert->principals == NULL) {\n\t\t\tfree(principal);\n\t\t\tkey->cert->principals = oprincipals;\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->cert->principals[key->cert->nprincipals++] = principal;\n\t}\n\n\t/*\n\t * Stash a copies of the critical options and extensions sections\n\t * for later use.\n\t */\n\tif ((ret = sshbuf_putb(key->cert->critical, crit)) != 0 ||\n\t    (exts != NULL &&\n\t    (ret = sshbuf_putb(key->cert->extensions, exts)) != 0))\n\t\tgoto out;\n\n\t/*\n\t * Validate critical options and extensions sections format.\n\t */\n\twhile (sshbuf_len(crit) != 0) {\n\t\tif ((ret = sshbuf_get_string_direct(crit, NULL, NULL)) != 0 ||\n\t\t    (ret = sshbuf_get_string_direct(crit, NULL, NULL)) != 0) {\n\t\t\tsshbuf_reset(key->cert->critical);\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\twhile (exts != NULL && sshbuf_len(exts) != 0) {\n\t\tif ((ret = sshbuf_get_string_direct(exts, NULL, NULL)) != 0 ||\n\t\t    (ret = sshbuf_get_string_direct(exts, NULL, NULL)) != 0) {\n\t\t\tsshbuf_reset(key->cert->extensions);\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Parse CA key and check signature */\n\tif (sshkey_from_blob_internal(ca, &key->cert->signature_key, 0) != 0) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tif (!sshkey_type_is_valid_ca(key->cert->signature_key->type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tif ((ret = sshkey_verify(key->cert->signature_key, sig, slen,\n\t    sshbuf_ptr(key->cert->certblob), signed_len, NULL, 0)) != 0)\n\t\tgoto out;\n\tif ((ret = get_sigtype(sig, slen, &key->cert->signature_type)) != 0)\n\t\tgoto out;\n\n\t/* Success */\n\tret = 0;\n out:\n\tsshbuf_free(ca);\n\tsshbuf_free(crit);\n\tsshbuf_free(exts);\n\tsshbuf_free(principals);\n\tfree(sig);\n\treturn ret;\n}"
  },
  {
    "function_name": "sshkey_from_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1726-1868",
    "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "dsa_pub_key_dup"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "dsa_g_dup"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "dsa_q_dup"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "dsa_p_dup"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "rsa_e_dup"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "rsa_n_dup"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "n"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_cert_copy",
          "args": [
            "k",
            "n"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_cert_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1656-1724",
          "snippet": "int\nsshkey_cert_copy(const struct sshkey *from_key, struct sshkey *to_key)\n{\n\tu_int i;\n\tconst struct sshkey_cert *from;\n\tstruct sshkey_cert *to;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (to_key == NULL || (from = from_key->cert) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((to = cert_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((r = sshbuf_putb(to->certblob, from->certblob)) != 0 ||\n\t    (r = sshbuf_putb(to->critical, from->critical)) != 0 ||\n\t    (r = sshbuf_putb(to->extensions, from->extensions)) != 0)\n\t\tgoto out;\n\n\tto->serial = from->serial;\n\tto->type = from->type;\n\tif (from->key_id == NULL)\n\t\tto->key_id = NULL;\n\telse if ((to->key_id = strdup(from->key_id)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tto->valid_after = from->valid_after;\n\tto->valid_before = from->valid_before;\n\tif (from->signature_key == NULL)\n\t\tto->signature_key = NULL;\n\telse if ((r = sshkey_from_private(from->signature_key,\n\t    &to->signature_key)) != 0)\n\t\tgoto out;\n\tif (from->signature_type != NULL &&\n\t    (to->signature_type = strdup(from->signature_type)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (from->nprincipals > SSHKEY_CERT_MAX_PRINCIPALS) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (from->nprincipals > 0) {\n\t\tif ((to->principals = calloc(from->nprincipals,\n\t\t    sizeof(*to->principals))) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tfor (i = 0; i < from->nprincipals; i++) {\n\t\t\tto->principals[i] = strdup(from->principals[i]);\n\t\t\tif (to->principals[i] == NULL) {\n\t\t\t\tto->nprincipals = i;\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tto->nprincipals = from->nprincipals;\n\n\t/* success */\n\tcert_free(to_key->cert);\n\tto_key->cert = to;\n\tto = NULL;\n\tr = 0;\n out:\n\tcert_free(to);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_cert_copy(const struct sshkey *from_key, struct sshkey *to_key)\n{\n\tu_int i;\n\tconst struct sshkey_cert *from;\n\tstruct sshkey_cert *to;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (to_key == NULL || (from = from_key->cert) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((to = cert_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((r = sshbuf_putb(to->certblob, from->certblob)) != 0 ||\n\t    (r = sshbuf_putb(to->critical, from->critical)) != 0 ||\n\t    (r = sshbuf_putb(to->extensions, from->extensions)) != 0)\n\t\tgoto out;\n\n\tto->serial = from->serial;\n\tto->type = from->type;\n\tif (from->key_id == NULL)\n\t\tto->key_id = NULL;\n\telse if ((to->key_id = strdup(from->key_id)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tto->valid_after = from->valid_after;\n\tto->valid_before = from->valid_before;\n\tif (from->signature_key == NULL)\n\t\tto->signature_key = NULL;\n\telse if ((r = sshkey_from_private(from->signature_key,\n\t    &to->signature_key)) != 0)\n\t\tgoto out;\n\tif (from->signature_type != NULL &&\n\t    (to->signature_type = strdup(from->signature_type)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (from->nprincipals > SSHKEY_CERT_MAX_PRINCIPALS) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (from->nprincipals > 0) {\n\t\tif ((to->principals = calloc(from->nprincipals,\n\t\t    sizeof(*to->principals))) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tfor (i = 0; i < from->nprincipals; i++) {\n\t\t\tto->principals[i] = strdup(from->principals[i]);\n\t\t\tif (to->principals[i] == NULL) {\n\t\t\t\tto->nprincipals = i;\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tto->nprincipals = from->nprincipals;\n\n\t/* success */\n\tcert_free(to_key->cert);\n\tto_key->cert = to;\n\tto = NULL;\n\tr = 0;\n out:\n\tcert_free(to);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "k"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "n->xmss_pk",
            "k->xmss_pk",
            "pklen"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "pklen"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_pklen",
          "args": [
            "n"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_pklen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "245-253",
          "snippet": "size_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_init",
          "args": [
            "n",
            "k->xmss_name"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_init_enc_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "265-288",
          "snippet": "int\nsshkey_xmss_init_enc_key(struct sshkey *k, const char *ciphername)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tconst struct sshcipher *cipher;\n\tsize_t keylen = 0, ivlen = 0;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((state->enc_ciphername = strdup(ciphername)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tstate->enc_keyiv_len = keylen + ivlen;\n\tif ((state->enc_keyiv = calloc(state->enc_keyiv_len, 1)) == NULL) {\n\t\tfree(state->enc_ciphername);\n\t\tstate->enc_ciphername = NULL;\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tarc4random_buf(state->enc_keyiv, state->enc_keyiv_len);\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_init_enc_key(struct sshkey *k, const char *ciphername)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tconst struct sshcipher *cipher;\n\tsize_t keylen = 0, ivlen = 0;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((state->enc_ciphername = strdup(ciphername)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tstate->enc_keyiv_len = keylen + ivlen;\n\tif ((state->enc_keyiv = calloc(state->enc_keyiv_len, 1)) == NULL) {\n\t\tfree(state->enc_ciphername);\n\t\tstate->enc_ciphername = NULL;\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tarc4random_buf(state->enc_keyiv, state->enc_keyiv_len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_new",
          "args": [
            "k->type"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "485-550",
          "snippet": "struct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "n->ed25519_pk",
            "k->ed25519_pk",
            "ED25519_PK_SZ"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_set0_key",
          "args": [
            "n->rsa",
            "rsa_n_dup",
            "rsa_e_dup",
            "NULL"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_set0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "243-263",
          "snippet": "int\nRSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d)\n{\n\tif ((r->n == NULL && n == NULL) || (r->e == NULL && e == NULL))\n\t\treturn 0;\n\n\tif (n != NULL) {\n\t\tBN_free(r->n);\n\t\tr->n = n;\n\t}\n\tif (e != NULL) {\n\t\tBN_free(r->e);\n\t\tr->e = e;\n\t}\n\tif (d != NULL) {\n\t\tBN_free(r->d);\n\t\tr->d = d;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nRSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d)\n{\n\tif ((r->n == NULL && n == NULL) || (r->e == NULL && e == NULL))\n\t\treturn 0;\n\n\tif (n != NULL) {\n\t\tBN_free(r->n);\n\t\tr->n = n;\n\t}\n\tif (e != NULL) {\n\t\tBN_free(r->e);\n\t\tr->e = e;\n\t}\n\tif (d != NULL) {\n\t\tBN_free(r->d);\n\t\tr->d = d;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_dup",
          "args": [
            "rsa_e"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_dup",
          "args": [
            "rsa_n"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_get0_key",
          "args": [
            "k->rsa",
            "&rsa_n",
            "&rsa_e",
            "NULL"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_get0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "230-239",
          "snippet": "void\nRSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)\n{\n\tif (n != NULL)\n\t\t*n = r->n;\n\tif (e != NULL)\n\t\t*e = r->e;\n\tif (d != NULL)\n\t\t*d = r->d;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nRSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)\n{\n\tif (n != NULL)\n\t\t*n = r->n;\n\tif (e != NULL)\n\t\t*e = r->e;\n\tif (d != NULL)\n\t\t*d = r->d;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_set_public_key",
          "args": [
            "n->ecdsa",
            "EC_KEY_get0_public_key(k->ecdsa)"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_public_key",
          "args": [
            "k->ecdsa"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_new_by_curve_name",
          "args": [
            "k->ecdsa_nid"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_set0_key",
          "args": [
            "n->dsa",
            "dsa_pub_key_dup",
            "NULL"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_set0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "210-226",
          "snippet": "int\nDSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key)\n{\n\tif (d->pub_key == NULL && pub_key == NULL)\n\t\treturn 0;\n\n\tif (pub_key != NULL) {\n\t\tBN_free(d->pub_key);\n\t\td->pub_key = pub_key;\n\t}\n\tif (priv_key != NULL) {\n\t\tBN_free(d->priv_key);\n\t\td->priv_key = priv_key;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nDSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key)\n{\n\tif (d->pub_key == NULL && pub_key == NULL)\n\t\treturn 0;\n\n\tif (pub_key != NULL) {\n\t\tBN_free(d->pub_key);\n\t\td->pub_key = pub_key;\n\t}\n\tif (priv_key != NULL) {\n\t\tBN_free(d->priv_key);\n\t\td->priv_key = priv_key;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_set0_pqg",
          "args": [
            "n->dsa",
            "dsa_p_dup",
            "dsa_q_dup",
            "dsa_g_dup"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_set0_pqg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "174-195",
          "snippet": "int\nDSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)\n{\n\tif ((d->p == NULL && p == NULL) || (d->q == NULL && q == NULL) ||\n\t    (d->g == NULL && g == NULL))\n\t\treturn 0;\n\n\tif (p != NULL) {\n\t\tBN_free(d->p);\n\t\td->p = p;\n\t}\n\tif (q != NULL) {\n\t\tBN_free(d->q);\n\t\td->q = q;\n\t}\n\tif (g != NULL) {\n\t\tBN_free(d->g);\n\t\td->g = g;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nDSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)\n{\n\tif ((d->p == NULL && p == NULL) || (d->q == NULL && q == NULL) ||\n\t    (d->g == NULL && g == NULL))\n\t\treturn 0;\n\n\tif (p != NULL) {\n\t\tBN_free(d->p);\n\t\td->p = p;\n\t}\n\tif (q != NULL) {\n\t\tBN_free(d->q);\n\t\td->q = q;\n\t}\n\tif (g != NULL) {\n\t\tBN_free(d->g);\n\t\td->g = g;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_dup",
          "args": [
            "dsa_pub_key"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_dup",
          "args": [
            "dsa_g"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_dup",
          "args": [
            "dsa_q"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_dup",
          "args": [
            "dsa_p"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_get0_key",
          "args": [
            "k->dsa",
            "&dsa_pub_key",
            "NULL"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_get0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "199-206",
          "snippet": "void\nDSA_get0_key(const DSA *d, const BIGNUM **pub_key, const BIGNUM **priv_key)\n{\n\tif (pub_key != NULL)\n\t\t*pub_key = d->pub_key;\n\tif (priv_key != NULL)\n\t\t*priv_key = d->priv_key;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nDSA_get0_key(const DSA *d, const BIGNUM **pub_key, const BIGNUM **priv_key)\n{\n\tif (pub_key != NULL)\n\t\t*pub_key = d->pub_key;\n\tif (priv_key != NULL)\n\t\t*priv_key = d->priv_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_get0_pqg",
          "args": [
            "k->dsa",
            "&dsa_p",
            "&dsa_q",
            "&dsa_g"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_get0_pqg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "161-170",
          "snippet": "void\nDSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)\n{\n\tif (p != NULL)\n\t\t*p = d->p;\n\tif (q != NULL)\n\t\t*q = d->q;\n\tif (g != NULL)\n\t\t*g = d->g;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nDSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)\n{\n\tif (p != NULL)\n\t\t*p = d->p;\n\tif (q != NULL)\n\t\t*q = d->q;\n\tif (g != NULL)\n\t\t*g = d->g;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_cert_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1656-1724",
    "snippet": "int\nsshkey_cert_copy(const struct sshkey *from_key, struct sshkey *to_key)\n{\n\tu_int i;\n\tconst struct sshkey_cert *from;\n\tstruct sshkey_cert *to;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (to_key == NULL || (from = from_key->cert) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((to = cert_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((r = sshbuf_putb(to->certblob, from->certblob)) != 0 ||\n\t    (r = sshbuf_putb(to->critical, from->critical)) != 0 ||\n\t    (r = sshbuf_putb(to->extensions, from->extensions)) != 0)\n\t\tgoto out;\n\n\tto->serial = from->serial;\n\tto->type = from->type;\n\tif (from->key_id == NULL)\n\t\tto->key_id = NULL;\n\telse if ((to->key_id = strdup(from->key_id)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tto->valid_after = from->valid_after;\n\tto->valid_before = from->valid_before;\n\tif (from->signature_key == NULL)\n\t\tto->signature_key = NULL;\n\telse if ((r = sshkey_from_private(from->signature_key,\n\t    &to->signature_key)) != 0)\n\t\tgoto out;\n\tif (from->signature_type != NULL &&\n\t    (to->signature_type = strdup(from->signature_type)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (from->nprincipals > SSHKEY_CERT_MAX_PRINCIPALS) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (from->nprincipals > 0) {\n\t\tif ((to->principals = calloc(from->nprincipals,\n\t\t    sizeof(*to->principals))) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tfor (i = 0; i < from->nprincipals; i++) {\n\t\t\tto->principals[i] = strdup(from->principals[i]);\n\t\t\tif (to->principals[i] == NULL) {\n\t\t\t\tto->nprincipals = i;\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tto->nprincipals = from->nprincipals;\n\n\t/* success */\n\tcert_free(to_key->cert);\n\tto_key->cert = to;\n\tto = NULL;\n\tr = 0;\n out:\n\tcert_free(to);\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cert_free",
          "args": [
            "to"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "cert_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "446-463",
          "snippet": "static void\ncert_free(struct sshkey_cert *cert)\n{\n\tu_int i;\n\n\tif (cert == NULL)\n\t\treturn;\n\tsshbuf_free(cert->certblob);\n\tsshbuf_free(cert->critical);\n\tsshbuf_free(cert->extensions);\n\tfree(cert->key_id);\n\tfor (i = 0; i < cert->nprincipals; i++)\n\t\tfree(cert->principals[i]);\n\tfree(cert->principals);\n\tsshkey_free(cert->signature_key);\n\tfree(cert->signature_type);\n\tfreezero(cert, sizeof(*cert));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncert_free(struct sshkey_cert *cert)\n{\n\tu_int i;\n\n\tif (cert == NULL)\n\t\treturn;\n\tsshbuf_free(cert->certblob);\n\tsshbuf_free(cert->critical);\n\tsshbuf_free(cert->extensions);\n\tfree(cert->key_id);\n\tfor (i = 0; i < cert->nprincipals; i++)\n\t\tfree(cert->principals[i]);\n\tfree(cert->principals);\n\tsshkey_free(cert->signature_key);\n\tfree(cert->signature_type);\n\tfreezero(cert, sizeof(*cert));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "from->principals[i]"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "from->nprincipals",
            "sizeof(*to->principals)"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "from->signature_key",
            "&to->signature_key"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putb",
          "args": [
            "to->extensions",
            "from->extensions"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "248-252",
          "snippet": "int\nsshbuf_putb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cert_new",
          "args": [],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "cert_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "465-483",
          "snippet": "static struct sshkey_cert *\ncert_new(void)\n{\n\tstruct sshkey_cert *cert;\n\n\tif ((cert = calloc(1, sizeof(*cert))) == NULL)\n\t\treturn NULL;\n\tif ((cert->certblob = sshbuf_new()) == NULL ||\n\t    (cert->critical = sshbuf_new()) == NULL ||\n\t    (cert->extensions = sshbuf_new()) == NULL) {\n\t\tcert_free(cert);\n\t\treturn NULL;\n\t}\n\tcert->key_id = NULL;\n\tcert->principals = NULL;\n\tcert->signature_key = NULL;\n\tcert->signature_type = NULL;\n\treturn cert;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshkey_cert *\ncert_new(void)\n{\n\tstruct sshkey_cert *cert;\n\n\tif ((cert = calloc(1, sizeof(*cert))) == NULL)\n\t\treturn NULL;\n\tif ((cert->certblob = sshbuf_new()) == NULL ||\n\t    (cert->critical = sshbuf_new()) == NULL ||\n\t    (cert->extensions = sshbuf_new()) == NULL) {\n\t\tcert_free(cert);\n\t\treturn NULL;\n\t}\n\tcert->key_id = NULL;\n\tcert->principals = NULL;\n\tcert->signature_key = NULL;\n\tcert->signature_type = NULL;\n\treturn cert;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_cert_copy(const struct sshkey *from_key, struct sshkey *to_key)\n{\n\tu_int i;\n\tconst struct sshkey_cert *from;\n\tstruct sshkey_cert *to;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (to_key == NULL || (from = from_key->cert) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((to = cert_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((r = sshbuf_putb(to->certblob, from->certblob)) != 0 ||\n\t    (r = sshbuf_putb(to->critical, from->critical)) != 0 ||\n\t    (r = sshbuf_putb(to->extensions, from->extensions)) != 0)\n\t\tgoto out;\n\n\tto->serial = from->serial;\n\tto->type = from->type;\n\tif (from->key_id == NULL)\n\t\tto->key_id = NULL;\n\telse if ((to->key_id = strdup(from->key_id)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tto->valid_after = from->valid_after;\n\tto->valid_before = from->valid_before;\n\tif (from->signature_key == NULL)\n\t\tto->signature_key = NULL;\n\telse if ((r = sshkey_from_private(from->signature_key,\n\t    &to->signature_key)) != 0)\n\t\tgoto out;\n\tif (from->signature_type != NULL &&\n\t    (to->signature_type = strdup(from->signature_type)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (from->nprincipals > SSHKEY_CERT_MAX_PRINCIPALS) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (from->nprincipals > 0) {\n\t\tif ((to->principals = calloc(from->nprincipals,\n\t\t    sizeof(*to->principals))) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tfor (i = 0; i < from->nprincipals; i++) {\n\t\t\tto->principals[i] = strdup(from->principals[i]);\n\t\t\tif (to->principals[i] == NULL) {\n\t\t\t\tto->nprincipals = i;\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tto->nprincipals = from->nprincipals;\n\n\t/* success */\n\tcert_free(to_key->cert);\n\tto_key->cert = to;\n\tto = NULL;\n\tr = 0;\n out:\n\tcert_free(to);\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_generate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1605-1654",
    "snippet": "int\nsshkey_generate(int type, u_int bits, struct sshkey **keyp)\n{\n\tstruct sshkey *k;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*keyp = NULL;\n\tif ((k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tswitch (type) {\n\tcase KEY_ED25519:\n\t\tif ((k->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL ||\n\t\t    (k->ed25519_sk = malloc(ED25519_SK_SZ)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tcrypto_sign_ed25519_keypair(k->ed25519_pk, k->ed25519_sk);\n\t\tret = 0;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tret = sshkey_xmss_generate_private_key(k, bits);\n\t\tbreak;\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tret = dsa_generate_private_key(bits, &k->dsa);\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tret = ecdsa_generate_private_key(bits, &k->ecdsa_nid,\n\t\t    &k->ecdsa);\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tret = rsa_generate_private_key(bits, &k->rsa);\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (ret == 0) {\n\t\tk->type = type;\n\t\t*keyp = k;\n\t} else\n\t\tsshkey_free(k);\n\treturn ret;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "k"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsa_generate_private_key",
          "args": [
            "bits",
            "&k->rsa"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "rsa_generate_private_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1465-1494",
          "snippet": "static int\nrsa_generate_private_key(u_int bits, RSA **rsap)\n{\n\tRSA *private = NULL;\n\tBIGNUM *f4 = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (rsap == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (bits < SSH_RSA_MINIMUM_MODULUS_SIZE ||\n\t    bits > SSHBUF_MAX_BIGNUM * 8)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\t*rsap = NULL;\n\tif ((private = RSA_new()) == NULL || (f4 = BN_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (!BN_set_word(f4, RSA_F4) ||\n\t    !RSA_generate_key_ex(private, bits, f4, NULL)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\t*rsap = private;\n\tprivate = NULL;\n\tret = 0;\n out:\n\tRSA_free(private);\n\tBN_free(f4);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrsa_generate_private_key(u_int bits, RSA **rsap)\n{\n\tRSA *private = NULL;\n\tBIGNUM *f4 = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (rsap == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (bits < SSH_RSA_MINIMUM_MODULUS_SIZE ||\n\t    bits > SSHBUF_MAX_BIGNUM * 8)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\t*rsap = NULL;\n\tif ((private = RSA_new()) == NULL || (f4 = BN_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (!BN_set_word(f4, RSA_F4) ||\n\t    !RSA_generate_key_ex(private, bits, f4, NULL)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\t*rsap = private;\n\tprivate = NULL;\n\tret = 0;\n out:\n\tRSA_free(private);\n\tBN_free(f4);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecdsa_generate_private_key",
          "args": [
            "bits",
            "&k->ecdsa_nid",
            "&k->ecdsa"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "ecdsa_generate_private_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1575-1601",
          "snippet": "static int\necdsa_generate_private_key(u_int bits, int *nid, EC_KEY **ecdsap)\n{\n\tEC_KEY *private;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (nid == NULL || ecdsap == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((*nid = sshkey_ecdsa_bits_to_nid(bits)) == -1)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\t*ecdsap = NULL;\n\tif ((private = EC_KEY_new_by_curve_name(*nid)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_KEY_generate_key(private) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tEC_KEY_set_asn1_flag(private, OPENSSL_EC_NAMED_CURVE);\n\t*ecdsap = private;\n\tprivate = NULL;\n\tret = 0;\n out:\n\tEC_KEY_free(private);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\necdsa_generate_private_key(u_int bits, int *nid, EC_KEY **ecdsap)\n{\n\tEC_KEY *private;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (nid == NULL || ecdsap == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((*nid = sshkey_ecdsa_bits_to_nid(bits)) == -1)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\t*ecdsap = NULL;\n\tif ((private = EC_KEY_new_by_curve_name(*nid)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_KEY_generate_key(private) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tEC_KEY_set_asn1_flag(private, OPENSSL_EC_NAMED_CURVE);\n\t*ecdsap = private;\n\tprivate = NULL;\n\tret = 0;\n out:\n\tEC_KEY_free(private);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dsa_generate_private_key",
          "args": [
            "bits",
            "&k->dsa"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_generate_private_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1496-1522",
          "snippet": "static int\ndsa_generate_private_key(u_int bits, DSA **dsap)\n{\n\tDSA *private;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (dsap == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (bits != 1024)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\tif ((private = DSA_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t*dsap = NULL;\n\tif (!DSA_generate_parameters_ex(private, bits, NULL, 0, NULL,\n\t    NULL, NULL) || !DSA_generate_key(private)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\t*dsap = private;\n\tprivate = NULL;\n\tret = 0;\n out:\n\tDSA_free(private);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndsa_generate_private_key(u_int bits, DSA **dsap)\n{\n\tDSA *private;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (dsap == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (bits != 1024)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\tif ((private = DSA_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t*dsap = NULL;\n\tif (!DSA_generate_parameters_ex(private, bits, NULL, 0, NULL,\n\t    NULL, NULL) || !DSA_generate_key(private)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\t*dsap = private;\n\tprivate = NULL;\n\tret = 0;\n out:\n\tDSA_free(private);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_generate_private_key",
          "args": [
            "k",
            "bits"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_generate_private_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "365-391",
          "snippet": "int\nsshkey_xmss_generate_private_key(struct sshkey *k, u_int bits)\n{\n\tint r;\n\tconst char *name;\n\n\tif (bits == 10) {\n\t\tname = XMSS_SHA2_256_W16_H10_NAME;\n\t} else if (bits == 16) {\n\t\tname = XMSS_SHA2_256_W16_H16_NAME;\n\t} else if (bits == 20) {\n\t\tname = XMSS_SHA2_256_W16_H20_NAME;\n\t} else {\n\t\tname = XMSS_DEFAULT_NAME;\n\t}\n\tif ((r = sshkey_xmss_init(k, name)) != 0 ||\n\t    (r = sshkey_xmss_init_bds_state(k)) != 0 ||\n\t    (r = sshkey_xmss_init_enc_key(k, XMSS_CIPHERNAME)) != 0)\n\t\treturn r;\n\tif ((k->xmss_pk = malloc(sshkey_xmss_pklen(k))) == NULL ||\n\t    (k->xmss_sk = malloc(sshkey_xmss_sklen(k))) == NULL) {\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\txmss_keypair(k->xmss_pk, k->xmss_sk, sshkey_xmss_bds_state(k),\n\t    sshkey_xmss_params(k));\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define XMSS_CIPHERNAME\t\t\"aes256-gcm@openssh.com\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define XMSS_CIPHERNAME\t\t\"aes256-gcm@openssh.com\"\n\nint\nsshkey_xmss_generate_private_key(struct sshkey *k, u_int bits)\n{\n\tint r;\n\tconst char *name;\n\n\tif (bits == 10) {\n\t\tname = XMSS_SHA2_256_W16_H10_NAME;\n\t} else if (bits == 16) {\n\t\tname = XMSS_SHA2_256_W16_H16_NAME;\n\t} else if (bits == 20) {\n\t\tname = XMSS_SHA2_256_W16_H20_NAME;\n\t} else {\n\t\tname = XMSS_DEFAULT_NAME;\n\t}\n\tif ((r = sshkey_xmss_init(k, name)) != 0 ||\n\t    (r = sshkey_xmss_init_bds_state(k)) != 0 ||\n\t    (r = sshkey_xmss_init_enc_key(k, XMSS_CIPHERNAME)) != 0)\n\t\treturn r;\n\tif ((k->xmss_pk = malloc(sshkey_xmss_pklen(k))) == NULL ||\n\t    (k->xmss_sk = malloc(sshkey_xmss_sklen(k))) == NULL) {\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\txmss_keypair(k->xmss_pk, k->xmss_sk, sshkey_xmss_bds_state(k),\n\t    sshkey_xmss_params(k));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_sign_ed25519_keypair",
          "args": [
            "k->ed25519_pk",
            "k->ed25519_sk"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "crypto_sign_ed25519_keypair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ed25519.c",
          "lines": "26-49",
          "snippet": "int crypto_sign_ed25519_keypair(\n    unsigned char *pk,\n    unsigned char *sk\n    )\n{\n  sc25519 scsk;\n  ge25519 gepk;\n  unsigned char extsk[64];\n  int i;\n\n  randombytes(sk, 32);\n  crypto_hash_sha512(extsk, sk, 32);\n  extsk[0] &= 248;\n  extsk[31] &= 127;\n  extsk[31] |= 64;\n\n  sc25519_from32bytes(&scsk,extsk);\n  \n  ge25519_scalarmult_base(&gepk, &scsk);\n  ge25519_pack(pk, &gepk);\n  for(i=0;i<32;i++)\n    sk[32 + i] = pk[i];\n  return 0;\n}",
          "includes": [
            "#include \"ge25519.h\"",
            "#include \"crypto_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ge25519.h\"\n#include \"crypto_api.h\"\n#include \"includes.h\"\n\nint crypto_sign_ed25519_keypair(\n    unsigned char *pk,\n    unsigned char *sk\n    )\n{\n  sc25519 scsk;\n  ge25519 gepk;\n  unsigned char extsk[64];\n  int i;\n\n  randombytes(sk, 32);\n  crypto_hash_sha512(extsk, sk, 32);\n  extsk[0] &= 248;\n  extsk[31] &= 127;\n  extsk[31] |= 64;\n\n  sc25519_from32bytes(&scsk,extsk);\n  \n  ge25519_scalarmult_base(&gepk, &scsk);\n  ge25519_pack(pk, &gepk);\n  for(i=0;i<32;i++)\n    sk[32 + i] = pk[i];\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "ED25519_SK_SZ"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_new",
          "args": [
            "KEY_UNSPEC"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "485-550",
          "snippet": "struct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_generate(int type, u_int bits, struct sshkey **keyp)\n{\n\tstruct sshkey *k;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*keyp = NULL;\n\tif ((k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tswitch (type) {\n\tcase KEY_ED25519:\n\t\tif ((k->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL ||\n\t\t    (k->ed25519_sk = malloc(ED25519_SK_SZ)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tcrypto_sign_ed25519_keypair(k->ed25519_pk, k->ed25519_sk);\n\t\tret = 0;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tret = sshkey_xmss_generate_private_key(k, bits);\n\t\tbreak;\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tret = dsa_generate_private_key(bits, &k->dsa);\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tret = ecdsa_generate_private_key(bits, &k->ecdsa_nid,\n\t\t    &k->ecdsa);\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tret = rsa_generate_private_key(bits, &k->rsa);\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (ret == 0) {\n\t\tk->type = type;\n\t\t*keyp = k;\n\t} else\n\t\tsshkey_free(k);\n\treturn ret;\n}"
  },
  {
    "function_name": "ecdsa_generate_private_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1575-1601",
    "snippet": "static int\necdsa_generate_private_key(u_int bits, int *nid, EC_KEY **ecdsap)\n{\n\tEC_KEY *private;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (nid == NULL || ecdsap == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((*nid = sshkey_ecdsa_bits_to_nid(bits)) == -1)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\t*ecdsap = NULL;\n\tif ((private = EC_KEY_new_by_curve_name(*nid)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_KEY_generate_key(private) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tEC_KEY_set_asn1_flag(private, OPENSSL_EC_NAMED_CURVE);\n\t*ecdsap = private;\n\tprivate = NULL;\n\tret = 0;\n out:\n\tEC_KEY_free(private);\n\treturn ret;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EC_KEY_free",
          "args": [
            "private"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_set_asn1_flag",
          "args": [
            "private",
            "OPENSSL_EC_NAMED_CURVE"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_generate_key",
          "args": [
            "private"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_new_by_curve_name",
          "args": [
            "*nid"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_ecdsa_bits_to_nid",
          "args": [
            "bits"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ecdsa_bits_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "394-409",
          "snippet": "int\nsshkey_ecdsa_bits_to_nid(int bits)\n{\n\tswitch (bits) {\n\tcase 256:\n\t\treturn NID_X9_62_prime256v1;\n\tcase 384:\n\t\treturn NID_secp384r1;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase 521:\n\t\treturn NID_secp521r1;\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_ecdsa_bits_to_nid(int bits)\n{\n\tswitch (bits) {\n\tcase 256:\n\t\treturn NID_X9_62_prime256v1;\n\tcase 384:\n\t\treturn NID_secp384r1;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase 521:\n\t\treturn NID_secp521r1;\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\necdsa_generate_private_key(u_int bits, int *nid, EC_KEY **ecdsap)\n{\n\tEC_KEY *private;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (nid == NULL || ecdsap == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((*nid = sshkey_ecdsa_bits_to_nid(bits)) == -1)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\t*ecdsap = NULL;\n\tif ((private = EC_KEY_new_by_curve_name(*nid)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_KEY_generate_key(private) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tEC_KEY_set_asn1_flag(private, OPENSSL_EC_NAMED_CURVE);\n\t*ecdsap = private;\n\tprivate = NULL;\n\tret = 0;\n out:\n\tEC_KEY_free(private);\n\treturn ret;\n}"
  },
  {
    "function_name": "sshkey_ecdsa_key_to_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1525-1573",
    "snippet": "int\nsshkey_ecdsa_key_to_nid(EC_KEY *k)\n{\n\tEC_GROUP *eg;\n\tint nids[] = {\n\t\tNID_X9_62_prime256v1,\n\t\tNID_secp384r1,\n#  ifdef OPENSSL_HAS_NISTP521\n\t\tNID_secp521r1,\n#  endif /* OPENSSL_HAS_NISTP521 */\n\t\t-1\n\t};\n\tint nid;\n\tu_int i;\n\tBN_CTX *bnctx;\n\tconst EC_GROUP *g = EC_KEY_get0_group(k);\n\n\t/*\n\t * The group may be stored in a ASN.1 encoded private key in one of two\n\t * ways: as a \"named group\", which is reconstituted by ASN.1 object ID\n\t * or explicit group parameters encoded into the key blob. Only the\n\t * \"named group\" case sets the group NID for us, but we can figure\n\t * it out for the other case by comparing against all the groups that\n\t * are supported.\n\t */\n\tif ((nid = EC_GROUP_get_curve_name(g)) > 0)\n\t\treturn nid;\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn -1;\n\tfor (i = 0; nids[i] != -1; i++) {\n\t\tif ((eg = EC_GROUP_new_by_curve_name(nids[i])) == NULL) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn -1;\n\t\t}\n\t\tif (EC_GROUP_cmp(g, eg, bnctx) == 0)\n\t\t\tbreak;\n\t\tEC_GROUP_free(eg);\n\t}\n\tBN_CTX_free(bnctx);\n\tif (nids[i] != -1) {\n\t\t/* Use the group with the NID attached */\n\t\tEC_GROUP_set_asn1_flag(eg, OPENSSL_EC_NAMED_CURVE);\n\t\tif (EC_KEY_set_group(k, eg) != 1) {\n\t\t\tEC_GROUP_free(eg);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn nids[i];\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EC_GROUP_free",
          "args": [
            "eg"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_set_group",
          "args": [
            "k",
            "eg"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_GROUP_set_asn1_flag",
          "args": [
            "eg",
            "OPENSSL_EC_NAMED_CURVE"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_free",
          "args": [
            "bnctx"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_GROUP_free",
          "args": [
            "eg"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_GROUP_cmp",
          "args": [
            "g",
            "eg",
            "bnctx"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_free",
          "args": [
            "bnctx"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_GROUP_new_by_curve_name",
          "args": [
            "nids[i]"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_new",
          "args": [],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_GROUP_get_curve_name",
          "args": [
            "g"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "k"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_ecdsa_key_to_nid(EC_KEY *k)\n{\n\tEC_GROUP *eg;\n\tint nids[] = {\n\t\tNID_X9_62_prime256v1,\n\t\tNID_secp384r1,\n#  ifdef OPENSSL_HAS_NISTP521\n\t\tNID_secp521r1,\n#  endif /* OPENSSL_HAS_NISTP521 */\n\t\t-1\n\t};\n\tint nid;\n\tu_int i;\n\tBN_CTX *bnctx;\n\tconst EC_GROUP *g = EC_KEY_get0_group(k);\n\n\t/*\n\t * The group may be stored in a ASN.1 encoded private key in one of two\n\t * ways: as a \"named group\", which is reconstituted by ASN.1 object ID\n\t * or explicit group parameters encoded into the key blob. Only the\n\t * \"named group\" case sets the group NID for us, but we can figure\n\t * it out for the other case by comparing against all the groups that\n\t * are supported.\n\t */\n\tif ((nid = EC_GROUP_get_curve_name(g)) > 0)\n\t\treturn nid;\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn -1;\n\tfor (i = 0; nids[i] != -1; i++) {\n\t\tif ((eg = EC_GROUP_new_by_curve_name(nids[i])) == NULL) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn -1;\n\t\t}\n\t\tif (EC_GROUP_cmp(g, eg, bnctx) == 0)\n\t\t\tbreak;\n\t\tEC_GROUP_free(eg);\n\t}\n\tBN_CTX_free(bnctx);\n\tif (nids[i] != -1) {\n\t\t/* Use the group with the NID attached */\n\t\tEC_GROUP_set_asn1_flag(eg, OPENSSL_EC_NAMED_CURVE);\n\t\tif (EC_KEY_set_group(k, eg) != 1) {\n\t\t\tEC_GROUP_free(eg);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn nids[i];\n}"
  },
  {
    "function_name": "dsa_generate_private_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1496-1522",
    "snippet": "static int\ndsa_generate_private_key(u_int bits, DSA **dsap)\n{\n\tDSA *private;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (dsap == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (bits != 1024)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\tif ((private = DSA_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t*dsap = NULL;\n\tif (!DSA_generate_parameters_ex(private, bits, NULL, 0, NULL,\n\t    NULL, NULL) || !DSA_generate_key(private)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\t*dsap = private;\n\tprivate = NULL;\n\tret = 0;\n out:\n\tDSA_free(private);\n\treturn ret;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DSA_free",
          "args": [
            "private"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_generate_key",
          "args": [
            "private"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_generate_parameters_ex",
          "args": [
            "private",
            "bits",
            "NULL",
            "0",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_new",
          "args": [],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndsa_generate_private_key(u_int bits, DSA **dsap)\n{\n\tDSA *private;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (dsap == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (bits != 1024)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\tif ((private = DSA_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t*dsap = NULL;\n\tif (!DSA_generate_parameters_ex(private, bits, NULL, 0, NULL,\n\t    NULL, NULL) || !DSA_generate_key(private)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\t*dsap = private;\n\tprivate = NULL;\n\tret = 0;\n out:\n\tDSA_free(private);\n\treturn ret;\n}"
  },
  {
    "function_name": "rsa_generate_private_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1465-1494",
    "snippet": "static int\nrsa_generate_private_key(u_int bits, RSA **rsap)\n{\n\tRSA *private = NULL;\n\tBIGNUM *f4 = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (rsap == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (bits < SSH_RSA_MINIMUM_MODULUS_SIZE ||\n\t    bits > SSHBUF_MAX_BIGNUM * 8)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\t*rsap = NULL;\n\tif ((private = RSA_new()) == NULL || (f4 = BN_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (!BN_set_word(f4, RSA_F4) ||\n\t    !RSA_generate_key_ex(private, bits, f4, NULL)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\t*rsap = private;\n\tprivate = NULL;\n\tret = 0;\n out:\n\tRSA_free(private);\n\tBN_free(f4);\n\treturn ret;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BN_free",
          "args": [
            "f4"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_free",
          "args": [
            "private"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_generate_key_ex",
          "args": [
            "private",
            "bits",
            "f4",
            "NULL"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_set_word",
          "args": [
            "f4",
            "RSA_F4"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_new",
          "args": [],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrsa_generate_private_key(u_int bits, RSA **rsap)\n{\n\tRSA *private = NULL;\n\tBIGNUM *f4 = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (rsap == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (bits < SSH_RSA_MINIMUM_MODULUS_SIZE ||\n\t    bits > SSHBUF_MAX_BIGNUM * 8)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\t*rsap = NULL;\n\tif ((private = RSA_new()) == NULL || (f4 = BN_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (!BN_set_word(f4, RSA_F4) ||\n\t    !RSA_generate_key_ex(private, bits, f4, NULL)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\t*rsap = private;\n\tprivate = NULL;\n\tret = 0;\n out:\n\tRSA_free(private);\n\tBN_free(f4);\n\treturn ret;\n}"
  },
  {
    "function_name": "sshkey_cert_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1451-1462",
    "snippet": "const char *\nsshkey_cert_type(const struct sshkey *k)\n{\n\tswitch (k->cert->type) {\n\tcase SSH2_CERT_TYPE_USER:\n\t\treturn \"user\";\n\tcase SSH2_CERT_TYPE_HOST:\n\t\treturn \"host\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_cert_type(const struct sshkey *k)\n{\n\tswitch (k->cert->type) {\n\tcase SSH2_CERT_TYPE_USER:\n\t\treturn \"user\";\n\tcase SSH2_CERT_TYPE_HOST:\n\t\treturn \"host\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}"
  },
  {
    "function_name": "sshkey_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1428-1449",
    "snippet": "int\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "feof",
          "args": [
            "f"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "sshbuf_ptr(b)",
            "sshbuf_len(b)",
            "1",
            "f"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "b"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_format_text",
          "args": [
            "key",
            "b"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_format_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1411-1426",
          "snippet": "int\nsshkey_format_text(const struct sshkey *key, struct sshbuf *b)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tchar *uu = NULL;\n\n\tif ((r = sshkey_to_base64(key, &uu)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_putf(b, \"%s %s\",\n\t    sshkey_ssh_name(key), uu)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tfree(uu);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_format_text(const struct sshkey *key, struct sshbuf *b)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tchar *uu = NULL;\n\n\tif ((r = sshkey_to_base64(key, &uu)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_putf(b, \"%s %s\",\n\t    sshkey_ssh_name(key), uu)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tfree(uu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_format_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1411-1426",
    "snippet": "int\nsshkey_format_text(const struct sshkey *key, struct sshbuf *b)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tchar *uu = NULL;\n\n\tif ((r = sshkey_to_base64(key, &uu)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_putf(b, \"%s %s\",\n\t    sshkey_ssh_name(key), uu)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tfree(uu);\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "uu"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putf",
          "args": [
            "b",
            "\"%s %s\"",
            "sshkey_ssh_name(key)",
            "uu"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "key"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_to_base64",
          "args": [
            "key",
            "&uu"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_to_base64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1382-1409",
          "snippet": "int\nsshkey_to_base64(const struct sshkey *key, char **b64p)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\tchar *uu = NULL;\n\n\tif (b64p != NULL)\n\t\t*b64p = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_putb(key, b)) != 0)\n\t\tgoto out;\n\tif ((uu = sshbuf_dtob64(b)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tif (b64p != NULL) {\n\t\t*b64p = uu;\n\t\tuu = NULL;\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tfree(uu);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_base64(const struct sshkey *key, char **b64p)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\tchar *uu = NULL;\n\n\tif (b64p != NULL)\n\t\t*b64p = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_putb(key, b)) != 0)\n\t\tgoto out;\n\tif ((uu = sshbuf_dtob64(b)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tif (b64p != NULL) {\n\t\t*b64p = uu;\n\t\tuu = NULL;\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tfree(uu);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_format_text(const struct sshkey *key, struct sshbuf *b)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tchar *uu = NULL;\n\n\tif ((r = sshkey_to_base64(key, &uu)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_putf(b, \"%s %s\",\n\t    sshkey_ssh_name(key), uu)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tfree(uu);\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_to_base64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1382-1409",
    "snippet": "int\nsshkey_to_base64(const struct sshkey *key, char **b64p)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\tchar *uu = NULL;\n\n\tif (b64p != NULL)\n\t\t*b64p = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_putb(key, b)) != 0)\n\t\tgoto out;\n\tif ((uu = sshbuf_dtob64(b)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tif (b64p != NULL) {\n\t\t*b64p = uu;\n\t\tuu = NULL;\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tfree(uu);\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "uu"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_dtob64",
          "args": [
            "b"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_dtob64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "92-111",
          "snippet": "char *\nsshbuf_dtob64(struct sshbuf *buf)\n{\n\tsize_t len = sshbuf_len(buf), plen;\n\tconst u_char *p = sshbuf_ptr(buf);\n\tchar *ret;\n\tint r;\n\n\tif (len == 0)\n\t\treturn strdup(\"\");\n\tplen = ((len + 2) / 3) * 4 + 1;\n\tif (SIZE_MAX / 2 <= len || (ret = malloc(plen)) == NULL)\n\t\treturn NULL;\n\tif ((r = b64_ntop(p, len, ret, plen)) == -1) {\n\t\texplicit_bzero(ret, plen);\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshbuf_dtob64(struct sshbuf *buf)\n{\n\tsize_t len = sshbuf_len(buf), plen;\n\tconst u_char *p = sshbuf_ptr(buf);\n\tchar *ret;\n\tint r;\n\n\tif (len == 0)\n\t\treturn strdup(\"\");\n\tplen = ((len + 2) / 3) * 4 + 1;\n\tif (SIZE_MAX / 2 <= len || (ret = malloc(plen)) == NULL)\n\t\treturn NULL;\n\tif ((r = b64_ntop(p, len, ret, plen)) == -1) {\n\t\texplicit_bzero(ret, plen);\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_putb",
          "args": [
            "key",
            "b"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_putb_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "842-846",
          "snippet": "int\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_base64(const struct sshkey *key, char **b64p)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\tchar *uu = NULL;\n\n\tif (b64p != NULL)\n\t\t*b64p = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_putb(key, b)) != 0)\n\t\tgoto out;\n\tif ((uu = sshbuf_dtob64(b)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tif (b64p != NULL) {\n\t\t*b64p = uu;\n\t\tuu = NULL;\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tfree(uu);\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1219-1379",
    "snippet": "int\nsshkey_read(struct sshkey *ret, char **cpp)\n{\n\tstruct sshkey *k;\n\tchar *cp, *blobcopy;\n\tsize_t space;\n\tint r, type, curve_nid = -1;\n\tstruct sshbuf *blob;\n\n\tif (ret == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tswitch (ret->type) {\n\tcase KEY_UNSPEC:\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\tbreak; /* ok */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\n\t/* Decode type */\n\tcp = *cpp;\n\tspace = strcspn(cp, \" \\t\");\n\tif (space == strlen(cp))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((type = peek_type_nid(cp, space, &curve_nid)) == KEY_UNSPEC)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* skip whitespace */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\tif (*cp == '\\0')\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (ret->type != KEY_UNSPEC && ret->type != type)\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\tif ((blob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* find end of keyblob and decode */\n\tspace = strcspn(cp, \" \\t\");\n\tif ((blobcopy = strndup(cp, space)) == NULL) {\n\t\tsshbuf_free(blob);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_b64tod(blob, blobcopy)) != 0) {\n\t\tfree(blobcopy);\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tfree(blobcopy);\n\tif ((r = sshkey_fromb(blob, &k)) != 0) {\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tsshbuf_free(blob);\n\n\t/* skip whitespace and leave cp at start of comment */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\n\t/* ensure type of blob matches type at start of line */\n\tif (k->type != type) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\t}\n\tif (sshkey_type_plain(type) == KEY_ECDSA && curve_nid != k->ecdsa_nid) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_EC_CURVE_MISMATCH;\n\t}\n\n\t/* Fill in ret from parsed key */\n\tret->type = type;\n\tif (sshkey_is_cert(ret)) {\n\t\tif (!sshkey_is_cert(k)) {\n\t\t\tsshkey_free(k);\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\t}\n\t\tif (ret->cert != NULL)\n\t\t\tcert_free(ret->cert);\n\t\tret->cert = k->cert;\n\t\tk->cert = NULL;\n\t}\n\tswitch (sshkey_type_plain(ret->type)) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_free(ret->rsa);\n\t\tret->rsa = k->rsa;\n\t\tk->rsa = NULL;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, ret->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_free(ret->dsa);\n\t\tret->dsa = k->dsa;\n\t\tk->dsa = NULL;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, ret->dsa, 8);\n#endif\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tEC_KEY_free(ret->ecdsa);\n\t\tret->ecdsa = k->ecdsa;\n\t\tret->ecdsa_nid = k->ecdsa_nid;\n\t\tk->ecdsa = NULL;\n\t\tk->ecdsa_nid = -1;\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_key(ret->ecdsa);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tfreezero(ret->ed25519_pk, ED25519_PK_SZ);\n\t\tret->ed25519_pk = k->ed25519_pk;\n\t\tk->ed25519_pk = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tfree(ret->xmss_pk);\n\t\tret->xmss_pk = k->xmss_pk;\n\t\tk->xmss_pk = NULL;\n\t\tfree(ret->xmss_state);\n\t\tret->xmss_state = k->xmss_state;\n\t\tk->xmss_state = NULL;\n\t\tfree(ret->xmss_name);\n\t\tret->xmss_name = k->xmss_name;\n\t\tk->xmss_name = NULL;\n\t\tfree(ret->xmss_filename);\n\t\tret->xmss_filename = k->xmss_filename;\n\t\tk->xmss_filename = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tsshkey_free(k);\n\n\t/* success */\n\t*cpp = cp;\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "k"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "ret->ed25519_pk",
            "ED25519_PK_SZ"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_dump_ec_key",
          "args": [
            "ret->ecdsa"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_dump_ec_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "3379-3392",
          "snippet": "void\nsshkey_dump_ec_key(const EC_KEY *key)\n{\n\tconst BIGNUM *exponent;\n\n\tsshkey_dump_ec_point(EC_KEY_get0_group(key),\n\t    EC_KEY_get0_public_key(key));\n\tfputs(\"exponent=\", stderr);\n\tif ((exponent = EC_KEY_get0_private_key(key)) == NULL)\n\t\tfputs(\"(NULL)\", stderr);\n\telse\n\t\tBN_print_fp(stderr, EC_KEY_get0_private_key(key));\n\tfputs(\"\\n\", stderr);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_dump_ec_key(const EC_KEY *key)\n{\n\tconst BIGNUM *exponent;\n\n\tsshkey_dump_ec_point(EC_KEY_get0_group(key),\n\t    EC_KEY_get0_public_key(key));\n\tfputs(\"exponent=\", stderr);\n\tif ((exponent = EC_KEY_get0_private_key(key)) == NULL)\n\t\tfputs(\"(NULL)\", stderr);\n\telse\n\t\tBN_print_fp(stderr, EC_KEY_get0_private_key(key));\n\tfputs(\"\\n\", stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_free",
          "args": [
            "ret->ecdsa"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_print_fp",
          "args": [
            "stderr",
            "ret->dsa",
            "8"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_free",
          "args": [
            "ret->dsa"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_print_fp",
          "args": [
            "stderr",
            "ret->rsa",
            "8"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_free",
          "args": [
            "ret->rsa"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "ret->type"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cert_free",
          "args": [
            "ret->cert"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "cert_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "446-463",
          "snippet": "static void\ncert_free(struct sshkey_cert *cert)\n{\n\tu_int i;\n\n\tif (cert == NULL)\n\t\treturn;\n\tsshbuf_free(cert->certblob);\n\tsshbuf_free(cert->critical);\n\tsshbuf_free(cert->extensions);\n\tfree(cert->key_id);\n\tfor (i = 0; i < cert->nprincipals; i++)\n\t\tfree(cert->principals[i]);\n\tfree(cert->principals);\n\tsshkey_free(cert->signature_key);\n\tfree(cert->signature_type);\n\tfreezero(cert, sizeof(*cert));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncert_free(struct sshkey_cert *cert)\n{\n\tu_int i;\n\n\tif (cert == NULL)\n\t\treturn;\n\tsshbuf_free(cert->certblob);\n\tsshbuf_free(cert->critical);\n\tsshbuf_free(cert->extensions);\n\tfree(cert->key_id);\n\tfor (i = 0; i < cert->nprincipals; i++)\n\t\tfree(cert->principals[i]);\n\tfree(cert->principals);\n\tsshkey_free(cert->signature_key);\n\tfree(cert->signature_type);\n\tfreezero(cert, sizeof(*cert));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "k"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "blob"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fromb",
          "args": [
            "blob",
            "&k"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fromb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2276-2280",
          "snippet": "int\nsshkey_fromb(struct sshbuf *b, struct sshkey **keyp)\n{\n\treturn sshkey_from_blob_internal(b, keyp, 1);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_fromb(struct sshbuf *b, struct sshkey **keyp)\n{\n\treturn sshkey_from_blob_internal(b, keyp, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_b64tod",
          "args": [
            "blob",
            "blobcopy"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_b64tod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "113-137",
          "snippet": "int\nsshbuf_b64tod(struct sshbuf *buf, const char *b64)\n{\n\tsize_t plen = strlen(b64);\n\tint nlen, r;\n\tu_char *p;\n\n\tif (plen == 0)\n\t\treturn 0;\n\tif ((p = malloc(plen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((nlen = b64_pton(b64, p, plen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_put(buf, p, nlen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn r;\n\t}\n\texplicit_bzero(p, plen);\n\tfree(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_b64tod(struct sshbuf *buf, const char *b64)\n{\n\tsize_t plen = strlen(b64);\n\tint nlen, r;\n\tu_char *p;\n\n\tif (plen == 0)\n\t\treturn 0;\n\tif ((p = malloc(plen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((nlen = b64_pton(b64, p, plen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_put(buf, p, nlen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn r;\n\t}\n\texplicit_bzero(p, plen);\n\tfree(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strndup",
          "args": [
            "cp",
            "space"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strndup.c",
          "lines": "27-41",
          "snippet": "char *\nstrndup(const char *str, size_t maxlen)\n{\n\tchar *copy;\n\tsize_t len;\n\n\tlen = strnlen(str, maxlen);\n\tcopy = malloc(len + 1);\n\tif (copy != NULL) {\n\t\t(void)memcpy(copy, str, len);\n\t\tcopy[len] = '\\0';\n\t}\n\n\treturn copy;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nstrndup(const char *str, size_t maxlen)\n{\n\tchar *copy;\n\tsize_t len;\n\n\tlen = strnlen(str, maxlen);\n\tcopy = malloc(len + 1);\n\tif (copy != NULL) {\n\t\t(void)memcpy(copy, str, len);\n\t\tcopy[len] = '\\0';\n\t}\n\n\treturn copy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "cp",
            "\" \\t\""
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "peek_type_nid",
          "args": [
            "cp",
            "space",
            "&curve_nid"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "peek_type_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1200-1216",
          "snippet": "static int\npeek_type_nid(const char *s, size_t l, int *nid)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL || strlen(kt->name) != l)\n\t\t\tcontinue;\n\t\tif (memcmp(s, kt->name, l) == 0) {\n\t\t\t*nid = -1;\n\t\t\tif (kt->type == KEY_ECDSA || kt->type == KEY_ECDSA_CERT)\n\t\t\t\t*nid = kt->nid;\n\t\t\treturn kt->type;\n\t\t}\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nstatic int\npeek_type_nid(const char *s, size_t l, int *nid)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL || strlen(kt->name) != l)\n\t\t\tcontinue;\n\t\tif (memcmp(s, kt->name, l) == 0) {\n\t\t\t*nid = -1;\n\t\t\tif (kt->type == KEY_ECDSA || kt->type == KEY_ECDSA_CERT)\n\t\t\t\t*nid = kt->nid;\n\t\t\treturn kt->type;\n\t\t}\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "cp",
            "\" \\t\""
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_read(struct sshkey *ret, char **cpp)\n{\n\tstruct sshkey *k;\n\tchar *cp, *blobcopy;\n\tsize_t space;\n\tint r, type, curve_nid = -1;\n\tstruct sshbuf *blob;\n\n\tif (ret == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tswitch (ret->type) {\n\tcase KEY_UNSPEC:\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\tbreak; /* ok */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\n\t/* Decode type */\n\tcp = *cpp;\n\tspace = strcspn(cp, \" \\t\");\n\tif (space == strlen(cp))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((type = peek_type_nid(cp, space, &curve_nid)) == KEY_UNSPEC)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* skip whitespace */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\tif (*cp == '\\0')\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (ret->type != KEY_UNSPEC && ret->type != type)\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\tif ((blob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* find end of keyblob and decode */\n\tspace = strcspn(cp, \" \\t\");\n\tif ((blobcopy = strndup(cp, space)) == NULL) {\n\t\tsshbuf_free(blob);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_b64tod(blob, blobcopy)) != 0) {\n\t\tfree(blobcopy);\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tfree(blobcopy);\n\tif ((r = sshkey_fromb(blob, &k)) != 0) {\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tsshbuf_free(blob);\n\n\t/* skip whitespace and leave cp at start of comment */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\n\t/* ensure type of blob matches type at start of line */\n\tif (k->type != type) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\t}\n\tif (sshkey_type_plain(type) == KEY_ECDSA && curve_nid != k->ecdsa_nid) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_EC_CURVE_MISMATCH;\n\t}\n\n\t/* Fill in ret from parsed key */\n\tret->type = type;\n\tif (sshkey_is_cert(ret)) {\n\t\tif (!sshkey_is_cert(k)) {\n\t\t\tsshkey_free(k);\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\t}\n\t\tif (ret->cert != NULL)\n\t\t\tcert_free(ret->cert);\n\t\tret->cert = k->cert;\n\t\tk->cert = NULL;\n\t}\n\tswitch (sshkey_type_plain(ret->type)) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_free(ret->rsa);\n\t\tret->rsa = k->rsa;\n\t\tk->rsa = NULL;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, ret->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_free(ret->dsa);\n\t\tret->dsa = k->dsa;\n\t\tk->dsa = NULL;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, ret->dsa, 8);\n#endif\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tEC_KEY_free(ret->ecdsa);\n\t\tret->ecdsa = k->ecdsa;\n\t\tret->ecdsa_nid = k->ecdsa_nid;\n\t\tk->ecdsa = NULL;\n\t\tk->ecdsa_nid = -1;\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_key(ret->ecdsa);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tfreezero(ret->ed25519_pk, ED25519_PK_SZ);\n\t\tret->ed25519_pk = k->ed25519_pk;\n\t\tk->ed25519_pk = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tfree(ret->xmss_pk);\n\t\tret->xmss_pk = k->xmss_pk;\n\t\tk->xmss_pk = NULL;\n\t\tfree(ret->xmss_state);\n\t\tret->xmss_state = k->xmss_state;\n\t\tk->xmss_state = NULL;\n\t\tfree(ret->xmss_name);\n\t\tret->xmss_name = k->xmss_name;\n\t\tk->xmss_name = NULL;\n\t\tfree(ret->xmss_filename);\n\t\tret->xmss_filename = k->xmss_filename;\n\t\tk->xmss_filename = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tsshkey_free(k);\n\n\t/* success */\n\t*cpp = cp;\n\treturn 0;\n}"
  },
  {
    "function_name": "peek_type_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1200-1216",
    "snippet": "static int\npeek_type_nid(const char *s, size_t l, int *nid)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL || strlen(kt->name) != l)\n\t\t\tcontinue;\n\t\tif (memcmp(s, kt->name, l) == 0) {\n\t\t\t*nid = -1;\n\t\t\tif (kt->type == KEY_ECDSA || kt->type == KEY_ECDSA_CERT)\n\t\t\t\t*nid = kt->nid;\n\t\t\treturn kt->type;\n\t\t}\n\t}\n\treturn KEY_UNSPEC;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "s",
            "kt->name",
            "l"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kt->name"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nstatic int\npeek_type_nid(const char *s, size_t l, int *nid)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL || strlen(kt->name) != l)\n\t\t\tcontinue;\n\t\tif (memcmp(s, kt->name, l) == 0) {\n\t\t\t*nid = -1;\n\t\t\tif (kt->type == KEY_ECDSA || kt->type == KEY_ECDSA_CERT)\n\t\t\t\t*nid = kt->nid;\n\t\t\treturn kt->type;\n\t\t}\n\t}\n\treturn KEY_UNSPEC;\n}"
  },
  {
    "function_name": "sshkey_fingerprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1155-1198",
    "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dgst_raw"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "dgst_raw",
            "dgst_raw_len"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fingerprint_randomart",
          "args": [
            "ssh_digest_alg_name(dgst_alg)",
            "dgst_raw",
            "dgst_raw_len",
            "k"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "fingerprint_randomart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1058-1153",
          "snippet": "static char *\nfingerprint_randomart(const char *alg, u_char *dgst_raw, size_t dgst_raw_len,\n    const struct sshkey *k)\n{\n\t/*\n\t * Chars to be used after each other every time the worm\n\t * intersects with itself.  Matter of taste.\n\t */\n\tchar\t*augmentation_string = \" .o+=*BOX@%&#/^SE\";\n\tchar\t*retval, *p, title[FLDSIZE_X], hash[FLDSIZE_X];\n\tu_char\t field[FLDSIZE_X][FLDSIZE_Y];\n\tsize_t\t i, tlen, hlen;\n\tu_int\t b;\n\tint\t x, y, r;\n\tsize_t\t len = strlen(augmentation_string) - 1;\n\n\tif ((retval = calloc((FLDSIZE_X + 3), (FLDSIZE_Y + 2))) == NULL)\n\t\treturn NULL;\n\n\t/* initialize field */\n\tmemset(field, 0, FLDSIZE_X * FLDSIZE_Y * sizeof(char));\n\tx = FLDSIZE_X / 2;\n\ty = FLDSIZE_Y / 2;\n\n\t/* process raw key */\n\tfor (i = 0; i < dgst_raw_len; i++) {\n\t\tint input;\n\t\t/* each byte conveys four 2-bit move commands */\n\t\tinput = dgst_raw[i];\n\t\tfor (b = 0; b < 4; b++) {\n\t\t\t/* evaluate 2 bit, rest is shifted later */\n\t\t\tx += (input & 0x1) ? 1 : -1;\n\t\t\ty += (input & 0x2) ? 1 : -1;\n\n\t\t\t/* assure we are still in bounds */\n\t\t\tx = MAXIMUM(x, 0);\n\t\t\ty = MAXIMUM(y, 0);\n\t\t\tx = MINIMUM(x, FLDSIZE_X - 1);\n\t\t\ty = MINIMUM(y, FLDSIZE_Y - 1);\n\n\t\t\t/* augment the field */\n\t\t\tif (field[x][y] < len - 2)\n\t\t\t\tfield[x][y]++;\n\t\t\tinput = input >> 2;\n\t\t}\n\t}\n\n\t/* mark starting point and end point*/\n\tfield[FLDSIZE_X / 2][FLDSIZE_Y / 2] = len - 1;\n\tfield[x][y] = len;\n\n\t/* assemble title */\n\tr = snprintf(title, sizeof(title), \"[%s %u]\",\n\t\tsshkey_type(k), sshkey_size(k));\n\t/* If [type size] won't fit, then try [type]; fits \"[ED25519-CERT]\" */\n\tif (r < 0 || r > (int)sizeof(title))\n\t\tr = snprintf(title, sizeof(title), \"[%s]\", sshkey_type(k));\n\ttlen = (r <= 0) ? 0 : strlen(title);\n\n\t/* assemble hash ID. */\n\tr = snprintf(hash, sizeof(hash), \"[%s]\", alg);\n\thlen = (r <= 0) ? 0 : strlen(hash);\n\n\t/* output upper border */\n\tp = retval;\n\t*p++ = '+';\n\tfor (i = 0; i < (FLDSIZE_X - tlen) / 2; i++)\n\t\t*p++ = '-';\n\tmemcpy(p, title, tlen);\n\tp += tlen;\n\tfor (i += tlen; i < FLDSIZE_X; i++)\n\t\t*p++ = '-';\n\t*p++ = '+';\n\t*p++ = '\\n';\n\n\t/* output content */\n\tfor (y = 0; y < FLDSIZE_Y; y++) {\n\t\t*p++ = '|';\n\t\tfor (x = 0; x < FLDSIZE_X; x++)\n\t\t\t*p++ = augmentation_string[MINIMUM(field[x][y], len)];\n\t\t*p++ = '|';\n\t\t*p++ = '\\n';\n\t}\n\n\t/* output lower border */\n\t*p++ = '+';\n\tfor (i = 0; i < (FLDSIZE_X - hlen) / 2; i++)\n\t\t*p++ = '-';\n\tmemcpy(p, hash, hlen);\n\tp += hlen;\n\tfor (i += hlen; i < FLDSIZE_X; i++)\n\t\t*p++ = '-';\n\t*p++ = '+';\n\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tFLDSIZE_X\t(FLDBASE * 2 + 1)",
            "#define\tFLDSIZE_Y\t(FLDBASE + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tFLDSIZE_X\t(FLDBASE * 2 + 1)\n#define\tFLDSIZE_Y\t(FLDBASE + 1)\n\nstatic char *\nfingerprint_randomart(const char *alg, u_char *dgst_raw, size_t dgst_raw_len,\n    const struct sshkey *k)\n{\n\t/*\n\t * Chars to be used after each other every time the worm\n\t * intersects with itself.  Matter of taste.\n\t */\n\tchar\t*augmentation_string = \" .o+=*BOX@%&#/^SE\";\n\tchar\t*retval, *p, title[FLDSIZE_X], hash[FLDSIZE_X];\n\tu_char\t field[FLDSIZE_X][FLDSIZE_Y];\n\tsize_t\t i, tlen, hlen;\n\tu_int\t b;\n\tint\t x, y, r;\n\tsize_t\t len = strlen(augmentation_string) - 1;\n\n\tif ((retval = calloc((FLDSIZE_X + 3), (FLDSIZE_Y + 2))) == NULL)\n\t\treturn NULL;\n\n\t/* initialize field */\n\tmemset(field, 0, FLDSIZE_X * FLDSIZE_Y * sizeof(char));\n\tx = FLDSIZE_X / 2;\n\ty = FLDSIZE_Y / 2;\n\n\t/* process raw key */\n\tfor (i = 0; i < dgst_raw_len; i++) {\n\t\tint input;\n\t\t/* each byte conveys four 2-bit move commands */\n\t\tinput = dgst_raw[i];\n\t\tfor (b = 0; b < 4; b++) {\n\t\t\t/* evaluate 2 bit, rest is shifted later */\n\t\t\tx += (input & 0x1) ? 1 : -1;\n\t\t\ty += (input & 0x2) ? 1 : -1;\n\n\t\t\t/* assure we are still in bounds */\n\t\t\tx = MAXIMUM(x, 0);\n\t\t\ty = MAXIMUM(y, 0);\n\t\t\tx = MINIMUM(x, FLDSIZE_X - 1);\n\t\t\ty = MINIMUM(y, FLDSIZE_Y - 1);\n\n\t\t\t/* augment the field */\n\t\t\tif (field[x][y] < len - 2)\n\t\t\t\tfield[x][y]++;\n\t\t\tinput = input >> 2;\n\t\t}\n\t}\n\n\t/* mark starting point and end point*/\n\tfield[FLDSIZE_X / 2][FLDSIZE_Y / 2] = len - 1;\n\tfield[x][y] = len;\n\n\t/* assemble title */\n\tr = snprintf(title, sizeof(title), \"[%s %u]\",\n\t\tsshkey_type(k), sshkey_size(k));\n\t/* If [type size] won't fit, then try [type]; fits \"[ED25519-CERT]\" */\n\tif (r < 0 || r > (int)sizeof(title))\n\t\tr = snprintf(title, sizeof(title), \"[%s]\", sshkey_type(k));\n\ttlen = (r <= 0) ? 0 : strlen(title);\n\n\t/* assemble hash ID. */\n\tr = snprintf(hash, sizeof(hash), \"[%s]\", alg);\n\thlen = (r <= 0) ? 0 : strlen(hash);\n\n\t/* output upper border */\n\tp = retval;\n\t*p++ = '+';\n\tfor (i = 0; i < (FLDSIZE_X - tlen) / 2; i++)\n\t\t*p++ = '-';\n\tmemcpy(p, title, tlen);\n\tp += tlen;\n\tfor (i += tlen; i < FLDSIZE_X; i++)\n\t\t*p++ = '-';\n\t*p++ = '+';\n\t*p++ = '\\n';\n\n\t/* output content */\n\tfor (y = 0; y < FLDSIZE_Y; y++) {\n\t\t*p++ = '|';\n\t\tfor (x = 0; x < FLDSIZE_X; x++)\n\t\t\t*p++ = augmentation_string[MINIMUM(field[x][y], len)];\n\t\t*p++ = '|';\n\t\t*p++ = '\\n';\n\t}\n\n\t/* output lower border */\n\t*p++ = '+';\n\tfor (i = 0; i < (FLDSIZE_X - hlen) / 2; i++)\n\t\t*p++ = '-';\n\tmemcpy(p, hash, hlen);\n\tp += hlen;\n\tfor (i += hlen; i < FLDSIZE_X; i++)\n\t\t*p++ = '-';\n\t*p++ = '+';\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_digest_alg_name",
          "args": [
            "dgst_alg"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_alg_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "135-141",
          "snippet": "const char *\nssh_digest_alg_name(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\n\treturn digest == NULL ? NULL : digest->name;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_digest_alg_name(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\n\treturn digest == NULL ? NULL : digest->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fingerprint_bubblebabble",
          "args": [
            "dgst_raw",
            "dgst_raw_len"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "fingerprint_bubblebabble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "977-1023",
          "snippet": "static char *\nfingerprint_bubblebabble(u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar vowels[] = { 'a', 'e', 'i', 'o', 'u', 'y' };\n\tchar consonants[] = { 'b', 'c', 'd', 'f', 'g', 'h', 'k', 'l', 'm',\n\t    'n', 'p', 'r', 's', 't', 'v', 'z', 'x' };\n\tu_int i, j = 0, rounds, seed = 1;\n\tchar *retval;\n\n\trounds = (dgst_raw_len / 2) + 1;\n\tif ((retval = calloc(rounds, 6)) == NULL)\n\t\treturn NULL;\n\tretval[j++] = 'x';\n\tfor (i = 0; i < rounds; i++) {\n\t\tu_int idx0, idx1, idx2, idx3, idx4;\n\t\tif ((i + 1 < rounds) || (dgst_raw_len % 2 != 0)) {\n\t\t\tidx0 = (((((u_int)(dgst_raw[2 * i])) >> 6) & 3) +\n\t\t\t    seed) % 6;\n\t\t\tidx1 = (((u_int)(dgst_raw[2 * i])) >> 2) & 15;\n\t\t\tidx2 = ((((u_int)(dgst_raw[2 * i])) & 3) +\n\t\t\t    (seed / 6)) % 6;\n\t\t\tretval[j++] = vowels[idx0];\n\t\t\tretval[j++] = consonants[idx1];\n\t\t\tretval[j++] = vowels[idx2];\n\t\t\tif ((i + 1) < rounds) {\n\t\t\t\tidx3 = (((u_int)(dgst_raw[(2 * i) + 1])) >> 4) & 15;\n\t\t\t\tidx4 = (((u_int)(dgst_raw[(2 * i) + 1]))) & 15;\n\t\t\t\tretval[j++] = consonants[idx3];\n\t\t\t\tretval[j++] = '-';\n\t\t\t\tretval[j++] = consonants[idx4];\n\t\t\t\tseed = ((seed * 5) +\n\t\t\t\t    ((((u_int)(dgst_raw[2 * i])) * 7) +\n\t\t\t\t    ((u_int)(dgst_raw[(2 * i) + 1])))) % 36;\n\t\t\t}\n\t\t} else {\n\t\t\tidx0 = seed % 6;\n\t\t\tidx1 = 16;\n\t\t\tidx2 = seed / 6;\n\t\t\tretval[j++] = vowels[idx0];\n\t\t\tretval[j++] = consonants[idx1];\n\t\t\tretval[j++] = vowels[idx2];\n\t\t}\n\t}\n\tretval[j++] = 'x';\n\tretval[j++] = '\\0';\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nfingerprint_bubblebabble(u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar vowels[] = { 'a', 'e', 'i', 'o', 'u', 'y' };\n\tchar consonants[] = { 'b', 'c', 'd', 'f', 'g', 'h', 'k', 'l', 'm',\n\t    'n', 'p', 'r', 's', 't', 'v', 'z', 'x' };\n\tu_int i, j = 0, rounds, seed = 1;\n\tchar *retval;\n\n\trounds = (dgst_raw_len / 2) + 1;\n\tif ((retval = calloc(rounds, 6)) == NULL)\n\t\treturn NULL;\n\tretval[j++] = 'x';\n\tfor (i = 0; i < rounds; i++) {\n\t\tu_int idx0, idx1, idx2, idx3, idx4;\n\t\tif ((i + 1 < rounds) || (dgst_raw_len % 2 != 0)) {\n\t\t\tidx0 = (((((u_int)(dgst_raw[2 * i])) >> 6) & 3) +\n\t\t\t    seed) % 6;\n\t\t\tidx1 = (((u_int)(dgst_raw[2 * i])) >> 2) & 15;\n\t\t\tidx2 = ((((u_int)(dgst_raw[2 * i])) & 3) +\n\t\t\t    (seed / 6)) % 6;\n\t\t\tretval[j++] = vowels[idx0];\n\t\t\tretval[j++] = consonants[idx1];\n\t\t\tretval[j++] = vowels[idx2];\n\t\t\tif ((i + 1) < rounds) {\n\t\t\t\tidx3 = (((u_int)(dgst_raw[(2 * i) + 1])) >> 4) & 15;\n\t\t\t\tidx4 = (((u_int)(dgst_raw[(2 * i) + 1]))) & 15;\n\t\t\t\tretval[j++] = consonants[idx3];\n\t\t\t\tretval[j++] = '-';\n\t\t\t\tretval[j++] = consonants[idx4];\n\t\t\t\tseed = ((seed * 5) +\n\t\t\t\t    ((((u_int)(dgst_raw[2 * i])) * 7) +\n\t\t\t\t    ((u_int)(dgst_raw[(2 * i) + 1])))) % 36;\n\t\t\t}\n\t\t} else {\n\t\t\tidx0 = seed % 6;\n\t\t\tidx1 = 16;\n\t\t\tidx2 = seed / 6;\n\t\t\tretval[j++] = vowels[idx0];\n\t\t\tretval[j++] = consonants[idx1];\n\t\t\tretval[j++] = vowels[idx2];\n\t\t}\n\t}\n\tretval[j++] = 'x';\n\tretval[j++] = '\\0';\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fingerprint_b64",
          "args": [
            "ssh_digest_alg_name(dgst_alg)",
            "dgst_raw",
            "dgst_raw_len"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "fingerprint_b64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "935-957",
          "snippet": "static char *\nfingerprint_b64(const char *alg, u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar *ret;\n\tsize_t plen = strlen(alg) + 1;\n\tsize_t rlen = ((dgst_raw_len + 2) / 3) * 4 + plen + 1;\n\tint r;\n\n\tif (dgst_raw_len > 65536 || (ret = calloc(1, rlen)) == NULL)\n\t\treturn NULL;\n\tstrlcpy(ret, alg, rlen);\n\tstrlcat(ret, \":\", rlen);\n\tif (dgst_raw_len == 0)\n\t\treturn ret;\n\tif ((r = b64_ntop(dgst_raw, dgst_raw_len,\n\t    ret + plen, rlen - plen)) == -1) {\n\t\tfreezero(ret, rlen);\n\t\treturn NULL;\n\t}\n\t/* Trim padding characters from end */\n\tret[strcspn(ret, \"=\")] = '\\0';\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nfingerprint_b64(const char *alg, u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar *ret;\n\tsize_t plen = strlen(alg) + 1;\n\tsize_t rlen = ((dgst_raw_len + 2) / 3) * 4 + plen + 1;\n\tint r;\n\n\tif (dgst_raw_len > 65536 || (ret = calloc(1, rlen)) == NULL)\n\t\treturn NULL;\n\tstrlcpy(ret, alg, rlen);\n\tstrlcat(ret, \":\", rlen);\n\tif (dgst_raw_len == 0)\n\t\treturn ret;\n\tif ((r = b64_ntop(dgst_raw, dgst_raw_len,\n\t    ret + plen, rlen - plen)) == -1) {\n\t\tfreezero(ret, rlen);\n\t\treturn NULL;\n\t}\n\t/* Trim padding characters from end */\n\tret[strcspn(ret, \"=\")] = '\\0';\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fingerprint_hex",
          "args": [
            "ssh_digest_alg_name(dgst_alg)",
            "dgst_raw",
            "dgst_raw_len"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "fingerprint_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "959-975",
          "snippet": "static char *\nfingerprint_hex(const char *alg, u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar *retval, hex[5];\n\tsize_t i, rlen = dgst_raw_len * 3 + strlen(alg) + 2;\n\n\tif (dgst_raw_len > 65536 || (retval = calloc(1, rlen)) == NULL)\n\t\treturn NULL;\n\tstrlcpy(retval, alg, rlen);\n\tstrlcat(retval, \":\", rlen);\n\tfor (i = 0; i < dgst_raw_len; i++) {\n\t\tsnprintf(hex, sizeof(hex), \"%s%02x\",\n\t\t    i > 0 ? \":\" : \"\", dgst_raw[i]);\n\t\tstrlcat(retval, hex, rlen);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nfingerprint_hex(const char *alg, u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar *retval, hex[5];\n\tsize_t i, rlen = dgst_raw_len * 3 + strlen(alg) + 2;\n\n\tif (dgst_raw_len > 65536 || (retval = calloc(1, rlen)) == NULL)\n\t\treturn NULL;\n\tstrlcpy(retval, alg, rlen);\n\tstrlcat(retval, \":\", rlen);\n\tfor (i = 0; i < dgst_raw_len; i++) {\n\t\tsnprintf(hex, sizeof(hex), \"%s%02x\",\n\t\t    i > 0 ? \":\" : \"\", dgst_raw[i]);\n\t\tstrlcat(retval, hex, rlen);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint_raw",
          "args": [
            "k",
            "dgst_alg",
            "&dgst_raw",
            "&dgst_raw_len"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "892-933",
          "snippet": "int\nsshkey_fingerprint_raw(const struct sshkey *k, int dgst_alg,\n    u_char **retp, size_t *lenp)\n{\n\tu_char *blob = NULL, *ret = NULL;\n\tsize_t blob_len = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (ssh_digest_bytes(dgst_alg) == 0) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((r = to_blob(k, &blob, &blob_len, 1, SSHKEY_SERIALIZE_DEFAULT))\n\t    != 0)\n\t\tgoto out;\n\tif ((ret = calloc(1, SSH_DIGEST_MAX_LENGTH)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_digest_memory(dgst_alg, blob, blob_len,\n\t    ret, SSH_DIGEST_MAX_LENGTH)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (retp != NULL) {\n\t\t*retp = ret;\n\t\tret = NULL;\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = ssh_digest_bytes(dgst_alg);\n\tr = 0;\n out:\n\tfree(ret);\n\tif (blob != NULL) {\n\t\texplicit_bzero(blob, blob_len);\n\t\tfree(blob);\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_fingerprint_raw(const struct sshkey *k, int dgst_alg,\n    u_char **retp, size_t *lenp)\n{\n\tu_char *blob = NULL, *ret = NULL;\n\tsize_t blob_len = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (ssh_digest_bytes(dgst_alg) == 0) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((r = to_blob(k, &blob, &blob_len, 1, SSHKEY_SERIALIZE_DEFAULT))\n\t    != 0)\n\t\tgoto out;\n\tif ((ret = calloc(1, SSH_DIGEST_MAX_LENGTH)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_digest_memory(dgst_alg, blob, blob_len,\n\t    ret, SSH_DIGEST_MAX_LENGTH)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (retp != NULL) {\n\t\t*retp = ret;\n\t\tret = NULL;\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = ssh_digest_bytes(dgst_alg);\n\tr = 0;\n out:\n\tfree(ret);\n\tif (blob != NULL) {\n\t\texplicit_bzero(blob, blob_len);\n\t\tfree(blob);\n\t}\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
  },
  {
    "function_name": "fingerprint_randomart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "1058-1153",
    "snippet": "static char *\nfingerprint_randomart(const char *alg, u_char *dgst_raw, size_t dgst_raw_len,\n    const struct sshkey *k)\n{\n\t/*\n\t * Chars to be used after each other every time the worm\n\t * intersects with itself.  Matter of taste.\n\t */\n\tchar\t*augmentation_string = \" .o+=*BOX@%&#/^SE\";\n\tchar\t*retval, *p, title[FLDSIZE_X], hash[FLDSIZE_X];\n\tu_char\t field[FLDSIZE_X][FLDSIZE_Y];\n\tsize_t\t i, tlen, hlen;\n\tu_int\t b;\n\tint\t x, y, r;\n\tsize_t\t len = strlen(augmentation_string) - 1;\n\n\tif ((retval = calloc((FLDSIZE_X + 3), (FLDSIZE_Y + 2))) == NULL)\n\t\treturn NULL;\n\n\t/* initialize field */\n\tmemset(field, 0, FLDSIZE_X * FLDSIZE_Y * sizeof(char));\n\tx = FLDSIZE_X / 2;\n\ty = FLDSIZE_Y / 2;\n\n\t/* process raw key */\n\tfor (i = 0; i < dgst_raw_len; i++) {\n\t\tint input;\n\t\t/* each byte conveys four 2-bit move commands */\n\t\tinput = dgst_raw[i];\n\t\tfor (b = 0; b < 4; b++) {\n\t\t\t/* evaluate 2 bit, rest is shifted later */\n\t\t\tx += (input & 0x1) ? 1 : -1;\n\t\t\ty += (input & 0x2) ? 1 : -1;\n\n\t\t\t/* assure we are still in bounds */\n\t\t\tx = MAXIMUM(x, 0);\n\t\t\ty = MAXIMUM(y, 0);\n\t\t\tx = MINIMUM(x, FLDSIZE_X - 1);\n\t\t\ty = MINIMUM(y, FLDSIZE_Y - 1);\n\n\t\t\t/* augment the field */\n\t\t\tif (field[x][y] < len - 2)\n\t\t\t\tfield[x][y]++;\n\t\t\tinput = input >> 2;\n\t\t}\n\t}\n\n\t/* mark starting point and end point*/\n\tfield[FLDSIZE_X / 2][FLDSIZE_Y / 2] = len - 1;\n\tfield[x][y] = len;\n\n\t/* assemble title */\n\tr = snprintf(title, sizeof(title), \"[%s %u]\",\n\t\tsshkey_type(k), sshkey_size(k));\n\t/* If [type size] won't fit, then try [type]; fits \"[ED25519-CERT]\" */\n\tif (r < 0 || r > (int)sizeof(title))\n\t\tr = snprintf(title, sizeof(title), \"[%s]\", sshkey_type(k));\n\ttlen = (r <= 0) ? 0 : strlen(title);\n\n\t/* assemble hash ID. */\n\tr = snprintf(hash, sizeof(hash), \"[%s]\", alg);\n\thlen = (r <= 0) ? 0 : strlen(hash);\n\n\t/* output upper border */\n\tp = retval;\n\t*p++ = '+';\n\tfor (i = 0; i < (FLDSIZE_X - tlen) / 2; i++)\n\t\t*p++ = '-';\n\tmemcpy(p, title, tlen);\n\tp += tlen;\n\tfor (i += tlen; i < FLDSIZE_X; i++)\n\t\t*p++ = '-';\n\t*p++ = '+';\n\t*p++ = '\\n';\n\n\t/* output content */\n\tfor (y = 0; y < FLDSIZE_Y; y++) {\n\t\t*p++ = '|';\n\t\tfor (x = 0; x < FLDSIZE_X; x++)\n\t\t\t*p++ = augmentation_string[MINIMUM(field[x][y], len)];\n\t\t*p++ = '|';\n\t\t*p++ = '\\n';\n\t}\n\n\t/* output lower border */\n\t*p++ = '+';\n\tfor (i = 0; i < (FLDSIZE_X - hlen) / 2; i++)\n\t\t*p++ = '-';\n\tmemcpy(p, hash, hlen);\n\tp += hlen;\n\tfor (i += hlen; i < FLDSIZE_X; i++)\n\t\t*p++ = '-';\n\t*p++ = '+';\n\n\treturn retval;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tFLDSIZE_X\t(FLDBASE * 2 + 1)",
      "#define\tFLDSIZE_Y\t(FLDBASE + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "hash",
            "hlen"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "field[x][y]",
            "len"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "title",
            "tlen"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hash"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "hash",
            "sizeof(hash)",
            "\"[%s]\"",
            "alg"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "title"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "k"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_size",
          "args": [
            "k"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "283-315",
          "snippet": "u_int\nsshkey_size(const struct sshkey *k)\n{\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *dsa_p;\n#endif /* WITH_OPENSSL */\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (k->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(k->rsa, &rsa_n, NULL, NULL);\n\t\treturn BN_num_bits(rsa_n);\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif (k->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, NULL, NULL);\n\t\treturn BN_num_bits(dsa_p);\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\treturn sshkey_curve_nid_to_bits(k->ecdsa_nid);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn 256;\t/* XXX */\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\nsshkey_size(const struct sshkey *k)\n{\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *dsa_p;\n#endif /* WITH_OPENSSL */\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (k->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(k->rsa, &rsa_n, NULL, NULL);\n\t\treturn BN_num_bits(rsa_n);\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif (k->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, NULL, NULL);\n\t\treturn BN_num_bits(dsa_p);\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\treturn sshkey_curve_nid_to_bits(k->ecdsa_nid);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn 256;\t/* XXX */\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "y",
            "FLDSIZE_Y - 1"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "x",
            "FLDSIZE_X - 1"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "y",
            "0"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "x",
            "0"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "field",
            "0",
            "FLDSIZE_X * FLDSIZE_Y * sizeof(char)"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(FLDSIZE_X + 3)",
            "(FLDSIZE_Y + 2)"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "augmentation_string"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tFLDSIZE_X\t(FLDBASE * 2 + 1)\n#define\tFLDSIZE_Y\t(FLDBASE + 1)\n\nstatic char *\nfingerprint_randomart(const char *alg, u_char *dgst_raw, size_t dgst_raw_len,\n    const struct sshkey *k)\n{\n\t/*\n\t * Chars to be used after each other every time the worm\n\t * intersects with itself.  Matter of taste.\n\t */\n\tchar\t*augmentation_string = \" .o+=*BOX@%&#/^SE\";\n\tchar\t*retval, *p, title[FLDSIZE_X], hash[FLDSIZE_X];\n\tu_char\t field[FLDSIZE_X][FLDSIZE_Y];\n\tsize_t\t i, tlen, hlen;\n\tu_int\t b;\n\tint\t x, y, r;\n\tsize_t\t len = strlen(augmentation_string) - 1;\n\n\tif ((retval = calloc((FLDSIZE_X + 3), (FLDSIZE_Y + 2))) == NULL)\n\t\treturn NULL;\n\n\t/* initialize field */\n\tmemset(field, 0, FLDSIZE_X * FLDSIZE_Y * sizeof(char));\n\tx = FLDSIZE_X / 2;\n\ty = FLDSIZE_Y / 2;\n\n\t/* process raw key */\n\tfor (i = 0; i < dgst_raw_len; i++) {\n\t\tint input;\n\t\t/* each byte conveys four 2-bit move commands */\n\t\tinput = dgst_raw[i];\n\t\tfor (b = 0; b < 4; b++) {\n\t\t\t/* evaluate 2 bit, rest is shifted later */\n\t\t\tx += (input & 0x1) ? 1 : -1;\n\t\t\ty += (input & 0x2) ? 1 : -1;\n\n\t\t\t/* assure we are still in bounds */\n\t\t\tx = MAXIMUM(x, 0);\n\t\t\ty = MAXIMUM(y, 0);\n\t\t\tx = MINIMUM(x, FLDSIZE_X - 1);\n\t\t\ty = MINIMUM(y, FLDSIZE_Y - 1);\n\n\t\t\t/* augment the field */\n\t\t\tif (field[x][y] < len - 2)\n\t\t\t\tfield[x][y]++;\n\t\t\tinput = input >> 2;\n\t\t}\n\t}\n\n\t/* mark starting point and end point*/\n\tfield[FLDSIZE_X / 2][FLDSIZE_Y / 2] = len - 1;\n\tfield[x][y] = len;\n\n\t/* assemble title */\n\tr = snprintf(title, sizeof(title), \"[%s %u]\",\n\t\tsshkey_type(k), sshkey_size(k));\n\t/* If [type size] won't fit, then try [type]; fits \"[ED25519-CERT]\" */\n\tif (r < 0 || r > (int)sizeof(title))\n\t\tr = snprintf(title, sizeof(title), \"[%s]\", sshkey_type(k));\n\ttlen = (r <= 0) ? 0 : strlen(title);\n\n\t/* assemble hash ID. */\n\tr = snprintf(hash, sizeof(hash), \"[%s]\", alg);\n\thlen = (r <= 0) ? 0 : strlen(hash);\n\n\t/* output upper border */\n\tp = retval;\n\t*p++ = '+';\n\tfor (i = 0; i < (FLDSIZE_X - tlen) / 2; i++)\n\t\t*p++ = '-';\n\tmemcpy(p, title, tlen);\n\tp += tlen;\n\tfor (i += tlen; i < FLDSIZE_X; i++)\n\t\t*p++ = '-';\n\t*p++ = '+';\n\t*p++ = '\\n';\n\n\t/* output content */\n\tfor (y = 0; y < FLDSIZE_Y; y++) {\n\t\t*p++ = '|';\n\t\tfor (x = 0; x < FLDSIZE_X; x++)\n\t\t\t*p++ = augmentation_string[MINIMUM(field[x][y], len)];\n\t\t*p++ = '|';\n\t\t*p++ = '\\n';\n\t}\n\n\t/* output lower border */\n\t*p++ = '+';\n\tfor (i = 0; i < (FLDSIZE_X - hlen) / 2; i++)\n\t\t*p++ = '-';\n\tmemcpy(p, hash, hlen);\n\tp += hlen;\n\tfor (i += hlen; i < FLDSIZE_X; i++)\n\t\t*p++ = '-';\n\t*p++ = '+';\n\n\treturn retval;\n}"
  },
  {
    "function_name": "fingerprint_bubblebabble",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "977-1023",
    "snippet": "static char *\nfingerprint_bubblebabble(u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar vowels[] = { 'a', 'e', 'i', 'o', 'u', 'y' };\n\tchar consonants[] = { 'b', 'c', 'd', 'f', 'g', 'h', 'k', 'l', 'm',\n\t    'n', 'p', 'r', 's', 't', 'v', 'z', 'x' };\n\tu_int i, j = 0, rounds, seed = 1;\n\tchar *retval;\n\n\trounds = (dgst_raw_len / 2) + 1;\n\tif ((retval = calloc(rounds, 6)) == NULL)\n\t\treturn NULL;\n\tretval[j++] = 'x';\n\tfor (i = 0; i < rounds; i++) {\n\t\tu_int idx0, idx1, idx2, idx3, idx4;\n\t\tif ((i + 1 < rounds) || (dgst_raw_len % 2 != 0)) {\n\t\t\tidx0 = (((((u_int)(dgst_raw[2 * i])) >> 6) & 3) +\n\t\t\t    seed) % 6;\n\t\t\tidx1 = (((u_int)(dgst_raw[2 * i])) >> 2) & 15;\n\t\t\tidx2 = ((((u_int)(dgst_raw[2 * i])) & 3) +\n\t\t\t    (seed / 6)) % 6;\n\t\t\tretval[j++] = vowels[idx0];\n\t\t\tretval[j++] = consonants[idx1];\n\t\t\tretval[j++] = vowels[idx2];\n\t\t\tif ((i + 1) < rounds) {\n\t\t\t\tidx3 = (((u_int)(dgst_raw[(2 * i) + 1])) >> 4) & 15;\n\t\t\t\tidx4 = (((u_int)(dgst_raw[(2 * i) + 1]))) & 15;\n\t\t\t\tretval[j++] = consonants[idx3];\n\t\t\t\tretval[j++] = '-';\n\t\t\t\tretval[j++] = consonants[idx4];\n\t\t\t\tseed = ((seed * 5) +\n\t\t\t\t    ((((u_int)(dgst_raw[2 * i])) * 7) +\n\t\t\t\t    ((u_int)(dgst_raw[(2 * i) + 1])))) % 36;\n\t\t\t}\n\t\t} else {\n\t\t\tidx0 = seed % 6;\n\t\t\tidx1 = 16;\n\t\t\tidx2 = seed / 6;\n\t\t\tretval[j++] = vowels[idx0];\n\t\t\tretval[j++] = consonants[idx1];\n\t\t\tretval[j++] = vowels[idx2];\n\t\t}\n\t}\n\tretval[j++] = 'x';\n\tretval[j++] = '\\0';\n\treturn retval;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "dgst_raw[(2 * i) + 1]"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dgst_raw[2 * i]"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dgst_raw[(2 * i) + 1]"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dgst_raw[(2 * i) + 1]"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dgst_raw[2 * i]"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dgst_raw[2 * i]"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dgst_raw[2 * i]"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "rounds",
            "6"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nfingerprint_bubblebabble(u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar vowels[] = { 'a', 'e', 'i', 'o', 'u', 'y' };\n\tchar consonants[] = { 'b', 'c', 'd', 'f', 'g', 'h', 'k', 'l', 'm',\n\t    'n', 'p', 'r', 's', 't', 'v', 'z', 'x' };\n\tu_int i, j = 0, rounds, seed = 1;\n\tchar *retval;\n\n\trounds = (dgst_raw_len / 2) + 1;\n\tif ((retval = calloc(rounds, 6)) == NULL)\n\t\treturn NULL;\n\tretval[j++] = 'x';\n\tfor (i = 0; i < rounds; i++) {\n\t\tu_int idx0, idx1, idx2, idx3, idx4;\n\t\tif ((i + 1 < rounds) || (dgst_raw_len % 2 != 0)) {\n\t\t\tidx0 = (((((u_int)(dgst_raw[2 * i])) >> 6) & 3) +\n\t\t\t    seed) % 6;\n\t\t\tidx1 = (((u_int)(dgst_raw[2 * i])) >> 2) & 15;\n\t\t\tidx2 = ((((u_int)(dgst_raw[2 * i])) & 3) +\n\t\t\t    (seed / 6)) % 6;\n\t\t\tretval[j++] = vowels[idx0];\n\t\t\tretval[j++] = consonants[idx1];\n\t\t\tretval[j++] = vowels[idx2];\n\t\t\tif ((i + 1) < rounds) {\n\t\t\t\tidx3 = (((u_int)(dgst_raw[(2 * i) + 1])) >> 4) & 15;\n\t\t\t\tidx4 = (((u_int)(dgst_raw[(2 * i) + 1]))) & 15;\n\t\t\t\tretval[j++] = consonants[idx3];\n\t\t\t\tretval[j++] = '-';\n\t\t\t\tretval[j++] = consonants[idx4];\n\t\t\t\tseed = ((seed * 5) +\n\t\t\t\t    ((((u_int)(dgst_raw[2 * i])) * 7) +\n\t\t\t\t    ((u_int)(dgst_raw[(2 * i) + 1])))) % 36;\n\t\t\t}\n\t\t} else {\n\t\t\tidx0 = seed % 6;\n\t\t\tidx1 = 16;\n\t\t\tidx2 = seed / 6;\n\t\t\tretval[j++] = vowels[idx0];\n\t\t\tretval[j++] = consonants[idx1];\n\t\t\tretval[j++] = vowels[idx2];\n\t\t}\n\t}\n\tretval[j++] = 'x';\n\tretval[j++] = '\\0';\n\treturn retval;\n}"
  },
  {
    "function_name": "fingerprint_hex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "959-975",
    "snippet": "static char *\nfingerprint_hex(const char *alg, u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar *retval, hex[5];\n\tsize_t i, rlen = dgst_raw_len * 3 + strlen(alg) + 2;\n\n\tif (dgst_raw_len > 65536 || (retval = calloc(1, rlen)) == NULL)\n\t\treturn NULL;\n\tstrlcpy(retval, alg, rlen);\n\tstrlcat(retval, \":\", rlen);\n\tfor (i = 0; i < dgst_raw_len; i++) {\n\t\tsnprintf(hex, sizeof(hex), \"%s%02x\",\n\t\t    i > 0 ? \":\" : \"\", dgst_raw[i]);\n\t\tstrlcat(retval, hex, rlen);\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "retval",
            "hex",
            "rlen"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "strlcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcat.c",
          "lines": "34-60",
          "snippet": "size_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "hex",
            "sizeof(hex)",
            "\"%s%02x\"",
            "i > 0 ? \":\" : \"\"",
            "dgst_raw[i]"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "retval",
            "alg",
            "rlen"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "rlen"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "alg"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nfingerprint_hex(const char *alg, u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar *retval, hex[5];\n\tsize_t i, rlen = dgst_raw_len * 3 + strlen(alg) + 2;\n\n\tif (dgst_raw_len > 65536 || (retval = calloc(1, rlen)) == NULL)\n\t\treturn NULL;\n\tstrlcpy(retval, alg, rlen);\n\tstrlcat(retval, \":\", rlen);\n\tfor (i = 0; i < dgst_raw_len; i++) {\n\t\tsnprintf(hex, sizeof(hex), \"%s%02x\",\n\t\t    i > 0 ? \":\" : \"\", dgst_raw[i]);\n\t\tstrlcat(retval, hex, rlen);\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "fingerprint_b64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "935-957",
    "snippet": "static char *\nfingerprint_b64(const char *alg, u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar *ret;\n\tsize_t plen = strlen(alg) + 1;\n\tsize_t rlen = ((dgst_raw_len + 2) / 3) * 4 + plen + 1;\n\tint r;\n\n\tif (dgst_raw_len > 65536 || (ret = calloc(1, rlen)) == NULL)\n\t\treturn NULL;\n\tstrlcpy(ret, alg, rlen);\n\tstrlcat(ret, \":\", rlen);\n\tif (dgst_raw_len == 0)\n\t\treturn ret;\n\tif ((r = b64_ntop(dgst_raw, dgst_raw_len,\n\t    ret + plen, rlen - plen)) == -1) {\n\t\tfreezero(ret, rlen);\n\t\treturn NULL;\n\t}\n\t/* Trim padding characters from end */\n\tret[strcspn(ret, \"=\")] = '\\0';\n\treturn ret;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "ret",
            "\"=\""
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "ret",
            "rlen"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "b64_ntop",
          "args": [
            "dgst_raw",
            "dgst_raw_len",
            "ret + plen",
            "rlen - plen"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "b64_ntop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/base64.c",
          "lines": "133-185",
          "snippet": "int\nb64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize)\n{\n\tsize_t datalength = 0;\n\tu_char input[3];\n\tu_char output[4];\n\tu_int i;\n\n\twhile (2 < srclength) {\n\t\tinput[0] = *src++;\n\t\tinput[1] = *src++;\n\t\tinput[2] = *src++;\n\t\tsrclength -= 3;\n\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\t\toutput[3] = input[2] & 0x3f;\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Base64[output[3]];\n\t}\n    \n\t/* Now we worry about padding. */\n\tif (0 != srclength) {\n\t\t/* Get what's left. */\n\t\tinput[0] = input[1] = input[2] = '\\0';\n\t\tfor (i = 0; i < srclength; i++)\n\t\t\tinput[i] = *src++;\n\t\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\tif (srclength == 1)\n\t\t\ttarget[datalength++] = Pad64;\n\t\telse\n\t\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Pad64;\n\t}\n\tif (datalength >= targsize)\n\t\treturn (-1);\n\ttarget[datalength] = '\\0';\t/* Returned value doesn't count \\0. */\n\treturn (datalength);\n}",
          "includes": [
            "#include \"base64.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base64.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nb64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize)\n{\n\tsize_t datalength = 0;\n\tu_char input[3];\n\tu_char output[4];\n\tu_int i;\n\n\twhile (2 < srclength) {\n\t\tinput[0] = *src++;\n\t\tinput[1] = *src++;\n\t\tinput[2] = *src++;\n\t\tsrclength -= 3;\n\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\t\toutput[3] = input[2] & 0x3f;\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Base64[output[3]];\n\t}\n    \n\t/* Now we worry about padding. */\n\tif (0 != srclength) {\n\t\t/* Get what's left. */\n\t\tinput[0] = input[1] = input[2] = '\\0';\n\t\tfor (i = 0; i < srclength; i++)\n\t\t\tinput[i] = *src++;\n\t\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\tif (srclength == 1)\n\t\t\ttarget[datalength++] = Pad64;\n\t\telse\n\t\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Pad64;\n\t}\n\tif (datalength >= targsize)\n\t\treturn (-1);\n\ttarget[datalength] = '\\0';\t/* Returned value doesn't count \\0. */\n\treturn (datalength);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "ret",
            "\":\"",
            "rlen"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "strlcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcat.c",
          "lines": "34-60",
          "snippet": "size_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ret",
            "alg",
            "rlen"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "rlen"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "alg"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nfingerprint_b64(const char *alg, u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar *ret;\n\tsize_t plen = strlen(alg) + 1;\n\tsize_t rlen = ((dgst_raw_len + 2) / 3) * 4 + plen + 1;\n\tint r;\n\n\tif (dgst_raw_len > 65536 || (ret = calloc(1, rlen)) == NULL)\n\t\treturn NULL;\n\tstrlcpy(ret, alg, rlen);\n\tstrlcat(ret, \":\", rlen);\n\tif (dgst_raw_len == 0)\n\t\treturn ret;\n\tif ((r = b64_ntop(dgst_raw, dgst_raw_len,\n\t    ret + plen, rlen - plen)) == -1) {\n\t\tfreezero(ret, rlen);\n\t\treturn NULL;\n\t}\n\t/* Trim padding characters from end */\n\tret[strcspn(ret, \"=\")] = '\\0';\n\treturn ret;\n}"
  },
  {
    "function_name": "sshkey_fingerprint_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "892-933",
    "snippet": "int\nsshkey_fingerprint_raw(const struct sshkey *k, int dgst_alg,\n    u_char **retp, size_t *lenp)\n{\n\tu_char *blob = NULL, *ret = NULL;\n\tsize_t blob_len = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (ssh_digest_bytes(dgst_alg) == 0) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((r = to_blob(k, &blob, &blob_len, 1, SSHKEY_SERIALIZE_DEFAULT))\n\t    != 0)\n\t\tgoto out;\n\tif ((ret = calloc(1, SSH_DIGEST_MAX_LENGTH)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_digest_memory(dgst_alg, blob, blob_len,\n\t    ret, SSH_DIGEST_MAX_LENGTH)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (retp != NULL) {\n\t\t*retp = ret;\n\t\tret = NULL;\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = ssh_digest_bytes(dgst_alg);\n\tr = 0;\n out:\n\tfree(ret);\n\tif (blob != NULL) {\n\t\texplicit_bzero(blob, blob_len);\n\t\tfree(blob);\n\t}\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "blob"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "blob",
            "blob_len"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_digest_bytes",
          "args": [
            "dgst_alg"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "143-149",
          "snippet": "size_t\nssh_digest_bytes(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\n\treturn digest == NULL ? 0 : digest->digest_len;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nssh_digest_bytes(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\n\treturn digest == NULL ? 0 : digest->digest_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_digest_memory",
          "args": [
            "dgst_alg",
            "blob",
            "blob_len",
            "ret",
            "SSH_DIGEST_MAX_LENGTH"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "235-247",
          "snippet": "int\nssh_digest_memory(int alg, const void *m, size_t mlen, u_char *d, size_t dlen)\n{\n\tstruct ssh_digest_ctx *ctx = ssh_digest_start(alg);\n\n\tif (ctx == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (ssh_digest_update(ctx, m, mlen) != 0 ||\n\t    ssh_digest_final(ctx, d, dlen) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tssh_digest_free(ctx);\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_digest_memory(int alg, const void *m, size_t mlen, u_char *d, size_t dlen)\n{\n\tstruct ssh_digest_ctx *ctx = ssh_digest_start(alg);\n\n\tif (ctx == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (ssh_digest_update(ctx, m, mlen) != 0 ||\n\t    ssh_digest_final(ctx, d, dlen) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tssh_digest_free(ctx);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "SSH_DIGEST_MAX_LENGTH"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_blob",
          "args": [
            "k",
            "&blob",
            "&blob_len",
            "1",
            "SSHKEY_SERIALIZE_DEFAULT"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "848-878",
          "snippet": "static int\nto_blob(const struct sshkey *key, u_char **blobp, size_t *lenp, int force_plain,\n    enum sshkey_serialize_rep opts)\n{\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tsize_t len;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (blobp != NULL)\n\t\t*blobp = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((ret = to_blob_buf(key, b, force_plain, opts)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (blobp != NULL) {\n\t\tif ((*blobp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*blobp, sshbuf_ptr(b), len);\n\t}\n\tret = 0;\n out:\n\tsshbuf_free(b);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nstatic int\nto_blob(const struct sshkey *key, u_char **blobp, size_t *lenp, int force_plain,\n    enum sshkey_serialize_rep opts)\n{\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tsize_t len;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (blobp != NULL)\n\t\t*blobp = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((ret = to_blob_buf(key, b, force_plain, opts)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (blobp != NULL) {\n\t\tif ((*blobp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*blobp, sshbuf_ptr(b), len);\n\t}\n\tret = 0;\n out:\n\tsshbuf_free(b);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_fingerprint_raw(const struct sshkey *k, int dgst_alg,\n    u_char **retp, size_t *lenp)\n{\n\tu_char *blob = NULL, *ret = NULL;\n\tsize_t blob_len = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (ssh_digest_bytes(dgst_alg) == 0) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((r = to_blob(k, &blob, &blob_len, 1, SSHKEY_SERIALIZE_DEFAULT))\n\t    != 0)\n\t\tgoto out;\n\tif ((ret = calloc(1, SSH_DIGEST_MAX_LENGTH)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_digest_memory(dgst_alg, blob, blob_len,\n\t    ret, SSH_DIGEST_MAX_LENGTH)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (retp != NULL) {\n\t\t*retp = ret;\n\t\tret = NULL;\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = ssh_digest_bytes(dgst_alg);\n\tr = 0;\n out:\n\tfree(ret);\n\tif (blob != NULL) {\n\t\texplicit_bzero(blob, blob_len);\n\t\tfree(blob);\n\t}\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_plain_to_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "886-890",
    "snippet": "int\nsshkey_plain_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 1, SSHKEY_SERIALIZE_DEFAULT);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_blob",
          "args": [
            "key",
            "blobp",
            "lenp",
            "1",
            "SSHKEY_SERIALIZE_DEFAULT"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "848-878",
          "snippet": "static int\nto_blob(const struct sshkey *key, u_char **blobp, size_t *lenp, int force_plain,\n    enum sshkey_serialize_rep opts)\n{\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tsize_t len;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (blobp != NULL)\n\t\t*blobp = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((ret = to_blob_buf(key, b, force_plain, opts)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (blobp != NULL) {\n\t\tif ((*blobp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*blobp, sshbuf_ptr(b), len);\n\t}\n\tret = 0;\n out:\n\tsshbuf_free(b);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nstatic int\nto_blob(const struct sshkey *key, u_char **blobp, size_t *lenp, int force_plain,\n    enum sshkey_serialize_rep opts)\n{\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tsize_t len;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (blobp != NULL)\n\t\t*blobp = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((ret = to_blob_buf(key, b, force_plain, opts)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (blobp != NULL) {\n\t\tif ((*blobp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*blobp, sshbuf_ptr(b), len);\n\t}\n\tret = 0;\n out:\n\tsshbuf_free(b);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_plain_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 1, SSHKEY_SERIALIZE_DEFAULT);\n}"
  },
  {
    "function_name": "sshkey_to_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "880-884",
    "snippet": "int\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_blob",
          "args": [
            "key",
            "blobp",
            "lenp",
            "0",
            "SSHKEY_SERIALIZE_DEFAULT"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "848-878",
          "snippet": "static int\nto_blob(const struct sshkey *key, u_char **blobp, size_t *lenp, int force_plain,\n    enum sshkey_serialize_rep opts)\n{\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tsize_t len;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (blobp != NULL)\n\t\t*blobp = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((ret = to_blob_buf(key, b, force_plain, opts)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (blobp != NULL) {\n\t\tif ((*blobp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*blobp, sshbuf_ptr(b), len);\n\t}\n\tret = 0;\n out:\n\tsshbuf_free(b);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nstatic int\nto_blob(const struct sshkey *key, u_char **blobp, size_t *lenp, int force_plain,\n    enum sshkey_serialize_rep opts)\n{\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tsize_t len;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (blobp != NULL)\n\t\t*blobp = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((ret = to_blob_buf(key, b, force_plain, opts)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (blobp != NULL) {\n\t\tif ((*blobp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*blobp, sshbuf_ptr(b), len);\n\t}\n\tret = 0;\n out:\n\tsshbuf_free(b);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}"
  },
  {
    "function_name": "to_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "848-878",
    "snippet": "static int\nto_blob(const struct sshkey *key, u_char **blobp, size_t *lenp, int force_plain,\n    enum sshkey_serialize_rep opts)\n{\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tsize_t len;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (blobp != NULL)\n\t\t*blobp = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((ret = to_blob_buf(key, b, force_plain, opts)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (blobp != NULL) {\n\t\tif ((*blobp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*blobp, sshbuf_ptr(b), len);\n\t}\n\tret = 0;\n out:\n\tsshbuf_free(b);\n\treturn ret;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*blobp",
            "sshbuf_ptr(b)",
            "len"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "b"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_blob_buf",
          "args": [
            "key",
            "b",
            "force_plain",
            "opts"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "to_blob_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "716-812",
          "snippet": "static int\nto_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,\n  enum sshkey_serialize_rep opts)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tconst char *typename;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (key == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif (sshkey_is_cert(key)) {\n\t\tif (key->cert == NULL)\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\tif (sshbuf_len(key->cert->certblob) == 0)\n\t\t\treturn SSH_ERR_KEY_LACKS_CERTBLOB;\n\t}\n\ttype = force_plain ? sshkey_type_plain(key->type) : key->type;\n\ttypename = sshkey_ssh_name_from_type_nid(type, key->ecdsa_nid);\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\t/* Use the existing blob */\n\t\t/* XXX modified flag? */\n\t\tif ((ret = sshbuf_putb(b, key->cert->certblob)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif (key->dsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_pub_key)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (key->ecdsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_eckey(b, key->ecdsa)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# endif\n\tcase KEY_RSA:\n\t\tif (key->rsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_n)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif (key->ed25519_pk == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL || key->xmss_pk == NULL ||\n\t\t    sshkey_xmss_pklen(key) == 0)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->xmss_pk, sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (ret = sshkey_xmss_serialize_pk_info(key, b, opts)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nstatic int\nto_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,\n  enum sshkey_serialize_rep opts)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tconst char *typename;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (key == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif (sshkey_is_cert(key)) {\n\t\tif (key->cert == NULL)\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\tif (sshbuf_len(key->cert->certblob) == 0)\n\t\t\treturn SSH_ERR_KEY_LACKS_CERTBLOB;\n\t}\n\ttype = force_plain ? sshkey_type_plain(key->type) : key->type;\n\ttypename = sshkey_ssh_name_from_type_nid(type, key->ecdsa_nid);\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\t/* Use the existing blob */\n\t\t/* XXX modified flag? */\n\t\tif ((ret = sshbuf_putb(b, key->cert->certblob)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif (key->dsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_pub_key)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (key->ecdsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_eckey(b, key->ecdsa)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# endif\n\tcase KEY_RSA:\n\t\tif (key->rsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_n)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif (key->ed25519_pk == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL || key->xmss_pk == NULL ||\n\t\t    sshkey_xmss_pklen(key) == 0)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->xmss_pk, sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (ret = sshkey_xmss_serialize_pk_info(key, b, opts)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nstatic int\nto_blob(const struct sshkey *key, u_char **blobp, size_t *lenp, int force_plain,\n    enum sshkey_serialize_rep opts)\n{\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tsize_t len;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (blobp != NULL)\n\t\t*blobp = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((ret = to_blob_buf(key, b, force_plain, opts)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (blobp != NULL) {\n\t\tif ((*blobp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*blobp, sshbuf_ptr(b), len);\n\t}\n\tret = 0;\n out:\n\tsshbuf_free(b);\n\treturn ret;\n}"
  },
  {
    "function_name": "sshkey_putb_plain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "842-846",
    "snippet": "int\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_blob_buf",
          "args": [
            "key",
            "b",
            "1",
            "SSHKEY_SERIALIZE_DEFAULT"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "to_blob_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "716-812",
          "snippet": "static int\nto_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,\n  enum sshkey_serialize_rep opts)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tconst char *typename;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (key == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif (sshkey_is_cert(key)) {\n\t\tif (key->cert == NULL)\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\tif (sshbuf_len(key->cert->certblob) == 0)\n\t\t\treturn SSH_ERR_KEY_LACKS_CERTBLOB;\n\t}\n\ttype = force_plain ? sshkey_type_plain(key->type) : key->type;\n\ttypename = sshkey_ssh_name_from_type_nid(type, key->ecdsa_nid);\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\t/* Use the existing blob */\n\t\t/* XXX modified flag? */\n\t\tif ((ret = sshbuf_putb(b, key->cert->certblob)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif (key->dsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_pub_key)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (key->ecdsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_eckey(b, key->ecdsa)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# endif\n\tcase KEY_RSA:\n\t\tif (key->rsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_n)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif (key->ed25519_pk == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL || key->xmss_pk == NULL ||\n\t\t    sshkey_xmss_pklen(key) == 0)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->xmss_pk, sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (ret = sshkey_xmss_serialize_pk_info(key, b, opts)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nstatic int\nto_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,\n  enum sshkey_serialize_rep opts)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tconst char *typename;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (key == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif (sshkey_is_cert(key)) {\n\t\tif (key->cert == NULL)\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\tif (sshbuf_len(key->cert->certblob) == 0)\n\t\t\treturn SSH_ERR_KEY_LACKS_CERTBLOB;\n\t}\n\ttype = force_plain ? sshkey_type_plain(key->type) : key->type;\n\ttypename = sshkey_ssh_name_from_type_nid(type, key->ecdsa_nid);\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\t/* Use the existing blob */\n\t\t/* XXX modified flag? */\n\t\tif ((ret = sshbuf_putb(b, key->cert->certblob)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif (key->dsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_pub_key)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (key->ecdsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_eckey(b, key->ecdsa)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# endif\n\tcase KEY_RSA:\n\t\tif (key->rsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_n)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif (key->ed25519_pk == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL || key->xmss_pk == NULL ||\n\t\t    sshkey_xmss_pklen(key) == 0)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->xmss_pk, sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (ret = sshkey_xmss_serialize_pk_info(key, b, opts)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}"
  },
  {
    "function_name": "sshkey_puts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "836-840",
    "snippet": "int\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_puts_opts",
          "args": [
            "key",
            "b",
            "SSHKEY_SERIALIZE_DEFAULT"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_puts_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "820-834",
          "snippet": "int\nsshkey_puts_opts(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct sshbuf *tmp;\n\tint r;\n\n\tif ((tmp = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = to_blob_buf(key, tmp, 0, opts);\n\tif (r == 0)\n\t\tr = sshbuf_put_stringb(b, tmp);\n\tsshbuf_free(tmp);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nint\nsshkey_puts_opts(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct sshbuf *tmp;\n\tint r;\n\n\tif ((tmp = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = to_blob_buf(key, tmp, 0, opts);\n\tif (r == 0)\n\t\tr = sshbuf_put_stringb(b, tmp);\n\tsshbuf_free(tmp);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}"
  },
  {
    "function_name": "sshkey_puts_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "820-834",
    "snippet": "int\nsshkey_puts_opts(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct sshbuf *tmp;\n\tint r;\n\n\tif ((tmp = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = to_blob_buf(key, tmp, 0, opts);\n\tif (r == 0)\n\t\tr = sshbuf_put_stringb(b, tmp);\n\tsshbuf_free(tmp);\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "tmp"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "b",
            "tmp"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_blob_buf",
          "args": [
            "key",
            "tmp",
            "0",
            "opts"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "to_blob_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "716-812",
          "snippet": "static int\nto_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,\n  enum sshkey_serialize_rep opts)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tconst char *typename;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (key == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif (sshkey_is_cert(key)) {\n\t\tif (key->cert == NULL)\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\tif (sshbuf_len(key->cert->certblob) == 0)\n\t\t\treturn SSH_ERR_KEY_LACKS_CERTBLOB;\n\t}\n\ttype = force_plain ? sshkey_type_plain(key->type) : key->type;\n\ttypename = sshkey_ssh_name_from_type_nid(type, key->ecdsa_nid);\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\t/* Use the existing blob */\n\t\t/* XXX modified flag? */\n\t\tif ((ret = sshbuf_putb(b, key->cert->certblob)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif (key->dsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_pub_key)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (key->ecdsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_eckey(b, key->ecdsa)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# endif\n\tcase KEY_RSA:\n\t\tif (key->rsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_n)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif (key->ed25519_pk == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL || key->xmss_pk == NULL ||\n\t\t    sshkey_xmss_pklen(key) == 0)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->xmss_pk, sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (ret = sshkey_xmss_serialize_pk_info(key, b, opts)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nstatic int\nto_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,\n  enum sshkey_serialize_rep opts)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tconst char *typename;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (key == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif (sshkey_is_cert(key)) {\n\t\tif (key->cert == NULL)\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\tif (sshbuf_len(key->cert->certblob) == 0)\n\t\t\treturn SSH_ERR_KEY_LACKS_CERTBLOB;\n\t}\n\ttype = force_plain ? sshkey_type_plain(key->type) : key->type;\n\ttypename = sshkey_ssh_name_from_type_nid(type, key->ecdsa_nid);\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\t/* Use the existing blob */\n\t\t/* XXX modified flag? */\n\t\tif ((ret = sshbuf_putb(b, key->cert->certblob)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif (key->dsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_pub_key)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (key->ecdsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_eckey(b, key->ecdsa)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# endif\n\tcase KEY_RSA:\n\t\tif (key->rsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_n)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif (key->ed25519_pk == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL || key->xmss_pk == NULL ||\n\t\t    sshkey_xmss_pklen(key) == 0)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->xmss_pk, sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (ret = sshkey_xmss_serialize_pk_info(key, b, opts)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nint\nsshkey_puts_opts(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct sshbuf *tmp;\n\tint r;\n\n\tif ((tmp = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = to_blob_buf(key, tmp, 0, opts);\n\tif (r == 0)\n\t\tr = sshbuf_put_stringb(b, tmp);\n\tsshbuf_free(tmp);\n\treturn r;\n}"
  },
  {
    "function_name": "sshkey_putb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "814-818",
    "snippet": "int\nsshkey_putb(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 0, SSHKEY_SERIALIZE_DEFAULT);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_blob_buf",
          "args": [
            "key",
            "b",
            "0",
            "SSHKEY_SERIALIZE_DEFAULT"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "to_blob_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "716-812",
          "snippet": "static int\nto_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,\n  enum sshkey_serialize_rep opts)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tconst char *typename;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (key == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif (sshkey_is_cert(key)) {\n\t\tif (key->cert == NULL)\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\tif (sshbuf_len(key->cert->certblob) == 0)\n\t\t\treturn SSH_ERR_KEY_LACKS_CERTBLOB;\n\t}\n\ttype = force_plain ? sshkey_type_plain(key->type) : key->type;\n\ttypename = sshkey_ssh_name_from_type_nid(type, key->ecdsa_nid);\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\t/* Use the existing blob */\n\t\t/* XXX modified flag? */\n\t\tif ((ret = sshbuf_putb(b, key->cert->certblob)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif (key->dsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_pub_key)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (key->ecdsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_eckey(b, key->ecdsa)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# endif\n\tcase KEY_RSA:\n\t\tif (key->rsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_n)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif (key->ed25519_pk == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL || key->xmss_pk == NULL ||\n\t\t    sshkey_xmss_pklen(key) == 0)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->xmss_pk, sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (ret = sshkey_xmss_serialize_pk_info(key, b, opts)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nstatic int\nto_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,\n  enum sshkey_serialize_rep opts)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tconst char *typename;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (key == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif (sshkey_is_cert(key)) {\n\t\tif (key->cert == NULL)\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\tif (sshbuf_len(key->cert->certblob) == 0)\n\t\t\treturn SSH_ERR_KEY_LACKS_CERTBLOB;\n\t}\n\ttype = force_plain ? sshkey_type_plain(key->type) : key->type;\n\ttypename = sshkey_ssh_name_from_type_nid(type, key->ecdsa_nid);\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\t/* Use the existing blob */\n\t\t/* XXX modified flag? */\n\t\tif ((ret = sshbuf_putb(b, key->cert->certblob)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif (key->dsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_pub_key)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (key->ecdsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_eckey(b, key->ecdsa)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# endif\n\tcase KEY_RSA:\n\t\tif (key->rsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_n)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif (key->ed25519_pk == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL || key->xmss_pk == NULL ||\n\t\t    sshkey_xmss_pklen(key) == 0)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->xmss_pk, sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (ret = sshkey_xmss_serialize_pk_info(key, b, opts)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_putb(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 0, SSHKEY_SERIALIZE_DEFAULT);\n}"
  },
  {
    "function_name": "to_blob_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "716-812",
    "snippet": "static int\nto_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,\n  enum sshkey_serialize_rep opts)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tconst char *typename;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (key == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif (sshkey_is_cert(key)) {\n\t\tif (key->cert == NULL)\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\tif (sshbuf_len(key->cert->certblob) == 0)\n\t\t\treturn SSH_ERR_KEY_LACKS_CERTBLOB;\n\t}\n\ttype = force_plain ? sshkey_type_plain(key->type) : key->type;\n\ttypename = sshkey_ssh_name_from_type_nid(type, key->ecdsa_nid);\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\t/* Use the existing blob */\n\t\t/* XXX modified flag? */\n\t\tif ((ret = sshbuf_putb(b, key->cert->certblob)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif (key->dsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_pub_key)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (key->ecdsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_eckey(b, key->ecdsa)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# endif\n\tcase KEY_RSA:\n\t\tif (key->rsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_n)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif (key->ed25519_pk == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL || key->xmss_pk == NULL ||\n\t\t    sshkey_xmss_pklen(key) == 0)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->xmss_pk, sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (ret = sshkey_xmss_serialize_pk_info(key, b, opts)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_xmss_serialize_pk_info",
          "args": [
            "key",
            "b",
            "opts"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_serialize_pk_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "322-341",
          "snippet": "int\nsshkey_xmss_serialize_pk_info(const struct sshkey *k, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char have_info = 1;\n\tu_int32_t idx;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (opts != SSHKEY_SERIALIZE_INFO)\n\t\treturn 0;\n\tidx = k->xmss_sk ? PEEK_U32(k->xmss_sk) : state->idx;\n\tif ((r = sshbuf_put_u8(b, have_info)) != 0 ||\n\t    (r = sshbuf_put_u32(b, idx)) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->maxidx)) != 0)\n\t\treturn r;\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_serialize_pk_info(const struct sshkey *k, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char have_info = 1;\n\tu_int32_t idx;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (opts != SSHKEY_SERIALIZE_INFO)\n\t\treturn 0;\n\tidx = k->xmss_sk ? PEEK_U32(k->xmss_sk) : state->idx;\n\tif ((r = sshbuf_put_u8(b, have_info)) != 0 ||\n\t    (r = sshbuf_put_u32(b, idx)) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->maxidx)) != 0)\n\t\treturn r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "b",
            "key->xmss_pk",
            "sshkey_xmss_pklen(key)"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_pklen",
          "args": [
            "key"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_pklen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "245-253",
          "snippet": "size_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "b",
            "key->xmss_name"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_bignum2",
          "args": [
            "b",
            "rsa_n"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_bignum2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-crypto.c",
          "lines": "146-166",
          "snippet": "int\nsshbuf_put_bignum2(struct sshbuf *buf, const BIGNUM *v)\n{\n\tu_char d[SSHBUF_MAX_BIGNUM + 1];\n\tint len = BN_num_bytes(v), prepend = 0, r;\n\n\tif (len < 0 || len > SSHBUF_MAX_BIGNUM)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*d = '\\0';\n\tif (BN_bn2bin(v, d + 1) != len)\n\t\treturn SSH_ERR_INTERNAL_ERROR; /* Shouldn't happen */\n\t/* If MSB is set, prepend a \\0 */\n\tif (len > 0 && (d[1] & 0x80) != 0)\n\t\tprepend = 1;\n\tif ((r = sshbuf_put_string(buf, d + 1 - prepend, len + prepend)) < 0) {\n\t\texplicit_bzero(d, sizeof(d));\n\t\treturn r;\n\t}\n\texplicit_bzero(d, sizeof(d));\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n# include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_bignum2(struct sshbuf *buf, const BIGNUM *v)\n{\n\tu_char d[SSHBUF_MAX_BIGNUM + 1];\n\tint len = BN_num_bytes(v), prepend = 0, r;\n\n\tif (len < 0 || len > SSHBUF_MAX_BIGNUM)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*d = '\\0';\n\tif (BN_bn2bin(v, d + 1) != len)\n\t\treturn SSH_ERR_INTERNAL_ERROR; /* Shouldn't happen */\n\t/* If MSB is set, prepend a \\0 */\n\tif (len > 0 && (d[1] & 0x80) != 0)\n\t\tprepend = 1;\n\tif ((r = sshbuf_put_string(buf, d + 1 - prepend, len + prepend)) < 0) {\n\t\texplicit_bzero(d, sizeof(d));\n\t\treturn r;\n\t}\n\texplicit_bzero(d, sizeof(d));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_get0_key",
          "args": [
            "key->rsa",
            "&rsa_n",
            "&rsa_e",
            "NULL"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_get0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "230-239",
          "snippet": "void\nRSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)\n{\n\tif (n != NULL)\n\t\t*n = r->n;\n\tif (e != NULL)\n\t\t*e = r->e;\n\tif (d != NULL)\n\t\t*d = r->d;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nRSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)\n{\n\tif (n != NULL)\n\t\t*n = r->n;\n\tif (e != NULL)\n\t\t*e = r->e;\n\tif (d != NULL)\n\t\t*d = r->d;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_eckey",
          "args": [
            "b",
            "key->ecdsa"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_eckey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-crypto.c",
          "lines": "217-222",
          "snippet": "int\nsshbuf_put_eckey(struct sshbuf *buf, const EC_KEY *v)\n{\n\treturn sshbuf_put_ec(buf, EC_KEY_get0_public_key(v),\n\t    EC_KEY_get0_group(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n# include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_eckey(struct sshbuf *buf, const EC_KEY *v)\n{\n\treturn sshbuf_put_ec(buf, EC_KEY_get0_public_key(v),\n\t    EC_KEY_get0_group(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_curve_nid_to_name",
          "args": [
            "key->ecdsa_nid"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_curve_nid_to_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "411-426",
          "snippet": "const char *\nsshkey_curve_nid_to_name(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn \"nistp256\";\n\tcase NID_secp384r1:\n\t\treturn \"nistp384\";\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn \"nistp521\";\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_curve_nid_to_name(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn \"nistp256\";\n\tcase NID_secp384r1:\n\t\treturn \"nistp384\";\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn \"nistp521\";\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_get0_key",
          "args": [
            "key->dsa",
            "&dsa_pub_key",
            "NULL"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_get0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "199-206",
          "snippet": "void\nDSA_get0_key(const DSA *d, const BIGNUM **pub_key, const BIGNUM **priv_key)\n{\n\tif (pub_key != NULL)\n\t\t*pub_key = d->pub_key;\n\tif (priv_key != NULL)\n\t\t*priv_key = d->priv_key;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nDSA_get0_key(const DSA *d, const BIGNUM **pub_key, const BIGNUM **priv_key)\n{\n\tif (pub_key != NULL)\n\t\t*pub_key = d->pub_key;\n\tif (priv_key != NULL)\n\t\t*priv_key = d->priv_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_get0_pqg",
          "args": [
            "key->dsa",
            "&dsa_p",
            "&dsa_q",
            "&dsa_g"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_get0_pqg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "161-170",
          "snippet": "void\nDSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)\n{\n\tif (p != NULL)\n\t\t*p = d->p;\n\tif (q != NULL)\n\t\t*q = d->q;\n\tif (g != NULL)\n\t\t*g = d->g;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nDSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)\n{\n\tif (p != NULL)\n\t\t*p = d->p;\n\tif (q != NULL)\n\t\t*q = d->q;\n\tif (g != NULL)\n\t\t*g = d->g;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putb",
          "args": [
            "b",
            "key->cert->certblob"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "248-252",
          "snippet": "int\nsshbuf_putb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name_from_type_nid",
          "args": [
            "type",
            "key->ecdsa_nid"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_from_type_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "153-163",
          "snippet": "static const char *\nsshkey_ssh_name_from_type_nid(int type, int nid)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type && (kt->nid == 0 || kt->nid == nid))\n\t\t\treturn kt->name;\n\t}\n\treturn \"ssh-unknown\";\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nstatic const char *\nsshkey_ssh_name_from_type_nid(int type, int nid)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type && (kt->nid == 0 || kt->nid == nid))\n\t\t\treturn kt->name;\n\t}\n\treturn \"ssh-unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "key->type"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "key->cert->certblob"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nstatic int\nto_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,\n  enum sshkey_serialize_rep opts)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tconst char *typename;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (key == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif (sshkey_is_cert(key)) {\n\t\tif (key->cert == NULL)\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\tif (sshbuf_len(key->cert->certblob) == 0)\n\t\t\treturn SSH_ERR_KEY_LACKS_CERTBLOB;\n\t}\n\ttype = force_plain ? sshkey_type_plain(key->type) : key->type;\n\ttypename = sshkey_ssh_name_from_type_nid(type, key->ecdsa_nid);\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\t/* Use the existing blob */\n\t\t/* XXX modified flag? */\n\t\tif ((ret = sshbuf_putb(b, key->cert->certblob)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif (key->dsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(key->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, dsa_pub_key)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (key->ecdsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b,\n\t\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_eckey(b, key->ecdsa)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n# endif\n\tcase KEY_RSA:\n\t\tif (key->rsa == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(b, rsa_n)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif (key->ed25519_pk == NULL)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif (key->xmss_name == NULL || key->xmss_pk == NULL ||\n\t\t    sshkey_xmss_pklen(key) == 0)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tif ((ret = sshbuf_put_cstring(b, typename)) != 0 ||\n\t\t    (ret = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t\t    (ret = sshbuf_put_string(b,\n\t\t    key->xmss_pk, sshkey_xmss_pklen(key))) != 0 ||\n\t\t    (ret = sshkey_xmss_serialize_pk_info(key, b, opts)) != 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "704-714",
    "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_equal_public",
          "args": [
            "a",
            "b"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "627-702",
          "snippet": "int\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cert_compare",
          "args": [
            "a->cert",
            "b->cert"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "cert_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "608-621",
          "snippet": "static int\ncert_compare(struct sshkey_cert *a, struct sshkey_cert *b)\n{\n\tif (a == NULL && b == NULL)\n\t\treturn 1;\n\tif (a == NULL || b == NULL)\n\t\treturn 0;\n\tif (sshbuf_len(a->certblob) != sshbuf_len(b->certblob))\n\t\treturn 0;\n\tif (timingsafe_bcmp(sshbuf_ptr(a->certblob), sshbuf_ptr(b->certblob),\n\t    sshbuf_len(a->certblob)) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncert_compare(struct sshkey_cert *a, struct sshkey_cert *b)\n{\n\tif (a == NULL && b == NULL)\n\t\treturn 1;\n\tif (a == NULL || b == NULL)\n\t\treturn 0;\n\tif (sshbuf_len(a->certblob) != sshbuf_len(b->certblob))\n\t\treturn 0;\n\tif (timingsafe_bcmp(sshbuf_ptr(a->certblob), sshbuf_ptr(b->certblob),\n\t    sshbuf_len(a->certblob)) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "a"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
  },
  {
    "function_name": "sshkey_equal_public",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "627-702",
    "snippet": "int\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a->xmss_pk",
            "b->xmss_pk",
            "sshkey_xmss_pklen(a)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_pklen",
          "args": [
            "a"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_pklen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "245-253",
          "snippet": "size_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a->ed25519_pk",
            "b->ed25519_pk",
            "ED25519_PK_SZ"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_free",
          "args": [
            "bnctx"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_free",
          "args": [
            "bnctx"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_cmp",
          "args": [
            "EC_KEY_get0_group(a->ecdsa)",
            "EC_KEY_get0_public_key(a->ecdsa)",
            "EC_KEY_get0_public_key(b->ecdsa)",
            "bnctx"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_public_key",
          "args": [
            "b->ecdsa"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_public_key",
          "args": [
            "a->ecdsa"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "a->ecdsa"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_GROUP_cmp",
          "args": [
            "EC_KEY_get0_group(a->ecdsa)",
            "EC_KEY_get0_group(b->ecdsa)",
            "bnctx"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "b->ecdsa"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "a->ecdsa"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_new",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_public_key",
          "args": [
            "b->ecdsa"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_public_key",
          "args": [
            "a->ecdsa"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_cmp",
          "args": [
            "dsa_pub_key_a",
            "dsa_pub_key_b"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_cmp",
          "args": [
            "dsa_g_a",
            "dsa_g_b"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_cmp",
          "args": [
            "dsa_q_a",
            "dsa_q_b"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_cmp",
          "args": [
            "dsa_p_a",
            "dsa_p_b"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_get0_key",
          "args": [
            "b->dsa",
            "&dsa_pub_key_b",
            "NULL"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_get0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "199-206",
          "snippet": "void\nDSA_get0_key(const DSA *d, const BIGNUM **pub_key, const BIGNUM **priv_key)\n{\n\tif (pub_key != NULL)\n\t\t*pub_key = d->pub_key;\n\tif (priv_key != NULL)\n\t\t*priv_key = d->priv_key;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nDSA_get0_key(const DSA *d, const BIGNUM **pub_key, const BIGNUM **priv_key)\n{\n\tif (pub_key != NULL)\n\t\t*pub_key = d->pub_key;\n\tif (priv_key != NULL)\n\t\t*priv_key = d->priv_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_get0_pqg",
          "args": [
            "b->dsa",
            "&dsa_p_b",
            "&dsa_q_b",
            "&dsa_g_b"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_get0_pqg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "161-170",
          "snippet": "void\nDSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)\n{\n\tif (p != NULL)\n\t\t*p = d->p;\n\tif (q != NULL)\n\t\t*q = d->q;\n\tif (g != NULL)\n\t\t*g = d->g;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nDSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)\n{\n\tif (p != NULL)\n\t\t*p = d->p;\n\tif (q != NULL)\n\t\t*q = d->q;\n\tif (g != NULL)\n\t\t*g = d->g;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_cmp",
          "args": [
            "rsa_n_a",
            "rsa_n_b"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_cmp",
          "args": [
            "rsa_e_a",
            "rsa_e_b"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_get0_key",
          "args": [
            "b->rsa",
            "&rsa_n_b",
            "&rsa_e_b",
            "NULL"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_get0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "230-239",
          "snippet": "void\nRSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)\n{\n\tif (n != NULL)\n\t\t*n = r->n;\n\tif (e != NULL)\n\t\t*e = r->e;\n\tif (d != NULL)\n\t\t*d = r->d;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nRSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)\n{\n\tif (n != NULL)\n\t\t*n = r->n;\n\tif (e != NULL)\n\t\t*e = r->e;\n\tif (d != NULL)\n\t\t*d = r->d;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "b->type"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}"
  },
  {
    "function_name": "cert_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "608-621",
    "snippet": "static int\ncert_compare(struct sshkey_cert *a, struct sshkey_cert *b)\n{\n\tif (a == NULL && b == NULL)\n\t\treturn 1;\n\tif (a == NULL || b == NULL)\n\t\treturn 0;\n\tif (sshbuf_len(a->certblob) != sshbuf_len(b->certblob))\n\t\treturn 0;\n\tif (timingsafe_bcmp(sshbuf_ptr(a->certblob), sshbuf_ptr(b->certblob),\n\t    sshbuf_len(a->certblob)) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timingsafe_bcmp",
          "args": [
            "sshbuf_ptr(a->certblob)",
            "sshbuf_ptr(b->certblob)",
            "sshbuf_len(a->certblob)"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "timingsafe_bcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/timingsafe_bcmp.c",
          "lines": "23-32",
          "snippet": "int\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}",
          "includes": [
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"includes.h\"\n\nint\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "a->certblob"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "b->certblob"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncert_compare(struct sshkey_cert *a, struct sshkey_cert *b)\n{\n\tif (a == NULL && b == NULL)\n\t\treturn 1;\n\tif (a == NULL || b == NULL)\n\t\treturn 0;\n\tif (sshbuf_len(a->certblob) != sshbuf_len(b->certblob))\n\t\treturn 0;\n\tif (timingsafe_bcmp(sshbuf_ptr(a->certblob), sshbuf_ptr(b->certblob),\n\t    sshbuf_len(a->certblob)) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "sshkey_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "552-606",
    "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "k",
            "sizeof(*k)"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cert_free",
          "args": [
            "k->cert"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "cert_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "446-463",
          "snippet": "static void\ncert_free(struct sshkey_cert *cert)\n{\n\tu_int i;\n\n\tif (cert == NULL)\n\t\treturn;\n\tsshbuf_free(cert->certblob);\n\tsshbuf_free(cert->critical);\n\tsshbuf_free(cert->extensions);\n\tfree(cert->key_id);\n\tfor (i = 0; i < cert->nprincipals; i++)\n\t\tfree(cert->principals[i]);\n\tfree(cert->principals);\n\tsshkey_free(cert->signature_key);\n\tfree(cert->signature_type);\n\tfreezero(cert, sizeof(*cert));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncert_free(struct sshkey_cert *cert)\n{\n\tu_int i;\n\n\tif (cert == NULL)\n\t\treturn;\n\tsshbuf_free(cert->certblob);\n\tsshbuf_free(cert->critical);\n\tsshbuf_free(cert->extensions);\n\tfree(cert->key_id);\n\tfor (i = 0; i < cert->nprincipals; i++)\n\t\tfree(cert->principals[i]);\n\tfree(cert->principals);\n\tsshkey_free(cert->signature_key);\n\tfree(cert->signature_type);\n\tfreezero(cert, sizeof(*cert));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "k"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "k->xmss_filename"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_free_state",
          "args": [
            "k"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_free_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "135-150",
          "snippet": "void\nsshkey_xmss_free_state(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tsshkey_xmss_free_bds(key);\n\tif (state) {\n\t\tif (state->enc_keyiv) {\n\t\t\texplicit_bzero(state->enc_keyiv, state->enc_keyiv_len);\n\t\t\tfree(state->enc_keyiv);\n\t\t}\n\t\tfree(state->enc_ciphername);\n\t\tfree(state);\n\t}\n\tkey->xmss_state = NULL;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_xmss_free_state(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tsshkey_xmss_free_bds(key);\n\tif (state) {\n\t\tif (state->enc_keyiv) {\n\t\t\texplicit_bzero(state->enc_keyiv, state->enc_keyiv_len);\n\t\t\tfree(state->enc_keyiv);\n\t\t}\n\t\tfree(state->enc_ciphername);\n\t\tfree(state);\n\t}\n\tkey->xmss_state = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_sklen",
          "args": [
            "k"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_sklen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "255-263",
          "snippet": "size_t\nsshkey_xmss_sklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 4 + 4;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_sklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 4 + 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_pklen",
          "args": [
            "k"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_pklen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "245-253",
          "snippet": "size_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_free",
          "args": [
            "k->ecdsa"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_free",
          "args": [
            "k->dsa"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_free",
          "args": [
            "k->rsa"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
  },
  {
    "function_name": "sshkey_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "485-550",
    "snippet": "struct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "k"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cert_new",
          "args": [],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "cert_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "465-483",
          "snippet": "static struct sshkey_cert *\ncert_new(void)\n{\n\tstruct sshkey_cert *cert;\n\n\tif ((cert = calloc(1, sizeof(*cert))) == NULL)\n\t\treturn NULL;\n\tif ((cert->certblob = sshbuf_new()) == NULL ||\n\t    (cert->critical = sshbuf_new()) == NULL ||\n\t    (cert->extensions = sshbuf_new()) == NULL) {\n\t\tcert_free(cert);\n\t\treturn NULL;\n\t}\n\tcert->key_id = NULL;\n\tcert->principals = NULL;\n\tcert->signature_key = NULL;\n\tcert->signature_type = NULL;\n\treturn cert;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshkey_cert *\ncert_new(void)\n{\n\tstruct sshkey_cert *cert;\n\n\tif ((cert = calloc(1, sizeof(*cert))) == NULL)\n\t\treturn NULL;\n\tif ((cert->certblob = sshbuf_new()) == NULL ||\n\t    (cert->critical = sshbuf_new()) == NULL ||\n\t    (cert->extensions = sshbuf_new()) == NULL) {\n\t\tcert_free(cert);\n\t\treturn NULL;\n\t}\n\tcert->key_id = NULL;\n\tcert->principals = NULL;\n\tcert->signature_key = NULL;\n\tcert->signature_type = NULL;\n\treturn cert;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "k"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_new",
          "args": [],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_new",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*k)"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}"
  },
  {
    "function_name": "cert_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "465-483",
    "snippet": "static struct sshkey_cert *\ncert_new(void)\n{\n\tstruct sshkey_cert *cert;\n\n\tif ((cert = calloc(1, sizeof(*cert))) == NULL)\n\t\treturn NULL;\n\tif ((cert->certblob = sshbuf_new()) == NULL ||\n\t    (cert->critical = sshbuf_new()) == NULL ||\n\t    (cert->extensions = sshbuf_new()) == NULL) {\n\t\tcert_free(cert);\n\t\treturn NULL;\n\t}\n\tcert->key_id = NULL;\n\tcert->principals = NULL;\n\tcert->signature_key = NULL;\n\tcert->signature_type = NULL;\n\treturn cert;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cert_free",
          "args": [
            "cert"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "cert_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "446-463",
          "snippet": "static void\ncert_free(struct sshkey_cert *cert)\n{\n\tu_int i;\n\n\tif (cert == NULL)\n\t\treturn;\n\tsshbuf_free(cert->certblob);\n\tsshbuf_free(cert->critical);\n\tsshbuf_free(cert->extensions);\n\tfree(cert->key_id);\n\tfor (i = 0; i < cert->nprincipals; i++)\n\t\tfree(cert->principals[i]);\n\tfree(cert->principals);\n\tsshkey_free(cert->signature_key);\n\tfree(cert->signature_type);\n\tfreezero(cert, sizeof(*cert));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncert_free(struct sshkey_cert *cert)\n{\n\tu_int i;\n\n\tif (cert == NULL)\n\t\treturn;\n\tsshbuf_free(cert->certblob);\n\tsshbuf_free(cert->critical);\n\tsshbuf_free(cert->extensions);\n\tfree(cert->key_id);\n\tfor (i = 0; i < cert->nprincipals; i++)\n\t\tfree(cert->principals[i]);\n\tfree(cert->principals);\n\tsshkey_free(cert->signature_key);\n\tfree(cert->signature_type);\n\tfreezero(cert, sizeof(*cert));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*cert)"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshkey_cert *\ncert_new(void)\n{\n\tstruct sshkey_cert *cert;\n\n\tif ((cert = calloc(1, sizeof(*cert))) == NULL)\n\t\treturn NULL;\n\tif ((cert->certblob = sshbuf_new()) == NULL ||\n\t    (cert->critical = sshbuf_new()) == NULL ||\n\t    (cert->extensions = sshbuf_new()) == NULL) {\n\t\tcert_free(cert);\n\t\treturn NULL;\n\t}\n\tcert->key_id = NULL;\n\tcert->principals = NULL;\n\tcert->signature_key = NULL;\n\tcert->signature_type = NULL;\n\treturn cert;\n}"
  },
  {
    "function_name": "cert_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "446-463",
    "snippet": "static void\ncert_free(struct sshkey_cert *cert)\n{\n\tu_int i;\n\n\tif (cert == NULL)\n\t\treturn;\n\tsshbuf_free(cert->certblob);\n\tsshbuf_free(cert->critical);\n\tsshbuf_free(cert->extensions);\n\tfree(cert->key_id);\n\tfor (i = 0; i < cert->nprincipals; i++)\n\t\tfree(cert->principals[i]);\n\tfree(cert->principals);\n\tsshkey_free(cert->signature_key);\n\tfree(cert->signature_type);\n\tfreezero(cert, sizeof(*cert));\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "cert",
            "sizeof(*cert)"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cert->signature_type"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "cert->extensions"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncert_free(struct sshkey_cert *cert)\n{\n\tu_int i;\n\n\tif (cert == NULL)\n\t\treturn;\n\tsshbuf_free(cert->certblob);\n\tsshbuf_free(cert->critical);\n\tsshbuf_free(cert->extensions);\n\tfree(cert->key_id);\n\tfor (i = 0; i < cert->nprincipals; i++)\n\t\tfree(cert->principals[i]);\n\tfree(cert->principals);\n\tsshkey_free(cert->signature_key);\n\tfree(cert->signature_type);\n\tfreezero(cert, sizeof(*cert));\n}"
  },
  {
    "function_name": "sshkey_ec_nid_to_hash_alg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "428-443",
    "snippet": "int\nsshkey_ec_nid_to_hash_alg(int nid)\n{\n\tint kbits = sshkey_curve_nid_to_bits(nid);\n\n\tif (kbits <= 0)\n\t\treturn -1;\n\n\t/* RFC5656 section 6.2.1 */\n\tif (kbits <= 256)\n\t\treturn SSH_DIGEST_SHA256;\n\telse if (kbits <= 384)\n\t\treturn SSH_DIGEST_SHA384;\n\telse\n\t\treturn SSH_DIGEST_SHA512;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_curve_nid_to_bits",
          "args": [
            "nid"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_curve_nid_to_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "377-392",
          "snippet": "u_int\nsshkey_curve_nid_to_bits(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn 256;\n\tcase NID_secp384r1:\n\t\treturn 384;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn 521;\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\nsshkey_curve_nid_to_bits(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn 256;\n\tcase NID_secp384r1:\n\t\treturn 384;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn 521;\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_ec_nid_to_hash_alg(int nid)\n{\n\tint kbits = sshkey_curve_nid_to_bits(nid);\n\n\tif (kbits <= 0)\n\t\treturn -1;\n\n\t/* RFC5656 section 6.2.1 */\n\tif (kbits <= 256)\n\t\treturn SSH_DIGEST_SHA256;\n\telse if (kbits <= 384)\n\t\treturn SSH_DIGEST_SHA384;\n\telse\n\t\treturn SSH_DIGEST_SHA512;\n}"
  },
  {
    "function_name": "sshkey_curve_nid_to_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "411-426",
    "snippet": "const char *\nsshkey_curve_nid_to_name(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn \"nistp256\";\n\tcase NID_secp384r1:\n\t\treturn \"nistp384\";\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn \"nistp521\";\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_curve_nid_to_name(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn \"nistp256\";\n\tcase NID_secp384r1:\n\t\treturn \"nistp384\";\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn \"nistp521\";\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "sshkey_ecdsa_bits_to_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "394-409",
    "snippet": "int\nsshkey_ecdsa_bits_to_nid(int bits)\n{\n\tswitch (bits) {\n\tcase 256:\n\t\treturn NID_X9_62_prime256v1;\n\tcase 384:\n\t\treturn NID_secp384r1;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase 521:\n\t\treturn NID_secp521r1;\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_ecdsa_bits_to_nid(int bits)\n{\n\tswitch (bits) {\n\tcase 256:\n\t\treturn NID_X9_62_prime256v1;\n\tcase 384:\n\t\treturn NID_secp384r1;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase 521:\n\t\treturn NID_secp521r1;\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "sshkey_curve_nid_to_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "377-392",
    "snippet": "u_int\nsshkey_curve_nid_to_bits(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn 256;\n\tcase NID_secp384r1:\n\t\treturn 384;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn 521;\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\nsshkey_curve_nid_to_bits(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn 256;\n\tcase NID_secp384r1:\n\t\treturn 384;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn 521;\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "sshkey_curve_name_to_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "362-375",
    "snippet": "int\nsshkey_curve_name_to_nid(const char *name)\n{\n\tif (strcmp(name, \"nistp256\") == 0)\n\t\treturn NID_X9_62_prime256v1;\n\telse if (strcmp(name, \"nistp384\") == 0)\n\t\treturn NID_secp384r1;\n# ifdef OPENSSL_HAS_NISTP521\n\telse if (strcmp(name, \"nistp521\") == 0)\n\t\treturn NID_secp521r1;\n# endif /* OPENSSL_HAS_NISTP521 */\n\telse\n\t\treturn -1;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"nistp384\""
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_curve_name_to_nid(const char *name)\n{\n\tif (strcmp(name, \"nistp256\") == 0)\n\t\treturn NID_X9_62_prime256v1;\n\telse if (strcmp(name, \"nistp384\") == 0)\n\t\treturn NID_secp384r1;\n# ifdef OPENSSL_HAS_NISTP521\n\telse if (strcmp(name, \"nistp521\") == 0)\n\t\treturn NID_secp521r1;\n# endif /* OPENSSL_HAS_NISTP521 */\n\telse\n\t\treturn -1;\n}"
  },
  {
    "function_name": "sshkey_type_plain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "341-358",
    "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
  },
  {
    "function_name": "sshkey_is_cert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "332-338",
    "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_type_is_cert",
          "args": [
            "k->type"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "165-175",
          "snippet": "int\nsshkey_type_is_cert(int type)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type)\n\t\t\treturn kt->cert;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_is_cert(int type)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type)\n\t\t\treturn kt->cert;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
  },
  {
    "function_name": "sshkey_type_is_valid_ca",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "317-330",
    "snippet": "static int\nsshkey_type_is_valid_ca(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_XMSS:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nsshkey_type_is_valid_ca(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_XMSS:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "sshkey_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "283-315",
    "snippet": "u_int\nsshkey_size(const struct sshkey *k)\n{\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *dsa_p;\n#endif /* WITH_OPENSSL */\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (k->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(k->rsa, &rsa_n, NULL, NULL);\n\t\treturn BN_num_bits(rsa_n);\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif (k->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, NULL, NULL);\n\t\treturn BN_num_bits(dsa_p);\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\treturn sshkey_curve_nid_to_bits(k->ecdsa_nid);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn 256;\t/* XXX */\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_curve_nid_to_bits",
          "args": [
            "k->ecdsa_nid"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_curve_nid_to_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "377-392",
          "snippet": "u_int\nsshkey_curve_nid_to_bits(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn 256;\n\tcase NID_secp384r1:\n\t\treturn 384;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn 521;\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\nsshkey_curve_nid_to_bits(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn 256;\n\tcase NID_secp384r1:\n\t\treturn 384;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn 521;\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_num_bits",
          "args": [
            "dsa_p"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_get0_pqg",
          "args": [
            "k->dsa",
            "&dsa_p",
            "NULL",
            "NULL"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_get0_pqg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "161-170",
          "snippet": "void\nDSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)\n{\n\tif (p != NULL)\n\t\t*p = d->p;\n\tif (q != NULL)\n\t\t*q = d->q;\n\tif (g != NULL)\n\t\t*g = d->g;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nDSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)\n{\n\tif (p != NULL)\n\t\t*p = d->p;\n\tif (q != NULL)\n\t\t*q = d->q;\n\tif (g != NULL)\n\t\t*g = d->g;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_num_bits",
          "args": [
            "rsa_n"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_get0_key",
          "args": [
            "k->rsa",
            "&rsa_n",
            "NULL",
            "NULL"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_get0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "230-239",
          "snippet": "void\nRSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)\n{\n\tif (n != NULL)\n\t\t*n = r->n;\n\tif (e != NULL)\n\t\t*e = r->e;\n\tif (d != NULL)\n\t\t*d = r->d;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nRSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)\n{\n\tif (n != NULL)\n\t\t*n = r->n;\n\tif (e != NULL)\n\t\t*e = r->e;\n\tif (d != NULL)\n\t\t*d = r->d;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\nsshkey_size(const struct sshkey *k)\n{\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *dsa_p;\n#endif /* WITH_OPENSSL */\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (k->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(k->rsa, &rsa_n, NULL, NULL);\n\t\treturn BN_num_bits(rsa_n);\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif (k->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, NULL, NULL);\n\t\treturn BN_num_bits(dsa_p);\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\treturn sshkey_curve_nid_to_bits(k->ecdsa_nid);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn 256;\t/* XXX */\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_names_valid2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "246-281",
    "snippet": "int\nsshkey_names_valid2(const char *names, int allow_wildcard)\n{\n\tchar *s, *cp, *p;\n\tconst struct keytype *kt;\n\tint type;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\ttype = sshkey_type_from_name(p);\n\t\tif (type == KEY_UNSPEC) {\n\t\t\tif (allow_wildcard) {\n\t\t\t\t/*\n\t\t\t\t * Try matching key types against the string.\n\t\t\t\t * If any has a positive or negative match then\n\t\t\t\t * the component is accepted.\n\t\t\t\t */\n\t\t\t\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t\t\t\tif (match_pattern_list(kt->name,\n\t\t\t\t\t    p, 0) != 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (kt->type != -1)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(s);\n\treturn 1;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "kt->name",
            "p",
            "0"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "p"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&cp",
            "\",\""
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "xstrsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keyscan.c",
          "lines": "162-178",
          "snippet": "static char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}",
          "includes": [
            "#include \"dns.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"myproposal.h\"",
            "#include \"compat.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <openssl/bn.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/resource.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"compat.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <netdb.h>\n#include <openssl/bn.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/resource.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "names"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "names",
            "\"\""
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_names_valid2(const char *names, int allow_wildcard)\n{\n\tchar *s, *cp, *p;\n\tconst struct keytype *kt;\n\tint type;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\ttype = sshkey_type_from_name(p);\n\t\tif (type == KEY_UNSPEC) {\n\t\t\tif (allow_wildcard) {\n\t\t\t\t/*\n\t\t\t\t * Try matching key types against the string.\n\t\t\t\t * If any has a positive or negative match then\n\t\t\t\t * the component is accepted.\n\t\t\t\t */\n\t\t\t\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t\t\t\tif (match_pattern_list(kt->name,\n\t\t\t\t\t    p, 0) != 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (kt->type != -1)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(s);\n\treturn 1;\n}"
  },
  {
    "function_name": "sshkey_alg_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "218-244",
    "snippet": "char *\nsshkey_alg_list(int certs_only, int plain_only, int include_sigonly, char sep)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL)\n\t\t\tcontinue;\n\t\tif (!include_sigonly && kt->sigonly)\n\t\t\tcontinue;\n\t\tif ((certs_only && !kt->cert) || (plain_only && kt->cert))\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(kt->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, kt->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ret + rlen",
            "kt->name",
            "nlen + 1"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ret"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "ret",
            "rlen + nlen + 2"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "48-56",
          "snippet": "void *\nrpl_realloc(void *ptr, size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\tif (ptr == 0)\n\t\treturn malloc(size);\n\treturn realloc(ptr, size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_realloc(void *ptr, size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\tif (ptr == 0)\n\t\treturn malloc(size);\n\treturn realloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kt->name"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nchar *\nsshkey_alg_list(int certs_only, int plain_only, int include_sigonly, char sep)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL)\n\t\t\tcontinue;\n\t\tif (!include_sigonly && kt->sigonly)\n\t\t\tcontinue;\n\t\tif ((certs_only && !kt->cert) || (plain_only && kt->cert))\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(kt->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, kt->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sshkey_ecdsa_nid_from_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "204-216",
    "snippet": "int\nsshkey_ecdsa_nid_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type != KEY_ECDSA && kt->type != KEY_ECDSA_CERT)\n\t\t\tcontinue;\n\t\tif (kt->name != NULL && strcmp(name, kt->name) == 0)\n\t\t\treturn kt->nid;\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "kt->name"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_ecdsa_nid_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type != KEY_ECDSA && kt->type != KEY_ECDSA_CERT)\n\t\t\tcontinue;\n\t\tif (kt->name != NULL && strcmp(name, kt->name) == 0)\n\t\t\treturn kt->nid;\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "sshkey_type_from_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "190-202",
    "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "kt->shortname",
            "name"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "kt->name"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
  },
  {
    "function_name": "sshkey_ssh_name_plain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "183-188",
    "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_ssh_name_from_type_nid",
          "args": [
            "sshkey_type_plain(k->type)",
            "k->ecdsa_nid"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_from_type_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "153-163",
          "snippet": "static const char *\nsshkey_ssh_name_from_type_nid(int type, int nid)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type && (kt->nid == 0 || kt->nid == nid))\n\t\t\treturn kt->name;\n\t}\n\treturn \"ssh-unknown\";\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nstatic const char *\nsshkey_ssh_name_from_type_nid(int type, int nid)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type && (kt->nid == 0 || kt->nid == nid))\n\t\t\treturn kt->name;\n\t}\n\treturn \"ssh-unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "k->type"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
  },
  {
    "function_name": "sshkey_ssh_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "177-181",
    "snippet": "const char *\nsshkey_ssh_name(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(k->type, k->ecdsa_nid);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_ssh_name_from_type_nid",
          "args": [
            "k->type",
            "k->ecdsa_nid"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_from_type_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "153-163",
          "snippet": "static const char *\nsshkey_ssh_name_from_type_nid(int type, int nid)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type && (kt->nid == 0 || kt->nid == nid))\n\t\t\treturn kt->name;\n\t}\n\treturn \"ssh-unknown\";\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nstatic const char *\nsshkey_ssh_name_from_type_nid(int type, int nid)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type && (kt->nid == 0 || kt->nid == nid))\n\t\t\treturn kt->name;\n\t}\n\treturn \"ssh-unknown\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(k->type, k->ecdsa_nid);\n}"
  },
  {
    "function_name": "sshkey_type_is_cert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "165-175",
    "snippet": "int\nsshkey_type_is_cert(int type)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type)\n\t\t\treturn kt->cert;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_is_cert(int type)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type)\n\t\t\treturn kt->cert;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sshkey_ssh_name_from_type_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "153-163",
    "snippet": "static const char *\nsshkey_ssh_name_from_type_nid(int type, int nid)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type && (kt->nid == 0 || kt->nid == nid))\n\t\t\treturn kt->name;\n\t}\n\treturn \"ssh-unknown\";\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nstatic const char *\nsshkey_ssh_name_from_type_nid(int type, int nid)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type && (kt->nid == 0 || kt->nid == nid))\n\t\t\treturn kt->name;\n\t}\n\treturn \"ssh-unknown\";\n}"
  },
  {
    "function_name": "sshkey_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
    "lines": "141-151",
    "snippet": "const char *\nsshkey_type(const struct sshkey *k)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == k->type)\n\t\t\treturn kt->shortname;\n\t}\n\treturn \"unknown\";\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"xmss_fast.h\"",
      "#include \"match.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include <util.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"crypto_api.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nconst char *\nsshkey_type(const struct sshkey *k)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == k->type)\n\t\t\treturn kt->shortname;\n\t}\n\treturn \"unknown\";\n}"
  }
]