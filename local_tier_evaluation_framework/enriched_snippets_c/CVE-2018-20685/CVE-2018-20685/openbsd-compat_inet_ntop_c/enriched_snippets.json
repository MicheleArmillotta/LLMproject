[
  {
    "function_name": "inet_ntop6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_ntop.c",
    "lines": "107-209",
    "snippet": "static const char *\ninet_ntop6(const u_char *src, char *dst, size_t size)\n{\n\t/*\n\t * Note that int32_t and int16_t need only be \"at least\" large enough\n\t * to contain a value of the specified size.  On some systems, like\n\t * Crays, there is no such thing as an integer variable with 16 bits.\n\t * Keep this in mind if you think this function should have been coded\n\t * to use pointer overlays.  All the world's not a VAX.\n\t */\n\tchar tmp[sizeof \"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\"];\n\tchar *tp, *ep;\n\tstruct { int base, len; } best, cur;\n\tu_int words[IN6ADDRSZ / INT16SZ];\n\tint i;\n\tint advance;\n\n\t/*\n\t * Preprocess:\n\t *\tCopy the input (bytewise) array into a wordwise array.\n\t *\tFind the longest run of 0x00's in src[] for :: shorthanding.\n\t */\n\tmemset(words, '\\0', sizeof words);\n\tfor (i = 0; i < IN6ADDRSZ; i++)\n\t\twords[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));\n\tbest.base = -1;\n\tcur.base = -1;\n\tfor (i = 0; i < (IN6ADDRSZ / INT16SZ); i++) {\n\t\tif (words[i] == 0) {\n\t\t\tif (cur.base == -1)\n\t\t\t\tcur.base = i, cur.len = 1;\n\t\t\telse\n\t\t\t\tcur.len++;\n\t\t} else {\n\t\t\tif (cur.base != -1) {\n\t\t\t\tif (best.base == -1 || cur.len > best.len)\n\t\t\t\t\tbest = cur;\n\t\t\t\tcur.base = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (cur.base != -1) {\n\t\tif (best.base == -1 || cur.len > best.len)\n\t\t\tbest = cur;\n\t}\n\tif (best.base != -1 && best.len < 2)\n\t\tbest.base = -1;\n\n\t/*\n\t * Format the result.\n\t */\n\ttp = tmp;\n\tep = tmp + sizeof(tmp);\n\tfor (i = 0; i < (IN6ADDRSZ / INT16SZ) && tp < ep; i++) {\n\t\t/* Are we inside the best run of 0x00's? */\n\t\tif (best.base != -1 && i >= best.base &&\n\t\t    i < (best.base + best.len)) {\n\t\t\tif (i == best.base) {\n\t\t\t\tif (tp + 1 >= ep)\n\t\t\t\t\treturn (NULL);\n\t\t\t\t*tp++ = ':';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/* Are we following an initial run of 0x00s or any real hex? */\n\t\tif (i != 0) {\n\t\t\tif (tp + 1 >= ep)\n\t\t\t\treturn (NULL);\n\t\t\t*tp++ = ':';\n\t\t}\n\t\t/* Is this address an encapsulated IPv4? */\n\t\tif (i == 6 && best.base == 0 &&\n\t\t    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {\n\t\t\tif (!inet_ntop4(src+12, tp, (size_t)(ep - tp)))\n\t\t\t\treturn (NULL);\n\t\t\ttp += strlen(tp);\n\t\t\tbreak;\n\t\t}\n\t\tadvance = snprintf(tp, ep - tp, \"%x\", words[i]);\n\t\tif (advance <= 0 || advance >= ep - tp)\n\t\t\treturn (NULL);\n\t\ttp += advance;\n\t}\n\t/* Was it a trailing run of 0x00's? */\n\tif (best.base != -1 && (best.base + best.len) == (IN6ADDRSZ / INT16SZ)) {\n\t\tif (tp + 1 >= ep)\n\t\t\treturn (NULL);\n\t\t*tp++ = ':';\n\t}\n\tif (tp + 1 >= ep)\n\t\treturn (NULL);\n\t*tp++ = '\\0';\n\n\t/*\n\t * Check for overflow, copy, and we're done.\n\t */\n\tif ((size_t)(tp - tmp) > size) {\n\t\terrno = ENOSPC;\n\t\treturn (NULL);\n\t}\n\tstrlcpy(dst, tmp, size);\n\treturn (dst);\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <arpa/nameser.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define INT16SZ     2    /* for systems without 16-bit ints */",
      "#define IN6ADDRSZ   16   /* IPv6 T_AAAA */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "dst",
            "tmp",
            "size"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tp",
            "ep - tp",
            "\"%x\"",
            "words[i]"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tp"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntop4",
          "args": [
            "src+12",
            "tp",
            "(size_t)(ep - tp)"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntop4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_ntop.c",
          "lines": "85-99",
          "snippet": "static const char *\ninet_ntop4(const u_char *src, char *dst, size_t size)\n{\n\tstatic const char fmt[] = \"%u.%u.%u.%u\";\n\tchar tmp[sizeof \"255.255.255.255\"];\n\tint l;\n\n\tl = snprintf(tmp, size, fmt, src[0], src[1], src[2], src[3]);\n\tif (l <= 0 || l >= size) {\n\t\terrno = ENOSPC;\n\t\treturn (NULL);\n\t}\n\tstrlcpy(dst, tmp, size);\n\treturn (dst);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <arpa/nameser.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <arpa/nameser.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nstatic const char *\ninet_ntop4(const u_char *src, char *dst, size_t size)\n{\n\tstatic const char fmt[] = \"%u.%u.%u.%u\";\n\tchar tmp[sizeof \"255.255.255.255\"];\n\tint l;\n\n\tl = snprintf(tmp, size, fmt, src[0], src[1], src[2], src[3]);\n\tif (l <= 0 || l >= size) {\n\t\terrno = ENOSPC;\n\t\treturn (NULL);\n\t}\n\tstrlcpy(dst, tmp, size);\n\treturn (dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "words",
            "'\\0'",
            "sizeof words"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <arpa/nameser.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\n#define INT16SZ     2    /* for systems without 16-bit ints */\n#define IN6ADDRSZ   16   /* IPv6 T_AAAA */\n\nstatic const char *\ninet_ntop6(const u_char *src, char *dst, size_t size)\n{\n\t/*\n\t * Note that int32_t and int16_t need only be \"at least\" large enough\n\t * to contain a value of the specified size.  On some systems, like\n\t * Crays, there is no such thing as an integer variable with 16 bits.\n\t * Keep this in mind if you think this function should have been coded\n\t * to use pointer overlays.  All the world's not a VAX.\n\t */\n\tchar tmp[sizeof \"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\"];\n\tchar *tp, *ep;\n\tstruct { int base, len; } best, cur;\n\tu_int words[IN6ADDRSZ / INT16SZ];\n\tint i;\n\tint advance;\n\n\t/*\n\t * Preprocess:\n\t *\tCopy the input (bytewise) array into a wordwise array.\n\t *\tFind the longest run of 0x00's in src[] for :: shorthanding.\n\t */\n\tmemset(words, '\\0', sizeof words);\n\tfor (i = 0; i < IN6ADDRSZ; i++)\n\t\twords[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));\n\tbest.base = -1;\n\tcur.base = -1;\n\tfor (i = 0; i < (IN6ADDRSZ / INT16SZ); i++) {\n\t\tif (words[i] == 0) {\n\t\t\tif (cur.base == -1)\n\t\t\t\tcur.base = i, cur.len = 1;\n\t\t\telse\n\t\t\t\tcur.len++;\n\t\t} else {\n\t\t\tif (cur.base != -1) {\n\t\t\t\tif (best.base == -1 || cur.len > best.len)\n\t\t\t\t\tbest = cur;\n\t\t\t\tcur.base = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (cur.base != -1) {\n\t\tif (best.base == -1 || cur.len > best.len)\n\t\t\tbest = cur;\n\t}\n\tif (best.base != -1 && best.len < 2)\n\t\tbest.base = -1;\n\n\t/*\n\t * Format the result.\n\t */\n\ttp = tmp;\n\tep = tmp + sizeof(tmp);\n\tfor (i = 0; i < (IN6ADDRSZ / INT16SZ) && tp < ep; i++) {\n\t\t/* Are we inside the best run of 0x00's? */\n\t\tif (best.base != -1 && i >= best.base &&\n\t\t    i < (best.base + best.len)) {\n\t\t\tif (i == best.base) {\n\t\t\t\tif (tp + 1 >= ep)\n\t\t\t\t\treturn (NULL);\n\t\t\t\t*tp++ = ':';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/* Are we following an initial run of 0x00s or any real hex? */\n\t\tif (i != 0) {\n\t\t\tif (tp + 1 >= ep)\n\t\t\t\treturn (NULL);\n\t\t\t*tp++ = ':';\n\t\t}\n\t\t/* Is this address an encapsulated IPv4? */\n\t\tif (i == 6 && best.base == 0 &&\n\t\t    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {\n\t\t\tif (!inet_ntop4(src+12, tp, (size_t)(ep - tp)))\n\t\t\t\treturn (NULL);\n\t\t\ttp += strlen(tp);\n\t\t\tbreak;\n\t\t}\n\t\tadvance = snprintf(tp, ep - tp, \"%x\", words[i]);\n\t\tif (advance <= 0 || advance >= ep - tp)\n\t\t\treturn (NULL);\n\t\ttp += advance;\n\t}\n\t/* Was it a trailing run of 0x00's? */\n\tif (best.base != -1 && (best.base + best.len) == (IN6ADDRSZ / INT16SZ)) {\n\t\tif (tp + 1 >= ep)\n\t\t\treturn (NULL);\n\t\t*tp++ = ':';\n\t}\n\tif (tp + 1 >= ep)\n\t\treturn (NULL);\n\t*tp++ = '\\0';\n\n\t/*\n\t * Check for overflow, copy, and we're done.\n\t */\n\tif ((size_t)(tp - tmp) > size) {\n\t\terrno = ENOSPC;\n\t\treturn (NULL);\n\t}\n\tstrlcpy(dst, tmp, size);\n\treturn (dst);\n}"
  },
  {
    "function_name": "inet_ntop4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_ntop.c",
    "lines": "85-99",
    "snippet": "static const char *\ninet_ntop4(const u_char *src, char *dst, size_t size)\n{\n\tstatic const char fmt[] = \"%u.%u.%u.%u\";\n\tchar tmp[sizeof \"255.255.255.255\"];\n\tint l;\n\n\tl = snprintf(tmp, size, fmt, src[0], src[1], src[2], src[3]);\n\tif (l <= 0 || l >= size) {\n\t\terrno = ENOSPC;\n\t\treturn (NULL);\n\t}\n\tstrlcpy(dst, tmp, size);\n\treturn (dst);\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <arpa/nameser.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "dst",
            "tmp",
            "size"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmp",
            "size",
            "fmt",
            "src[0]",
            "src[1]",
            "src[2]",
            "src[3]"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <arpa/nameser.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nstatic const char *\ninet_ntop4(const u_char *src, char *dst, size_t size)\n{\n\tstatic const char fmt[] = \"%u.%u.%u.%u\";\n\tchar tmp[sizeof \"255.255.255.255\"];\n\tint l;\n\n\tl = snprintf(tmp, size, fmt, src[0], src[1], src[2], src[3]);\n\tif (l <= 0 || l >= size) {\n\t\terrno = ENOSPC;\n\t\treturn (NULL);\n\t}\n\tstrlcpy(dst, tmp, size);\n\treturn (dst);\n}"
  },
  {
    "function_name": "inet_ntop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_ntop.c",
    "lines": "59-72",
    "snippet": "const char *\ninet_ntop(int af, const void *src, char *dst, socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn (inet_ntop4(src, dst, (size_t)size));\n\tcase AF_INET6:\n\t\treturn (inet_ntop6(src, dst, (size_t)size));\n\tdefault:\n\t\terrno = EAFNOSUPPORT;\n\t\treturn (NULL);\n\t}\n\t/* NOTREACHED */\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <arpa/nameser.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inet_ntop6",
          "args": [
            "src",
            "dst",
            "(size_t)size"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntop6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_ntop.c",
          "lines": "107-209",
          "snippet": "static const char *\ninet_ntop6(const u_char *src, char *dst, size_t size)\n{\n\t/*\n\t * Note that int32_t and int16_t need only be \"at least\" large enough\n\t * to contain a value of the specified size.  On some systems, like\n\t * Crays, there is no such thing as an integer variable with 16 bits.\n\t * Keep this in mind if you think this function should have been coded\n\t * to use pointer overlays.  All the world's not a VAX.\n\t */\n\tchar tmp[sizeof \"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\"];\n\tchar *tp, *ep;\n\tstruct { int base, len; } best, cur;\n\tu_int words[IN6ADDRSZ / INT16SZ];\n\tint i;\n\tint advance;\n\n\t/*\n\t * Preprocess:\n\t *\tCopy the input (bytewise) array into a wordwise array.\n\t *\tFind the longest run of 0x00's in src[] for :: shorthanding.\n\t */\n\tmemset(words, '\\0', sizeof words);\n\tfor (i = 0; i < IN6ADDRSZ; i++)\n\t\twords[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));\n\tbest.base = -1;\n\tcur.base = -1;\n\tfor (i = 0; i < (IN6ADDRSZ / INT16SZ); i++) {\n\t\tif (words[i] == 0) {\n\t\t\tif (cur.base == -1)\n\t\t\t\tcur.base = i, cur.len = 1;\n\t\t\telse\n\t\t\t\tcur.len++;\n\t\t} else {\n\t\t\tif (cur.base != -1) {\n\t\t\t\tif (best.base == -1 || cur.len > best.len)\n\t\t\t\t\tbest = cur;\n\t\t\t\tcur.base = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (cur.base != -1) {\n\t\tif (best.base == -1 || cur.len > best.len)\n\t\t\tbest = cur;\n\t}\n\tif (best.base != -1 && best.len < 2)\n\t\tbest.base = -1;\n\n\t/*\n\t * Format the result.\n\t */\n\ttp = tmp;\n\tep = tmp + sizeof(tmp);\n\tfor (i = 0; i < (IN6ADDRSZ / INT16SZ) && tp < ep; i++) {\n\t\t/* Are we inside the best run of 0x00's? */\n\t\tif (best.base != -1 && i >= best.base &&\n\t\t    i < (best.base + best.len)) {\n\t\t\tif (i == best.base) {\n\t\t\t\tif (tp + 1 >= ep)\n\t\t\t\t\treturn (NULL);\n\t\t\t\t*tp++ = ':';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/* Are we following an initial run of 0x00s or any real hex? */\n\t\tif (i != 0) {\n\t\t\tif (tp + 1 >= ep)\n\t\t\t\treturn (NULL);\n\t\t\t*tp++ = ':';\n\t\t}\n\t\t/* Is this address an encapsulated IPv4? */\n\t\tif (i == 6 && best.base == 0 &&\n\t\t    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {\n\t\t\tif (!inet_ntop4(src+12, tp, (size_t)(ep - tp)))\n\t\t\t\treturn (NULL);\n\t\t\ttp += strlen(tp);\n\t\t\tbreak;\n\t\t}\n\t\tadvance = snprintf(tp, ep - tp, \"%x\", words[i]);\n\t\tif (advance <= 0 || advance >= ep - tp)\n\t\t\treturn (NULL);\n\t\ttp += advance;\n\t}\n\t/* Was it a trailing run of 0x00's? */\n\tif (best.base != -1 && (best.base + best.len) == (IN6ADDRSZ / INT16SZ)) {\n\t\tif (tp + 1 >= ep)\n\t\t\treturn (NULL);\n\t\t*tp++ = ':';\n\t}\n\tif (tp + 1 >= ep)\n\t\treturn (NULL);\n\t*tp++ = '\\0';\n\n\t/*\n\t * Check for overflow, copy, and we're done.\n\t */\n\tif ((size_t)(tp - tmp) > size) {\n\t\terrno = ENOSPC;\n\t\treturn (NULL);\n\t}\n\tstrlcpy(dst, tmp, size);\n\treturn (dst);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <arpa/nameser.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define INT16SZ     2    /* for systems without 16-bit ints */",
            "#define IN6ADDRSZ   16   /* IPv6 T_AAAA */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <arpa/nameser.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\n#define INT16SZ     2    /* for systems without 16-bit ints */\n#define IN6ADDRSZ   16   /* IPv6 T_AAAA */\n\nstatic const char *\ninet_ntop6(const u_char *src, char *dst, size_t size)\n{\n\t/*\n\t * Note that int32_t and int16_t need only be \"at least\" large enough\n\t * to contain a value of the specified size.  On some systems, like\n\t * Crays, there is no such thing as an integer variable with 16 bits.\n\t * Keep this in mind if you think this function should have been coded\n\t * to use pointer overlays.  All the world's not a VAX.\n\t */\n\tchar tmp[sizeof \"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\"];\n\tchar *tp, *ep;\n\tstruct { int base, len; } best, cur;\n\tu_int words[IN6ADDRSZ / INT16SZ];\n\tint i;\n\tint advance;\n\n\t/*\n\t * Preprocess:\n\t *\tCopy the input (bytewise) array into a wordwise array.\n\t *\tFind the longest run of 0x00's in src[] for :: shorthanding.\n\t */\n\tmemset(words, '\\0', sizeof words);\n\tfor (i = 0; i < IN6ADDRSZ; i++)\n\t\twords[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));\n\tbest.base = -1;\n\tcur.base = -1;\n\tfor (i = 0; i < (IN6ADDRSZ / INT16SZ); i++) {\n\t\tif (words[i] == 0) {\n\t\t\tif (cur.base == -1)\n\t\t\t\tcur.base = i, cur.len = 1;\n\t\t\telse\n\t\t\t\tcur.len++;\n\t\t} else {\n\t\t\tif (cur.base != -1) {\n\t\t\t\tif (best.base == -1 || cur.len > best.len)\n\t\t\t\t\tbest = cur;\n\t\t\t\tcur.base = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (cur.base != -1) {\n\t\tif (best.base == -1 || cur.len > best.len)\n\t\t\tbest = cur;\n\t}\n\tif (best.base != -1 && best.len < 2)\n\t\tbest.base = -1;\n\n\t/*\n\t * Format the result.\n\t */\n\ttp = tmp;\n\tep = tmp + sizeof(tmp);\n\tfor (i = 0; i < (IN6ADDRSZ / INT16SZ) && tp < ep; i++) {\n\t\t/* Are we inside the best run of 0x00's? */\n\t\tif (best.base != -1 && i >= best.base &&\n\t\t    i < (best.base + best.len)) {\n\t\t\tif (i == best.base) {\n\t\t\t\tif (tp + 1 >= ep)\n\t\t\t\t\treturn (NULL);\n\t\t\t\t*tp++ = ':';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/* Are we following an initial run of 0x00s or any real hex? */\n\t\tif (i != 0) {\n\t\t\tif (tp + 1 >= ep)\n\t\t\t\treturn (NULL);\n\t\t\t*tp++ = ':';\n\t\t}\n\t\t/* Is this address an encapsulated IPv4? */\n\t\tif (i == 6 && best.base == 0 &&\n\t\t    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {\n\t\t\tif (!inet_ntop4(src+12, tp, (size_t)(ep - tp)))\n\t\t\t\treturn (NULL);\n\t\t\ttp += strlen(tp);\n\t\t\tbreak;\n\t\t}\n\t\tadvance = snprintf(tp, ep - tp, \"%x\", words[i]);\n\t\tif (advance <= 0 || advance >= ep - tp)\n\t\t\treturn (NULL);\n\t\ttp += advance;\n\t}\n\t/* Was it a trailing run of 0x00's? */\n\tif (best.base != -1 && (best.base + best.len) == (IN6ADDRSZ / INT16SZ)) {\n\t\tif (tp + 1 >= ep)\n\t\t\treturn (NULL);\n\t\t*tp++ = ':';\n\t}\n\tif (tp + 1 >= ep)\n\t\treturn (NULL);\n\t*tp++ = '\\0';\n\n\t/*\n\t * Check for overflow, copy, and we're done.\n\t */\n\tif ((size_t)(tp - tmp) > size) {\n\t\terrno = ENOSPC;\n\t\treturn (NULL);\n\t}\n\tstrlcpy(dst, tmp, size);\n\treturn (dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_ntop4",
          "args": [
            "src",
            "dst",
            "(size_t)size"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntop4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_ntop.c",
          "lines": "85-99",
          "snippet": "static const char *\ninet_ntop4(const u_char *src, char *dst, size_t size)\n{\n\tstatic const char fmt[] = \"%u.%u.%u.%u\";\n\tchar tmp[sizeof \"255.255.255.255\"];\n\tint l;\n\n\tl = snprintf(tmp, size, fmt, src[0], src[1], src[2], src[3]);\n\tif (l <= 0 || l >= size) {\n\t\terrno = ENOSPC;\n\t\treturn (NULL);\n\t}\n\tstrlcpy(dst, tmp, size);\n\treturn (dst);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <arpa/nameser.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <arpa/nameser.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nstatic const char *\ninet_ntop4(const u_char *src, char *dst, size_t size)\n{\n\tstatic const char fmt[] = \"%u.%u.%u.%u\";\n\tchar tmp[sizeof \"255.255.255.255\"];\n\tint l;\n\n\tl = snprintf(tmp, size, fmt, src[0], src[1], src[2], src[3]);\n\tif (l <= 0 || l >= size) {\n\t\terrno = ENOSPC;\n\t\treturn (NULL);\n\t}\n\tstrlcpy(dst, tmp, size);\n\treturn (dst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <arpa/nameser.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nconst char *\ninet_ntop(int af, const void *src, char *dst, socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn (inet_ntop4(src, dst, (size_t)size));\n\tcase AF_INET6:\n\t\treturn (inet_ntop6(src, dst, (size_t)size));\n\tdefault:\n\t\terrno = EAFNOSUPPORT;\n\t\treturn (NULL);\n\t}\n\t/* NOTREACHED */\n}"
  }
]