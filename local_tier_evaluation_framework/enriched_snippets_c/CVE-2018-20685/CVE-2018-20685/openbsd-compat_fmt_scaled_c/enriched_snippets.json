[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fmt_scaled.c",
    "lines": "283-300",
    "snippet": "int\nmain(int argc, char **argv)\n{\n\tchar *cinput = \"1.5K\", buf[FMT_SCALED_STRSIZE];\n\tlong long ninput = 10483892, result;\n\n\tif (scan_scaled(cinput, &result) == 0)\n\t\tprintf(\"\\\"%s\\\" -> %lld\\n\", cinput, result);\n\telse\n\t\tperror(cinput);\n\n\tif (fmt_scaled(ninput, buf) == 0)\n\t\tprintf(\"%lld -> \\\"%s\\\"\\n\", ninput, buf);\n\telse\n\t\tfprintf(stderr, \"%lld invalid (%s)\\n\", ninput, strerror(errno));\n\n\treturn 0;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%lld invalid (%s)\\n\"",
            "ninput",
            "strerror(errno)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%lld -> \\\"%s\\\"\\n\"",
            "ninput",
            "buf"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-asprintf.c",
          "lines": "86-97",
          "snippet": "int asprintf(char **str, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\t*str = NULL;\n\tva_start(ap, fmt);\n\tret = vasprintf(str, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint asprintf(char **str, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\t*str = NULL;\n\tva_start(ap, fmt);\n\tret = vasprintf(str, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmt_scaled",
          "args": [
            "ninput",
            "buf"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_scaled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fmt_scaled.c",
          "lines": "218-276",
          "snippet": "int\nfmt_scaled(long long number, char *result)\n{\n\tlong long abval, fract = 0;\n\tunsigned int i;\n\tunit_type unit = NONE;\n\n\tabval = llabs(number);\n\n\t/* Not every negative long long has a positive representation.\n\t * Also check for numbers that are just too darned big to format\n\t */\n\tif (abval < 0 || abval / 1024 >= scale_factors[SCALE_LENGTH-1]) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\n\t/* scale whole part; get unscaled fraction */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\t\tif (abval/1024 < scale_factors[i]) {\n\t\t\tunit = units[i];\n\t\t\tfract = (i == 0) ? 0 : abval % scale_factors[i];\n\t\t\tnumber /= scale_factors[i];\n\t\t\tif (i > 0)\n\t\t\t\tfract /= scale_factors[i - 1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfract = (10 * fract + 512) / 1024;\n\t/* if the result would be >= 10, round main number */\n\tif (fract >= 10) {\n\t\tif (number >= 0)\n\t\t\tnumber++;\n\t\telse\n\t\t\tnumber--;\n\t\tfract = 0;\n\t} else if (fract < 0) {\n\t\t/* shouldn't happen */\n\t\tfract = 0;\n\t}\n\n\tif (number == 0)\n\t\tstrlcpy(result, \"0B\", FMT_SCALED_STRSIZE);\n\telse if (unit == NONE || number >= 100 || number <= -100) {\n\t\tif (fract >= 5) {\n\t\t\tif (number >= 0)\n\t\t\t\tnumber++;\n\t\t\telse\n\t\t\t\tnumber--;\n\t\t}\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld%c\",\n\t\t\tnumber, scale_chars[unit]);\n\t} else\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld.%1lld%c\",\n\t\t\tnumber, fract, scale_chars[unit]);\n\n\treturn 0;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"includes.h\"\n\n#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))\n\nint\nfmt_scaled(long long number, char *result)\n{\n\tlong long abval, fract = 0;\n\tunsigned int i;\n\tunit_type unit = NONE;\n\n\tabval = llabs(number);\n\n\t/* Not every negative long long has a positive representation.\n\t * Also check for numbers that are just too darned big to format\n\t */\n\tif (abval < 0 || abval / 1024 >= scale_factors[SCALE_LENGTH-1]) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\n\t/* scale whole part; get unscaled fraction */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\t\tif (abval/1024 < scale_factors[i]) {\n\t\t\tunit = units[i];\n\t\t\tfract = (i == 0) ? 0 : abval % scale_factors[i];\n\t\t\tnumber /= scale_factors[i];\n\t\t\tif (i > 0)\n\t\t\t\tfract /= scale_factors[i - 1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfract = (10 * fract + 512) / 1024;\n\t/* if the result would be >= 10, round main number */\n\tif (fract >= 10) {\n\t\tif (number >= 0)\n\t\t\tnumber++;\n\t\telse\n\t\t\tnumber--;\n\t\tfract = 0;\n\t} else if (fract < 0) {\n\t\t/* shouldn't happen */\n\t\tfract = 0;\n\t}\n\n\tif (number == 0)\n\t\tstrlcpy(result, \"0B\", FMT_SCALED_STRSIZE);\n\telse if (unit == NONE || number >= 100 || number <= -100) {\n\t\tif (fract >= 5) {\n\t\t\tif (number >= 0)\n\t\t\t\tnumber++;\n\t\t\telse\n\t\t\t\tnumber--;\n\t\t}\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld%c\",\n\t\t\tnumber, scale_chars[unit]);\n\t} else\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld.%1lld%c\",\n\t\t\tnumber, fract, scale_chars[unit]);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "cinput"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_scaled",
          "args": [
            "cinput",
            "&result"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "scan_scaled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fmt_scaled.c",
          "lines": "75-212",
          "snippet": "int\nscan_scaled(char *scaled, long long *result)\n{\n\tchar *p = scaled;\n\tint sign = 0;\n\tunsigned int i, ndigits = 0, fract_digits = 0;\n\tlong long scale_fact = 1, whole = 0, fpart = 0;\n\n\t/* Skip leading whitespace */\n\twhile (isascii((unsigned char)*p) && isspace((unsigned char)*p))\n\t\t++p;\n\n\t/* Then at most one leading + or - */\n\twhile (*p == '-' || *p == '+') {\n\t\tif (*p == '-') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = -1;\n\t\t\t++p;\n\t\t} else if (*p == '+') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = +1;\n\t\t\t++p;\n\t\t}\n\t}\n\n\t/* Main loop: Scan digits, find decimal point, if present.\n\t * We don't allow exponentials, so no scientific notation\n\t * (but note that E for Exa might look like e to some!).\n\t * Advance 'p' to end, to get scale factor.\n\t */\n\tfor (; isascii((unsigned char)*p) &&\n\t    (isdigit((unsigned char)*p) || *p=='.'); ++p) {\n\t\tif (*p == '.') {\n\t\t\tif (fract_digits > 0) {\t/* oops, more than one '.' */\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfract_digits = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ti = (*p) - '0';\t\t\t/* whew! finally a digit we can use */\n\t\tif (fract_digits > 0) {\n\t\t\tif (fract_digits >= MAX_DIGITS-1)\n\t\t\t\t/* ignore extra fractional digits */\n\t\t\t\tcontinue;\n\t\t\tfract_digits++;\t\t/* for later scaling */\n\t\t\tif (fpart > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart *= 10;\n\t\t\tif (i > LLONG_MAX - fpart) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart += i;\n\t\t} else {\t\t\t\t/* normal digit */\n\t\t\tif (++ndigits >= MAX_DIGITS) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (whole > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole *= 10;\n\t\t\tif (i > LLONG_MAX - whole) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole += i;\n\t\t}\n\t}\n\n\tif (sign) {\n\t\twhole *= sign;\n\t\tfpart *= sign;\n\t}\n\n\t/* If no scale factor given, we're done. fraction is discarded. */\n\tif (!*p) {\n\t\t*result = whole;\n\t\treturn 0;\n\t}\n\n\t/* Validate scale factor, and scale whole and fraction by it. */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\n\t\t/* Are we there yet? */\n\t\tif (*p == scale_chars[i] ||\n\t\t\t*p == tolower((unsigned char)scale_chars[i])) {\n\n\t\t\t/* If it ends with alphanumerics after the scale char, bad. */\n\t\t\tif (isalnum((unsigned char)*(p+1))) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tscale_fact = scale_factors[i];\n\n\t\t\t/* check for overflow and underflow after scaling */\n\t\t\tif (whole > LLONG_MAX / scale_fact ||\n\t\t\t    whole < LLONG_MIN / scale_fact) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* scale whole part */\n\t\t\twhole *= scale_fact;\n\n\t\t\t/* truncate fpart so it doesn't overflow.\n\t\t\t * then scale fractional part.\n\t\t\t */\n\t\t\twhile (fpart >= LLONG_MAX / scale_fact) {\n\t\t\t\tfpart /= 10;\n\t\t\t\tfract_digits--;\n\t\t\t}\n\t\t\tfpart *= scale_fact;\n\t\t\tif (fract_digits > 0) {\n\t\t\t\tfor (i = 0; i < fract_digits -1; i++)\n\t\t\t\t\tfpart /= 10;\n\t\t\t}\n\t\t\twhole += fpart;\n\t\t\t*result = whole;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Invalid unit or character */\n\terrno = EINVAL;\n\treturn -1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_DIGITS (SCALE_LENGTH * 3)\t/* XXX strlen(sprintf(\"%lld\", -1)? */",
            "#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"includes.h\"\n\n#define MAX_DIGITS (SCALE_LENGTH * 3)\t/* XXX strlen(sprintf(\"%lld\", -1)? */\n#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))\n\nint\nscan_scaled(char *scaled, long long *result)\n{\n\tchar *p = scaled;\n\tint sign = 0;\n\tunsigned int i, ndigits = 0, fract_digits = 0;\n\tlong long scale_fact = 1, whole = 0, fpart = 0;\n\n\t/* Skip leading whitespace */\n\twhile (isascii((unsigned char)*p) && isspace((unsigned char)*p))\n\t\t++p;\n\n\t/* Then at most one leading + or - */\n\twhile (*p == '-' || *p == '+') {\n\t\tif (*p == '-') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = -1;\n\t\t\t++p;\n\t\t} else if (*p == '+') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = +1;\n\t\t\t++p;\n\t\t}\n\t}\n\n\t/* Main loop: Scan digits, find decimal point, if present.\n\t * We don't allow exponentials, so no scientific notation\n\t * (but note that E for Exa might look like e to some!).\n\t * Advance 'p' to end, to get scale factor.\n\t */\n\tfor (; isascii((unsigned char)*p) &&\n\t    (isdigit((unsigned char)*p) || *p=='.'); ++p) {\n\t\tif (*p == '.') {\n\t\t\tif (fract_digits > 0) {\t/* oops, more than one '.' */\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfract_digits = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ti = (*p) - '0';\t\t\t/* whew! finally a digit we can use */\n\t\tif (fract_digits > 0) {\n\t\t\tif (fract_digits >= MAX_DIGITS-1)\n\t\t\t\t/* ignore extra fractional digits */\n\t\t\t\tcontinue;\n\t\t\tfract_digits++;\t\t/* for later scaling */\n\t\t\tif (fpart > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart *= 10;\n\t\t\tif (i > LLONG_MAX - fpart) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart += i;\n\t\t} else {\t\t\t\t/* normal digit */\n\t\t\tif (++ndigits >= MAX_DIGITS) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (whole > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole *= 10;\n\t\t\tif (i > LLONG_MAX - whole) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole += i;\n\t\t}\n\t}\n\n\tif (sign) {\n\t\twhole *= sign;\n\t\tfpart *= sign;\n\t}\n\n\t/* If no scale factor given, we're done. fraction is discarded. */\n\tif (!*p) {\n\t\t*result = whole;\n\t\treturn 0;\n\t}\n\n\t/* Validate scale factor, and scale whole and fraction by it. */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\n\t\t/* Are we there yet? */\n\t\tif (*p == scale_chars[i] ||\n\t\t\t*p == tolower((unsigned char)scale_chars[i])) {\n\n\t\t\t/* If it ends with alphanumerics after the scale char, bad. */\n\t\t\tif (isalnum((unsigned char)*(p+1))) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tscale_fact = scale_factors[i];\n\n\t\t\t/* check for overflow and underflow after scaling */\n\t\t\tif (whole > LLONG_MAX / scale_fact ||\n\t\t\t    whole < LLONG_MIN / scale_fact) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* scale whole part */\n\t\t\twhole *= scale_fact;\n\n\t\t\t/* truncate fpart so it doesn't overflow.\n\t\t\t * then scale fractional part.\n\t\t\t */\n\t\t\twhile (fpart >= LLONG_MAX / scale_fact) {\n\t\t\t\tfpart /= 10;\n\t\t\t\tfract_digits--;\n\t\t\t}\n\t\t\tfpart *= scale_fact;\n\t\t\tif (fract_digits > 0) {\n\t\t\t\tfor (i = 0; i < fract_digits -1; i++)\n\t\t\t\t\tfpart /= 10;\n\t\t\t}\n\t\t\twhole += fpart;\n\t\t\t*result = whole;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Invalid unit or character */\n\terrno = EINVAL;\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"includes.h\"\n\nint\nmain(int argc, char **argv)\n{\n\tchar *cinput = \"1.5K\", buf[FMT_SCALED_STRSIZE];\n\tlong long ninput = 10483892, result;\n\n\tif (scan_scaled(cinput, &result) == 0)\n\t\tprintf(\"\\\"%s\\\" -> %lld\\n\", cinput, result);\n\telse\n\t\tperror(cinput);\n\n\tif (fmt_scaled(ninput, buf) == 0)\n\t\tprintf(\"%lld -> \\\"%s\\\"\\n\", ninput, buf);\n\telse\n\t\tfprintf(stderr, \"%lld invalid (%s)\\n\", ninput, strerror(errno));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fmt_scaled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fmt_scaled.c",
    "lines": "218-276",
    "snippet": "int\nfmt_scaled(long long number, char *result)\n{\n\tlong long abval, fract = 0;\n\tunsigned int i;\n\tunit_type unit = NONE;\n\n\tabval = llabs(number);\n\n\t/* Not every negative long long has a positive representation.\n\t * Also check for numbers that are just too darned big to format\n\t */\n\tif (abval < 0 || abval / 1024 >= scale_factors[SCALE_LENGTH-1]) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\n\t/* scale whole part; get unscaled fraction */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\t\tif (abval/1024 < scale_factors[i]) {\n\t\t\tunit = units[i];\n\t\t\tfract = (i == 0) ? 0 : abval % scale_factors[i];\n\t\t\tnumber /= scale_factors[i];\n\t\t\tif (i > 0)\n\t\t\t\tfract /= scale_factors[i - 1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfract = (10 * fract + 512) / 1024;\n\t/* if the result would be >= 10, round main number */\n\tif (fract >= 10) {\n\t\tif (number >= 0)\n\t\t\tnumber++;\n\t\telse\n\t\t\tnumber--;\n\t\tfract = 0;\n\t} else if (fract < 0) {\n\t\t/* shouldn't happen */\n\t\tfract = 0;\n\t}\n\n\tif (number == 0)\n\t\tstrlcpy(result, \"0B\", FMT_SCALED_STRSIZE);\n\telse if (unit == NONE || number >= 100 || number <= -100) {\n\t\tif (fract >= 5) {\n\t\t\tif (number >= 0)\n\t\t\t\tnumber++;\n\t\t\telse\n\t\t\t\tnumber--;\n\t\t}\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld%c\",\n\t\t\tnumber, scale_chars[unit]);\n\t} else\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld.%1lld%c\",\n\t\t\tnumber, fract, scale_chars[unit]);\n\n\treturn 0;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "FMT_SCALED_STRSIZE",
            "\"%lld.%1lld%c\"",
            "number",
            "fract",
            "scale_chars[unit]"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "result",
            "\"0B\"",
            "FMT_SCALED_STRSIZE"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "llabs",
          "args": [
            "number"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "llabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "280-284",
          "snippet": "long long\nllabs(long long j)\n{\n\treturn (j < 0 ? -j : j);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nlong long\nllabs(long long j)\n{\n\treturn (j < 0 ? -j : j);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"includes.h\"\n\n#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))\n\nint\nfmt_scaled(long long number, char *result)\n{\n\tlong long abval, fract = 0;\n\tunsigned int i;\n\tunit_type unit = NONE;\n\n\tabval = llabs(number);\n\n\t/* Not every negative long long has a positive representation.\n\t * Also check for numbers that are just too darned big to format\n\t */\n\tif (abval < 0 || abval / 1024 >= scale_factors[SCALE_LENGTH-1]) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\n\t/* scale whole part; get unscaled fraction */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\t\tif (abval/1024 < scale_factors[i]) {\n\t\t\tunit = units[i];\n\t\t\tfract = (i == 0) ? 0 : abval % scale_factors[i];\n\t\t\tnumber /= scale_factors[i];\n\t\t\tif (i > 0)\n\t\t\t\tfract /= scale_factors[i - 1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfract = (10 * fract + 512) / 1024;\n\t/* if the result would be >= 10, round main number */\n\tif (fract >= 10) {\n\t\tif (number >= 0)\n\t\t\tnumber++;\n\t\telse\n\t\t\tnumber--;\n\t\tfract = 0;\n\t} else if (fract < 0) {\n\t\t/* shouldn't happen */\n\t\tfract = 0;\n\t}\n\n\tif (number == 0)\n\t\tstrlcpy(result, \"0B\", FMT_SCALED_STRSIZE);\n\telse if (unit == NONE || number >= 100 || number <= -100) {\n\t\tif (fract >= 5) {\n\t\t\tif (number >= 0)\n\t\t\t\tnumber++;\n\t\t\telse\n\t\t\t\tnumber--;\n\t\t}\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld%c\",\n\t\t\tnumber, scale_chars[unit]);\n\t} else\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld.%1lld%c\",\n\t\t\tnumber, fract, scale_chars[unit]);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "scan_scaled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fmt_scaled.c",
    "lines": "75-212",
    "snippet": "int\nscan_scaled(char *scaled, long long *result)\n{\n\tchar *p = scaled;\n\tint sign = 0;\n\tunsigned int i, ndigits = 0, fract_digits = 0;\n\tlong long scale_fact = 1, whole = 0, fpart = 0;\n\n\t/* Skip leading whitespace */\n\twhile (isascii((unsigned char)*p) && isspace((unsigned char)*p))\n\t\t++p;\n\n\t/* Then at most one leading + or - */\n\twhile (*p == '-' || *p == '+') {\n\t\tif (*p == '-') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = -1;\n\t\t\t++p;\n\t\t} else if (*p == '+') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = +1;\n\t\t\t++p;\n\t\t}\n\t}\n\n\t/* Main loop: Scan digits, find decimal point, if present.\n\t * We don't allow exponentials, so no scientific notation\n\t * (but note that E for Exa might look like e to some!).\n\t * Advance 'p' to end, to get scale factor.\n\t */\n\tfor (; isascii((unsigned char)*p) &&\n\t    (isdigit((unsigned char)*p) || *p=='.'); ++p) {\n\t\tif (*p == '.') {\n\t\t\tif (fract_digits > 0) {\t/* oops, more than one '.' */\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfract_digits = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ti = (*p) - '0';\t\t\t/* whew! finally a digit we can use */\n\t\tif (fract_digits > 0) {\n\t\t\tif (fract_digits >= MAX_DIGITS-1)\n\t\t\t\t/* ignore extra fractional digits */\n\t\t\t\tcontinue;\n\t\t\tfract_digits++;\t\t/* for later scaling */\n\t\t\tif (fpart > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart *= 10;\n\t\t\tif (i > LLONG_MAX - fpart) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart += i;\n\t\t} else {\t\t\t\t/* normal digit */\n\t\t\tif (++ndigits >= MAX_DIGITS) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (whole > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole *= 10;\n\t\t\tif (i > LLONG_MAX - whole) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole += i;\n\t\t}\n\t}\n\n\tif (sign) {\n\t\twhole *= sign;\n\t\tfpart *= sign;\n\t}\n\n\t/* If no scale factor given, we're done. fraction is discarded. */\n\tif (!*p) {\n\t\t*result = whole;\n\t\treturn 0;\n\t}\n\n\t/* Validate scale factor, and scale whole and fraction by it. */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\n\t\t/* Are we there yet? */\n\t\tif (*p == scale_chars[i] ||\n\t\t\t*p == tolower((unsigned char)scale_chars[i])) {\n\n\t\t\t/* If it ends with alphanumerics after the scale char, bad. */\n\t\t\tif (isalnum((unsigned char)*(p+1))) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tscale_fact = scale_factors[i];\n\n\t\t\t/* check for overflow and underflow after scaling */\n\t\t\tif (whole > LLONG_MAX / scale_fact ||\n\t\t\t    whole < LLONG_MIN / scale_fact) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* scale whole part */\n\t\t\twhole *= scale_fact;\n\n\t\t\t/* truncate fpart so it doesn't overflow.\n\t\t\t * then scale fractional part.\n\t\t\t */\n\t\t\twhile (fpart >= LLONG_MAX / scale_fact) {\n\t\t\t\tfpart /= 10;\n\t\t\t\tfract_digits--;\n\t\t\t}\n\t\t\tfpart *= scale_fact;\n\t\t\tif (fract_digits > 0) {\n\t\t\t\tfor (i = 0; i < fract_digits -1; i++)\n\t\t\t\t\tfpart /= 10;\n\t\t\t}\n\t\t\twhole += fpart;\n\t\t\t*result = whole;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Invalid unit or character */\n\terrno = EINVAL;\n\treturn -1;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MAX_DIGITS (SCALE_LENGTH * 3)\t/* XXX strlen(sprintf(\"%lld\", -1)? */",
      "#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "(unsigned char)*(p+1)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "(unsigned char)scale_chars[i]"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char)*p"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isascii",
          "args": [
            "(unsigned char)*p"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char)*p"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isascii",
          "args": [
            "(unsigned char)*p"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"includes.h\"\n\n#define MAX_DIGITS (SCALE_LENGTH * 3)\t/* XXX strlen(sprintf(\"%lld\", -1)? */\n#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))\n\nint\nscan_scaled(char *scaled, long long *result)\n{\n\tchar *p = scaled;\n\tint sign = 0;\n\tunsigned int i, ndigits = 0, fract_digits = 0;\n\tlong long scale_fact = 1, whole = 0, fpart = 0;\n\n\t/* Skip leading whitespace */\n\twhile (isascii((unsigned char)*p) && isspace((unsigned char)*p))\n\t\t++p;\n\n\t/* Then at most one leading + or - */\n\twhile (*p == '-' || *p == '+') {\n\t\tif (*p == '-') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = -1;\n\t\t\t++p;\n\t\t} else if (*p == '+') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = +1;\n\t\t\t++p;\n\t\t}\n\t}\n\n\t/* Main loop: Scan digits, find decimal point, if present.\n\t * We don't allow exponentials, so no scientific notation\n\t * (but note that E for Exa might look like e to some!).\n\t * Advance 'p' to end, to get scale factor.\n\t */\n\tfor (; isascii((unsigned char)*p) &&\n\t    (isdigit((unsigned char)*p) || *p=='.'); ++p) {\n\t\tif (*p == '.') {\n\t\t\tif (fract_digits > 0) {\t/* oops, more than one '.' */\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfract_digits = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ti = (*p) - '0';\t\t\t/* whew! finally a digit we can use */\n\t\tif (fract_digits > 0) {\n\t\t\tif (fract_digits >= MAX_DIGITS-1)\n\t\t\t\t/* ignore extra fractional digits */\n\t\t\t\tcontinue;\n\t\t\tfract_digits++;\t\t/* for later scaling */\n\t\t\tif (fpart > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart *= 10;\n\t\t\tif (i > LLONG_MAX - fpart) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart += i;\n\t\t} else {\t\t\t\t/* normal digit */\n\t\t\tif (++ndigits >= MAX_DIGITS) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (whole > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole *= 10;\n\t\t\tif (i > LLONG_MAX - whole) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole += i;\n\t\t}\n\t}\n\n\tif (sign) {\n\t\twhole *= sign;\n\t\tfpart *= sign;\n\t}\n\n\t/* If no scale factor given, we're done. fraction is discarded. */\n\tif (!*p) {\n\t\t*result = whole;\n\t\treturn 0;\n\t}\n\n\t/* Validate scale factor, and scale whole and fraction by it. */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\n\t\t/* Are we there yet? */\n\t\tif (*p == scale_chars[i] ||\n\t\t\t*p == tolower((unsigned char)scale_chars[i])) {\n\n\t\t\t/* If it ends with alphanumerics after the scale char, bad. */\n\t\t\tif (isalnum((unsigned char)*(p+1))) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tscale_fact = scale_factors[i];\n\n\t\t\t/* check for overflow and underflow after scaling */\n\t\t\tif (whole > LLONG_MAX / scale_fact ||\n\t\t\t    whole < LLONG_MIN / scale_fact) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* scale whole part */\n\t\t\twhole *= scale_fact;\n\n\t\t\t/* truncate fpart so it doesn't overflow.\n\t\t\t * then scale fractional part.\n\t\t\t */\n\t\t\twhile (fpart >= LLONG_MAX / scale_fact) {\n\t\t\t\tfpart /= 10;\n\t\t\t\tfract_digits--;\n\t\t\t}\n\t\t\tfpart *= scale_fact;\n\t\t\tif (fract_digits > 0) {\n\t\t\t\tfor (i = 0; i < fract_digits -1; i++)\n\t\t\t\t\tfpart /= 10;\n\t\t\t}\n\t\t\twhole += fpart;\n\t\t\t*result = whole;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Invalid unit or character */\n\terrno = EINVAL;\n\treturn -1;\n}"
  }
]