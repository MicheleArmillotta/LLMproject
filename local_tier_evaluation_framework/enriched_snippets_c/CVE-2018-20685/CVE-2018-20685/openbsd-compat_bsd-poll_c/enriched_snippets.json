[
  {
    "function_name": "poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-poll.c",
    "lines": "40-116",
    "snippet": "int\npoll(struct pollfd *fds, nfds_t nfds, int timeout)\n{\n\tnfds_t i;\n\tint saved_errno, ret, fd, maxfd = 0;\n\tfd_set *readfds = NULL, *writefds = NULL, *exceptfds = NULL;\n\tsize_t nmemb;\n\tstruct timeval tv, *tvp = NULL;\n\n\tfor (i = 0; i < nfds; i++) {\n\t\tfd = fds[i].fd;\n\t\tif (fd >= FD_SETSIZE) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tmaxfd = MAX(maxfd, fd);\n\t}\n\n\tnmemb = howmany(maxfd + 1 , NFDBITS);\n\tif ((readfds = calloc(nmemb, sizeof(fd_mask))) == NULL ||\n\t    (writefds = calloc(nmemb, sizeof(fd_mask))) == NULL ||\n\t    (exceptfds = calloc(nmemb, sizeof(fd_mask))) == NULL) {\n\t\tsaved_errno = ENOMEM;\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* populate event bit vectors for the events we're interested in */\n\tfor (i = 0; i < nfds; i++) {\n\t\tfd = fds[i].fd;\n\t\tif (fd == -1)\n\t\t\tcontinue;\n\t\tif (fds[i].events & POLLIN) {\n\t\t\tFD_SET(fd, readfds);\n\t\t\tFD_SET(fd, exceptfds);\n\t\t}\n\t\tif (fds[i].events & POLLOUT) {\n\t\t\tFD_SET(fd, writefds);\n\t\t\tFD_SET(fd, exceptfds);\n\t\t}\n\t}\n\n\t/* poll timeout is msec, select is timeval (sec + usec) */\n\tif (timeout >= 0) {\n\t\ttv.tv_sec = timeout / 1000;\n\t\ttv.tv_usec = (timeout % 1000) * 1000;\n\t\ttvp = &tv;\n\t}\n\n\tret = select(maxfd + 1, readfds, writefds, exceptfds, tvp);\n\tsaved_errno = errno;\n\n\t/* scan through select results and set poll() flags */\n\tfor (i = 0; i < nfds; i++) {\n\t\tfd = fds[i].fd;\n\t\tfds[i].revents = 0;\n\t\tif (fd == -1)\n\t\t\tcontinue;\n\t\tif (FD_ISSET(fd, readfds)) {\n\t\t\tfds[i].revents |= POLLIN;\n\t\t}\n\t\tif (FD_ISSET(fd, writefds)) {\n\t\t\tfds[i].revents |= POLLOUT;\n\t\t}\n\t\tif (FD_ISSET(fd, exceptfds)) {\n\t\t\tfds[i].revents |= POLLERR;\n\t\t}\n\t}\n\nout:\n\tfree(readfds);\n\tfree(writefds);\n\tfree(exceptfds);\n\tif (ret == -1)\n\t\terrno = saved_errno;\n\treturn ret;\n}",
    "includes": [
      "#include \"bsd-poll.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "# include <sys/select.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "exceptfds"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "fd",
            "exceptfds"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "maxfd + 1",
            "readfds",
            "writefds",
            "exceptfds",
            "tvp"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "110-122",
          "snippet": "static void select(unsigned int p[64],unsigned int q[64],const unsigned int r[64],const unsigned int s[64],unsigned int b)\n{\n  unsigned int j;\n  unsigned int t;\n  unsigned int bminus1;\n\n  bminus1 = b - 1;\n  for (j = 0;j < 64;++j) {\n    t = bminus1 & (r[j] ^ s[j]);\n    p[j] = s[j] ^ t;\n    q[j] = r[j] ^ t;\n  }\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void select(unsigned int p[64],unsigned int q[64],const unsigned int r[64],const unsigned int s[64],unsigned int b)\n{\n  unsigned int j;\n  unsigned int t;\n  unsigned int bminus1;\n\n  bminus1 = b - 1;\n  for (j = 0;j < 64;++j) {\n    t = bminus1 & (r[j] ^ s[j]);\n    p[j] = s[j] ^ t;\n    q[j] = r[j] ^ t;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "fd",
            "exceptfds"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_SET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "19-21",
          "snippet": "void kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nvoid kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "nmemb",
            "sizeof(fd_mask)"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "36-44",
          "snippet": "void *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "howmany",
          "args": [
            "maxfd + 1",
            "NFDBITS"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "maxfd",
            "fd"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "_SPLAY_MINMAX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sys-tree.h",
          "lines": "247-278",
          "snippet": "void name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}",
          "includes": [
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n\nvoid name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bsd-poll.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n# include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npoll(struct pollfd *fds, nfds_t nfds, int timeout)\n{\n\tnfds_t i;\n\tint saved_errno, ret, fd, maxfd = 0;\n\tfd_set *readfds = NULL, *writefds = NULL, *exceptfds = NULL;\n\tsize_t nmemb;\n\tstruct timeval tv, *tvp = NULL;\n\n\tfor (i = 0; i < nfds; i++) {\n\t\tfd = fds[i].fd;\n\t\tif (fd >= FD_SETSIZE) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tmaxfd = MAX(maxfd, fd);\n\t}\n\n\tnmemb = howmany(maxfd + 1 , NFDBITS);\n\tif ((readfds = calloc(nmemb, sizeof(fd_mask))) == NULL ||\n\t    (writefds = calloc(nmemb, sizeof(fd_mask))) == NULL ||\n\t    (exceptfds = calloc(nmemb, sizeof(fd_mask))) == NULL) {\n\t\tsaved_errno = ENOMEM;\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* populate event bit vectors for the events we're interested in */\n\tfor (i = 0; i < nfds; i++) {\n\t\tfd = fds[i].fd;\n\t\tif (fd == -1)\n\t\t\tcontinue;\n\t\tif (fds[i].events & POLLIN) {\n\t\t\tFD_SET(fd, readfds);\n\t\t\tFD_SET(fd, exceptfds);\n\t\t}\n\t\tif (fds[i].events & POLLOUT) {\n\t\t\tFD_SET(fd, writefds);\n\t\t\tFD_SET(fd, exceptfds);\n\t\t}\n\t}\n\n\t/* poll timeout is msec, select is timeval (sec + usec) */\n\tif (timeout >= 0) {\n\t\ttv.tv_sec = timeout / 1000;\n\t\ttv.tv_usec = (timeout % 1000) * 1000;\n\t\ttvp = &tv;\n\t}\n\n\tret = select(maxfd + 1, readfds, writefds, exceptfds, tvp);\n\tsaved_errno = errno;\n\n\t/* scan through select results and set poll() flags */\n\tfor (i = 0; i < nfds; i++) {\n\t\tfd = fds[i].fd;\n\t\tfds[i].revents = 0;\n\t\tif (fd == -1)\n\t\t\tcontinue;\n\t\tif (FD_ISSET(fd, readfds)) {\n\t\t\tfds[i].revents |= POLLIN;\n\t\t}\n\t\tif (FD_ISSET(fd, writefds)) {\n\t\t\tfds[i].revents |= POLLOUT;\n\t\t}\n\t\tif (FD_ISSET(fd, exceptfds)) {\n\t\t\tfds[i].revents |= POLLERR;\n\t\t}\n\t}\n\nout:\n\tfree(readfds);\n\tfree(writefds);\n\tfree(exceptfds);\n\tif (ret == -1)\n\t\terrno = saved_errno;\n\treturn ret;\n}"
  }
]