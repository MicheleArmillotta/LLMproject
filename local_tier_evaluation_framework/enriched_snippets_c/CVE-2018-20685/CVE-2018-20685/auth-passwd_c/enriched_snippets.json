[
  {
    "function_name": "sys_auth_passwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-passwd.c",
    "lines": "191-222",
    "snippet": "int\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tchar *encrypted_password, *salt = NULL;\n\n\t/* Just use the supplied fake password if authctxt is invalid */\n\tchar *pw_password = authctxt->valid ? shadow_pw(pw) : pw->pw_passwd;\n\n\tif (pw_password == NULL)\n\t\treturn 0;\n\n\t/* Check for users with no password. */\n\tif (strcmp(pw_password, \"\") == 0 && strcmp(password, \"\") == 0)\n\t\treturn (1);\n\n\t/*\n\t * Encrypt the candidate password using the proper salt, or pass a\n\t * NULL and let xcrypt pick one.\n\t */\n\tif (authctxt->valid && pw_password[0] && pw_password[1])\n\t\tsalt = pw_password;\n\tencrypted_password = xcrypt(password, salt);\n\n\t/*\n\t * Authentication is accepted if the encrypted passwords\n\t * are identical.\n\t */\n\treturn encrypted_password != NULL &&\n\t    strcmp(encrypted_password, pw_password) == 0;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "encrypted_password",
            "pw_password"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcrypt",
          "args": [
            "password",
            "salt"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "xcrypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/xcrypt.c",
          "lines": "99-128",
          "snippet": "char *\nxcrypt(const char *password, const char *salt)\n{\n\tchar *crypted;\n\n\t/*\n\t * If we don't have a salt we are encrypting a fake password for\n\t * for timing purposes.  Pick an appropriate salt.\n\t */\n\tif (salt == NULL)\n\t\tsalt = pick_salt();\n\n# ifdef HAVE_MD5_PASSWORDS\n\tif (is_md5_salt(salt))\n\t\tcrypted = md5_crypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(__hpux) && !defined(HAVE_SECUREWARE)\n\tif (iscomsec())\n\t\tcrypted = bigcrypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(HAVE_SECUREWARE)\n\tcrypted = bigcrypt(password, salt);\n# else\n\tcrypted = crypt(password, salt);\n# endif\n\n\treturn crypted;\n}",
          "includes": [
            "#  include <openssl/des.h>",
            "#  include \"md5crypt.h\"",
            "#  include <pwdadj.h>",
            "#  include <sys/audit.h>",
            "#  include <sys/label.h>",
            "#  include <shadow.h>",
            "#  include <prot.h>",
            "#  include <sys/audit.h>",
            "#  include <sys/security.h>",
            "#  include <prot.h>",
            "#  include <hpsecurity.h>",
            "#  include <crypt.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <openssl/des.h>\n#  include \"md5crypt.h\"\n#  include <pwdadj.h>\n#  include <sys/audit.h>\n#  include <sys/label.h>\n#  include <shadow.h>\n#  include <prot.h>\n#  include <sys/audit.h>\n#  include <sys/security.h>\n#  include <prot.h>\n#  include <hpsecurity.h>\n#  include <crypt.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nxcrypt(const char *password, const char *salt)\n{\n\tchar *crypted;\n\n\t/*\n\t * If we don't have a salt we are encrypting a fake password for\n\t * for timing purposes.  Pick an appropriate salt.\n\t */\n\tif (salt == NULL)\n\t\tsalt = pick_salt();\n\n# ifdef HAVE_MD5_PASSWORDS\n\tif (is_md5_salt(salt))\n\t\tcrypted = md5_crypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(__hpux) && !defined(HAVE_SECUREWARE)\n\tif (iscomsec())\n\t\tcrypted = bigcrypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(HAVE_SECUREWARE)\n\tcrypted = bigcrypt(password, salt);\n# else\n\tcrypted = crypt(password, salt);\n# endif\n\n\treturn crypted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shadow_pw",
          "args": [
            "pw"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "auth_shadow_pwexpired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-shadow.c",
          "lines": "87-140",
          "snippet": "int\nauth_shadow_pwexpired(Authctxt *ctxt)\n{\n\tstruct spwd *spw = NULL;\n\tconst char *user = ctxt->pw->pw_name;\n\ttime_t today;\n\tint r, daysleft, disabled = 0;\n\n\tif ((spw = getspnam((char *)user)) == NULL) {\n\t\terror(\"Could not get shadow information for %.100s\", user);\n\t\treturn 0;\n\t}\n\n\ttoday = time(NULL) / DAY;\n\tdebug3(\"%s: today %d sp_lstchg %d sp_max %d\", __func__, (int)today,\n\t    (int)spw->sp_lstchg, (int)spw->sp_max);\n\n#if defined(__hpux) && !defined(HAVE_SECUREWARE)\n\tif (iscomsec()) {\n\t\tstruct pr_passwd *pr;\n\n\t\tpr = getprpwnam((char *)user);\n\n\t\t/* Test for Trusted Mode expiry disabled */\n\t\tif (pr != NULL && pr->ufld.fd_min == 0 &&\n\t\t    pr->ufld.fd_lifetime == 0 && pr->ufld.fd_expire == 0 &&\n\t\t    pr->ufld.fd_pw_expire_warning == 0 &&\n\t\t    pr->ufld.fd_schange != 0)\n\t\t\tdisabled = 1;\n\t}\n#endif\n\n\t/* TODO: check sp_inact */\n\tdaysleft = spw->sp_lstchg + spw->sp_max - today;\n\tif (disabled) {\n\t\tdebug3(\"password expiration disabled\");\n\t} else if (spw->sp_lstchg == 0) {\n\t\tlogit(\"User %.100s password has expired (root forced)\", user);\n\t\treturn 1;\n\t} else if (spw->sp_max == -1) {\n\t\tdebug3(\"password expiration disabled\");\n\t} else if (daysleft < 0) {\n\t\tlogit(\"User %.100s password has expired (password aged)\", user);\n\t\treturn 1;\n\t} else if (daysleft <= spw->sp_warn) {\n\t\tdebug3(\"password will expire in %d days\", daysleft);\n\t\tif ((r = sshbuf_putf(loginmsg, \n\t\t    \"Your password will expire in %d day%s.\\n\", daysleft,\n\t\t    daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define DAY\t(24L * 60 * 60) /* 1 day in seconds */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include \"includes.h\"\n\n#define DAY\t(24L * 60 * 60) /* 1 day in seconds */\n\nint\nauth_shadow_pwexpired(Authctxt *ctxt)\n{\n\tstruct spwd *spw = NULL;\n\tconst char *user = ctxt->pw->pw_name;\n\ttime_t today;\n\tint r, daysleft, disabled = 0;\n\n\tif ((spw = getspnam((char *)user)) == NULL) {\n\t\terror(\"Could not get shadow information for %.100s\", user);\n\t\treturn 0;\n\t}\n\n\ttoday = time(NULL) / DAY;\n\tdebug3(\"%s: today %d sp_lstchg %d sp_max %d\", __func__, (int)today,\n\t    (int)spw->sp_lstchg, (int)spw->sp_max);\n\n#if defined(__hpux) && !defined(HAVE_SECUREWARE)\n\tif (iscomsec()) {\n\t\tstruct pr_passwd *pr;\n\n\t\tpr = getprpwnam((char *)user);\n\n\t\t/* Test for Trusted Mode expiry disabled */\n\t\tif (pr != NULL && pr->ufld.fd_min == 0 &&\n\t\t    pr->ufld.fd_lifetime == 0 && pr->ufld.fd_expire == 0 &&\n\t\t    pr->ufld.fd_pw_expire_warning == 0 &&\n\t\t    pr->ufld.fd_schange != 0)\n\t\t\tdisabled = 1;\n\t}\n#endif\n\n\t/* TODO: check sp_inact */\n\tdaysleft = spw->sp_lstchg + spw->sp_max - today;\n\tif (disabled) {\n\t\tdebug3(\"password expiration disabled\");\n\t} else if (spw->sp_lstchg == 0) {\n\t\tlogit(\"User %.100s password has expired (root forced)\", user);\n\t\treturn 1;\n\t} else if (spw->sp_max == -1) {\n\t\tdebug3(\"password expiration disabled\");\n\t} else if (daysleft < 0) {\n\t\tlogit(\"User %.100s password has expired (password aged)\", user);\n\t\treturn 1;\n\t} else if (daysleft <= spw->sp_warn) {\n\t\tdebug3(\"password will expire in %d days\", daysleft);\n\t\tif ((r = sshbuf_putf(loginmsg, \n\t\t    \"Your password will expire in %d day%s.\\n\", daysleft,\n\t\t    daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tchar *encrypted_password, *salt = NULL;\n\n\t/* Just use the supplied fake password if authctxt is invalid */\n\tchar *pw_password = authctxt->valid ? shadow_pw(pw) : pw->pw_passwd;\n\n\tif (pw_password == NULL)\n\t\treturn 0;\n\n\t/* Check for users with no password. */\n\tif (strcmp(pw_password, \"\") == 0 && strcmp(password, \"\") == 0)\n\t\treturn (1);\n\n\t/*\n\t * Encrypt the candidate password using the proper salt, or pass a\n\t * NULL and let xcrypt pick one.\n\t */\n\tif (authctxt->valid && pw_password[0] && pw_password[1])\n\t\tsalt = pw_password;\n\tencrypted_password = xcrypt(password, salt);\n\n\t/*\n\t * Authentication is accepted if the encrypted passwords\n\t * are identical.\n\t */\n\treturn encrypted_password != NULL &&\n\t    strcmp(encrypted_password, pw_password) == 0;\n}"
  },
  {
    "function_name": "sys_auth_passwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-passwd.c",
    "lines": "166-189",
    "snippet": "int\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tauth_session_t *as;\n\tstatic int expire_checked = 0;\n\n\tas = auth_usercheck(authctxt->pw->pw_name, authctxt->style, \"auth-ssh\",\n\t    (char *)password);\n\tif (as == NULL)\n\t\treturn (0);\n\tif (auth_getstate(as) & AUTH_PWEXPIRED) {\n\t\tauth_close(as);\n\t\tauth_restrict_session(ssh);\n\t\tauthctxt->force_pwchange = 1;\n\t\treturn (1);\n\t} else {\n\t\tif (!expire_checked) {\n\t\t\texpire_checked = 1;\n\t\t\twarn_expiry(authctxt, as);\n\t\t}\n\t\treturn (auth_close(as));\n\t}\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "auth_close",
          "args": [
            "as"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warn_expiry",
          "args": [
            "authctxt",
            "as"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "warn_expiry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-passwd.c",
          "lines": "132-164",
          "snippet": "static void\nwarn_expiry(Authctxt *authctxt, auth_session_t *as)\n{\n\tint r;\n\tquad_t pwtimeleft, actimeleft, daysleft, pwwarntime, acwarntime;\n\n\tpwwarntime = acwarntime = TWO_WEEKS;\n\n\tpwtimeleft = auth_check_change(as);\n\tactimeleft = auth_check_expire(as);\n#ifdef HAVE_LOGIN_CAP\n\tif (authctxt->valid) {\n\t\tpwwarntime = login_getcaptime(lc, \"password-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t\tacwarntime = login_getcaptime(lc, \"expire-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t}\n#endif\n\tif (pwtimeleft != 0 && pwtimeleft < pwwarntime) {\n\t\tdaysleft = pwtimeleft / DAY + 1;\n\t\tif ((r = sshbuf_putf(loginmsg,\n\t\t    \"Your password will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif (actimeleft != 0 && actimeleft < acwarntime) {\n\t\tdaysleft = actimeleft / DAY + 1;\n\t\tif ((r = sshbuf_putf(loginmsg,\n\t\t    \"Your account will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define TWO_WEEKS\t(2L * 7 * DAY)\t/* 2 weeks in seconds */",
            "#define DAY\t\t(24L * 60 * 60) /* 1 day in seconds */"
          ],
          "globals_used": [
            "extern struct sshbuf *loginmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define TWO_WEEKS\t(2L * 7 * DAY)\t/* 2 weeks in seconds */\n#define DAY\t\t(24L * 60 * 60) /* 1 day in seconds */\n\nextern struct sshbuf *loginmsg;\n\nstatic void\nwarn_expiry(Authctxt *authctxt, auth_session_t *as)\n{\n\tint r;\n\tquad_t pwtimeleft, actimeleft, daysleft, pwwarntime, acwarntime;\n\n\tpwwarntime = acwarntime = TWO_WEEKS;\n\n\tpwtimeleft = auth_check_change(as);\n\tactimeleft = auth_check_expire(as);\n#ifdef HAVE_LOGIN_CAP\n\tif (authctxt->valid) {\n\t\tpwwarntime = login_getcaptime(lc, \"password-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t\tacwarntime = login_getcaptime(lc, \"expire-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t}\n#endif\n\tif (pwtimeleft != 0 && pwtimeleft < pwwarntime) {\n\t\tdaysleft = pwtimeleft / DAY + 1;\n\t\tif ((r = sshbuf_putf(loginmsg,\n\t\t    \"Your password will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif (actimeleft != 0 && actimeleft < acwarntime) {\n\t\tdaysleft = actimeleft / DAY + 1;\n\t\tif ((r = sshbuf_putf(loginmsg,\n\t\t    \"Your account will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_restrict_session",
          "args": [
            "ssh"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "auth_restrict_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "1092-1107",
          "snippet": "void\nauth_restrict_session(struct ssh *ssh)\n{\n\tstruct sshauthopt *restricted;\n\n\tdebug(\"%s: restricting session\", __func__);\n\n\t/* A blank sshauthopt defaults to permitting nothing */\n\trestricted = sshauthopt_new();\n\trestricted->permit_pty_flag = 1;\n\trestricted->restricted = 1;\n\n\tif (auth_activate_options(ssh, restricted) != 0)\n\t\tfatal(\"%s: failed to restrict session\", __func__);\n\tsshauthopt_free(restricted);\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nauth_restrict_session(struct ssh *ssh)\n{\n\tstruct sshauthopt *restricted;\n\n\tdebug(\"%s: restricting session\", __func__);\n\n\t/* A blank sshauthopt defaults to permitting nothing */\n\trestricted = sshauthopt_new();\n\trestricted->permit_pty_flag = 1;\n\trestricted->restricted = 1;\n\n\tif (auth_activate_options(ssh, restricted) != 0)\n\t\tfatal(\"%s: failed to restrict session\", __func__);\n\tsshauthopt_free(restricted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_close",
          "args": [
            "as"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_getstate",
          "args": [
            "as"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_usercheck",
          "args": [
            "authctxt->pw->pw_name",
            "authctxt->style",
            "\"auth-ssh\"",
            "(char *)password"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tauth_session_t *as;\n\tstatic int expire_checked = 0;\n\n\tas = auth_usercheck(authctxt->pw->pw_name, authctxt->style, \"auth-ssh\",\n\t    (char *)password);\n\tif (as == NULL)\n\t\treturn (0);\n\tif (auth_getstate(as) & AUTH_PWEXPIRED) {\n\t\tauth_close(as);\n\t\tauth_restrict_session(ssh);\n\t\tauthctxt->force_pwchange = 1;\n\t\treturn (1);\n\t} else {\n\t\tif (!expire_checked) {\n\t\t\texpire_checked = 1;\n\t\t\twarn_expiry(authctxt, as);\n\t\t}\n\t\treturn (auth_close(as));\n\t}\n}"
  },
  {
    "function_name": "warn_expiry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-passwd.c",
    "lines": "132-164",
    "snippet": "static void\nwarn_expiry(Authctxt *authctxt, auth_session_t *as)\n{\n\tint r;\n\tquad_t pwtimeleft, actimeleft, daysleft, pwwarntime, acwarntime;\n\n\tpwwarntime = acwarntime = TWO_WEEKS;\n\n\tpwtimeleft = auth_check_change(as);\n\tactimeleft = auth_check_expire(as);\n#ifdef HAVE_LOGIN_CAP\n\tif (authctxt->valid) {\n\t\tpwwarntime = login_getcaptime(lc, \"password-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t\tacwarntime = login_getcaptime(lc, \"expire-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t}\n#endif\n\tif (pwtimeleft != 0 && pwtimeleft < pwwarntime) {\n\t\tdaysleft = pwtimeleft / DAY + 1;\n\t\tif ((r = sshbuf_putf(loginmsg,\n\t\t    \"Your password will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif (actimeleft != 0 && actimeleft < acwarntime) {\n\t\tdaysleft = actimeleft / DAY + 1;\n\t\tif ((r = sshbuf_putf(loginmsg,\n\t\t    \"Your account will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define TWO_WEEKS\t(2L * 7 * DAY)\t/* 2 weeks in seconds */",
      "#define DAY\t\t(24L * 60 * 60) /* 1 day in seconds */"
    ],
    "globals_used": [
      "extern struct sshbuf *loginmsg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putf",
          "args": [
            "loginmsg",
            "\"Your account will expire in %lld day%s.\\n\"",
            "daysleft",
            "daysleft == 1 ? \"\" : \"s\""
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "login_getcaptime",
          "args": [
            "lc",
            "\"expire-warn\"",
            "TWO_WEEKS",
            "TWO_WEEKS"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "login_getcaptime",
          "args": [
            "lc",
            "\"password-warn\"",
            "TWO_WEEKS",
            "TWO_WEEKS"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_check_expire",
          "args": [
            "as"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_check_change",
          "args": [
            "as"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define TWO_WEEKS\t(2L * 7 * DAY)\t/* 2 weeks in seconds */\n#define DAY\t\t(24L * 60 * 60) /* 1 day in seconds */\n\nextern struct sshbuf *loginmsg;\n\nstatic void\nwarn_expiry(Authctxt *authctxt, auth_session_t *as)\n{\n\tint r;\n\tquad_t pwtimeleft, actimeleft, daysleft, pwwarntime, acwarntime;\n\n\tpwwarntime = acwarntime = TWO_WEEKS;\n\n\tpwtimeleft = auth_check_change(as);\n\tactimeleft = auth_check_expire(as);\n#ifdef HAVE_LOGIN_CAP\n\tif (authctxt->valid) {\n\t\tpwwarntime = login_getcaptime(lc, \"password-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t\tacwarntime = login_getcaptime(lc, \"expire-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t}\n#endif\n\tif (pwtimeleft != 0 && pwtimeleft < pwwarntime) {\n\t\tdaysleft = pwtimeleft / DAY + 1;\n\t\tif ((r = sshbuf_putf(loginmsg,\n\t\t    \"Your password will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif (actimeleft != 0 && actimeleft < acwarntime) {\n\t\tdaysleft = actimeleft / DAY + 1;\n\t\tif ((r = sshbuf_putf(loginmsg,\n\t\t    \"Your account will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n}"
  },
  {
    "function_name": "auth_password",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-passwd.c",
    "lines": "76-129",
    "snippet": "int\nauth_password(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(ssh, password);\n\tif (authctxt->force_pwchange)\n\t\tauth_restrict_session(ssh);\n\treturn (result && ok);\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MAX_PASSWORD_LEN\t1024"
    ],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "auth_restrict_session",
          "args": [
            "ssh"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "auth_restrict_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "1092-1107",
          "snippet": "void\nauth_restrict_session(struct ssh *ssh)\n{\n\tstruct sshauthopt *restricted;\n\n\tdebug(\"%s: restricting session\", __func__);\n\n\t/* A blank sshauthopt defaults to permitting nothing */\n\trestricted = sshauthopt_new();\n\trestricted->permit_pty_flag = 1;\n\trestricted->restricted = 1;\n\n\tif (auth_activate_options(ssh, restricted) != 0)\n\t\tfatal(\"%s: failed to restrict session\", __func__);\n\tsshauthopt_free(restricted);\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nauth_restrict_session(struct ssh *ssh)\n{\n\tstruct sshauthopt *restricted;\n\n\tdebug(\"%s: restricting session\", __func__);\n\n\t/* A blank sshauthopt defaults to permitting nothing */\n\trestricted = sshauthopt_new();\n\trestricted->permit_pty_flag = 1;\n\trestricted->restricted = 1;\n\n\tif (auth_activate_options(ssh, restricted) != 0)\n\t\tfatal(\"%s: failed to restrict session\", __func__);\n\tsshauthopt_free(restricted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sys_auth_passwd",
          "args": [
            "ssh",
            "password"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "sys_auth_passwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-passwd.c",
          "lines": "191-222",
          "snippet": "int\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tchar *encrypted_password, *salt = NULL;\n\n\t/* Just use the supplied fake password if authctxt is invalid */\n\tchar *pw_password = authctxt->valid ? shadow_pw(pw) : pw->pw_passwd;\n\n\tif (pw_password == NULL)\n\t\treturn 0;\n\n\t/* Check for users with no password. */\n\tif (strcmp(pw_password, \"\") == 0 && strcmp(password, \"\") == 0)\n\t\treturn (1);\n\n\t/*\n\t * Encrypt the candidate password using the proper salt, or pass a\n\t * NULL and let xcrypt pick one.\n\t */\n\tif (authctxt->valid && pw_password[0] && pw_password[1])\n\t\tsalt = pw_password;\n\tencrypted_password = xcrypt(password, salt);\n\n\t/*\n\t * Authentication is accepted if the encrypted passwords\n\t * are identical.\n\t */\n\treturn encrypted_password != NULL &&\n\t    strcmp(encrypted_password, pw_password) == 0;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tchar *encrypted_password, *salt = NULL;\n\n\t/* Just use the supplied fake password if authctxt is invalid */\n\tchar *pw_password = authctxt->valid ? shadow_pw(pw) : pw->pw_passwd;\n\n\tif (pw_password == NULL)\n\t\treturn 0;\n\n\t/* Check for users with no password. */\n\tif (strcmp(pw_password, \"\") == 0 && strcmp(password, \"\") == 0)\n\t\treturn (1);\n\n\t/*\n\t * Encrypt the candidate password using the proper salt, or pass a\n\t * NULL and let xcrypt pick one.\n\t */\n\tif (authctxt->valid && pw_password[0] && pw_password[1])\n\t\tsalt = pw_password;\n\tencrypted_password = xcrypt(password, salt);\n\n\t/*\n\t * Authentication is accepted if the encrypted passwords\n\t * are identical.\n\t */\n\treturn encrypted_password != NULL &&\n\t    strcmp(encrypted_password, pw_password) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_shadow_pwexpired",
          "args": [
            "authctxt"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "auth_shadow_pwexpired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-shadow.c",
          "lines": "87-140",
          "snippet": "int\nauth_shadow_pwexpired(Authctxt *ctxt)\n{\n\tstruct spwd *spw = NULL;\n\tconst char *user = ctxt->pw->pw_name;\n\ttime_t today;\n\tint r, daysleft, disabled = 0;\n\n\tif ((spw = getspnam((char *)user)) == NULL) {\n\t\terror(\"Could not get shadow information for %.100s\", user);\n\t\treturn 0;\n\t}\n\n\ttoday = time(NULL) / DAY;\n\tdebug3(\"%s: today %d sp_lstchg %d sp_max %d\", __func__, (int)today,\n\t    (int)spw->sp_lstchg, (int)spw->sp_max);\n\n#if defined(__hpux) && !defined(HAVE_SECUREWARE)\n\tif (iscomsec()) {\n\t\tstruct pr_passwd *pr;\n\n\t\tpr = getprpwnam((char *)user);\n\n\t\t/* Test for Trusted Mode expiry disabled */\n\t\tif (pr != NULL && pr->ufld.fd_min == 0 &&\n\t\t    pr->ufld.fd_lifetime == 0 && pr->ufld.fd_expire == 0 &&\n\t\t    pr->ufld.fd_pw_expire_warning == 0 &&\n\t\t    pr->ufld.fd_schange != 0)\n\t\t\tdisabled = 1;\n\t}\n#endif\n\n\t/* TODO: check sp_inact */\n\tdaysleft = spw->sp_lstchg + spw->sp_max - today;\n\tif (disabled) {\n\t\tdebug3(\"password expiration disabled\");\n\t} else if (spw->sp_lstchg == 0) {\n\t\tlogit(\"User %.100s password has expired (root forced)\", user);\n\t\treturn 1;\n\t} else if (spw->sp_max == -1) {\n\t\tdebug3(\"password expiration disabled\");\n\t} else if (daysleft < 0) {\n\t\tlogit(\"User %.100s password has expired (password aged)\", user);\n\t\treturn 1;\n\t} else if (daysleft <= spw->sp_warn) {\n\t\tdebug3(\"password will expire in %d days\", daysleft);\n\t\tif ((r = sshbuf_putf(loginmsg, \n\t\t    \"Your password will expire in %d day%s.\\n\", daysleft,\n\t\t    daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define DAY\t(24L * 60 * 60) /* 1 day in seconds */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include \"includes.h\"\n\n#define DAY\t(24L * 60 * 60) /* 1 day in seconds */\n\nint\nauth_shadow_pwexpired(Authctxt *ctxt)\n{\n\tstruct spwd *spw = NULL;\n\tconst char *user = ctxt->pw->pw_name;\n\ttime_t today;\n\tint r, daysleft, disabled = 0;\n\n\tif ((spw = getspnam((char *)user)) == NULL) {\n\t\terror(\"Could not get shadow information for %.100s\", user);\n\t\treturn 0;\n\t}\n\n\ttoday = time(NULL) / DAY;\n\tdebug3(\"%s: today %d sp_lstchg %d sp_max %d\", __func__, (int)today,\n\t    (int)spw->sp_lstchg, (int)spw->sp_max);\n\n#if defined(__hpux) && !defined(HAVE_SECUREWARE)\n\tif (iscomsec()) {\n\t\tstruct pr_passwd *pr;\n\n\t\tpr = getprpwnam((char *)user);\n\n\t\t/* Test for Trusted Mode expiry disabled */\n\t\tif (pr != NULL && pr->ufld.fd_min == 0 &&\n\t\t    pr->ufld.fd_lifetime == 0 && pr->ufld.fd_expire == 0 &&\n\t\t    pr->ufld.fd_pw_expire_warning == 0 &&\n\t\t    pr->ufld.fd_schange != 0)\n\t\t\tdisabled = 1;\n\t}\n#endif\n\n\t/* TODO: check sp_inact */\n\tdaysleft = spw->sp_lstchg + spw->sp_max - today;\n\tif (disabled) {\n\t\tdebug3(\"password expiration disabled\");\n\t} else if (spw->sp_lstchg == 0) {\n\t\tlogit(\"User %.100s password has expired (root forced)\", user);\n\t\treturn 1;\n\t} else if (spw->sp_max == -1) {\n\t\tdebug3(\"password expiration disabled\");\n\t} else if (daysleft < 0) {\n\t\tlogit(\"User %.100s password has expired (password aged)\", user);\n\t\treturn 1;\n\t} else if (daysleft <= spw->sp_warn) {\n\t\tdebug3(\"password will expire in %d days\", daysleft);\n\t\tif ((r = sshbuf_putf(loginmsg, \n\t\t    \"Your password will expire in %d day%s.\\n\", daysleft,\n\t\t    daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpam_auth_passwd",
          "args": [
            "authctxt",
            "password"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "sshpam_auth_passwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1287-1331",
          "snippet": "int\nsshpam_auth_passwd(Authctxt *authctxt, const char *password)\n{\n\tint flags = (options.permit_empty_passwd == 0 ?\n\t    PAM_DISALLOW_NULL_AUTHTOK : 0);\n\tchar *fake = NULL;\n\n\tif (!options.use_pam || sshpam_handle == NULL)\n\t\tfatal(\"PAM: %s called when PAM disabled or failed to \"\n\t\t    \"initialise.\", __func__);\n\n\tsshpam_password = password;\n\tsshpam_authctxt = authctxt;\n\n\t/*\n\t * If the user logging in is invalid, or is root but is not permitted\n\t * by PermitRootLogin, use an invalid password to prevent leaking\n\t * information via timing (eg if the PAM config has a delay on fail).\n\t */\n\tif (!authctxt->valid || (authctxt->pw->pw_uid == 0 &&\n\t    options.permit_root_login != PERMIT_YES))\n\t\tsshpam_password = fake = fake_password(password);\n\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&passwd_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: %s: failed to set PAM_CONV: %s\", __func__,\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\n\tsshpam_err = pam_authenticate(sshpam_handle, flags);\n\tsshpam_password = NULL;\n\tfree(fake);\n\tif (sshpam_err == PAM_MAXTRIES)\n\t\tsshpam_set_maxtries_reached(1);\n\tif (sshpam_err == PAM_SUCCESS && authctxt->valid) {\n\t\tdebug(\"PAM: password authentication accepted for %.100s\",\n\t\t    authctxt->user);\n\t\treturn 1;\n\t} else {\n\t\tdebug(\"PAM: password authentication failed for %.100s: %s\",\n\t\t    authctxt->valid ? authctxt->user : \"an illegal user\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpam_auth_passwd(Authctxt *authctxt, const char *password)\n{\n\tint flags = (options.permit_empty_passwd == 0 ?\n\t    PAM_DISALLOW_NULL_AUTHTOK : 0);\n\tchar *fake = NULL;\n\n\tif (!options.use_pam || sshpam_handle == NULL)\n\t\tfatal(\"PAM: %s called when PAM disabled or failed to \"\n\t\t    \"initialise.\", __func__);\n\n\tsshpam_password = password;\n\tsshpam_authctxt = authctxt;\n\n\t/*\n\t * If the user logging in is invalid, or is root but is not permitted\n\t * by PermitRootLogin, use an invalid password to prevent leaking\n\t * information via timing (eg if the PAM config has a delay on fail).\n\t */\n\tif (!authctxt->valid || (authctxt->pw->pw_uid == 0 &&\n\t    options.permit_root_login != PERMIT_YES))\n\t\tsshpam_password = fake = fake_password(password);\n\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&passwd_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: %s: failed to set PAM_CONV: %s\", __func__,\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\n\tsshpam_err = pam_authenticate(sshpam_handle, flags);\n\tsshpam_password = NULL;\n\tfree(fake);\n\tif (sshpam_err == PAM_MAXTRIES)\n\t\tsshpam_set_maxtries_reached(1);\n\tif (sshpam_err == PAM_SUCCESS && authctxt->valid) {\n\t\tdebug(\"PAM: password authentication accepted for %.100s\",\n\t\t    authctxt->user);\n\t\treturn 1;\n\t} else {\n\t\tdebug(\"PAM: password authentication failed for %.100s: %s\",\n\t\t    authctxt->valid ? authctxt->user : \"an illegal user\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cygwin_set_impersonation_token",
          "args": [
            "hToken"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cygwin_logon_user",
          "args": [
            "pw",
            "password"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_krb5_password",
          "args": [
            "authctxt",
            "password"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "auth_krb5_password",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-krb5.c",
          "lines": "71-220",
          "snippet": "int\nauth_krb5_password(Authctxt *authctxt, const char *password)\n{\n#ifndef HEIMDAL\n\tkrb5_creds creds;\n\tkrb5_principal server;\n#endif\n\tkrb5_error_code problem;\n\tkrb5_ccache ccache = NULL;\n\tint len;\n\tchar *client, *platform_client;\n\tconst char *errmsg;\n\n\t/* get platform-specific kerberos client principal name (if it exists) */\n\tplatform_client = platform_krb5_get_principal_name(authctxt->pw->pw_name);\n\tclient = platform_client ? platform_client : authctxt->pw->pw_name;\n\n\ttemporarily_use_uid(authctxt->pw);\n\n\tproblem = krb5_init(authctxt);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_parse_name(authctxt->krb5_ctx, client,\n\t\t    &authctxt->krb5_user);\n\tif (problem)\n\t\tgoto out;\n\n#ifdef HEIMDAL\n# ifdef HAVE_KRB5_CC_NEW_UNIQUE\n\tproblem = krb5_cc_new_unique(authctxt->krb5_ctx,\n\t     krb5_mcc_ops.prefix, NULL, &ccache);\n# else\n\tproblem = krb5_cc_gen_new(authctxt->krb5_ctx, &krb5_mcc_ops, &ccache);\n# endif\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_cc_initialize(authctxt->krb5_ctx, ccache,\n\t\tauthctxt->krb5_user);\n\tif (problem)\n\t\tgoto out;\n\n\trestore_uid();\n\n\tproblem = krb5_verify_user(authctxt->krb5_ctx, authctxt->krb5_user,\n\t    ccache, password, 1, NULL);\n\n\ttemporarily_use_uid(authctxt->pw);\n\n\tif (problem)\n\t\tgoto out;\n\n# ifdef HAVE_KRB5_CC_NEW_UNIQUE\n\tproblem = krb5_cc_new_unique(authctxt->krb5_ctx,\n\t     krb5_fcc_ops.prefix, NULL, &authctxt->krb5_fwd_ccache);\n# else\n\tproblem = krb5_cc_gen_new(authctxt->krb5_ctx, &krb5_fcc_ops,\n\t    &authctxt->krb5_fwd_ccache);\n# endif\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_cc_copy_cache(authctxt->krb5_ctx, ccache,\n\t    authctxt->krb5_fwd_ccache);\n\tkrb5_cc_destroy(authctxt->krb5_ctx, ccache);\n\tccache = NULL;\n\tif (problem)\n\t\tgoto out;\n\n#else\n\tproblem = krb5_get_init_creds_password(authctxt->krb5_ctx, &creds,\n\t    authctxt->krb5_user, (char *)password, NULL, NULL, 0, NULL, NULL);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_sname_to_principal(authctxt->krb5_ctx, NULL, NULL,\n\t    KRB5_NT_SRV_HST, &server);\n\tif (problem)\n\t\tgoto out;\n\n\trestore_uid();\n\tproblem = krb5_verify_init_creds(authctxt->krb5_ctx, &creds, server,\n\t    NULL, NULL, NULL);\n\tkrb5_free_principal(authctxt->krb5_ctx, server);\n\ttemporarily_use_uid(authctxt->pw);\n\tif (problem)\n\t\tgoto out;\n\n\tif (!krb5_kuserok(authctxt->krb5_ctx, authctxt->krb5_user,\n\t    authctxt->pw->pw_name)) {\n\t\tproblem = -1;\n\t\tgoto out;\n\t}\n\n\tproblem = ssh_krb5_cc_gen(authctxt->krb5_ctx, &authctxt->krb5_fwd_ccache);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_cc_initialize(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache,\n\t\t\t\t     authctxt->krb5_user);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem= krb5_cc_store_cred(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache,\n\t\t\t\t &creds);\n\tif (problem)\n\t\tgoto out;\n#endif\n\n\tauthctxt->krb5_ticket_file = (char *)krb5_cc_get_name(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache);\n\n\tlen = strlen(authctxt->krb5_ticket_file) + 6;\n\tauthctxt->krb5_ccname = xmalloc(len);\n\tsnprintf(authctxt->krb5_ccname, len, \"FILE:%s\",\n\t    authctxt->krb5_ticket_file);\n\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\tdo_pam_putenv(\"KRB5CCNAME\", authctxt->krb5_ccname);\n#endif\n\n out:\n\trestore_uid();\n\t\n\tfree(platform_client);\n\n\tif (problem) {\n\t\tif (ccache)\n\t\t\tkrb5_cc_destroy(authctxt->krb5_ctx, ccache);\n\n\t\tif (authctxt->krb5_ctx != NULL && problem!=-1) {\n\t\t\terrmsg = krb5_get_error_message(authctxt->krb5_ctx,\n\t\t\t    problem);\n \t\t\tdebug(\"Kerberos password authentication failed: %s\",\n\t\t\t    errmsg);\n\t\t\tkrb5_free_error_message(authctxt->krb5_ctx, errmsg);\n\t\t} else\n\t\t\tdebug(\"Kerberos password authentication failed: %d\",\n\t\t\t    problem);\n\n\t\tkrb5_cleanup_proc(authctxt);\n\n\t\tif (options.kerberos_or_local_passwd)\n\t\t\treturn (-1);\n\t\telse\n\t\t\treturn (0);\n\t}\n\treturn (authctxt->valid ? 1 : 0);\n}",
          "includes": [
            "#include <krb5.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <krb5.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nauth_krb5_password(Authctxt *authctxt, const char *password)\n{\n#ifndef HEIMDAL\n\tkrb5_creds creds;\n\tkrb5_principal server;\n#endif\n\tkrb5_error_code problem;\n\tkrb5_ccache ccache = NULL;\n\tint len;\n\tchar *client, *platform_client;\n\tconst char *errmsg;\n\n\t/* get platform-specific kerberos client principal name (if it exists) */\n\tplatform_client = platform_krb5_get_principal_name(authctxt->pw->pw_name);\n\tclient = platform_client ? platform_client : authctxt->pw->pw_name;\n\n\ttemporarily_use_uid(authctxt->pw);\n\n\tproblem = krb5_init(authctxt);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_parse_name(authctxt->krb5_ctx, client,\n\t\t    &authctxt->krb5_user);\n\tif (problem)\n\t\tgoto out;\n\n#ifdef HEIMDAL\n# ifdef HAVE_KRB5_CC_NEW_UNIQUE\n\tproblem = krb5_cc_new_unique(authctxt->krb5_ctx,\n\t     krb5_mcc_ops.prefix, NULL, &ccache);\n# else\n\tproblem = krb5_cc_gen_new(authctxt->krb5_ctx, &krb5_mcc_ops, &ccache);\n# endif\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_cc_initialize(authctxt->krb5_ctx, ccache,\n\t\tauthctxt->krb5_user);\n\tif (problem)\n\t\tgoto out;\n\n\trestore_uid();\n\n\tproblem = krb5_verify_user(authctxt->krb5_ctx, authctxt->krb5_user,\n\t    ccache, password, 1, NULL);\n\n\ttemporarily_use_uid(authctxt->pw);\n\n\tif (problem)\n\t\tgoto out;\n\n# ifdef HAVE_KRB5_CC_NEW_UNIQUE\n\tproblem = krb5_cc_new_unique(authctxt->krb5_ctx,\n\t     krb5_fcc_ops.prefix, NULL, &authctxt->krb5_fwd_ccache);\n# else\n\tproblem = krb5_cc_gen_new(authctxt->krb5_ctx, &krb5_fcc_ops,\n\t    &authctxt->krb5_fwd_ccache);\n# endif\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_cc_copy_cache(authctxt->krb5_ctx, ccache,\n\t    authctxt->krb5_fwd_ccache);\n\tkrb5_cc_destroy(authctxt->krb5_ctx, ccache);\n\tccache = NULL;\n\tif (problem)\n\t\tgoto out;\n\n#else\n\tproblem = krb5_get_init_creds_password(authctxt->krb5_ctx, &creds,\n\t    authctxt->krb5_user, (char *)password, NULL, NULL, 0, NULL, NULL);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_sname_to_principal(authctxt->krb5_ctx, NULL, NULL,\n\t    KRB5_NT_SRV_HST, &server);\n\tif (problem)\n\t\tgoto out;\n\n\trestore_uid();\n\tproblem = krb5_verify_init_creds(authctxt->krb5_ctx, &creds, server,\n\t    NULL, NULL, NULL);\n\tkrb5_free_principal(authctxt->krb5_ctx, server);\n\ttemporarily_use_uid(authctxt->pw);\n\tif (problem)\n\t\tgoto out;\n\n\tif (!krb5_kuserok(authctxt->krb5_ctx, authctxt->krb5_user,\n\t    authctxt->pw->pw_name)) {\n\t\tproblem = -1;\n\t\tgoto out;\n\t}\n\n\tproblem = ssh_krb5_cc_gen(authctxt->krb5_ctx, &authctxt->krb5_fwd_ccache);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_cc_initialize(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache,\n\t\t\t\t     authctxt->krb5_user);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem= krb5_cc_store_cred(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache,\n\t\t\t\t &creds);\n\tif (problem)\n\t\tgoto out;\n#endif\n\n\tauthctxt->krb5_ticket_file = (char *)krb5_cc_get_name(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache);\n\n\tlen = strlen(authctxt->krb5_ticket_file) + 6;\n\tauthctxt->krb5_ccname = xmalloc(len);\n\tsnprintf(authctxt->krb5_ccname, len, \"FILE:%s\",\n\t    authctxt->krb5_ticket_file);\n\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\tdo_pam_putenv(\"KRB5CCNAME\", authctxt->krb5_ccname);\n#endif\n\n out:\n\trestore_uid();\n\t\n\tfree(platform_client);\n\n\tif (problem) {\n\t\tif (ccache)\n\t\t\tkrb5_cc_destroy(authctxt->krb5_ctx, ccache);\n\n\t\tif (authctxt->krb5_ctx != NULL && problem!=-1) {\n\t\t\terrmsg = krb5_get_error_message(authctxt->krb5_ctx,\n\t\t\t    problem);\n \t\t\tdebug(\"Kerberos password authentication failed: %s\",\n\t\t\t    errmsg);\n\t\t\tkrb5_free_error_message(authctxt->krb5_ctx, errmsg);\n\t\t} else\n\t\t\tdebug(\"Kerberos password authentication failed: %d\",\n\t\t\t    problem);\n\n\t\tkrb5_cleanup_proc(authctxt);\n\n\t\tif (options.kerberos_or_local_passwd)\n\t\t\treturn (-1);\n\t\telse\n\t\t\treturn (0);\n\t}\n\treturn (authctxt->valid ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "password"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_PASSWORD_LEN\t1024\n\nextern ServerOptions options;\n\nint\nauth_password(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(ssh, password);\n\tif (authctxt->force_pwchange)\n\t\tauth_restrict_session(ssh);\n\treturn (result && ok);\n}"
  }
]