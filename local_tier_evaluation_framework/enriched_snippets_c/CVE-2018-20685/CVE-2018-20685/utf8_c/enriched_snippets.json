[
  {
    "function_name": "msetlocale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
    "lines": "310-340",
    "snippet": "void\nmsetlocale(void)\n{\n\tconst char *vars[] = { \"LC_ALL\", \"LC_CTYPE\", \"LANG\", NULL };\n\tchar *cp;\n\tint i;\n\n\t/*\n\t * We can't yet cope with dotless/dotted I in Turkish locales,\n\t * so fall back to the C locale for these.\n\t */\n\tfor (i = 0; vars[i] != NULL; i++) {\n\t\tif ((cp = getenv(vars[i])) == NULL)\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"TR\", 2) != 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * If we're in a UTF-8 locale then prefer to use\n\t\t * the C.UTF-8 locale (or equivalent) if it exists.\n\t\t */\n\t\tif ((strcasestr(cp, \"UTF-8\") != NULL ||\n\t\t    strcasestr(cp, \"UTF8\") != NULL) &&\n\t\t    (setlocale(LC_CTYPE, \"C.UTF-8\") != NULL ||\n\t\t    setlocale(LC_CTYPE, \"POSIX.UTF-8\") != NULL))\n\t\t\treturn;\n\t\tsetlocale(LC_CTYPE, \"C\");\n\t\treturn;\n\t}\n\t/* We can handle this locale */\n\tsetlocale(LC_CTYPE, \"\");\n}",
    "includes": [
      "#include \"utf8.h\"",
      "# include <wchar.h>",
      "# include <vis.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "# include <langinfo.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "LC_CTYPE",
            "\"\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "LC_CTYPE",
            "\"C\""
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "LC_CTYPE",
            "\"POSIX.UTF-8\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "LC_CTYPE",
            "\"C.UTF-8\""
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasestr",
          "args": [
            "cp",
            "\"UTF8\""
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "strcasestr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strcasestr.c",
          "lines": "48-66",
          "snippet": "char *\nstrcasestr(const char *s, const char *find)\n{\n\tchar c, sc;\n\tsize_t len;\n\n\tif ((c = *find++) != 0) {\n\t\tc = (char)tolower((unsigned char)c);\n\t\tlen = strlen(find);\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tif ((sc = *s++) == 0)\n\t\t\t\t\treturn (NULL);\n\t\t\t} while ((char)tolower((unsigned char)sc) != c);\n\t\t} while (strncasecmp(s, find, len) != 0);\n\t\ts--;\n\t}\n\treturn ((char *)s);\n}",
          "includes": [
            "#include <string.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nchar *\nstrcasestr(const char *s, const char *find)\n{\n\tchar c, sc;\n\tsize_t len;\n\n\tif ((c = *find++) != 0) {\n\t\tc = (char)tolower((unsigned char)c);\n\t\tlen = strlen(find);\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tif ((sc = *s++) == 0)\n\t\t\t\t\treturn (NULL);\n\t\t\t} while ((char)tolower((unsigned char)sc) != c);\n\t\t} while (strncasecmp(s, find, len) != 0);\n\t\ts--;\n\t}\n\treturn ((char *)s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "cp",
            "\"TR\"",
            "2"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "vars[i]"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmsetlocale(void)\n{\n\tconst char *vars[] = { \"LC_ALL\", \"LC_CTYPE\", \"LANG\", NULL };\n\tchar *cp;\n\tint i;\n\n\t/*\n\t * We can't yet cope with dotless/dotted I in Turkish locales,\n\t * so fall back to the C locale for these.\n\t */\n\tfor (i = 0; vars[i] != NULL; i++) {\n\t\tif ((cp = getenv(vars[i])) == NULL)\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"TR\", 2) != 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * If we're in a UTF-8 locale then prefer to use\n\t\t * the C.UTF-8 locale (or equivalent) if it exists.\n\t\t */\n\t\tif ((strcasestr(cp, \"UTF-8\") != NULL ||\n\t\t    strcasestr(cp, \"UTF8\") != NULL) &&\n\t\t    (setlocale(LC_CTYPE, \"C.UTF-8\") != NULL ||\n\t\t    setlocale(LC_CTYPE, \"POSIX.UTF-8\") != NULL))\n\t\t\treturn;\n\t\tsetlocale(LC_CTYPE, \"C\");\n\t\treturn;\n\t}\n\t/* We can handle this locale */\n\tsetlocale(LC_CTYPE, \"\");\n}"
  },
  {
    "function_name": "mprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
    "lines": "289-299",
    "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
    "includes": [
      "#include \"utf8.h\"",
      "# include <wchar.h>",
      "# include <vis.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "# include <langinfo.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfmprintf",
          "args": [
            "stdout",
            "fmt",
            "ap"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "vfmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "263-275",
          "snippet": "int\nvfmprintf(FILE *stream, const char *fmt, va_list ap)\n{\n\tchar\t*str;\n\tint\t ret;\n\n\tif ((ret = vasnmprintf(&str, INT_MAX, NULL, fmt, ap)) < 0)\n\t\treturn -1;\n\tif (fputs(str, stream) == EOF)\n\t\tret = -1;\n\tfree(str);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nvfmprintf(FILE *stream, const char *fmt, va_list ap)\n{\n\tchar\t*str;\n\tint\t ret;\n\n\tif ((ret = vasnmprintf(&str, INT_MAX, NULL, fmt, ap)) < 0)\n\t\treturn -1;\n\tif (fputs(str, stream) == EOF)\n\t\tret = -1;\n\tfree(str);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
  },
  {
    "function_name": "fmprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
    "lines": "277-287",
    "snippet": "int\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
    "includes": [
      "#include \"utf8.h\"",
      "# include <wchar.h>",
      "# include <vis.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "# include <langinfo.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfmprintf",
          "args": [
            "stream",
            "fmt",
            "ap"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "vfmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "263-275",
          "snippet": "int\nvfmprintf(FILE *stream, const char *fmt, va_list ap)\n{\n\tchar\t*str;\n\tint\t ret;\n\n\tif ((ret = vasnmprintf(&str, INT_MAX, NULL, fmt, ap)) < 0)\n\t\treturn -1;\n\tif (fputs(str, stream) == EOF)\n\t\tret = -1;\n\tfree(str);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nvfmprintf(FILE *stream, const char *fmt, va_list ap)\n{\n\tchar\t*str;\n\tint\t ret;\n\n\tif ((ret = vasnmprintf(&str, INT_MAX, NULL, fmt, ap)) < 0)\n\t\treturn -1;\n\tif (fputs(str, stream) == EOF)\n\t\tret = -1;\n\tfree(str);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
  },
  {
    "function_name": "vfmprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
    "lines": "263-275",
    "snippet": "int\nvfmprintf(FILE *stream, const char *fmt, va_list ap)\n{\n\tchar\t*str;\n\tint\t ret;\n\n\tif ((ret = vasnmprintf(&str, INT_MAX, NULL, fmt, ap)) < 0)\n\t\treturn -1;\n\tif (fputs(str, stream) == EOF)\n\t\tret = -1;\n\tfree(str);\n\treturn ret;\n}",
    "includes": [
      "#include \"utf8.h\"",
      "# include <wchar.h>",
      "# include <vis.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "# include <langinfo.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "str",
            "stream"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vasnmprintf",
          "args": [
            "&str",
            "INT_MAX",
            "NULL",
            "fmt",
            "ap"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "vasnmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "104-238",
          "snippet": "static int\nvasnmprintf(char **str, size_t maxsz, int *wp, const char *fmt, va_list ap)\n{\n\tchar\t*src;\t/* Source string returned from vasprintf. */\n\tchar\t*sp;\t/* Pointer into src. */\n\tchar\t*dst;\t/* Destination string to be returned. */\n\tchar\t*dp;\t/* Pointer into dst. */\n\tchar\t*tp;\t/* Temporary pointer for dst. */\n\tsize_t\t sz;\t/* Number of bytes allocated for dst. */\n\twchar_t\t wc;\t/* Wide character at sp. */\n\tint\t len;\t/* Number of bytes in the character at sp. */\n\tint\t ret;\t/* Number of bytes needed to format src. */\n\tint\t width;\t/* Display width of the character wc. */\n\tint\t total_width, max_width, print;\n\n\tsrc = NULL;\n\tif ((ret = vasprintf(&src, fmt, ap)) <= 0)\n\t\tgoto fail;\n\n\tsz = strlen(src) + 1;\n\tif ((dst = malloc(sz)) == NULL) {\n\t\tfree(src);\n\t\tret = -1;\n\t\tgoto fail;\n\t}\n\n\tif (maxsz > INT_MAX)\n\t\tmaxsz = INT_MAX;\n\n\tsp = src;\n\tdp = dst;\n\tret = 0;\n\tprint = 1;\n\ttotal_width = 0;\n\tmax_width = wp == NULL ? INT_MAX : *wp;\n\twhile (*sp != '\\0') {\n\t\tif ((len = mbtowc(&wc, sp, MB_CUR_MAX)) == -1) {\n\t\t\t(void)mbtowc(NULL, NULL, MB_CUR_MAX);\n\t\t\tif (dangerous_locale()) {\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = 1;\n\t\t\twidth = -1;\n\t\t} else if (wp == NULL &&\n\t\t    (wc == L'\\n' || wc == L'\\r' || wc == L'\\t')) {\n\t\t\t/*\n\t\t\t * Don't use width uninitialized; the actual\n\t\t\t * value doesn't matter because total_width\n\t\t\t * is only returned for wp != NULL.\n\t\t\t */\n\t\t\twidth = 0;\n\t\t} else if ((width = wcwidth(wc)) == -1 &&\n\t\t    dangerous_locale()) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Valid, printable character. */\n\n\t\tif (width >= 0) {\n\t\t\tif (print && (dp - dst >= (int)maxsz - len ||\n\t\t\t    total_width > max_width - width))\n\t\t\t\tprint = 0;\n\t\t\tif (print) {\n\t\t\t\tif (grow_dst(&dst, &sz, maxsz,\n\t\t\t\t    &dp, len) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttotal_width += width;\n\t\t\t\tmemcpy(dp, sp, len);\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tsp += len;\n\t\t\tif (ret >= 0)\n\t\t\t\tret += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Escaping required. */\n\n\t\twhile (len > 0) {\n\t\t\tif (print && (dp - dst >= (int)maxsz - 4 ||\n\t\t\t    total_width > max_width - 4))\n\t\t\t\tprint = 0;\n\t\t\tif (print) {\n\t\t\t\tif (grow_dst(&dst, &sz, maxsz,\n\t\t\t\t    &dp, 4) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttp = vis(dp, *sp, VIS_OCTAL | VIS_ALL, 0);\n\t\t\t\twidth = tp - dp;\n\t\t\t\ttotal_width += width;\n\t\t\t\tdp = tp;\n\t\t\t} else\n\t\t\t\twidth = 4;\n\t\t\tlen--;\n\t\t\tsp++;\n\t\t\tif (ret >= 0)\n\t\t\t\tret += width;\n\t\t}\n\t\tif (len > 0)\n\t\t\tbreak;\n\t}\n\tfree(src);\n\t*dp = '\\0';\n\t*str = dst;\n\tif (wp != NULL)\n\t\t*wp = total_width;\n\n\t/*\n\t * If the string was truncated by the width limit but\n\t * would have fit into the size limit, the only sane way\n\t * to report the problem is using the return value, such\n\t * that the usual idiom \"if (ret < 0 || ret >= sz) error\"\n\t * works as expected.\n\t */\n\n\tif (ret < (int)maxsz && !print)\n\t\tret = -1;\n\treturn ret;\n\nfail:\n\tif (wp != NULL)\n\t\t*wp = 0;\n\tif (ret == 0) {\n\t\t*str = src;\n\t\treturn 0;\n\t} else {\n\t\t*str = NULL;\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t dangerous_locale(void);",
            "static int\t grow_dst(char **, size_t *, size_t, char **, size_t);",
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t dangerous_locale(void);\nstatic int\t grow_dst(char **, size_t *, size_t, char **, size_t);\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nstatic int\nvasnmprintf(char **str, size_t maxsz, int *wp, const char *fmt, va_list ap)\n{\n\tchar\t*src;\t/* Source string returned from vasprintf. */\n\tchar\t*sp;\t/* Pointer into src. */\n\tchar\t*dst;\t/* Destination string to be returned. */\n\tchar\t*dp;\t/* Pointer into dst. */\n\tchar\t*tp;\t/* Temporary pointer for dst. */\n\tsize_t\t sz;\t/* Number of bytes allocated for dst. */\n\twchar_t\t wc;\t/* Wide character at sp. */\n\tint\t len;\t/* Number of bytes in the character at sp. */\n\tint\t ret;\t/* Number of bytes needed to format src. */\n\tint\t width;\t/* Display width of the character wc. */\n\tint\t total_width, max_width, print;\n\n\tsrc = NULL;\n\tif ((ret = vasprintf(&src, fmt, ap)) <= 0)\n\t\tgoto fail;\n\n\tsz = strlen(src) + 1;\n\tif ((dst = malloc(sz)) == NULL) {\n\t\tfree(src);\n\t\tret = -1;\n\t\tgoto fail;\n\t}\n\n\tif (maxsz > INT_MAX)\n\t\tmaxsz = INT_MAX;\n\n\tsp = src;\n\tdp = dst;\n\tret = 0;\n\tprint = 1;\n\ttotal_width = 0;\n\tmax_width = wp == NULL ? INT_MAX : *wp;\n\twhile (*sp != '\\0') {\n\t\tif ((len = mbtowc(&wc, sp, MB_CUR_MAX)) == -1) {\n\t\t\t(void)mbtowc(NULL, NULL, MB_CUR_MAX);\n\t\t\tif (dangerous_locale()) {\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = 1;\n\t\t\twidth = -1;\n\t\t} else if (wp == NULL &&\n\t\t    (wc == L'\\n' || wc == L'\\r' || wc == L'\\t')) {\n\t\t\t/*\n\t\t\t * Don't use width uninitialized; the actual\n\t\t\t * value doesn't matter because total_width\n\t\t\t * is only returned for wp != NULL.\n\t\t\t */\n\t\t\twidth = 0;\n\t\t} else if ((width = wcwidth(wc)) == -1 &&\n\t\t    dangerous_locale()) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Valid, printable character. */\n\n\t\tif (width >= 0) {\n\t\t\tif (print && (dp - dst >= (int)maxsz - len ||\n\t\t\t    total_width > max_width - width))\n\t\t\t\tprint = 0;\n\t\t\tif (print) {\n\t\t\t\tif (grow_dst(&dst, &sz, maxsz,\n\t\t\t\t    &dp, len) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttotal_width += width;\n\t\t\t\tmemcpy(dp, sp, len);\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tsp += len;\n\t\t\tif (ret >= 0)\n\t\t\t\tret += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Escaping required. */\n\n\t\twhile (len > 0) {\n\t\t\tif (print && (dp - dst >= (int)maxsz - 4 ||\n\t\t\t    total_width > max_width - 4))\n\t\t\t\tprint = 0;\n\t\t\tif (print) {\n\t\t\t\tif (grow_dst(&dst, &sz, maxsz,\n\t\t\t\t    &dp, 4) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttp = vis(dp, *sp, VIS_OCTAL | VIS_ALL, 0);\n\t\t\t\twidth = tp - dp;\n\t\t\t\ttotal_width += width;\n\t\t\t\tdp = tp;\n\t\t\t} else\n\t\t\t\twidth = 4;\n\t\t\tlen--;\n\t\t\tsp++;\n\t\t\tif (ret >= 0)\n\t\t\t\tret += width;\n\t\t}\n\t\tif (len > 0)\n\t\t\tbreak;\n\t}\n\tfree(src);\n\t*dp = '\\0';\n\t*str = dst;\n\tif (wp != NULL)\n\t\t*wp = total_width;\n\n\t/*\n\t * If the string was truncated by the width limit but\n\t * would have fit into the size limit, the only sane way\n\t * to report the problem is using the return value, such\n\t * that the usual idiom \"if (ret < 0 || ret >= sz) error\"\n\t * works as expected.\n\t */\n\n\tif (ret < (int)maxsz && !print)\n\t\tret = -1;\n\treturn ret;\n\nfail:\n\tif (wp != NULL)\n\t\t*wp = 0;\n\tif (ret == 0) {\n\t\t*str = src;\n\t\treturn 0;\n\t} else {\n\t\t*str = NULL;\n\t\treturn -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nvfmprintf(FILE *stream, const char *fmt, va_list ap)\n{\n\tchar\t*str;\n\tint\t ret;\n\n\tif ((ret = vasnmprintf(&str, INT_MAX, NULL, fmt, ap)) < 0)\n\t\treturn -1;\n\tif (fputs(str, stream) == EOF)\n\t\tret = -1;\n\tfree(str);\n\treturn ret;\n}"
  },
  {
    "function_name": "snmprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
    "lines": "240-256",
    "snippet": "int\nsnmprintf(char *str, size_t sz, int *wp, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tchar\t*cp;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vasnmprintf(&cp, sz, wp, fmt, ap);\n\tva_end(ap);\n\tif (cp != NULL) {\n\t\t(void)strlcpy(str, cp, sz);\n\t\tfree(cp);\n\t} else\n\t\t*str = '\\0';\n\treturn ret;\n}",
    "includes": [
      "#include \"utf8.h\"",
      "# include <wchar.h>",
      "# include <vis.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "# include <langinfo.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t grow_dst(char **, size_t *, size_t, char **, size_t);",
      "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cp"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "str",
            "cp",
            "sz"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vasnmprintf",
          "args": [
            "&cp",
            "sz",
            "wp",
            "fmt",
            "ap"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "vasnmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "104-238",
          "snippet": "static int\nvasnmprintf(char **str, size_t maxsz, int *wp, const char *fmt, va_list ap)\n{\n\tchar\t*src;\t/* Source string returned from vasprintf. */\n\tchar\t*sp;\t/* Pointer into src. */\n\tchar\t*dst;\t/* Destination string to be returned. */\n\tchar\t*dp;\t/* Pointer into dst. */\n\tchar\t*tp;\t/* Temporary pointer for dst. */\n\tsize_t\t sz;\t/* Number of bytes allocated for dst. */\n\twchar_t\t wc;\t/* Wide character at sp. */\n\tint\t len;\t/* Number of bytes in the character at sp. */\n\tint\t ret;\t/* Number of bytes needed to format src. */\n\tint\t width;\t/* Display width of the character wc. */\n\tint\t total_width, max_width, print;\n\n\tsrc = NULL;\n\tif ((ret = vasprintf(&src, fmt, ap)) <= 0)\n\t\tgoto fail;\n\n\tsz = strlen(src) + 1;\n\tif ((dst = malloc(sz)) == NULL) {\n\t\tfree(src);\n\t\tret = -1;\n\t\tgoto fail;\n\t}\n\n\tif (maxsz > INT_MAX)\n\t\tmaxsz = INT_MAX;\n\n\tsp = src;\n\tdp = dst;\n\tret = 0;\n\tprint = 1;\n\ttotal_width = 0;\n\tmax_width = wp == NULL ? INT_MAX : *wp;\n\twhile (*sp != '\\0') {\n\t\tif ((len = mbtowc(&wc, sp, MB_CUR_MAX)) == -1) {\n\t\t\t(void)mbtowc(NULL, NULL, MB_CUR_MAX);\n\t\t\tif (dangerous_locale()) {\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = 1;\n\t\t\twidth = -1;\n\t\t} else if (wp == NULL &&\n\t\t    (wc == L'\\n' || wc == L'\\r' || wc == L'\\t')) {\n\t\t\t/*\n\t\t\t * Don't use width uninitialized; the actual\n\t\t\t * value doesn't matter because total_width\n\t\t\t * is only returned for wp != NULL.\n\t\t\t */\n\t\t\twidth = 0;\n\t\t} else if ((width = wcwidth(wc)) == -1 &&\n\t\t    dangerous_locale()) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Valid, printable character. */\n\n\t\tif (width >= 0) {\n\t\t\tif (print && (dp - dst >= (int)maxsz - len ||\n\t\t\t    total_width > max_width - width))\n\t\t\t\tprint = 0;\n\t\t\tif (print) {\n\t\t\t\tif (grow_dst(&dst, &sz, maxsz,\n\t\t\t\t    &dp, len) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttotal_width += width;\n\t\t\t\tmemcpy(dp, sp, len);\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tsp += len;\n\t\t\tif (ret >= 0)\n\t\t\t\tret += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Escaping required. */\n\n\t\twhile (len > 0) {\n\t\t\tif (print && (dp - dst >= (int)maxsz - 4 ||\n\t\t\t    total_width > max_width - 4))\n\t\t\t\tprint = 0;\n\t\t\tif (print) {\n\t\t\t\tif (grow_dst(&dst, &sz, maxsz,\n\t\t\t\t    &dp, 4) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttp = vis(dp, *sp, VIS_OCTAL | VIS_ALL, 0);\n\t\t\t\twidth = tp - dp;\n\t\t\t\ttotal_width += width;\n\t\t\t\tdp = tp;\n\t\t\t} else\n\t\t\t\twidth = 4;\n\t\t\tlen--;\n\t\t\tsp++;\n\t\t\tif (ret >= 0)\n\t\t\t\tret += width;\n\t\t}\n\t\tif (len > 0)\n\t\t\tbreak;\n\t}\n\tfree(src);\n\t*dp = '\\0';\n\t*str = dst;\n\tif (wp != NULL)\n\t\t*wp = total_width;\n\n\t/*\n\t * If the string was truncated by the width limit but\n\t * would have fit into the size limit, the only sane way\n\t * to report the problem is using the return value, such\n\t * that the usual idiom \"if (ret < 0 || ret >= sz) error\"\n\t * works as expected.\n\t */\n\n\tif (ret < (int)maxsz && !print)\n\t\tret = -1;\n\treturn ret;\n\nfail:\n\tif (wp != NULL)\n\t\t*wp = 0;\n\tif (ret == 0) {\n\t\t*str = src;\n\t\treturn 0;\n\t} else {\n\t\t*str = NULL;\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t dangerous_locale(void);",
            "static int\t grow_dst(char **, size_t *, size_t, char **, size_t);",
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t dangerous_locale(void);\nstatic int\t grow_dst(char **, size_t *, size_t, char **, size_t);\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nstatic int\nvasnmprintf(char **str, size_t maxsz, int *wp, const char *fmt, va_list ap)\n{\n\tchar\t*src;\t/* Source string returned from vasprintf. */\n\tchar\t*sp;\t/* Pointer into src. */\n\tchar\t*dst;\t/* Destination string to be returned. */\n\tchar\t*dp;\t/* Pointer into dst. */\n\tchar\t*tp;\t/* Temporary pointer for dst. */\n\tsize_t\t sz;\t/* Number of bytes allocated for dst. */\n\twchar_t\t wc;\t/* Wide character at sp. */\n\tint\t len;\t/* Number of bytes in the character at sp. */\n\tint\t ret;\t/* Number of bytes needed to format src. */\n\tint\t width;\t/* Display width of the character wc. */\n\tint\t total_width, max_width, print;\n\n\tsrc = NULL;\n\tif ((ret = vasprintf(&src, fmt, ap)) <= 0)\n\t\tgoto fail;\n\n\tsz = strlen(src) + 1;\n\tif ((dst = malloc(sz)) == NULL) {\n\t\tfree(src);\n\t\tret = -1;\n\t\tgoto fail;\n\t}\n\n\tif (maxsz > INT_MAX)\n\t\tmaxsz = INT_MAX;\n\n\tsp = src;\n\tdp = dst;\n\tret = 0;\n\tprint = 1;\n\ttotal_width = 0;\n\tmax_width = wp == NULL ? INT_MAX : *wp;\n\twhile (*sp != '\\0') {\n\t\tif ((len = mbtowc(&wc, sp, MB_CUR_MAX)) == -1) {\n\t\t\t(void)mbtowc(NULL, NULL, MB_CUR_MAX);\n\t\t\tif (dangerous_locale()) {\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = 1;\n\t\t\twidth = -1;\n\t\t} else if (wp == NULL &&\n\t\t    (wc == L'\\n' || wc == L'\\r' || wc == L'\\t')) {\n\t\t\t/*\n\t\t\t * Don't use width uninitialized; the actual\n\t\t\t * value doesn't matter because total_width\n\t\t\t * is only returned for wp != NULL.\n\t\t\t */\n\t\t\twidth = 0;\n\t\t} else if ((width = wcwidth(wc)) == -1 &&\n\t\t    dangerous_locale()) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Valid, printable character. */\n\n\t\tif (width >= 0) {\n\t\t\tif (print && (dp - dst >= (int)maxsz - len ||\n\t\t\t    total_width > max_width - width))\n\t\t\t\tprint = 0;\n\t\t\tif (print) {\n\t\t\t\tif (grow_dst(&dst, &sz, maxsz,\n\t\t\t\t    &dp, len) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttotal_width += width;\n\t\t\t\tmemcpy(dp, sp, len);\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tsp += len;\n\t\t\tif (ret >= 0)\n\t\t\t\tret += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Escaping required. */\n\n\t\twhile (len > 0) {\n\t\t\tif (print && (dp - dst >= (int)maxsz - 4 ||\n\t\t\t    total_width > max_width - 4))\n\t\t\t\tprint = 0;\n\t\t\tif (print) {\n\t\t\t\tif (grow_dst(&dst, &sz, maxsz,\n\t\t\t\t    &dp, 4) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttp = vis(dp, *sp, VIS_OCTAL | VIS_ALL, 0);\n\t\t\t\twidth = tp - dp;\n\t\t\t\ttotal_width += width;\n\t\t\t\tdp = tp;\n\t\t\t} else\n\t\t\t\twidth = 4;\n\t\t\tlen--;\n\t\t\tsp++;\n\t\t\tif (ret >= 0)\n\t\t\t\tret += width;\n\t\t}\n\t\tif (len > 0)\n\t\t\tbreak;\n\t}\n\tfree(src);\n\t*dp = '\\0';\n\t*str = dst;\n\tif (wp != NULL)\n\t\t*wp = total_width;\n\n\t/*\n\t * If the string was truncated by the width limit but\n\t * would have fit into the size limit, the only sane way\n\t * to report the problem is using the return value, such\n\t * that the usual idiom \"if (ret < 0 || ret >= sz) error\"\n\t * works as expected.\n\t */\n\n\tif (ret < (int)maxsz && !print)\n\t\tret = -1;\n\treturn ret;\n\nfail:\n\tif (wp != NULL)\n\t\t*wp = 0;\n\tif (ret == 0) {\n\t\t*str = src;\n\t\treturn 0;\n\t} else {\n\t\t*str = NULL;\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t grow_dst(char **, size_t *, size_t, char **, size_t);\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nsnmprintf(char *str, size_t sz, int *wp, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tchar\t*cp;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vasnmprintf(&cp, sz, wp, fmt, ap);\n\tva_end(ap);\n\tif (cp != NULL) {\n\t\t(void)strlcpy(str, cp, sz);\n\t\tfree(cp);\n\t} else\n\t\t*str = '\\0';\n\treturn ret;\n}"
  },
  {
    "function_name": "vasnmprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
    "lines": "104-238",
    "snippet": "static int\nvasnmprintf(char **str, size_t maxsz, int *wp, const char *fmt, va_list ap)\n{\n\tchar\t*src;\t/* Source string returned from vasprintf. */\n\tchar\t*sp;\t/* Pointer into src. */\n\tchar\t*dst;\t/* Destination string to be returned. */\n\tchar\t*dp;\t/* Pointer into dst. */\n\tchar\t*tp;\t/* Temporary pointer for dst. */\n\tsize_t\t sz;\t/* Number of bytes allocated for dst. */\n\twchar_t\t wc;\t/* Wide character at sp. */\n\tint\t len;\t/* Number of bytes in the character at sp. */\n\tint\t ret;\t/* Number of bytes needed to format src. */\n\tint\t width;\t/* Display width of the character wc. */\n\tint\t total_width, max_width, print;\n\n\tsrc = NULL;\n\tif ((ret = vasprintf(&src, fmt, ap)) <= 0)\n\t\tgoto fail;\n\n\tsz = strlen(src) + 1;\n\tif ((dst = malloc(sz)) == NULL) {\n\t\tfree(src);\n\t\tret = -1;\n\t\tgoto fail;\n\t}\n\n\tif (maxsz > INT_MAX)\n\t\tmaxsz = INT_MAX;\n\n\tsp = src;\n\tdp = dst;\n\tret = 0;\n\tprint = 1;\n\ttotal_width = 0;\n\tmax_width = wp == NULL ? INT_MAX : *wp;\n\twhile (*sp != '\\0') {\n\t\tif ((len = mbtowc(&wc, sp, MB_CUR_MAX)) == -1) {\n\t\t\t(void)mbtowc(NULL, NULL, MB_CUR_MAX);\n\t\t\tif (dangerous_locale()) {\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = 1;\n\t\t\twidth = -1;\n\t\t} else if (wp == NULL &&\n\t\t    (wc == L'\\n' || wc == L'\\r' || wc == L'\\t')) {\n\t\t\t/*\n\t\t\t * Don't use width uninitialized; the actual\n\t\t\t * value doesn't matter because total_width\n\t\t\t * is only returned for wp != NULL.\n\t\t\t */\n\t\t\twidth = 0;\n\t\t} else if ((width = wcwidth(wc)) == -1 &&\n\t\t    dangerous_locale()) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Valid, printable character. */\n\n\t\tif (width >= 0) {\n\t\t\tif (print && (dp - dst >= (int)maxsz - len ||\n\t\t\t    total_width > max_width - width))\n\t\t\t\tprint = 0;\n\t\t\tif (print) {\n\t\t\t\tif (grow_dst(&dst, &sz, maxsz,\n\t\t\t\t    &dp, len) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttotal_width += width;\n\t\t\t\tmemcpy(dp, sp, len);\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tsp += len;\n\t\t\tif (ret >= 0)\n\t\t\t\tret += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Escaping required. */\n\n\t\twhile (len > 0) {\n\t\t\tif (print && (dp - dst >= (int)maxsz - 4 ||\n\t\t\t    total_width > max_width - 4))\n\t\t\t\tprint = 0;\n\t\t\tif (print) {\n\t\t\t\tif (grow_dst(&dst, &sz, maxsz,\n\t\t\t\t    &dp, 4) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttp = vis(dp, *sp, VIS_OCTAL | VIS_ALL, 0);\n\t\t\t\twidth = tp - dp;\n\t\t\t\ttotal_width += width;\n\t\t\t\tdp = tp;\n\t\t\t} else\n\t\t\t\twidth = 4;\n\t\t\tlen--;\n\t\t\tsp++;\n\t\t\tif (ret >= 0)\n\t\t\t\tret += width;\n\t\t}\n\t\tif (len > 0)\n\t\t\tbreak;\n\t}\n\tfree(src);\n\t*dp = '\\0';\n\t*str = dst;\n\tif (wp != NULL)\n\t\t*wp = total_width;\n\n\t/*\n\t * If the string was truncated by the width limit but\n\t * would have fit into the size limit, the only sane way\n\t * to report the problem is using the return value, such\n\t * that the usual idiom \"if (ret < 0 || ret >= sz) error\"\n\t * works as expected.\n\t */\n\n\tif (ret < (int)maxsz && !print)\n\t\tret = -1;\n\treturn ret;\n\nfail:\n\tif (wp != NULL)\n\t\t*wp = 0;\n\tif (ret == 0) {\n\t\t*str = src;\n\t\treturn 0;\n\t} else {\n\t\t*str = NULL;\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include \"utf8.h\"",
      "# include <wchar.h>",
      "# include <vis.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "# include <langinfo.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t dangerous_locale(void);",
      "static int\t grow_dst(char **, size_t *, size_t, char **, size_t);",
      "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "src"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vis",
          "args": [
            "dp",
            "*sp",
            "VIS_OCTAL | VIS_ALL",
            "0"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "strvisx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/vis.c",
          "lines": "235-249",
          "snippet": "int\nstrvisx(char *dst, const char *src, size_t len, int flag)\n{\n\tchar c;\n\tchar *start;\n\n\tfor (start = dst; len > 1; len--) {\n\t\tc = *src;\n\t\tdst = vis(dst, c, flag, *++src);\n\t}\n\tif (len)\n\t\tdst = vis(dst, *src, flag, '\\0');\n\t*dst = '\\0';\n\treturn (dst - start);\n}",
          "includes": [
            "#include \"vis.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vis.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nstrvisx(char *dst, const char *src, size_t len, int flag)\n{\n\tchar c;\n\tchar *start;\n\n\tfor (start = dst; len > 1; len--) {\n\t\tc = *src;\n\t\tdst = vis(dst, c, flag, *++src);\n\t}\n\tif (len)\n\t\tdst = vis(dst, *src, flag, '\\0');\n\t*dst = '\\0';\n\treturn (dst - start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grow_dst",
          "args": [
            "&dst",
            "&sz",
            "maxsz",
            "&dp",
            "4"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "grow_dst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "73-90",
          "snippet": "static int\ngrow_dst(char **dst, size_t *sz, size_t maxsz, char **dp, size_t need)\n{\n\tchar\t*tp;\n\tsize_t\t tsz;\n\n\tif (*dp + need < *dst + *sz)\n\t\treturn 0;\n\ttsz = *sz + 128;\n\tif (tsz > maxsz)\n\t\ttsz = maxsz;\n\tif ((tp = recallocarray(*dst, *sz, tsz, 1)) == NULL)\n\t\treturn -1;\n\t*dp = tp + (*dp - *dst);\n\t*dst = tp;\n\t*sz = tsz;\n\treturn 0;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t grow_dst(char **, size_t *, size_t, char **, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t grow_dst(char **, size_t *, size_t, char **, size_t);\n\nstatic int\ngrow_dst(char **dst, size_t *sz, size_t maxsz, char **dp, size_t need)\n{\n\tchar\t*tp;\n\tsize_t\t tsz;\n\n\tif (*dp + need < *dst + *sz)\n\t\treturn 0;\n\ttsz = *sz + 128;\n\tif (tsz > maxsz)\n\t\ttsz = maxsz;\n\tif ((tp = recallocarray(*dst, *sz, tsz, 1)) == NULL)\n\t\treturn -1;\n\t*dp = tp + (*dp - *dst);\n\t*dst = tp;\n\t*sz = tsz;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dp",
            "sp",
            "len"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dangerous_locale",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "dangerous_locale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "60-71",
          "snippet": "static int\ndangerous_locale(void) {\n\tchar\t*loc;\n\n\tloc = nl_langinfo(CODESET);\n\treturn strcmp(loc, \"UTF-8\") != 0 &&\n\t    strcmp(loc, \"US-ASCII\") != 0 &&\t\t/* OpenBSD */\n\t    strcmp(loc, \"ANSI_X3.4-1968\") != 0 &&\t/* Linux */\n\t    strcmp(loc, \"ISO8859-1\") != 0 &&\t\t/* AIX */\n\t    strcmp(loc, \"646\") != 0 &&\t\t\t/* Solaris, NetBSD */\n\t    strcmp(loc, \"\") != 0;\t\t\t/* Solaris 6 */\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t dangerous_locale(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t dangerous_locale(void);\n\nstatic int\ndangerous_locale(void) {\n\tchar\t*loc;\n\n\tloc = nl_langinfo(CODESET);\n\treturn strcmp(loc, \"UTF-8\") != 0 &&\n\t    strcmp(loc, \"US-ASCII\") != 0 &&\t\t/* OpenBSD */\n\t    strcmp(loc, \"ANSI_X3.4-1968\") != 0 &&\t/* Linux */\n\t    strcmp(loc, \"ISO8859-1\") != 0 &&\t\t/* AIX */\n\t    strcmp(loc, \"646\") != 0 &&\t\t\t/* Solaris, NetBSD */\n\t    strcmp(loc, \"\") != 0;\t\t\t/* Solaris 6 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "wcwidth",
          "args": [
            "wc"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mbtowc",
          "args": [
            "NULL",
            "NULL",
            "MB_CUR_MAX"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "mbtowc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "264-276",
          "snippet": "int\nmbtowc(wchar_t *pwc, const char *s, size_t n)\n{\n\tif (s == NULL || *s == '\\0')\n\t\treturn 0;\t/* ASCII is not state-dependent */\n\tif (*s < 0 || *s > 0x7f || n < 1) {\n\t\terrno = EOPNOTSUPP;\n\t\treturn -1;\n\t}\n\tif (pwc != NULL)\n\t\t*pwc = *s;\n\treturn 1;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmbtowc(wchar_t *pwc, const char *s, size_t n)\n{\n\tif (s == NULL || *s == '\\0')\n\t\treturn 0;\t/* ASCII is not state-dependent */\n\tif (*s < 0 || *s > 0x7f || n < 1) {\n\t\terrno = EOPNOTSUPP;\n\t\treturn -1;\n\t}\n\tif (pwc != NULL)\n\t\t*pwc = *s;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sz"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "src"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vasprintf",
          "args": [
            "&src",
            "fmt",
            "ap"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "vasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-asprintf.c",
          "lines": "39-82",
          "snippet": "int\nvasprintf(char **str, const char *fmt, va_list ap)\n{\n\tint ret = -1;\n\tva_list ap2;\n\tchar *string, *newstr;\n\tsize_t len;\n\n\tVA_COPY(ap2, ap);\n\tif ((string = malloc(INIT_SZ)) == NULL)\n\t\tgoto fail;\n\n\tret = vsnprintf(string, INIT_SZ, fmt, ap2);\n\tif (ret >= 0 && ret < INIT_SZ) { /* succeeded with initial alloc */\n\t\t*str = string;\n\t} else if (ret == INT_MAX || ret < 0) { /* Bad length */\n\t\tfree(string);\n\t\tgoto fail;\n\t} else {\t/* bigger than initial, realloc allowing for nul */\n\t\tlen = (size_t)ret + 1;\n\t\tif ((newstr = realloc(string, len)) == NULL) {\n\t\t\tfree(string);\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tva_end(ap2);\n\t\t\tVA_COPY(ap2, ap);\n\t\t\tret = vsnprintf(newstr, len, fmt, ap2);\n\t\t\tif (ret >= 0 && (size_t)ret < len) {\n\t\t\t\t*str = newstr;\n\t\t\t} else { /* failed with realloc'ed string, give up */\n\t\t\t\tfree(newstr);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\tva_end(ap2);\n\treturn (ret);\n\nfail:\n\t*str = NULL;\n\terrno = ENOMEM;\n\tva_end(ap2);\n\treturn (-1);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define INIT_SZ\t128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define INIT_SZ\t128\n\nint\nvasprintf(char **str, const char *fmt, va_list ap)\n{\n\tint ret = -1;\n\tva_list ap2;\n\tchar *string, *newstr;\n\tsize_t len;\n\n\tVA_COPY(ap2, ap);\n\tif ((string = malloc(INIT_SZ)) == NULL)\n\t\tgoto fail;\n\n\tret = vsnprintf(string, INIT_SZ, fmt, ap2);\n\tif (ret >= 0 && ret < INIT_SZ) { /* succeeded with initial alloc */\n\t\t*str = string;\n\t} else if (ret == INT_MAX || ret < 0) { /* Bad length */\n\t\tfree(string);\n\t\tgoto fail;\n\t} else {\t/* bigger than initial, realloc allowing for nul */\n\t\tlen = (size_t)ret + 1;\n\t\tif ((newstr = realloc(string, len)) == NULL) {\n\t\t\tfree(string);\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tva_end(ap2);\n\t\t\tVA_COPY(ap2, ap);\n\t\t\tret = vsnprintf(newstr, len, fmt, ap2);\n\t\t\tif (ret >= 0 && (size_t)ret < len) {\n\t\t\t\t*str = newstr;\n\t\t\t} else { /* failed with realloc'ed string, give up */\n\t\t\t\tfree(newstr);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\tva_end(ap2);\n\treturn (ret);\n\nfail:\n\t*str = NULL;\n\terrno = ENOMEM;\n\tva_end(ap2);\n\treturn (-1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t dangerous_locale(void);\nstatic int\t grow_dst(char **, size_t *, size_t, char **, size_t);\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nstatic int\nvasnmprintf(char **str, size_t maxsz, int *wp, const char *fmt, va_list ap)\n{\n\tchar\t*src;\t/* Source string returned from vasprintf. */\n\tchar\t*sp;\t/* Pointer into src. */\n\tchar\t*dst;\t/* Destination string to be returned. */\n\tchar\t*dp;\t/* Pointer into dst. */\n\tchar\t*tp;\t/* Temporary pointer for dst. */\n\tsize_t\t sz;\t/* Number of bytes allocated for dst. */\n\twchar_t\t wc;\t/* Wide character at sp. */\n\tint\t len;\t/* Number of bytes in the character at sp. */\n\tint\t ret;\t/* Number of bytes needed to format src. */\n\tint\t width;\t/* Display width of the character wc. */\n\tint\t total_width, max_width, print;\n\n\tsrc = NULL;\n\tif ((ret = vasprintf(&src, fmt, ap)) <= 0)\n\t\tgoto fail;\n\n\tsz = strlen(src) + 1;\n\tif ((dst = malloc(sz)) == NULL) {\n\t\tfree(src);\n\t\tret = -1;\n\t\tgoto fail;\n\t}\n\n\tif (maxsz > INT_MAX)\n\t\tmaxsz = INT_MAX;\n\n\tsp = src;\n\tdp = dst;\n\tret = 0;\n\tprint = 1;\n\ttotal_width = 0;\n\tmax_width = wp == NULL ? INT_MAX : *wp;\n\twhile (*sp != '\\0') {\n\t\tif ((len = mbtowc(&wc, sp, MB_CUR_MAX)) == -1) {\n\t\t\t(void)mbtowc(NULL, NULL, MB_CUR_MAX);\n\t\t\tif (dangerous_locale()) {\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = 1;\n\t\t\twidth = -1;\n\t\t} else if (wp == NULL &&\n\t\t    (wc == L'\\n' || wc == L'\\r' || wc == L'\\t')) {\n\t\t\t/*\n\t\t\t * Don't use width uninitialized; the actual\n\t\t\t * value doesn't matter because total_width\n\t\t\t * is only returned for wp != NULL.\n\t\t\t */\n\t\t\twidth = 0;\n\t\t} else if ((width = wcwidth(wc)) == -1 &&\n\t\t    dangerous_locale()) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Valid, printable character. */\n\n\t\tif (width >= 0) {\n\t\t\tif (print && (dp - dst >= (int)maxsz - len ||\n\t\t\t    total_width > max_width - width))\n\t\t\t\tprint = 0;\n\t\t\tif (print) {\n\t\t\t\tif (grow_dst(&dst, &sz, maxsz,\n\t\t\t\t    &dp, len) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttotal_width += width;\n\t\t\t\tmemcpy(dp, sp, len);\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tsp += len;\n\t\t\tif (ret >= 0)\n\t\t\t\tret += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Escaping required. */\n\n\t\twhile (len > 0) {\n\t\t\tif (print && (dp - dst >= (int)maxsz - 4 ||\n\t\t\t    total_width > max_width - 4))\n\t\t\t\tprint = 0;\n\t\t\tif (print) {\n\t\t\t\tif (grow_dst(&dst, &sz, maxsz,\n\t\t\t\t    &dp, 4) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttp = vis(dp, *sp, VIS_OCTAL | VIS_ALL, 0);\n\t\t\t\twidth = tp - dp;\n\t\t\t\ttotal_width += width;\n\t\t\t\tdp = tp;\n\t\t\t} else\n\t\t\t\twidth = 4;\n\t\t\tlen--;\n\t\t\tsp++;\n\t\t\tif (ret >= 0)\n\t\t\t\tret += width;\n\t\t}\n\t\tif (len > 0)\n\t\t\tbreak;\n\t}\n\tfree(src);\n\t*dp = '\\0';\n\t*str = dst;\n\tif (wp != NULL)\n\t\t*wp = total_width;\n\n\t/*\n\t * If the string was truncated by the width limit but\n\t * would have fit into the size limit, the only sane way\n\t * to report the problem is using the return value, such\n\t * that the usual idiom \"if (ret < 0 || ret >= sz) error\"\n\t * works as expected.\n\t */\n\n\tif (ret < (int)maxsz && !print)\n\t\tret = -1;\n\treturn ret;\n\nfail:\n\tif (wp != NULL)\n\t\t*wp = 0;\n\tif (ret == 0) {\n\t\t*str = src;\n\t\treturn 0;\n\t} else {\n\t\t*str = NULL;\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "grow_dst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
    "lines": "73-90",
    "snippet": "static int\ngrow_dst(char **dst, size_t *sz, size_t maxsz, char **dp, size_t need)\n{\n\tchar\t*tp;\n\tsize_t\t tsz;\n\n\tif (*dp + need < *dst + *sz)\n\t\treturn 0;\n\ttsz = *sz + 128;\n\tif (tsz > maxsz)\n\t\ttsz = maxsz;\n\tif ((tp = recallocarray(*dst, *sz, tsz, 1)) == NULL)\n\t\treturn -1;\n\t*dp = tp + (*dp - *dst);\n\t*dst = tp;\n\t*sz = tsz;\n\treturn 0;\n}",
    "includes": [
      "#include \"utf8.h\"",
      "# include <wchar.h>",
      "# include <vis.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "# include <langinfo.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t grow_dst(char **, size_t *, size_t, char **, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "recallocarray",
          "args": [
            "*dst",
            "*sz",
            "tsz",
            "1"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t grow_dst(char **, size_t *, size_t, char **, size_t);\n\nstatic int\ngrow_dst(char **dst, size_t *sz, size_t maxsz, char **dp, size_t need)\n{\n\tchar\t*tp;\n\tsize_t\t tsz;\n\n\tif (*dp + need < *dst + *sz)\n\t\treturn 0;\n\ttsz = *sz + 128;\n\tif (tsz > maxsz)\n\t\ttsz = maxsz;\n\tif ((tp = recallocarray(*dst, *sz, tsz, 1)) == NULL)\n\t\treturn -1;\n\t*dp = tp + (*dp - *dst);\n\t*dst = tp;\n\t*sz = tsz;\n\treturn 0;\n}"
  },
  {
    "function_name": "dangerous_locale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
    "lines": "60-71",
    "snippet": "static int\ndangerous_locale(void) {\n\tchar\t*loc;\n\n\tloc = nl_langinfo(CODESET);\n\treturn strcmp(loc, \"UTF-8\") != 0 &&\n\t    strcmp(loc, \"US-ASCII\") != 0 &&\t\t/* OpenBSD */\n\t    strcmp(loc, \"ANSI_X3.4-1968\") != 0 &&\t/* Linux */\n\t    strcmp(loc, \"ISO8859-1\") != 0 &&\t\t/* AIX */\n\t    strcmp(loc, \"646\") != 0 &&\t\t\t/* Solaris, NetBSD */\n\t    strcmp(loc, \"\") != 0;\t\t\t/* Solaris 6 */\n}",
    "includes": [
      "#include \"utf8.h\"",
      "# include <wchar.h>",
      "# include <vis.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "# include <langinfo.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t dangerous_locale(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "loc",
            "\"\""
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nl_langinfo",
          "args": [
            "CODESET"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t dangerous_locale(void);\n\nstatic int\ndangerous_locale(void) {\n\tchar\t*loc;\n\n\tloc = nl_langinfo(CODESET);\n\treturn strcmp(loc, \"UTF-8\") != 0 &&\n\t    strcmp(loc, \"US-ASCII\") != 0 &&\t\t/* OpenBSD */\n\t    strcmp(loc, \"ANSI_X3.4-1968\") != 0 &&\t/* Linux */\n\t    strcmp(loc, \"ISO8859-1\") != 0 &&\t\t/* AIX */\n\t    strcmp(loc, \"646\") != 0 &&\t\t\t/* Solaris, NetBSD */\n\t    strcmp(loc, \"\") != 0;\t\t\t/* Solaris 6 */\n}"
  }
]