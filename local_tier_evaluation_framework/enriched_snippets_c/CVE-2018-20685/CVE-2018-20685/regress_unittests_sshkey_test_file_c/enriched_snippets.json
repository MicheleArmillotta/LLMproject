[
  {
    "function_name": "sshkey_file_tests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_file.c",
    "lines": "42-421",
    "snippet": "void\nsshkey_file_tests(void)\n{\n\tstruct sshkey *k1, *k2;\n\tstruct sshbuf *buf, *pw;\n\tBIGNUM *a, *b, *c;\n\tchar *cp;\n\n\tTEST_START(\"load passphrase\");\n\tpw = load_text_file(\"pw\");\n\tTEST_DONE();\n\n\n\tTEST_START(\"parse RSA from private\");\n\tbuf = load_file(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k1, NULL);\n\ta = load_bignum(\"rsa_1.param.n\");\n\tb = load_bignum(\"rsa_1.param.p\");\n\tc = load_bignum(\"rsa_1.param.q\");\n\tASSERT_BIGNUM_EQ(rsa_n(k1), a);\n\tASSERT_BIGNUM_EQ(rsa_p(k1), b);\n\tASSERT_BIGNUM_EQ(rsa_q(k1), c);\n\tBN_free(a);\n\tBN_free(b);\n\tBN_free(c);\n\tTEST_DONE();\n\n\tTEST_START(\"parse RSA from private w/ passphrase\");\n\tbuf = load_file(\"rsa_1_pw\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"parse RSA from new-format\");\n\tbuf = load_file(\"rsa_n\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"parse RSA from new-format w/ passphrase\");\n\tbuf = load_file(\"rsa_n_pw\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load RSA from public\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"rsa_1.pub\"), &k2,\n\t    NULL), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load RSA cert with SHA1 signature\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"rsa_1_sha1\"), &k2), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(k2->type, KEY_RSA_CERT);\n\tASSERT_INT_EQ(sshkey_equal_public(k1, k2), 1);\n\tASSERT_STRING_EQ(k2->cert->signature_type, \"ssh-rsa\");\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load RSA cert with SHA512 signature\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"rsa_1_sha512\"), &k2), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(k2->type, KEY_RSA_CERT);\n\tASSERT_INT_EQ(sshkey_equal_public(k1, k2), 1);\n\tASSERT_STRING_EQ(k2->cert->signature_type, \"rsa-sha2-512\");\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load RSA cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"rsa_1\"), &k2), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(k2->type, KEY_RSA_CERT);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 0);\n\tASSERT_INT_EQ(sshkey_equal_public(k1, k2), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"RSA key hex fingerprint\");\n\tbuf = load_text_file(\"rsa_1.fp\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tTEST_START(\"RSA cert hex fingerprint\");\n\tbuf = load_text_file(\"rsa_1-cert.fp\");\n\tcp = sshkey_fingerprint(k2, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"RSA key bubblebabble fingerprint\");\n\tbuf = load_text_file(\"rsa_1.fp.bb\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA1, SSH_FP_BUBBLEBABBLE);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tsshkey_free(k1);\n\n\tTEST_START(\"parse DSA from private\");\n\tbuf = load_file(\"dsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k1, NULL);\n\ta = load_bignum(\"dsa_1.param.g\");\n\tb = load_bignum(\"dsa_1.param.priv\");\n\tc = load_bignum(\"dsa_1.param.pub\");\n\tASSERT_BIGNUM_EQ(dsa_g(k1), a);\n\tASSERT_BIGNUM_EQ(dsa_priv_key(k1), b);\n\tASSERT_BIGNUM_EQ(dsa_pub_key(k1), c);\n\tBN_free(a);\n\tBN_free(b);\n\tBN_free(c);\n\tTEST_DONE();\n\n\tTEST_START(\"parse DSA from private w/ passphrase\");\n\tbuf = load_file(\"dsa_1_pw\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"parse DSA from new-format\");\n\tbuf = load_file(\"dsa_n\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"parse DSA from new-format w/ passphrase\");\n\tbuf = load_file(\"dsa_n_pw\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load DSA from public\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"dsa_1.pub\"), &k2,\n\t    NULL), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load DSA cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"dsa_1\"), &k2), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(k2->type, KEY_DSA_CERT);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 0);\n\tASSERT_INT_EQ(sshkey_equal_public(k1, k2), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"DSA key hex fingerprint\");\n\tbuf = load_text_file(\"dsa_1.fp\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tTEST_START(\"DSA cert hex fingerprint\");\n\tbuf = load_text_file(\"dsa_1-cert.fp\");\n\tcp = sshkey_fingerprint(k2, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"DSA key bubblebabble fingerprint\");\n\tbuf = load_text_file(\"dsa_1.fp.bb\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA1, SSH_FP_BUBBLEBABBLE);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tsshkey_free(k1);\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"parse ECDSA from private\");\n\tbuf = load_file(\"ecdsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k1, NULL);\n\tbuf = load_text_file(\"ecdsa_1.param.curve\");\n\tASSERT_STRING_EQ((const char *)sshbuf_ptr(buf),\n\t    OBJ_nid2sn(k1->ecdsa_nid));\n\tsshbuf_free(buf);\n\ta = load_bignum(\"ecdsa_1.param.priv\");\n\tb = load_bignum(\"ecdsa_1.param.pub\");\n\tc = EC_POINT_point2bn(EC_KEY_get0_group(k1->ecdsa),\n\t    EC_KEY_get0_public_key(k1->ecdsa), POINT_CONVERSION_UNCOMPRESSED,\n\t    NULL, NULL);\n\tASSERT_PTR_NE(c, NULL);\n\tASSERT_BIGNUM_EQ(EC_KEY_get0_private_key(k1->ecdsa), a);\n\tASSERT_BIGNUM_EQ(b, c);\n\tBN_free(a);\n\tBN_free(b);\n\tBN_free(c);\n\tTEST_DONE();\n\n\tTEST_START(\"parse ECDSA from private w/ passphrase\");\n\tbuf = load_file(\"ecdsa_1_pw\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"parse ECDSA from new-format\");\n\tbuf = load_file(\"ecdsa_n\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"parse ECDSA from new-format w/ passphrase\");\n\tbuf = load_file(\"ecdsa_n_pw\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load ECDSA from public\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"ecdsa_1.pub\"), &k2,\n\t    NULL), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load ECDSA cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"ecdsa_1\"), &k2), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(k2->type, KEY_ECDSA_CERT);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 0);\n\tASSERT_INT_EQ(sshkey_equal_public(k1, k2), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"ECDSA key hex fingerprint\");\n\tbuf = load_text_file(\"ecdsa_1.fp\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tTEST_START(\"ECDSA cert hex fingerprint\");\n\tbuf = load_text_file(\"ecdsa_1-cert.fp\");\n\tcp = sshkey_fingerprint(k2, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"ECDSA key bubblebabble fingerprint\");\n\tbuf = load_text_file(\"ecdsa_1.fp.bb\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA1, SSH_FP_BUBBLEBABBLE);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tsshkey_free(k1);\n#endif /* OPENSSL_HAS_ECC */\n\n\tTEST_START(\"parse Ed25519 from private\");\n\tbuf = load_file(\"ed25519_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_INT_EQ(k1->type, KEY_ED25519);\n\t/* XXX check key contents */\n\tTEST_DONE();\n\n\tTEST_START(\"parse Ed25519 from private w/ passphrase\");\n\tbuf = load_file(\"ed25519_1_pw\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load Ed25519 from public\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"ed25519_1.pub\"), &k2,\n\t    NULL), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load Ed25519 cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"ed25519_1\"), &k2), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(k2->type, KEY_ED25519_CERT);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 0);\n\tASSERT_INT_EQ(sshkey_equal_public(k1, k2), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"Ed25519 key hex fingerprint\");\n\tbuf = load_text_file(\"ed25519_1.fp\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tTEST_START(\"Ed25519 cert hex fingerprint\");\n\tbuf = load_text_file(\"ed25519_1-cert.fp\");\n\tcp = sshkey_fingerprint(k2, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"Ed25519 key bubblebabble fingerprint\");\n\tbuf = load_text_file(\"ed25519_1.fp.bb\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA1, SSH_FP_BUBBLEBABBLE);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tsshkey_free(k1);\n\n\tsshbuf_free(pw);\n\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"digest.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/objects.h>",
      "#include <openssl/dsa.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/bn.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sshkey_file_tests(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "pw"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "k1"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cp"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "cp",
            "(const char *)sshbuf_ptr(buf)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "buf"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "cp",
            "NULL"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "k1",
            "SSH_DIGEST_SHA1",
            "SSH_FP_BUBBLEBABBLE"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_text_file",
          "args": [
            "\"ed25519_1.fp.bb\""
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "load_text_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "54-73",
          "snippet": "struct sshbuf *\nload_text_file(const char *name)\n{\n\tstruct sshbuf *ret = load_file(name);\n\tconst u_char *p;\n\n\t/* Trim whitespace at EOL */\n\tfor (p = sshbuf_ptr(ret); sshbuf_len(ret) > 0;) {\n\t\tif (p[sshbuf_len(ret) - 1] == '\\r' ||\n\t\t    p[sshbuf_len(ret) - 1] == '\\t' ||\n\t\t    p[sshbuf_len(ret) - 1] == ' ' ||\n\t\t    p[sshbuf_len(ret) - 1] == '\\n')\n\t\t\tASSERT_INT_EQ(sshbuf_consume_end(ret, 1), 0);\n\t\telse\n\t\t\tbreak;\n\t}\n\t/* \\0 terminate */\n\tASSERT_INT_EQ(sshbuf_put_u8(ret, 0), 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nload_text_file(const char *name)\n{\n\tstruct sshbuf *ret = load_file(name);\n\tconst u_char *p;\n\n\t/* Trim whitespace at EOL */\n\tfor (p = sshbuf_ptr(ret); sshbuf_len(ret) > 0;) {\n\t\tif (p[sshbuf_len(ret) - 1] == '\\r' ||\n\t\t    p[sshbuf_len(ret) - 1] == '\\t' ||\n\t\t    p[sshbuf_len(ret) - 1] == ' ' ||\n\t\t    p[sshbuf_len(ret) - 1] == '\\n')\n\t\t\tASSERT_INT_EQ(sshbuf_consume_end(ret, 1), 0);\n\t\telse\n\t\t\tbreak;\n\t}\n\t/* \\0 terminate */\n\tASSERT_INT_EQ(sshbuf_put_u8(ret, 0), 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"Ed25519 key bubblebabble fingerprint\""
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "cp",
            "(const char *)sshbuf_ptr(buf)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "cp",
            "NULL"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"Ed25519 cert hex fingerprint\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "cp",
            "(const char *)sshbuf_ptr(buf)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "cp",
            "NULL"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"Ed25519 key hex fingerprint\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal_public(k1, k2)",
            "1"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_equal_public",
          "args": [
            "k1",
            "k2"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "627-702",
          "snippet": "int\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "0"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "k1",
            "k2"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "k2->type",
            "KEY_ED25519_CERT"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_cert(test_data_file(\"ed25519_1\"), &k2)",
            "0"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_load_cert",
          "args": [
            "test_data_file(\"ed25519_1\")",
            "&k2"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "357-385",
          "snippet": "int\nsshkey_load_cert(const char *filename, struct sshkey **keyp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif (asprintf(&file, \"%s-cert.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (keyp != NULL) {\n\t\t*keyp = pub;\n\t\tpub = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_cert(const char *filename, struct sshkey **keyp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif (asprintf(&file, \"%s-cert.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (keyp != NULL) {\n\t\t*keyp = pub;\n\t\tpub = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_data_file",
          "args": [
            "\"ed25519_1\""
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/test_helper.c",
          "lines": "181-196",
          "snippet": "const char *\ntest_data_file(const char *name)\n{\n\tstatic char ret[PATH_MAX];\n\n\tif (data_dir != NULL)\n\t\tsnprintf(ret, sizeof(ret), \"%s/%s\", data_dir, name);\n\telse\n\t\tstrlcpy(ret, name, sizeof(ret));\n\tif (access(ret, F_OK) != 0) {\n\t\tfprintf(stderr, \"Cannot access data file %s: %s\\n\",\n\t\t    ret, strerror(errno));\n\t\texit(1);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "# include <vis.h>",
            "#include <openssl/bn.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *data_dir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n# include <vis.h>\n#include <openssl/bn.h>\n#include <signal.h>\n#include <unistd.h>\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *data_dir = NULL;\n\nconst char *\ntest_data_file(const char *name)\n{\n\tstatic char ret[PATH_MAX];\n\n\tif (data_dir != NULL)\n\t\tsnprintf(ret, sizeof(ret), \"%s/%s\", data_dir, name);\n\telse\n\t\tstrlcpy(ret, name, sizeof(ret));\n\tif (access(ret, F_OK) != 0) {\n\t\tfprintf(stderr, \"Cannot access data file %s: %s\\n\",\n\t\t    ret, strerror(errno));\n\t\texit(1);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"load Ed25519 cert\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "1"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_public(test_data_file(\"ed25519_1.pub\"), &k2,\n\t    NULL)",
            "0"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_load_public",
          "args": [
            "test_data_file(\"ed25519_1.pub\")",
            "&k2",
            "NULL"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "312-354",
          "snippet": "int\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"load Ed25519 from public\""
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "1"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL)",
            "0"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_parse_private_fileblob",
          "args": [
            "buf",
            "(const char *)sshbuf_ptr(pw)",
            "&k2",
            "NULL"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_parse_private_fileblob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "4067-4078",
          "snippet": "int\nsshkey_parse_private_fileblob(struct sshbuf *buffer, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\treturn sshkey_parse_private_fileblob_type(buffer, KEY_UNSPEC,\n\t    passphrase, keyp, commentp);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_parse_private_fileblob(struct sshbuf *buffer, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\treturn sshkey_parse_private_fileblob_type(buffer, KEY_UNSPEC,\n\t    passphrase, keyp, commentp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_file",
          "args": [
            "\"ed25519_1_pw\""
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "load_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "41-52",
          "snippet": "struct sshbuf *\nload_file(const char *name)\n{\n\tint fd;\n\tstruct sshbuf *ret;\n\n\tASSERT_PTR_NE(ret = sshbuf_new(), NULL);\n\tASSERT_INT_NE(fd = open(test_data_file(name), O_RDONLY), -1);\n\tASSERT_INT_EQ(sshkey_load_file(fd, ret), 0);\n\tclose(fd);\n\treturn ret;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nload_file(const char *name)\n{\n\tint fd;\n\tstruct sshbuf *ret;\n\n\tASSERT_PTR_NE(ret = sshbuf_new(), NULL);\n\tASSERT_INT_NE(fd = open(test_data_file(name), O_RDONLY), -1);\n\tASSERT_INT_EQ(sshkey_load_file(fd, ret), 0);\n\tclose(fd);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"parse Ed25519 from private w/ passphrase\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "k1->type",
            "KEY_ED25519"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"parse Ed25519 from private\""
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "cp",
            "(const char *)sshbuf_ptr(buf)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "cp",
            "NULL"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"ECDSA key bubblebabble fingerprint\""
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "cp",
            "(const char *)sshbuf_ptr(buf)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "cp",
            "NULL"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"ECDSA cert hex fingerprint\""
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "cp",
            "(const char *)sshbuf_ptr(buf)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "cp",
            "NULL"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"ECDSA key hex fingerprint\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal_public(k1, k2)",
            "1"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "0"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "k2->type",
            "KEY_ECDSA_CERT"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_cert(test_data_file(\"ecdsa_1\"), &k2)",
            "0"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"load ECDSA cert\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "1"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_public(test_data_file(\"ecdsa_1.pub\"), &k2,\n\t    NULL)",
            "0"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"load ECDSA from public\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "1"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL)",
            "0"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"parse ECDSA from new-format w/ passphrase\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "1"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k2, NULL)",
            "0"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"parse ECDSA from new-format\""
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "1"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL)",
            "0"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"parse ECDSA from private w/ passphrase\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_free",
          "args": [
            "c"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_free",
          "args": [
            "b"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_free",
          "args": [
            "a"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_BIGNUM_EQ",
          "args": [
            "b",
            "c"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_BIGNUM_EQ",
          "args": [
            "EC_KEY_get0_private_key(k1->ecdsa)",
            "a"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_private_key",
          "args": [
            "k1->ecdsa"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "c",
            "NULL"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_point2bn",
          "args": [
            "EC_KEY_get0_group(k1->ecdsa)",
            "EC_KEY_get0_public_key(k1->ecdsa)",
            "POINT_CONVERSION_UNCOMPRESSED",
            "NULL",
            "NULL"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_public_key",
          "args": [
            "k1->ecdsa"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "k1->ecdsa"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_bignum",
          "args": [
            "\"ecdsa_1.param.pub\""
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "load_bignum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "75-85",
          "snippet": "BIGNUM *\nload_bignum(const char *name)\n{\n\tBIGNUM *ret = NULL;\n\tstruct sshbuf *buf;\n\n\tbuf = load_text_file(name);\n\tASSERT_INT_NE(BN_hex2bn(&ret, (const char *)sshbuf_ptr(buf)), 0);\n\tsshbuf_free(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nBIGNUM *\nload_bignum(const char *name)\n{\n\tBIGNUM *ret = NULL;\n\tstruct sshbuf *buf;\n\n\tbuf = load_text_file(name);\n\tASSERT_INT_NE(BN_hex2bn(&ret, (const char *)sshbuf_ptr(buf)), 0);\n\tsshbuf_free(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "(const char *)sshbuf_ptr(buf)",
            "OBJ_nid2sn(k1->ecdsa_nid)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OBJ_nid2sn",
          "args": [
            "k1->ecdsa_nid"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"parse ECDSA from private\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "cp",
            "(const char *)sshbuf_ptr(buf)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "cp",
            "NULL"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"DSA key bubblebabble fingerprint\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "cp",
            "(const char *)sshbuf_ptr(buf)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "cp",
            "NULL"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"DSA cert hex fingerprint\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "cp",
            "(const char *)sshbuf_ptr(buf)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "cp",
            "NULL"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"DSA key hex fingerprint\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal_public(k1, k2)",
            "1"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "0"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "k2->type",
            "KEY_DSA_CERT"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_cert(test_data_file(\"dsa_1\"), &k2)",
            "0"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"load DSA cert\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "1"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_public(test_data_file(\"dsa_1.pub\"), &k2,\n\t    NULL)",
            "0"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"load DSA from public\""
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "1"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL)",
            "0"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"parse DSA from new-format w/ passphrase\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "1"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k2, NULL)",
            "0"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"parse DSA from new-format\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "1"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL)",
            "0"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"parse DSA from private w/ passphrase\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_free",
          "args": [
            "c"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_free",
          "args": [
            "b"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_free",
          "args": [
            "a"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_BIGNUM_EQ",
          "args": [
            "dsa_pub_key(k1)",
            "c"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_pub_key",
          "args": [
            "k1"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_pub_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "142-151",
          "snippet": "const BIGNUM *\ndsa_pub_key(struct sshkey *k)\n{\n\tconst BIGNUM *pub_key = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->dsa, NULL);\n\tDSA_get0_key(k->dsa, &pub_key, NULL);\n\treturn pub_key;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst BIGNUM *\ndsa_pub_key(struct sshkey *k)\n{\n\tconst BIGNUM *pub_key = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->dsa, NULL);\n\tDSA_get0_key(k->dsa, &pub_key, NULL);\n\treturn pub_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_BIGNUM_EQ",
          "args": [
            "dsa_priv_key(k1)",
            "b"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_priv_key",
          "args": [
            "k1"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_priv_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "153-162",
          "snippet": "const BIGNUM *\ndsa_priv_key(struct sshkey *k)\n{\n\tconst BIGNUM *priv_key = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->dsa, NULL);\n\tDSA_get0_key(k->dsa, NULL, &priv_key);\n\treturn priv_key;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst BIGNUM *\ndsa_priv_key(struct sshkey *k)\n{\n\tconst BIGNUM *priv_key = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->dsa, NULL);\n\tDSA_get0_key(k->dsa, NULL, &priv_key);\n\treturn priv_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_BIGNUM_EQ",
          "args": [
            "dsa_g(k1)",
            "a"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_g",
          "args": [
            "k1"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_g",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "131-140",
          "snippet": "const BIGNUM *\ndsa_g(struct sshkey *k)\n{\n\tconst BIGNUM *g = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->dsa, NULL);\n\tDSA_get0_pqg(k->dsa, NULL, NULL, &g);\n\treturn g;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst BIGNUM *\ndsa_g(struct sshkey *k)\n{\n\tconst BIGNUM *g = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->dsa, NULL);\n\tDSA_get0_pqg(k->dsa, NULL, NULL, &g);\n\treturn g;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"parse DSA from private\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "cp",
            "(const char *)sshbuf_ptr(buf)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "cp",
            "NULL"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"RSA key bubblebabble fingerprint\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "cp",
            "(const char *)sshbuf_ptr(buf)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "cp",
            "NULL"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"RSA cert hex fingerprint\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "cp",
            "(const char *)sshbuf_ptr(buf)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "cp",
            "NULL"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"RSA key hex fingerprint\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal_public(k1, k2)",
            "1"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "0"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "k2->type",
            "KEY_RSA_CERT"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_cert(test_data_file(\"rsa_1\"), &k2)",
            "0"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"load RSA cert\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "k2->cert->signature_type",
            "\"rsa-sha2-512\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal_public(k1, k2)",
            "1"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "k2->type",
            "KEY_RSA_CERT"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_cert(test_data_file(\"rsa_1_sha512\"), &k2)",
            "0"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"load RSA cert with SHA512 signature\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "k2->cert->signature_type",
            "\"ssh-rsa\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal_public(k1, k2)",
            "1"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "k2->type",
            "KEY_RSA_CERT"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_cert(test_data_file(\"rsa_1_sha1\"), &k2)",
            "0"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"load RSA cert with SHA1 signature\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "1"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_public(test_data_file(\"rsa_1.pub\"), &k2,\n\t    NULL)",
            "0"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"load RSA from public\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "1"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL)",
            "0"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"parse RSA from new-format w/ passphrase\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "1"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k2, NULL)",
            "0"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"parse RSA from new-format\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(k1, k2)",
            "1"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k2",
            "NULL"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL)",
            "0"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"parse RSA from private w/ passphrase\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_free",
          "args": [
            "c"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_free",
          "args": [
            "b"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_free",
          "args": [
            "a"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_BIGNUM_EQ",
          "args": [
            "rsa_q(k1)",
            "c"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsa_q",
          "args": [
            "k1"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "rsa_q",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "120-129",
          "snippet": "const BIGNUM *\nrsa_q(struct sshkey *k)\n{\n\tconst BIGNUM *q = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->rsa, NULL);\n\tRSA_get0_factors(k->rsa, NULL, &q);\n\treturn q;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst BIGNUM *\nrsa_q(struct sshkey *k)\n{\n\tconst BIGNUM *q = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->rsa, NULL);\n\tRSA_get0_factors(k->rsa, NULL, &q);\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_BIGNUM_EQ",
          "args": [
            "rsa_p(k1)",
            "b"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsa_p",
          "args": [
            "k1"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "rsa_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "109-118",
          "snippet": "const BIGNUM *\nrsa_p(struct sshkey *k)\n{\n\tconst BIGNUM *p = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->rsa, NULL);\n\tRSA_get0_factors(k->rsa, &p, NULL);\n\treturn p;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst BIGNUM *\nrsa_p(struct sshkey *k)\n{\n\tconst BIGNUM *p = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->rsa, NULL);\n\tRSA_get0_factors(k->rsa, &p, NULL);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_BIGNUM_EQ",
          "args": [
            "rsa_n(k1)",
            "a"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsa_n",
          "args": [
            "k1"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "rsa_n",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "87-96",
          "snippet": "const BIGNUM *\nrsa_n(struct sshkey *k)\n{\n\tconst BIGNUM *n = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->rsa, NULL);\n\tRSA_get0_key(k->rsa, &n, NULL, NULL);\n\treturn n;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst BIGNUM *\nrsa_n(struct sshkey *k)\n{\n\tconst BIGNUM *n = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->rsa, NULL);\n\tRSA_get0_key(k->rsa, &n, NULL, NULL);\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"parse RSA from private\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"load passphrase\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid sshkey_file_tests(void);\n\nvoid\nsshkey_file_tests(void)\n{\n\tstruct sshkey *k1, *k2;\n\tstruct sshbuf *buf, *pw;\n\tBIGNUM *a, *b, *c;\n\tchar *cp;\n\n\tTEST_START(\"load passphrase\");\n\tpw = load_text_file(\"pw\");\n\tTEST_DONE();\n\n\n\tTEST_START(\"parse RSA from private\");\n\tbuf = load_file(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k1, NULL);\n\ta = load_bignum(\"rsa_1.param.n\");\n\tb = load_bignum(\"rsa_1.param.p\");\n\tc = load_bignum(\"rsa_1.param.q\");\n\tASSERT_BIGNUM_EQ(rsa_n(k1), a);\n\tASSERT_BIGNUM_EQ(rsa_p(k1), b);\n\tASSERT_BIGNUM_EQ(rsa_q(k1), c);\n\tBN_free(a);\n\tBN_free(b);\n\tBN_free(c);\n\tTEST_DONE();\n\n\tTEST_START(\"parse RSA from private w/ passphrase\");\n\tbuf = load_file(\"rsa_1_pw\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"parse RSA from new-format\");\n\tbuf = load_file(\"rsa_n\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"parse RSA from new-format w/ passphrase\");\n\tbuf = load_file(\"rsa_n_pw\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load RSA from public\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"rsa_1.pub\"), &k2,\n\t    NULL), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load RSA cert with SHA1 signature\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"rsa_1_sha1\"), &k2), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(k2->type, KEY_RSA_CERT);\n\tASSERT_INT_EQ(sshkey_equal_public(k1, k2), 1);\n\tASSERT_STRING_EQ(k2->cert->signature_type, \"ssh-rsa\");\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load RSA cert with SHA512 signature\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"rsa_1_sha512\"), &k2), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(k2->type, KEY_RSA_CERT);\n\tASSERT_INT_EQ(sshkey_equal_public(k1, k2), 1);\n\tASSERT_STRING_EQ(k2->cert->signature_type, \"rsa-sha2-512\");\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load RSA cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"rsa_1\"), &k2), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(k2->type, KEY_RSA_CERT);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 0);\n\tASSERT_INT_EQ(sshkey_equal_public(k1, k2), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"RSA key hex fingerprint\");\n\tbuf = load_text_file(\"rsa_1.fp\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tTEST_START(\"RSA cert hex fingerprint\");\n\tbuf = load_text_file(\"rsa_1-cert.fp\");\n\tcp = sshkey_fingerprint(k2, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"RSA key bubblebabble fingerprint\");\n\tbuf = load_text_file(\"rsa_1.fp.bb\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA1, SSH_FP_BUBBLEBABBLE);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tsshkey_free(k1);\n\n\tTEST_START(\"parse DSA from private\");\n\tbuf = load_file(\"dsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k1, NULL);\n\ta = load_bignum(\"dsa_1.param.g\");\n\tb = load_bignum(\"dsa_1.param.priv\");\n\tc = load_bignum(\"dsa_1.param.pub\");\n\tASSERT_BIGNUM_EQ(dsa_g(k1), a);\n\tASSERT_BIGNUM_EQ(dsa_priv_key(k1), b);\n\tASSERT_BIGNUM_EQ(dsa_pub_key(k1), c);\n\tBN_free(a);\n\tBN_free(b);\n\tBN_free(c);\n\tTEST_DONE();\n\n\tTEST_START(\"parse DSA from private w/ passphrase\");\n\tbuf = load_file(\"dsa_1_pw\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"parse DSA from new-format\");\n\tbuf = load_file(\"dsa_n\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"parse DSA from new-format w/ passphrase\");\n\tbuf = load_file(\"dsa_n_pw\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load DSA from public\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"dsa_1.pub\"), &k2,\n\t    NULL), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load DSA cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"dsa_1\"), &k2), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(k2->type, KEY_DSA_CERT);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 0);\n\tASSERT_INT_EQ(sshkey_equal_public(k1, k2), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"DSA key hex fingerprint\");\n\tbuf = load_text_file(\"dsa_1.fp\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tTEST_START(\"DSA cert hex fingerprint\");\n\tbuf = load_text_file(\"dsa_1-cert.fp\");\n\tcp = sshkey_fingerprint(k2, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"DSA key bubblebabble fingerprint\");\n\tbuf = load_text_file(\"dsa_1.fp.bb\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA1, SSH_FP_BUBBLEBABBLE);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tsshkey_free(k1);\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"parse ECDSA from private\");\n\tbuf = load_file(\"ecdsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k1, NULL);\n\tbuf = load_text_file(\"ecdsa_1.param.curve\");\n\tASSERT_STRING_EQ((const char *)sshbuf_ptr(buf),\n\t    OBJ_nid2sn(k1->ecdsa_nid));\n\tsshbuf_free(buf);\n\ta = load_bignum(\"ecdsa_1.param.priv\");\n\tb = load_bignum(\"ecdsa_1.param.pub\");\n\tc = EC_POINT_point2bn(EC_KEY_get0_group(k1->ecdsa),\n\t    EC_KEY_get0_public_key(k1->ecdsa), POINT_CONVERSION_UNCOMPRESSED,\n\t    NULL, NULL);\n\tASSERT_PTR_NE(c, NULL);\n\tASSERT_BIGNUM_EQ(EC_KEY_get0_private_key(k1->ecdsa), a);\n\tASSERT_BIGNUM_EQ(b, c);\n\tBN_free(a);\n\tBN_free(b);\n\tBN_free(c);\n\tTEST_DONE();\n\n\tTEST_START(\"parse ECDSA from private w/ passphrase\");\n\tbuf = load_file(\"ecdsa_1_pw\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"parse ECDSA from new-format\");\n\tbuf = load_file(\"ecdsa_n\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"parse ECDSA from new-format w/ passphrase\");\n\tbuf = load_file(\"ecdsa_n_pw\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load ECDSA from public\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"ecdsa_1.pub\"), &k2,\n\t    NULL), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load ECDSA cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"ecdsa_1\"), &k2), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(k2->type, KEY_ECDSA_CERT);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 0);\n\tASSERT_INT_EQ(sshkey_equal_public(k1, k2), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"ECDSA key hex fingerprint\");\n\tbuf = load_text_file(\"ecdsa_1.fp\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tTEST_START(\"ECDSA cert hex fingerprint\");\n\tbuf = load_text_file(\"ecdsa_1-cert.fp\");\n\tcp = sshkey_fingerprint(k2, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"ECDSA key bubblebabble fingerprint\");\n\tbuf = load_text_file(\"ecdsa_1.fp.bb\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA1, SSH_FP_BUBBLEBABBLE);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tsshkey_free(k1);\n#endif /* OPENSSL_HAS_ECC */\n\n\tTEST_START(\"parse Ed25519 from private\");\n\tbuf = load_file(\"ed25519_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_INT_EQ(k1->type, KEY_ED25519);\n\t/* XXX check key contents */\n\tTEST_DONE();\n\n\tTEST_START(\"parse Ed25519 from private w/ passphrase\");\n\tbuf = load_file(\"ed25519_1_pw\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,\n\t    (const char *)sshbuf_ptr(pw), &k2, NULL), 0);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load Ed25519 from public\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"ed25519_1.pub\"), &k2,\n\t    NULL), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"load Ed25519 cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"ed25519_1\"), &k2), 0);\n\tASSERT_PTR_NE(k2, NULL);\n\tASSERT_INT_EQ(k2->type, KEY_ED25519_CERT);\n\tASSERT_INT_EQ(sshkey_equal(k1, k2), 0);\n\tASSERT_INT_EQ(sshkey_equal_public(k1, k2), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"Ed25519 key hex fingerprint\");\n\tbuf = load_text_file(\"ed25519_1.fp\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tTEST_START(\"Ed25519 cert hex fingerprint\");\n\tbuf = load_text_file(\"ed25519_1-cert.fp\");\n\tcp = sshkey_fingerprint(k2, SSH_DIGEST_SHA256, SSH_FP_BASE64);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"Ed25519 key bubblebabble fingerprint\");\n\tbuf = load_text_file(\"ed25519_1.fp.bb\");\n\tcp = sshkey_fingerprint(k1, SSH_DIGEST_SHA1, SSH_FP_BUBBLEBABBLE);\n\tASSERT_PTR_NE(cp, NULL);\n\tASSERT_STRING_EQ(cp, (const char *)sshbuf_ptr(buf));\n\tsshbuf_free(buf);\n\tfree(cp);\n\tTEST_DONE();\n\n\tsshkey_free(k1);\n\n\tsshbuf_free(pw);\n\n}"
  }
]