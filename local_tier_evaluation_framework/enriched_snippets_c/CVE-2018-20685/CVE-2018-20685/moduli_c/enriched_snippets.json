[
  {
    "function_name": "prime_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
    "lines": "574-806",
    "snippet": "int\nprime_test(FILE *in, FILE *out, u_int32_t trials, u_int32_t generator_wanted,\n    char *checkpoint_file, unsigned long start_lineno, unsigned long num_lines)\n{\n\tBIGNUM *q, *p, *a;\n\tBN_CTX *ctx;\n\tchar *cp, *lp;\n\tu_int32_t count_in = 0, count_out = 0, count_possible = 0;\n\tu_int32_t generator_known, in_tests, in_tries, in_type, in_size;\n\tunsigned long last_processed = 0, end_lineno;\n\ttime_t time_start, time_stop;\n\tint res;\n\n\tif (trials < TRIAL_MINIMUM) {\n\t\terror(\"Minimum primality trials is %d\", TRIAL_MINIMUM);\n\t\treturn (-1);\n\t}\n\n\tif (num_lines == 0)\n\t\tend_lineno = count_lines(in);\n\telse\n\t\tend_lineno = start_lineno + num_lines;\n\n\ttime(&time_start);\n\n\tif ((p = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\tif ((q = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\tif ((ctx = BN_CTX_new()) == NULL)\n\t\tfatal(\"BN_CTX_new failed\");\n\n\tdebug2(\"%.24s Final %u Miller-Rabin trials (%x generator)\",\n\t    ctime(&time_start), trials, generator_wanted);\n\n\tif (checkpoint_file != NULL)\n\t\tlast_processed = read_checkpoint(checkpoint_file);\n\tlast_processed = start_lineno = MAXIMUM(last_processed, start_lineno);\n\tif (end_lineno == ULONG_MAX)\n\t\tdebug(\"process from line %lu from pipe\", last_processed);\n\telse\n\t\tdebug(\"process from line %lu to line %lu\", last_processed,\n\t\t    end_lineno);\n\n\tres = 0;\n\tlp = xmalloc(QLINESIZE + 1);\n\twhile (fgets(lp, QLINESIZE + 1, in) != NULL && count_in < end_lineno) {\n\t\tcount_in++;\n\t\tif (count_in <= last_processed) {\n\t\t\tdebug3(\"skipping line %u, before checkpoint or \"\n\t\t\t    \"specified start line\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tif (checkpoint_file != NULL)\n\t\t\twrite_checkpoint(checkpoint_file, count_in);\n\t\tprint_progress(start_lineno, count_in, end_lineno);\n\t\tif (strlen(lp) < 14 || *lp == '!' || *lp == '#') {\n\t\t\tdebug2(\"%10u: comment or short line\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* XXX - fragile parser */\n\t\t/* time */\n\t\tcp = &lp[14];\t/* (skip) */\n\n\t\t/* type */\n\t\tin_type = strtoul(cp, &cp, 10);\n\n\t\t/* tests */\n\t\tin_tests = strtoul(cp, &cp, 10);\n\n\t\tif (in_tests & MODULI_TESTS_COMPOSITE) {\n\t\t\tdebug2(\"%10u: known composite\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* tries */\n\t\tin_tries = strtoul(cp, &cp, 10);\n\n\t\t/* size (most significant bit) */\n\t\tin_size = strtoul(cp, &cp, 10);\n\n\t\t/* generator (hex) */\n\t\tgenerator_known = strtoul(cp, &cp, 16);\n\n\t\t/* Skip white space */\n\t\tcp += strspn(cp, \" \");\n\n\t\t/* modulus (hex) */\n\t\tswitch (in_type) {\n\t\tcase MODULI_TYPE_SOPHIE_GERMAIN:\n\t\t\tdebug2(\"%10u: (%u) Sophie-Germain\", count_in, in_type);\n\t\t\ta = q;\n\t\t\tif (BN_hex2bn(&a, cp) == 0)\n\t\t\t\tfatal(\"BN_hex2bn failed\");\n\t\t\t/* p = 2*q + 1 */\n\t\t\tif (BN_lshift(p, q, 1) == 0)\n\t\t\t\tfatal(\"BN_lshift failed\");\n\t\t\tif (BN_add_word(p, 1) == 0)\n\t\t\t\tfatal(\"BN_add_word failed\");\n\t\t\tin_size += 1;\n\t\t\tgenerator_known = 0;\n\t\t\tbreak;\n\t\tcase MODULI_TYPE_UNSTRUCTURED:\n\t\tcase MODULI_TYPE_SAFE:\n\t\tcase MODULI_TYPE_SCHNORR:\n\t\tcase MODULI_TYPE_STRONG:\n\t\tcase MODULI_TYPE_UNKNOWN:\n\t\t\tdebug2(\"%10u: (%u)\", count_in, in_type);\n\t\t\ta = p;\n\t\t\tif (BN_hex2bn(&a, cp) == 0)\n\t\t\t\tfatal(\"BN_hex2bn failed\");\n\t\t\t/* q = (p-1) / 2 */\n\t\t\tif (BN_rshift(q, p, 1) == 0)\n\t\t\t\tfatal(\"BN_rshift failed\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdebug2(\"Unknown prime type\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * due to earlier inconsistencies in interpretation, check\n\t\t * the proposed bit size.\n\t\t */\n\t\tif ((u_int32_t)BN_num_bits(p) != (in_size + 1)) {\n\t\t\tdebug2(\"%10u: bit size %u mismatch\", count_in, in_size);\n\t\t\tcontinue;\n\t\t}\n\t\tif (in_size < QSIZE_MINIMUM) {\n\t\t\tdebug2(\"%10u: bit size %u too short\", count_in, in_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (in_tests & MODULI_TESTS_MILLER_RABIN)\n\t\t\tin_tries += trials;\n\t\telse\n\t\t\tin_tries = trials;\n\n\t\t/*\n\t\t * guess unknown generator\n\t\t */\n\t\tif (generator_known == 0) {\n\t\t\tif (BN_mod_word(p, 24) == 11)\n\t\t\t\tgenerator_known = 2;\n\t\t\telse if (BN_mod_word(p, 12) == 5)\n\t\t\t\tgenerator_known = 3;\n\t\t\telse {\n\t\t\t\tu_int32_t r = BN_mod_word(p, 10);\n\n\t\t\t\tif (r == 3 || r == 7)\n\t\t\t\t\tgenerator_known = 5;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * skip tests when desired generator doesn't match\n\t\t */\n\t\tif (generator_wanted > 0 &&\n\t\t    generator_wanted != generator_known) {\n\t\t\tdebug2(\"%10u: generator %d != %d\",\n\t\t\t    count_in, generator_known, generator_wanted);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Primes with no known generator are useless for DH, so\n\t\t * skip those.\n\t\t */\n\t\tif (generator_known == 0) {\n\t\t\tdebug2(\"%10u: no known generator\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount_possible++;\n\n\t\t/*\n\t\t * The (1/4)^N performance bound on Miller-Rabin is\n\t\t * extremely pessimistic, so don't spend a lot of time\n\t\t * really verifying that q is prime until after we know\n\t\t * that p is also prime. A single pass will weed out the\n\t\t * vast majority of composite q's.\n\t\t */\n\t\tif (BN_is_prime_ex(q, 1, ctx, NULL) <= 0) {\n\t\t\tdebug(\"%10u: q failed first possible prime test\",\n\t\t\t    count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * q is possibly prime, so go ahead and really make sure\n\t\t * that p is prime. If it is, then we can go back and do\n\t\t * the same for q. If p is composite, chances are that\n\t\t * will show up on the first Rabin-Miller iteration so it\n\t\t * doesn't hurt to specify a high iteration count.\n\t\t */\n\t\tif (!BN_is_prime_ex(p, trials, ctx, NULL)) {\n\t\t\tdebug(\"%10u: p is not prime\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"%10u: p is almost certainly prime\", count_in);\n\n\t\t/* recheck q more rigorously */\n\t\tif (!BN_is_prime_ex(q, trials - 1, ctx, NULL)) {\n\t\t\tdebug(\"%10u: q is not prime\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"%10u: q is almost certainly prime\", count_in);\n\n\t\tif (qfileout(out, MODULI_TYPE_SAFE,\n\t\t    in_tests | MODULI_TESTS_MILLER_RABIN,\n\t\t    in_tries, in_size, generator_known, p)) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount_out++;\n\t}\n\n\ttime(&time_stop);\n\tfree(lp);\n\tBN_free(p);\n\tBN_free(q);\n\tBN_CTX_free(ctx);\n\n\tif (checkpoint_file != NULL)\n\t\tunlink(checkpoint_file);\n\n\tlogit(\"%.24s Found %u safe primes of %u candidates in %ld seconds\",\n\t    ctime(&time_stop), count_out, count_possible,\n\t    (long) (time_stop - time_start));\n\n\treturn (res);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"dh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <openssl/dh.h>",
      "#include <openssl/bn.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define TRIAL_MINIMUM\t(4)",
      "#define QSIZE_MINIMUM\t\t(511)",
      "#define QLINESIZE\t\t(100+8192)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%.24s Found %u safe primes of %u candidates in %ld seconds\"",
            "ctime(&time_stop)",
            "count_out",
            "count_possible",
            "(long) (time_stop - time_start)"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctime",
          "args": [
            "&time_stop"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "checkpoint_file"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_free",
          "args": [
            "ctx"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_free",
          "args": [
            "q"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_free",
          "args": [
            "p"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "lp"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "&time_stop"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
          "lines": "512-526",
          "snippet": "static char *\nfmt_time(time_t seconds)\n{\n\tint day, hr, min;\n\tstatic char buf[128];\n\n\tmin = (seconds / 60) % 60;\n\thr = (seconds / 60 / 60) % 24;\n\tday = seconds / 60 / 60 / 24;\n\tif (day > 0)\n\t\tsnprintf(buf, sizeof buf, \"%dd %d:%02d\", day, hr, min);\n\telse\n\t\tsnprintf(buf, sizeof buf, \"%d:%02d\", hr, min);\n\treturn buf;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"dh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nfmt_time(time_t seconds)\n{\n\tint day, hr, min;\n\tstatic char buf[128];\n\n\tmin = (seconds / 60) % 60;\n\thr = (seconds / 60 / 60) % 24;\n\tday = seconds / 60 / 60 / 24;\n\tif (day > 0)\n\t\tsnprintf(buf, sizeof buf, \"%dd %d:%02d\", day, hr, min);\n\telse\n\t\tsnprintf(buf, sizeof buf, \"%d:%02d\", hr, min);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qfileout",
          "args": [
            "out",
            "MODULI_TYPE_SAFE",
            "in_tests | MODULI_TESTS_MILLER_RABIN",
            "in_tries",
            "in_size",
            "generator_known",
            "p"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "qfileout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
          "lines": "152-178",
          "snippet": "static int\nqfileout(FILE * ofile, u_int32_t otype, u_int32_t otests, u_int32_t otries,\n    u_int32_t osize, u_int32_t ogenerator, BIGNUM * omodulus)\n{\n\tstruct tm *gtm;\n\ttime_t time_now;\n\tint res;\n\n\ttime(&time_now);\n\tgtm = gmtime(&time_now);\n\n\tres = fprintf(ofile, \"%04d%02d%02d%02d%02d%02d %u %u %u %u %x \",\n\t    gtm->tm_year + 1900, gtm->tm_mon + 1, gtm->tm_mday,\n\t    gtm->tm_hour, gtm->tm_min, gtm->tm_sec,\n\t    otype, otests, otries, osize, ogenerator);\n\n\tif (res < 0)\n\t\treturn (-1);\n\n\tif (BN_print_fp(ofile, omodulus) < 1)\n\t\treturn (-1);\n\n\tres = fprintf(ofile, \"\\n\");\n\tfflush(ofile);\n\n\treturn (res > 0 ? 0 : -1);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"dh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nqfileout(FILE * ofile, u_int32_t otype, u_int32_t otests, u_int32_t otries,\n    u_int32_t osize, u_int32_t ogenerator, BIGNUM * omodulus)\n{\n\tstruct tm *gtm;\n\ttime_t time_now;\n\tint res;\n\n\ttime(&time_now);\n\tgtm = gmtime(&time_now);\n\n\tres = fprintf(ofile, \"%04d%02d%02d%02d%02d%02d %u %u %u %u %x \",\n\t    gtm->tm_year + 1900, gtm->tm_mon + 1, gtm->tm_mday,\n\t    gtm->tm_hour, gtm->tm_min, gtm->tm_sec,\n\t    otype, otests, otries, osize, ogenerator);\n\n\tif (res < 0)\n\t\treturn (-1);\n\n\tif (BN_print_fp(ofile, omodulus) < 1)\n\t\treturn (-1);\n\n\tres = fprintf(ofile, \"\\n\");\n\tfflush(ofile);\n\n\treturn (res > 0 ? 0 : -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%10u: q is almost certainly prime\"",
            "count_in"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_is_prime_ex",
          "args": [
            "q",
            "trials - 1",
            "ctx",
            "NULL"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_is_prime_ex",
          "args": [
            "p",
            "trials",
            "ctx",
            "NULL"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_is_prime_ex",
          "args": [
            "q",
            "1",
            "ctx",
            "NULL"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%10u: no known generator\"",
            "count_in"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_mod_word",
          "args": [
            "p",
            "10"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_mod_word",
          "args": [
            "p",
            "12"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_mod_word",
          "args": [
            "p",
            "24"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_num_bits",
          "args": [
            "p"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"BN_rshift failed\""
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_rshift",
          "args": [
            "q",
            "p",
            "1"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_hex2bn",
          "args": [
            "&a",
            "cp"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_add_word",
          "args": [
            "p",
            "1"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_lshift",
          "args": [
            "p",
            "q",
            "1"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_hex2bn",
          "args": [
            "&a",
            "cp"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "\" \""
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "cp",
            "&cp",
            "16"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "strtoull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtoull.c",
          "lines": "49-109",
          "snippet": "unsigned long long\nstrtoull(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tunsigned long long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * See strtoq for comments as to the logic used.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else { \n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\tcutoff = ULLONG_MAX / (unsigned long long)base;\n\tcutlim = ULLONG_MAX % (unsigned long long)base;\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\tany = -1;\n\t\t\tacc = ULLONG_MAX;\n\t\t\terrno = ERANGE;\n\t\t} else {\n\t\t\tany = 1;\n\t\t\tacc *= (unsigned long long)base;\n\t\t\tacc += c;\n\t\t}\n\t}\n\tif (neg && any > 0)\n\t\tacc = -acc;\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nunsigned long long\nstrtoull(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tunsigned long long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * See strtoq for comments as to the logic used.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else { \n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\tcutoff = ULLONG_MAX / (unsigned long long)base;\n\tcutlim = ULLONG_MAX % (unsigned long long)base;\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\tany = -1;\n\t\t\tacc = ULLONG_MAX;\n\t\t\terrno = ERANGE;\n\t\t} else {\n\t\t\tany = 1;\n\t\t\tacc *= (unsigned long long)base;\n\t\t\tacc += c;\n\t\t}\n\t}\n\tif (neg && any > 0)\n\t\tacc = -acc;\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lp"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_progress",
          "args": [
            "start_lineno",
            "count_in",
            "end_lineno"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "print_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
          "lines": "528-566",
          "snippet": "static void\nprint_progress(unsigned long start_lineno, unsigned long current_lineno,\n    unsigned long end_lineno)\n{\n\tstatic time_t time_start, time_prev;\n\ttime_t time_now, elapsed;\n\tunsigned long num_to_process, processed, remaining, percent, eta;\n\tdouble time_per_line;\n\tchar *eta_str;\n\n\ttime_now = monotime();\n\tif (time_start == 0) {\n\t\ttime_start = time_prev = time_now;\n\t\treturn;\n\t}\n\t/* print progress after 1m then once per 5m */\n\tif (time_now - time_prev < 5 * 60)\n\t\treturn;\n\ttime_prev = time_now;\n\telapsed = time_now - time_start;\n\tprocessed = current_lineno - start_lineno;\n\tremaining = end_lineno - current_lineno;\n\tnum_to_process = end_lineno - start_lineno;\n\ttime_per_line = (double)elapsed / processed;\n\t/* if we don't know how many we're processing just report count+time */\n\ttime(&time_now);\n\tif (end_lineno == ULONG_MAX) {\n\t\tlogit(\"%.24s processed %lu in %s\", ctime(&time_now),\n\t\t    processed, fmt_time(elapsed));\n\t\treturn;\n\t}\n\tpercent = 100 * processed / num_to_process;\n\teta = time_per_line * remaining;\n\teta_str = xstrdup(fmt_time(eta));\n\tlogit(\"%.24s processed %lu of %lu (%lu%%) in %s, ETA %s\",\n\t    ctime(&time_now), processed, num_to_process, percent,\n\t    fmt_time(elapsed), eta_str);\n\tfree(eta_str);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"dh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nprint_progress(unsigned long start_lineno, unsigned long current_lineno,\n    unsigned long end_lineno)\n{\n\tstatic time_t time_start, time_prev;\n\ttime_t time_now, elapsed;\n\tunsigned long num_to_process, processed, remaining, percent, eta;\n\tdouble time_per_line;\n\tchar *eta_str;\n\n\ttime_now = monotime();\n\tif (time_start == 0) {\n\t\ttime_start = time_prev = time_now;\n\t\treturn;\n\t}\n\t/* print progress after 1m then once per 5m */\n\tif (time_now - time_prev < 5 * 60)\n\t\treturn;\n\ttime_prev = time_now;\n\telapsed = time_now - time_start;\n\tprocessed = current_lineno - start_lineno;\n\tremaining = end_lineno - current_lineno;\n\tnum_to_process = end_lineno - start_lineno;\n\ttime_per_line = (double)elapsed / processed;\n\t/* if we don't know how many we're processing just report count+time */\n\ttime(&time_now);\n\tif (end_lineno == ULONG_MAX) {\n\t\tlogit(\"%.24s processed %lu in %s\", ctime(&time_now),\n\t\t    processed, fmt_time(elapsed));\n\t\treturn;\n\t}\n\tpercent = 100 * processed / num_to_process;\n\teta = time_per_line * remaining;\n\teta_str = xstrdup(fmt_time(eta));\n\tlogit(\"%.24s processed %lu of %lu (%lu%%) in %s, ETA %s\",\n\t    ctime(&time_now), processed, num_to_process, percent,\n\t    fmt_time(elapsed), eta_str);\n\tfree(eta_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_checkpoint",
          "args": [
            "checkpoint_file",
            "count_in"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "write_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
          "lines": "448-477",
          "snippet": "static void\nwrite_checkpoint(char *cpfile, u_int32_t lineno)\n{\n\tFILE *fp;\n\tchar tmp[PATH_MAX];\n\tint r;\n\n\tr = snprintf(tmp, sizeof(tmp), \"%s.XXXXXXXXXX\", cpfile);\n\tif (r == -1 || r >= PATH_MAX) {\n\t\tlogit(\"write_checkpoint: temp pathname too long\");\n\t\treturn;\n\t}\n\tif ((r = mkstemp(tmp)) == -1) {\n\t\tlogit(\"mkstemp(%s): %s\", tmp, strerror(errno));\n\t\treturn;\n\t}\n\tif ((fp = fdopen(r, \"w\")) == NULL) {\n\t\tlogit(\"write_checkpoint: fdopen: %s\", strerror(errno));\n\t\tunlink(tmp);\n\t\tclose(r);\n\t\treturn;\n\t}\n\tif (fprintf(fp, \"%lu\\n\", (unsigned long)lineno) > 0 && fclose(fp) == 0\n\t    && rename(tmp, cpfile) == 0)\n\t\tdebug3(\"wrote checkpoint line %lu to '%s'\",\n\t\t    (unsigned long)lineno, cpfile);\n\telse\n\t\tlogit(\"failed to write to checkpoint file '%s': %s\", cpfile,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"dh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nwrite_checkpoint(char *cpfile, u_int32_t lineno)\n{\n\tFILE *fp;\n\tchar tmp[PATH_MAX];\n\tint r;\n\n\tr = snprintf(tmp, sizeof(tmp), \"%s.XXXXXXXXXX\", cpfile);\n\tif (r == -1 || r >= PATH_MAX) {\n\t\tlogit(\"write_checkpoint: temp pathname too long\");\n\t\treturn;\n\t}\n\tif ((r = mkstemp(tmp)) == -1) {\n\t\tlogit(\"mkstemp(%s): %s\", tmp, strerror(errno));\n\t\treturn;\n\t}\n\tif ((fp = fdopen(r, \"w\")) == NULL) {\n\t\tlogit(\"write_checkpoint: fdopen: %s\", strerror(errno));\n\t\tunlink(tmp);\n\t\tclose(r);\n\t\treturn;\n\t}\n\tif (fprintf(fp, \"%lu\\n\", (unsigned long)lineno) > 0 && fclose(fp) == 0\n\t    && rename(tmp, cpfile) == 0)\n\t\tdebug3(\"wrote checkpoint line %lu to '%s'\",\n\t\t    (unsigned long)lineno, cpfile);\n\telse\n\t\tlogit(\"failed to write to checkpoint file '%s': %s\", cpfile,\n\t\t    strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "lp",
            "QLINESIZE + 1",
            "in"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "QLINESIZE + 1"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "last_processed",
            "start_lineno"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_checkpoint",
          "args": [
            "checkpoint_file"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "read_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
          "lines": "479-493",
          "snippet": "static unsigned long\nread_checkpoint(char *cpfile)\n{\n\tFILE *fp;\n\tunsigned long lineno = 0;\n\n\tif ((fp = fopen(cpfile, \"r\")) == NULL)\n\t\treturn 0;\n\tif (fscanf(fp, \"%lu\\n\", &lineno) < 1)\n\t\tlogit(\"Failed to load checkpoint from '%s'\", cpfile);\n\telse\n\t\tlogit(\"Loaded checkpoint from '%s' line %lu\", cpfile, lineno);\n\tfclose(fp);\n\treturn lineno;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"dh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic unsigned long\nread_checkpoint(char *cpfile)\n{\n\tFILE *fp;\n\tunsigned long lineno = 0;\n\n\tif ((fp = fopen(cpfile, \"r\")) == NULL)\n\t\treturn 0;\n\tif (fscanf(fp, \"%lu\\n\", &lineno) < 1)\n\t\tlogit(\"Failed to load checkpoint from '%s'\", cpfile);\n\telse\n\t\tlogit(\"Loaded checkpoint from '%s' line %lu\", cpfile, lineno);\n\tfclose(fp);\n\treturn lineno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctime",
          "args": [
            "&time_start"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_new",
          "args": [],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_lines",
          "args": [
            "in"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "count_lines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
          "lines": "495-510",
          "snippet": "static unsigned long\ncount_lines(FILE *f)\n{\n\tunsigned long count = 0;\n\tchar lp[QLINESIZE + 1];\n\n\tif (fseek(f, 0, SEEK_SET) != 0) {\n\t\tdebug(\"input file is not seekable\");\n\t\treturn ULONG_MAX;\n\t}\n\twhile (fgets(lp, QLINESIZE + 1, f) != NULL)\n\t\tcount++;\n\trewind(f);\n\tdebug(\"input file has %lu lines\", count);\n\treturn count;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"dh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define QLINESIZE\t\t(100+8192)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define QLINESIZE\t\t(100+8192)\n\nstatic unsigned long\ncount_lines(FILE *f)\n{\n\tunsigned long count = 0;\n\tchar lp[QLINESIZE + 1];\n\n\tif (fseek(f, 0, SEEK_SET) != 0) {\n\t\tdebug(\"input file is not seekable\");\n\t\treturn ULONG_MAX;\n\t}\n\twhile (fgets(lp, QLINESIZE + 1, f) != NULL)\n\t\tcount++;\n\trewind(f);\n\tdebug(\"input file has %lu lines\", count);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Minimum primality trials is %d\"",
            "TRIAL_MINIMUM"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define TRIAL_MINIMUM\t(4)\n#define QSIZE_MINIMUM\t\t(511)\n#define QLINESIZE\t\t(100+8192)\n\nint\nprime_test(FILE *in, FILE *out, u_int32_t trials, u_int32_t generator_wanted,\n    char *checkpoint_file, unsigned long start_lineno, unsigned long num_lines)\n{\n\tBIGNUM *q, *p, *a;\n\tBN_CTX *ctx;\n\tchar *cp, *lp;\n\tu_int32_t count_in = 0, count_out = 0, count_possible = 0;\n\tu_int32_t generator_known, in_tests, in_tries, in_type, in_size;\n\tunsigned long last_processed = 0, end_lineno;\n\ttime_t time_start, time_stop;\n\tint res;\n\n\tif (trials < TRIAL_MINIMUM) {\n\t\terror(\"Minimum primality trials is %d\", TRIAL_MINIMUM);\n\t\treturn (-1);\n\t}\n\n\tif (num_lines == 0)\n\t\tend_lineno = count_lines(in);\n\telse\n\t\tend_lineno = start_lineno + num_lines;\n\n\ttime(&time_start);\n\n\tif ((p = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\tif ((q = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\tif ((ctx = BN_CTX_new()) == NULL)\n\t\tfatal(\"BN_CTX_new failed\");\n\n\tdebug2(\"%.24s Final %u Miller-Rabin trials (%x generator)\",\n\t    ctime(&time_start), trials, generator_wanted);\n\n\tif (checkpoint_file != NULL)\n\t\tlast_processed = read_checkpoint(checkpoint_file);\n\tlast_processed = start_lineno = MAXIMUM(last_processed, start_lineno);\n\tif (end_lineno == ULONG_MAX)\n\t\tdebug(\"process from line %lu from pipe\", last_processed);\n\telse\n\t\tdebug(\"process from line %lu to line %lu\", last_processed,\n\t\t    end_lineno);\n\n\tres = 0;\n\tlp = xmalloc(QLINESIZE + 1);\n\twhile (fgets(lp, QLINESIZE + 1, in) != NULL && count_in < end_lineno) {\n\t\tcount_in++;\n\t\tif (count_in <= last_processed) {\n\t\t\tdebug3(\"skipping line %u, before checkpoint or \"\n\t\t\t    \"specified start line\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tif (checkpoint_file != NULL)\n\t\t\twrite_checkpoint(checkpoint_file, count_in);\n\t\tprint_progress(start_lineno, count_in, end_lineno);\n\t\tif (strlen(lp) < 14 || *lp == '!' || *lp == '#') {\n\t\t\tdebug2(\"%10u: comment or short line\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* XXX - fragile parser */\n\t\t/* time */\n\t\tcp = &lp[14];\t/* (skip) */\n\n\t\t/* type */\n\t\tin_type = strtoul(cp, &cp, 10);\n\n\t\t/* tests */\n\t\tin_tests = strtoul(cp, &cp, 10);\n\n\t\tif (in_tests & MODULI_TESTS_COMPOSITE) {\n\t\t\tdebug2(\"%10u: known composite\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* tries */\n\t\tin_tries = strtoul(cp, &cp, 10);\n\n\t\t/* size (most significant bit) */\n\t\tin_size = strtoul(cp, &cp, 10);\n\n\t\t/* generator (hex) */\n\t\tgenerator_known = strtoul(cp, &cp, 16);\n\n\t\t/* Skip white space */\n\t\tcp += strspn(cp, \" \");\n\n\t\t/* modulus (hex) */\n\t\tswitch (in_type) {\n\t\tcase MODULI_TYPE_SOPHIE_GERMAIN:\n\t\t\tdebug2(\"%10u: (%u) Sophie-Germain\", count_in, in_type);\n\t\t\ta = q;\n\t\t\tif (BN_hex2bn(&a, cp) == 0)\n\t\t\t\tfatal(\"BN_hex2bn failed\");\n\t\t\t/* p = 2*q + 1 */\n\t\t\tif (BN_lshift(p, q, 1) == 0)\n\t\t\t\tfatal(\"BN_lshift failed\");\n\t\t\tif (BN_add_word(p, 1) == 0)\n\t\t\t\tfatal(\"BN_add_word failed\");\n\t\t\tin_size += 1;\n\t\t\tgenerator_known = 0;\n\t\t\tbreak;\n\t\tcase MODULI_TYPE_UNSTRUCTURED:\n\t\tcase MODULI_TYPE_SAFE:\n\t\tcase MODULI_TYPE_SCHNORR:\n\t\tcase MODULI_TYPE_STRONG:\n\t\tcase MODULI_TYPE_UNKNOWN:\n\t\t\tdebug2(\"%10u: (%u)\", count_in, in_type);\n\t\t\ta = p;\n\t\t\tif (BN_hex2bn(&a, cp) == 0)\n\t\t\t\tfatal(\"BN_hex2bn failed\");\n\t\t\t/* q = (p-1) / 2 */\n\t\t\tif (BN_rshift(q, p, 1) == 0)\n\t\t\t\tfatal(\"BN_rshift failed\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdebug2(\"Unknown prime type\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * due to earlier inconsistencies in interpretation, check\n\t\t * the proposed bit size.\n\t\t */\n\t\tif ((u_int32_t)BN_num_bits(p) != (in_size + 1)) {\n\t\t\tdebug2(\"%10u: bit size %u mismatch\", count_in, in_size);\n\t\t\tcontinue;\n\t\t}\n\t\tif (in_size < QSIZE_MINIMUM) {\n\t\t\tdebug2(\"%10u: bit size %u too short\", count_in, in_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (in_tests & MODULI_TESTS_MILLER_RABIN)\n\t\t\tin_tries += trials;\n\t\telse\n\t\t\tin_tries = trials;\n\n\t\t/*\n\t\t * guess unknown generator\n\t\t */\n\t\tif (generator_known == 0) {\n\t\t\tif (BN_mod_word(p, 24) == 11)\n\t\t\t\tgenerator_known = 2;\n\t\t\telse if (BN_mod_word(p, 12) == 5)\n\t\t\t\tgenerator_known = 3;\n\t\t\telse {\n\t\t\t\tu_int32_t r = BN_mod_word(p, 10);\n\n\t\t\t\tif (r == 3 || r == 7)\n\t\t\t\t\tgenerator_known = 5;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * skip tests when desired generator doesn't match\n\t\t */\n\t\tif (generator_wanted > 0 &&\n\t\t    generator_wanted != generator_known) {\n\t\t\tdebug2(\"%10u: generator %d != %d\",\n\t\t\t    count_in, generator_known, generator_wanted);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Primes with no known generator are useless for DH, so\n\t\t * skip those.\n\t\t */\n\t\tif (generator_known == 0) {\n\t\t\tdebug2(\"%10u: no known generator\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount_possible++;\n\n\t\t/*\n\t\t * The (1/4)^N performance bound on Miller-Rabin is\n\t\t * extremely pessimistic, so don't spend a lot of time\n\t\t * really verifying that q is prime until after we know\n\t\t * that p is also prime. A single pass will weed out the\n\t\t * vast majority of composite q's.\n\t\t */\n\t\tif (BN_is_prime_ex(q, 1, ctx, NULL) <= 0) {\n\t\t\tdebug(\"%10u: q failed first possible prime test\",\n\t\t\t    count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * q is possibly prime, so go ahead and really make sure\n\t\t * that p is prime. If it is, then we can go back and do\n\t\t * the same for q. If p is composite, chances are that\n\t\t * will show up on the first Rabin-Miller iteration so it\n\t\t * doesn't hurt to specify a high iteration count.\n\t\t */\n\t\tif (!BN_is_prime_ex(p, trials, ctx, NULL)) {\n\t\t\tdebug(\"%10u: p is not prime\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"%10u: p is almost certainly prime\", count_in);\n\n\t\t/* recheck q more rigorously */\n\t\tif (!BN_is_prime_ex(q, trials - 1, ctx, NULL)) {\n\t\t\tdebug(\"%10u: q is not prime\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"%10u: q is almost certainly prime\", count_in);\n\n\t\tif (qfileout(out, MODULI_TYPE_SAFE,\n\t\t    in_tests | MODULI_TESTS_MILLER_RABIN,\n\t\t    in_tries, in_size, generator_known, p)) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount_out++;\n\t}\n\n\ttime(&time_stop);\n\tfree(lp);\n\tBN_free(p);\n\tBN_free(q);\n\tBN_CTX_free(ctx);\n\n\tif (checkpoint_file != NULL)\n\t\tunlink(checkpoint_file);\n\n\tlogit(\"%.24s Found %u safe primes of %u candidates in %ld seconds\",\n\t    ctime(&time_stop), count_out, count_possible,\n\t    (long) (time_stop - time_start));\n\n\treturn (res);\n}"
  },
  {
    "function_name": "print_progress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
    "lines": "528-566",
    "snippet": "static void\nprint_progress(unsigned long start_lineno, unsigned long current_lineno,\n    unsigned long end_lineno)\n{\n\tstatic time_t time_start, time_prev;\n\ttime_t time_now, elapsed;\n\tunsigned long num_to_process, processed, remaining, percent, eta;\n\tdouble time_per_line;\n\tchar *eta_str;\n\n\ttime_now = monotime();\n\tif (time_start == 0) {\n\t\ttime_start = time_prev = time_now;\n\t\treturn;\n\t}\n\t/* print progress after 1m then once per 5m */\n\tif (time_now - time_prev < 5 * 60)\n\t\treturn;\n\ttime_prev = time_now;\n\telapsed = time_now - time_start;\n\tprocessed = current_lineno - start_lineno;\n\tremaining = end_lineno - current_lineno;\n\tnum_to_process = end_lineno - start_lineno;\n\ttime_per_line = (double)elapsed / processed;\n\t/* if we don't know how many we're processing just report count+time */\n\ttime(&time_now);\n\tif (end_lineno == ULONG_MAX) {\n\t\tlogit(\"%.24s processed %lu in %s\", ctime(&time_now),\n\t\t    processed, fmt_time(elapsed));\n\t\treturn;\n\t}\n\tpercent = 100 * processed / num_to_process;\n\teta = time_per_line * remaining;\n\teta_str = xstrdup(fmt_time(eta));\n\tlogit(\"%.24s processed %lu of %lu (%lu%%) in %s, ETA %s\",\n\t    ctime(&time_now), processed, num_to_process, percent,\n\t    fmt_time(elapsed), eta_str);\n\tfree(eta_str);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"dh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <openssl/dh.h>",
      "#include <openssl/bn.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "eta_str"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%.24s processed %lu of %lu (%lu%%) in %s, ETA %s\"",
            "ctime(&time_now)",
            "processed",
            "num_to_process",
            "percent",
            "fmt_time(elapsed)",
            "eta_str"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmt_time",
          "args": [
            "elapsed"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
          "lines": "512-526",
          "snippet": "static char *\nfmt_time(time_t seconds)\n{\n\tint day, hr, min;\n\tstatic char buf[128];\n\n\tmin = (seconds / 60) % 60;\n\thr = (seconds / 60 / 60) % 24;\n\tday = seconds / 60 / 60 / 24;\n\tif (day > 0)\n\t\tsnprintf(buf, sizeof buf, \"%dd %d:%02d\", day, hr, min);\n\telse\n\t\tsnprintf(buf, sizeof buf, \"%d:%02d\", hr, min);\n\treturn buf;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"dh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nfmt_time(time_t seconds)\n{\n\tint day, hr, min;\n\tstatic char buf[128];\n\n\tmin = (seconds / 60) % 60;\n\thr = (seconds / 60 / 60) % 24;\n\tday = seconds / 60 / 60 / 24;\n\tif (day > 0)\n\t\tsnprintf(buf, sizeof buf, \"%dd %d:%02d\", day, hr, min);\n\telse\n\t\tsnprintf(buf, sizeof buf, \"%d:%02d\", hr, min);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctime",
          "args": [
            "&time_now"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "fmt_time(eta)"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctime",
          "args": [
            "&time_now"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nprint_progress(unsigned long start_lineno, unsigned long current_lineno,\n    unsigned long end_lineno)\n{\n\tstatic time_t time_start, time_prev;\n\ttime_t time_now, elapsed;\n\tunsigned long num_to_process, processed, remaining, percent, eta;\n\tdouble time_per_line;\n\tchar *eta_str;\n\n\ttime_now = monotime();\n\tif (time_start == 0) {\n\t\ttime_start = time_prev = time_now;\n\t\treturn;\n\t}\n\t/* print progress after 1m then once per 5m */\n\tif (time_now - time_prev < 5 * 60)\n\t\treturn;\n\ttime_prev = time_now;\n\telapsed = time_now - time_start;\n\tprocessed = current_lineno - start_lineno;\n\tremaining = end_lineno - current_lineno;\n\tnum_to_process = end_lineno - start_lineno;\n\ttime_per_line = (double)elapsed / processed;\n\t/* if we don't know how many we're processing just report count+time */\n\ttime(&time_now);\n\tif (end_lineno == ULONG_MAX) {\n\t\tlogit(\"%.24s processed %lu in %s\", ctime(&time_now),\n\t\t    processed, fmt_time(elapsed));\n\t\treturn;\n\t}\n\tpercent = 100 * processed / num_to_process;\n\teta = time_per_line * remaining;\n\teta_str = xstrdup(fmt_time(eta));\n\tlogit(\"%.24s processed %lu of %lu (%lu%%) in %s, ETA %s\",\n\t    ctime(&time_now), processed, num_to_process, percent,\n\t    fmt_time(elapsed), eta_str);\n\tfree(eta_str);\n}"
  },
  {
    "function_name": "fmt_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
    "lines": "512-526",
    "snippet": "static char *\nfmt_time(time_t seconds)\n{\n\tint day, hr, min;\n\tstatic char buf[128];\n\n\tmin = (seconds / 60) % 60;\n\thr = (seconds / 60 / 60) % 24;\n\tday = seconds / 60 / 60 / 24;\n\tif (day > 0)\n\t\tsnprintf(buf, sizeof buf, \"%dd %d:%02d\", day, hr, min);\n\telse\n\t\tsnprintf(buf, sizeof buf, \"%d:%02d\", hr, min);\n\treturn buf;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"dh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <openssl/dh.h>",
      "#include <openssl/bn.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof buf",
            "\"%d:%02d\"",
            "hr",
            "min"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nfmt_time(time_t seconds)\n{\n\tint day, hr, min;\n\tstatic char buf[128];\n\n\tmin = (seconds / 60) % 60;\n\thr = (seconds / 60 / 60) % 24;\n\tday = seconds / 60 / 60 / 24;\n\tif (day > 0)\n\t\tsnprintf(buf, sizeof buf, \"%dd %d:%02d\", day, hr, min);\n\telse\n\t\tsnprintf(buf, sizeof buf, \"%d:%02d\", hr, min);\n\treturn buf;\n}"
  },
  {
    "function_name": "count_lines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
    "lines": "495-510",
    "snippet": "static unsigned long\ncount_lines(FILE *f)\n{\n\tunsigned long count = 0;\n\tchar lp[QLINESIZE + 1];\n\n\tif (fseek(f, 0, SEEK_SET) != 0) {\n\t\tdebug(\"input file is not seekable\");\n\t\treturn ULONG_MAX;\n\t}\n\twhile (fgets(lp, QLINESIZE + 1, f) != NULL)\n\t\tcount++;\n\trewind(f);\n\tdebug(\"input file has %lu lines\", count);\n\treturn count;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"dh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <openssl/dh.h>",
      "#include <openssl/bn.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define QLINESIZE\t\t(100+8192)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"input file has %lu lines\"",
            "count"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rewind",
          "args": [
            "f"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "lp",
            "QLINESIZE + 1",
            "f"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "f",
            "0",
            "SEEK_SET"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define QLINESIZE\t\t(100+8192)\n\nstatic unsigned long\ncount_lines(FILE *f)\n{\n\tunsigned long count = 0;\n\tchar lp[QLINESIZE + 1];\n\n\tif (fseek(f, 0, SEEK_SET) != 0) {\n\t\tdebug(\"input file is not seekable\");\n\t\treturn ULONG_MAX;\n\t}\n\twhile (fgets(lp, QLINESIZE + 1, f) != NULL)\n\t\tcount++;\n\trewind(f);\n\tdebug(\"input file has %lu lines\", count);\n\treturn count;\n}"
  },
  {
    "function_name": "read_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
    "lines": "479-493",
    "snippet": "static unsigned long\nread_checkpoint(char *cpfile)\n{\n\tFILE *fp;\n\tunsigned long lineno = 0;\n\n\tif ((fp = fopen(cpfile, \"r\")) == NULL)\n\t\treturn 0;\n\tif (fscanf(fp, \"%lu\\n\", &lineno) < 1)\n\t\tlogit(\"Failed to load checkpoint from '%s'\", cpfile);\n\telse\n\t\tlogit(\"Loaded checkpoint from '%s' line %lu\", cpfile, lineno);\n\tfclose(fp);\n\treturn lineno;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"dh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <openssl/dh.h>",
      "#include <openssl/bn.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Loaded checkpoint from '%s' line %lu\"",
            "cpfile",
            "lineno"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "fp",
            "\"%lu\\n\"",
            "&lineno"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "cpfile",
            "\"r\""
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic unsigned long\nread_checkpoint(char *cpfile)\n{\n\tFILE *fp;\n\tunsigned long lineno = 0;\n\n\tif ((fp = fopen(cpfile, \"r\")) == NULL)\n\t\treturn 0;\n\tif (fscanf(fp, \"%lu\\n\", &lineno) < 1)\n\t\tlogit(\"Failed to load checkpoint from '%s'\", cpfile);\n\telse\n\t\tlogit(\"Loaded checkpoint from '%s' line %lu\", cpfile, lineno);\n\tfclose(fp);\n\treturn lineno;\n}"
  },
  {
    "function_name": "write_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
    "lines": "448-477",
    "snippet": "static void\nwrite_checkpoint(char *cpfile, u_int32_t lineno)\n{\n\tFILE *fp;\n\tchar tmp[PATH_MAX];\n\tint r;\n\n\tr = snprintf(tmp, sizeof(tmp), \"%s.XXXXXXXXXX\", cpfile);\n\tif (r == -1 || r >= PATH_MAX) {\n\t\tlogit(\"write_checkpoint: temp pathname too long\");\n\t\treturn;\n\t}\n\tif ((r = mkstemp(tmp)) == -1) {\n\t\tlogit(\"mkstemp(%s): %s\", tmp, strerror(errno));\n\t\treturn;\n\t}\n\tif ((fp = fdopen(r, \"w\")) == NULL) {\n\t\tlogit(\"write_checkpoint: fdopen: %s\", strerror(errno));\n\t\tunlink(tmp);\n\t\tclose(r);\n\t\treturn;\n\t}\n\tif (fprintf(fp, \"%lu\\n\", (unsigned long)lineno) > 0 && fclose(fp) == 0\n\t    && rename(tmp, cpfile) == 0)\n\t\tdebug3(\"wrote checkpoint line %lu to '%s'\",\n\t\t    (unsigned long)lineno, cpfile);\n\telse\n\t\tlogit(\"failed to write to checkpoint file '%s': %s\", cpfile,\n\t\t    strerror(errno));\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"dh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <openssl/dh.h>",
      "#include <openssl/bn.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"failed to write to checkpoint file '%s': %s\"",
            "cpfile",
            "strerror(errno)"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"wrote checkpoint line %lu to '%s'\"",
            "(unsigned long)lineno",
            "cpfile"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "tmp",
            "cpfile"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"%lu\\n\"",
            "(unsigned long)lineno"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "r"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "r",
            "\"w\""
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmp"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "mkstemp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
          "lines": "120-124",
          "snippet": "int\nmkstemp(char *path)\n{\n\treturn(mktemp_internal(path, 0, MKTEMP_FILE));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MKTEMP_FILE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MKTEMP_FILE\t1\n\nint\nmkstemp(char *path)\n{\n\treturn(mktemp_internal(path, 0, MKTEMP_FILE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmp",
            "sizeof(tmp)",
            "\"%s.XXXXXXXXXX\"",
            "cpfile"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nwrite_checkpoint(char *cpfile, u_int32_t lineno)\n{\n\tFILE *fp;\n\tchar tmp[PATH_MAX];\n\tint r;\n\n\tr = snprintf(tmp, sizeof(tmp), \"%s.XXXXXXXXXX\", cpfile);\n\tif (r == -1 || r >= PATH_MAX) {\n\t\tlogit(\"write_checkpoint: temp pathname too long\");\n\t\treturn;\n\t}\n\tif ((r = mkstemp(tmp)) == -1) {\n\t\tlogit(\"mkstemp(%s): %s\", tmp, strerror(errno));\n\t\treturn;\n\t}\n\tif ((fp = fdopen(r, \"w\")) == NULL) {\n\t\tlogit(\"write_checkpoint: fdopen: %s\", strerror(errno));\n\t\tunlink(tmp);\n\t\tclose(r);\n\t\treturn;\n\t}\n\tif (fprintf(fp, \"%lu\\n\", (unsigned long)lineno) > 0 && fclose(fp) == 0\n\t    && rename(tmp, cpfile) == 0)\n\t\tdebug3(\"wrote checkpoint line %lu to '%s'\",\n\t\t    (unsigned long)lineno, cpfile);\n\telse\n\t\tlogit(\"failed to write to checkpoint file '%s': %s\", cpfile,\n\t\t    strerror(errno));\n}"
  },
  {
    "function_name": "gen_candidates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
    "lines": "242-446",
    "snippet": "int\ngen_candidates(FILE *out, u_int32_t memory, u_int32_t power, BIGNUM *start)\n{\n\tBIGNUM *q;\n\tu_int32_t j, r, s, t;\n\tu_int32_t smallwords = TINY_NUMBER >> 6;\n\tu_int32_t tinywords = TINY_NUMBER >> 6;\n\ttime_t time_start, time_stop;\n\tu_int32_t i;\n\tint ret = 0;\n\n\tlargememory = memory;\n\n\tif (memory != 0 &&\n\t    (memory < LARGE_MINIMUM || memory > LARGE_MAXIMUM)) {\n\t\terror(\"Invalid memory amount (min %ld, max %ld)\",\n\t\t    LARGE_MINIMUM, LARGE_MAXIMUM);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Set power to the length in bits of the prime to be generated.\n\t * This is changed to 1 less than the desired safe prime moduli p.\n\t */\n\tif (power > TEST_MAXIMUM) {\n\t\terror(\"Too many bits: %u > %lu\", power, TEST_MAXIMUM);\n\t\treturn (-1);\n\t} else if (power < TEST_MINIMUM) {\n\t\terror(\"Too few bits: %u < %u\", power, TEST_MINIMUM);\n\t\treturn (-1);\n\t}\n\tpower--; /* decrement before squaring */\n\n\t/*\n\t * The density of ordinary primes is on the order of 1/bits, so the\n\t * density of safe primes should be about (1/bits)**2. Set test range\n\t * to something well above bits**2 to be reasonably sure (but not\n\t * guaranteed) of catching at least one safe prime.\n\t */\n\tlargewords = ((power * power) >> (SHIFT_WORD - TEST_POWER));\n\n\t/*\n\t * Need idea of how much memory is available. We don't have to use all\n\t * of it.\n\t */\n\tif (largememory > LARGE_MAXIMUM) {\n\t\tlogit(\"Limited memory: %u MB; limit %lu MB\",\n\t\t    largememory, LARGE_MAXIMUM);\n\t\tlargememory = LARGE_MAXIMUM;\n\t}\n\n\tif (largewords <= (largememory << SHIFT_MEGAWORD)) {\n\t\tlogit(\"Increased memory: %u MB; need %u bytes\",\n\t\t    largememory, (largewords << SHIFT_BYTE));\n\t\tlargewords = (largememory << SHIFT_MEGAWORD);\n\t} else if (largememory > 0) {\n\t\tlogit(\"Decreased memory: %u MB; want %u bytes\",\n\t\t    largememory, (largewords << SHIFT_BYTE));\n\t\tlargewords = (largememory << SHIFT_MEGAWORD);\n\t}\n\n\tTinySieve = xcalloc(tinywords, sizeof(u_int32_t));\n\ttinybits = tinywords << SHIFT_WORD;\n\n\tSmallSieve = xcalloc(smallwords, sizeof(u_int32_t));\n\tsmallbits = smallwords << SHIFT_WORD;\n\n\t/*\n\t * dynamically determine available memory\n\t */\n\twhile ((LargeSieve = calloc(largewords, sizeof(u_int32_t))) == NULL)\n\t\tlargewords -= (1L << (SHIFT_MEGAWORD - 2)); /* 1/4 MB chunks */\n\n\tlargebits = largewords << SHIFT_WORD;\n\tlargenumbers = largebits * 2;\t/* even numbers excluded */\n\n\t/* validation check: count the number of primes tried */\n\tlargetries = 0;\n\tif ((q = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\n\t/*\n\t * Generate random starting point for subprime search, or use\n\t * specified parameter.\n\t */\n\tif ((largebase = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\tif (start == NULL) {\n\t\tif (BN_rand(largebase, power, 1, 1) == 0)\n\t\t\tfatal(\"BN_rand failed\");\n\t} else {\n\t\tif (BN_copy(largebase, start) == NULL)\n\t\t\tfatal(\"BN_copy: failed\");\n\t}\n\n\t/* ensure odd */\n\tif (BN_set_bit(largebase, 0) == 0)\n\t\tfatal(\"BN_set_bit: failed\");\n\n\ttime(&time_start);\n\n\tlogit(\"%.24s Sieve next %u plus %u-bit\", ctime(&time_start),\n\t    largenumbers, power);\n\tdebug2(\"start point: 0x%s\", BN_bn2hex(largebase));\n\n\t/*\n\t * TinySieve\n\t */\n\tfor (i = 0; i < tinybits; i++) {\n\t\tif (BIT_TEST(TinySieve, i))\n\t\t\tcontinue; /* 2*i+3 is composite */\n\n\t\t/* The next tiny prime */\n\t\tt = 2 * i + 3;\n\n\t\t/* Mark all multiples of t */\n\t\tfor (j = i + t; j < tinybits; j += t)\n\t\t\tBIT_SET(TinySieve, j);\n\n\t\tsieve_large(t);\n\t}\n\n\t/*\n\t * Start the small block search at the next possible prime. To avoid\n\t * fencepost errors, the last pass is skipped.\n\t */\n\tfor (smallbase = TINY_NUMBER + 3;\n\t    smallbase < (SMALL_MAXIMUM - TINY_NUMBER);\n\t    smallbase += TINY_NUMBER) {\n\t\tfor (i = 0; i < tinybits; i++) {\n\t\t\tif (BIT_TEST(TinySieve, i))\n\t\t\t\tcontinue; /* 2*i+3 is composite */\n\n\t\t\t/* The next tiny prime */\n\t\t\tt = 2 * i + 3;\n\t\t\tr = smallbase % t;\n\n\t\t\tif (r == 0) {\n\t\t\t\ts = 0; /* t divides into smallbase exactly */\n\t\t\t} else {\n\t\t\t\t/* smallbase+s is first entry divisible by t */\n\t\t\t\ts = t - r;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The sieve omits even numbers, so ensure that\n\t\t\t * smallbase+s is odd. Then, step through the sieve\n\t\t\t * in increments of 2*t\n\t\t\t */\n\t\t\tif (s & 1)\n\t\t\t\ts += t; /* Make smallbase+s odd, and s even */\n\n\t\t\t/* Mark all multiples of 2*t */\n\t\t\tfor (s /= 2; s < smallbits; s += t)\n\t\t\t\tBIT_SET(SmallSieve, s);\n\t\t}\n\n\t\t/*\n\t\t * SmallSieve\n\t\t */\n\t\tfor (i = 0; i < smallbits; i++) {\n\t\t\tif (BIT_TEST(SmallSieve, i))\n\t\t\t\tcontinue; /* 2*i+smallbase is composite */\n\n\t\t\t/* The next small prime */\n\t\t\tsieve_large((2 * i) + smallbase);\n\t\t}\n\n\t\tmemset(SmallSieve, 0, smallwords << SHIFT_BYTE);\n\t}\n\n\ttime(&time_stop);\n\n\tlogit(\"%.24s Sieved with %u small primes in %lld seconds\",\n\t    ctime(&time_stop), largetries, (long long)(time_stop - time_start));\n\n\tfor (j = r = 0; j < largebits; j++) {\n\t\tif (BIT_TEST(LargeSieve, j))\n\t\t\tcontinue; /* Definitely composite, skip */\n\n\t\tdebug2(\"test q = largebase+%u\", 2 * j);\n\t\tif (BN_set_word(q, 2 * j) == 0)\n\t\t\tfatal(\"BN_set_word failed\");\n\t\tif (BN_add(q, q, largebase) == 0)\n\t\t\tfatal(\"BN_add failed\");\n\t\tif (qfileout(out, MODULI_TYPE_SOPHIE_GERMAIN,\n\t\t    MODULI_TESTS_SIEVE, largetries,\n\t\t    (power - 1) /* MSB */, (0), q) == -1) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tr++; /* count q */\n\t}\n\n\ttime(&time_stop);\n\n\tfree(LargeSieve);\n\tfree(SmallSieve);\n\tfree(TinySieve);\n\n\tlogit(\"%.24s Found %u candidates\", ctime(&time_stop), r);\n\n\treturn (ret);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"dh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <openssl/dh.h>",
      "#include <openssl/bn.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define TEST_POWER\t(3)\t/* 2**n, n < SHIFT_WORD */",
      "#define TEST_MINIMUM\t(QSIZE_MINIMUM + 1)",
      "#define TEST_MAXIMUM\t(1UL<<16)",
      "#define TINY_NUMBER\t(1UL<<16)",
      "#define SMALL_MAXIMUM\t(0xffffffffUL)",
      "#define LARGE_MAXIMUM\t(127UL)\t/* megabytes */",
      "#define LARGE_MINIMUM\t(8UL)\t/* megabytes */",
      "#define SHIFT_MEGAWORD\t(SHIFT_MEGABYTE-SHIFT_BYTE)",
      "#define SHIFT_WORD\t(SHIFT_BIT+SHIFT_BYTE)",
      "#define SHIFT_BYTE\t(2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%.24s Found %u candidates\"",
            "ctime(&time_stop)",
            "r"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctime",
          "args": [
            "&time_stop"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "TinySieve"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "&time_stop"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
          "lines": "512-526",
          "snippet": "static char *\nfmt_time(time_t seconds)\n{\n\tint day, hr, min;\n\tstatic char buf[128];\n\n\tmin = (seconds / 60) % 60;\n\thr = (seconds / 60 / 60) % 24;\n\tday = seconds / 60 / 60 / 24;\n\tif (day > 0)\n\t\tsnprintf(buf, sizeof buf, \"%dd %d:%02d\", day, hr, min);\n\telse\n\t\tsnprintf(buf, sizeof buf, \"%d:%02d\", hr, min);\n\treturn buf;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"dh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nfmt_time(time_t seconds)\n{\n\tint day, hr, min;\n\tstatic char buf[128];\n\n\tmin = (seconds / 60) % 60;\n\thr = (seconds / 60 / 60) % 24;\n\tday = seconds / 60 / 60 / 24;\n\tif (day > 0)\n\t\tsnprintf(buf, sizeof buf, \"%dd %d:%02d\", day, hr, min);\n\telse\n\t\tsnprintf(buf, sizeof buf, \"%d:%02d\", hr, min);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qfileout",
          "args": [
            "out",
            "MODULI_TYPE_SOPHIE_GERMAIN",
            "MODULI_TESTS_SIEVE",
            "largetries",
            "(power - 1)/* MSB */",
            "(0)",
            "q"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "qfileout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
          "lines": "152-178",
          "snippet": "static int\nqfileout(FILE * ofile, u_int32_t otype, u_int32_t otests, u_int32_t otries,\n    u_int32_t osize, u_int32_t ogenerator, BIGNUM * omodulus)\n{\n\tstruct tm *gtm;\n\ttime_t time_now;\n\tint res;\n\n\ttime(&time_now);\n\tgtm = gmtime(&time_now);\n\n\tres = fprintf(ofile, \"%04d%02d%02d%02d%02d%02d %u %u %u %u %x \",\n\t    gtm->tm_year + 1900, gtm->tm_mon + 1, gtm->tm_mday,\n\t    gtm->tm_hour, gtm->tm_min, gtm->tm_sec,\n\t    otype, otests, otries, osize, ogenerator);\n\n\tif (res < 0)\n\t\treturn (-1);\n\n\tif (BN_print_fp(ofile, omodulus) < 1)\n\t\treturn (-1);\n\n\tres = fprintf(ofile, \"\\n\");\n\tfflush(ofile);\n\n\treturn (res > 0 ? 0 : -1);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"dh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nqfileout(FILE * ofile, u_int32_t otype, u_int32_t otests, u_int32_t otries,\n    u_int32_t osize, u_int32_t ogenerator, BIGNUM * omodulus)\n{\n\tstruct tm *gtm;\n\ttime_t time_now;\n\tint res;\n\n\ttime(&time_now);\n\tgtm = gmtime(&time_now);\n\n\tres = fprintf(ofile, \"%04d%02d%02d%02d%02d%02d %u %u %u %u %x \",\n\t    gtm->tm_year + 1900, gtm->tm_mon + 1, gtm->tm_mday,\n\t    gtm->tm_hour, gtm->tm_min, gtm->tm_sec,\n\t    otype, otests, otries, osize, ogenerator);\n\n\tif (res < 0)\n\t\treturn (-1);\n\n\tif (BN_print_fp(ofile, omodulus) < 1)\n\t\treturn (-1);\n\n\tres = fprintf(ofile, \"\\n\");\n\tfflush(ofile);\n\n\treturn (res > 0 ? 0 : -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"BN_add failed\""
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_add",
          "args": [
            "q",
            "q",
            "largebase"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_set_word",
          "args": [
            "q",
            "2 * j"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"test q = largebase+%u\"",
            "2 * j"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BIT_TEST",
          "args": [
            "LargeSieve",
            "j"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctime",
          "args": [
            "&time_stop"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "SmallSieve",
            "0",
            "smallwords << SHIFT_BYTE"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sieve_large",
          "args": [
            "(2 * i) + smallbase"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "sieve_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
          "lines": "184-235",
          "snippet": "static void\nsieve_large(u_int32_t s)\n{\n\tu_int32_t r, u;\n\n\tdebug3(\"sieve_large %u\", s);\n\tlargetries++;\n\t/* r = largebase mod s */\n\tr = BN_mod_word(largebase, s);\n\tif (r == 0)\n\t\tu = 0; /* s divides into largebase exactly */\n\telse\n\t\tu = s - r; /* largebase+u is first entry divisible by s */\n\n\tif (u < largebits * 2) {\n\t\t/*\n\t\t * The sieve omits p's and q's divisible by 2, so ensure that\n\t\t * largebase+u is odd. Then, step through the sieve in\n\t\t * increments of 2*s\n\t\t */\n\t\tif (u & 0x1)\n\t\t\tu += s; /* Make largebase+u odd, and u even */\n\n\t\t/* Mark all multiples of 2*s */\n\t\tfor (u /= 2; u < largebits; u += s)\n\t\t\tBIT_SET(LargeSieve, u);\n\t}\n\n\t/* r = p mod s */\n\tr = (2 * r + 1) % s;\n\tif (r == 0)\n\t\tu = 0; /* s divides p exactly */\n\telse\n\t\tu = s - r; /* p+u is first entry divisible by s */\n\n\tif (u < largebits * 4) {\n\t\t/*\n\t\t * The sieve omits p's divisible by 4, so ensure that\n\t\t * largebase+u is not. Then, step through the sieve in\n\t\t * increments of 4*s\n\t\t */\n\t\twhile (u & 0x3) {\n\t\t\tif (SMALL_MAXIMUM - u < s)\n\t\t\t\treturn;\n\t\t\tu += s;\n\t\t}\n\n\t\t/* Mark all multiples of 4*s */\n\t\tfor (u /= 4; u < largebits; u += s)\n\t\t\tBIT_SET(LargeSieve, u);\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"dh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SMALL_MAXIMUM\t(0xffffffffUL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SMALL_MAXIMUM\t(0xffffffffUL)\n\nstatic void\nsieve_large(u_int32_t s)\n{\n\tu_int32_t r, u;\n\n\tdebug3(\"sieve_large %u\", s);\n\tlargetries++;\n\t/* r = largebase mod s */\n\tr = BN_mod_word(largebase, s);\n\tif (r == 0)\n\t\tu = 0; /* s divides into largebase exactly */\n\telse\n\t\tu = s - r; /* largebase+u is first entry divisible by s */\n\n\tif (u < largebits * 2) {\n\t\t/*\n\t\t * The sieve omits p's and q's divisible by 2, so ensure that\n\t\t * largebase+u is odd. Then, step through the sieve in\n\t\t * increments of 2*s\n\t\t */\n\t\tif (u & 0x1)\n\t\t\tu += s; /* Make largebase+u odd, and u even */\n\n\t\t/* Mark all multiples of 2*s */\n\t\tfor (u /= 2; u < largebits; u += s)\n\t\t\tBIT_SET(LargeSieve, u);\n\t}\n\n\t/* r = p mod s */\n\tr = (2 * r + 1) % s;\n\tif (r == 0)\n\t\tu = 0; /* s divides p exactly */\n\telse\n\t\tu = s - r; /* p+u is first entry divisible by s */\n\n\tif (u < largebits * 4) {\n\t\t/*\n\t\t * The sieve omits p's divisible by 4, so ensure that\n\t\t * largebase+u is not. Then, step through the sieve in\n\t\t * increments of 4*s\n\t\t */\n\t\twhile (u & 0x3) {\n\t\t\tif (SMALL_MAXIMUM - u < s)\n\t\t\t\treturn;\n\t\t\tu += s;\n\t\t}\n\n\t\t/* Mark all multiples of 4*s */\n\t\tfor (u /= 4; u < largebits; u += s)\n\t\t\tBIT_SET(LargeSieve, u);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BIT_TEST",
          "args": [
            "SmallSieve",
            "i"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT_SET",
          "args": [
            "SmallSieve",
            "s"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT_TEST",
          "args": [
            "TinySieve",
            "i"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT_SET",
          "args": [
            "TinySieve",
            "j"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT_TEST",
          "args": [
            "TinySieve",
            "i"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_bn2hex",
          "args": [
            "largebase"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctime",
          "args": [
            "&time_start"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_set_bit",
          "args": [
            "largebase",
            "0"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_copy",
          "args": [
            "largebase",
            "start"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_rand",
          "args": [
            "largebase",
            "power",
            "1",
            "1"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "largewords",
            "sizeof(u_int32_t)"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Too few bits: %u < %u\"",
            "power",
            "TEST_MINIMUM"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define TEST_POWER\t(3)\t/* 2**n, n < SHIFT_WORD */\n#define TEST_MINIMUM\t(QSIZE_MINIMUM + 1)\n#define TEST_MAXIMUM\t(1UL<<16)\n#define TINY_NUMBER\t(1UL<<16)\n#define SMALL_MAXIMUM\t(0xffffffffUL)\n#define LARGE_MAXIMUM\t(127UL)\t/* megabytes */\n#define LARGE_MINIMUM\t(8UL)\t/* megabytes */\n#define SHIFT_MEGAWORD\t(SHIFT_MEGABYTE-SHIFT_BYTE)\n#define SHIFT_WORD\t(SHIFT_BIT+SHIFT_BYTE)\n#define SHIFT_BYTE\t(2)\n\nint\ngen_candidates(FILE *out, u_int32_t memory, u_int32_t power, BIGNUM *start)\n{\n\tBIGNUM *q;\n\tu_int32_t j, r, s, t;\n\tu_int32_t smallwords = TINY_NUMBER >> 6;\n\tu_int32_t tinywords = TINY_NUMBER >> 6;\n\ttime_t time_start, time_stop;\n\tu_int32_t i;\n\tint ret = 0;\n\n\tlargememory = memory;\n\n\tif (memory != 0 &&\n\t    (memory < LARGE_MINIMUM || memory > LARGE_MAXIMUM)) {\n\t\terror(\"Invalid memory amount (min %ld, max %ld)\",\n\t\t    LARGE_MINIMUM, LARGE_MAXIMUM);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Set power to the length in bits of the prime to be generated.\n\t * This is changed to 1 less than the desired safe prime moduli p.\n\t */\n\tif (power > TEST_MAXIMUM) {\n\t\terror(\"Too many bits: %u > %lu\", power, TEST_MAXIMUM);\n\t\treturn (-1);\n\t} else if (power < TEST_MINIMUM) {\n\t\terror(\"Too few bits: %u < %u\", power, TEST_MINIMUM);\n\t\treturn (-1);\n\t}\n\tpower--; /* decrement before squaring */\n\n\t/*\n\t * The density of ordinary primes is on the order of 1/bits, so the\n\t * density of safe primes should be about (1/bits)**2. Set test range\n\t * to something well above bits**2 to be reasonably sure (but not\n\t * guaranteed) of catching at least one safe prime.\n\t */\n\tlargewords = ((power * power) >> (SHIFT_WORD - TEST_POWER));\n\n\t/*\n\t * Need idea of how much memory is available. We don't have to use all\n\t * of it.\n\t */\n\tif (largememory > LARGE_MAXIMUM) {\n\t\tlogit(\"Limited memory: %u MB; limit %lu MB\",\n\t\t    largememory, LARGE_MAXIMUM);\n\t\tlargememory = LARGE_MAXIMUM;\n\t}\n\n\tif (largewords <= (largememory << SHIFT_MEGAWORD)) {\n\t\tlogit(\"Increased memory: %u MB; need %u bytes\",\n\t\t    largememory, (largewords << SHIFT_BYTE));\n\t\tlargewords = (largememory << SHIFT_MEGAWORD);\n\t} else if (largememory > 0) {\n\t\tlogit(\"Decreased memory: %u MB; want %u bytes\",\n\t\t    largememory, (largewords << SHIFT_BYTE));\n\t\tlargewords = (largememory << SHIFT_MEGAWORD);\n\t}\n\n\tTinySieve = xcalloc(tinywords, sizeof(u_int32_t));\n\ttinybits = tinywords << SHIFT_WORD;\n\n\tSmallSieve = xcalloc(smallwords, sizeof(u_int32_t));\n\tsmallbits = smallwords << SHIFT_WORD;\n\n\t/*\n\t * dynamically determine available memory\n\t */\n\twhile ((LargeSieve = calloc(largewords, sizeof(u_int32_t))) == NULL)\n\t\tlargewords -= (1L << (SHIFT_MEGAWORD - 2)); /* 1/4 MB chunks */\n\n\tlargebits = largewords << SHIFT_WORD;\n\tlargenumbers = largebits * 2;\t/* even numbers excluded */\n\n\t/* validation check: count the number of primes tried */\n\tlargetries = 0;\n\tif ((q = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\n\t/*\n\t * Generate random starting point for subprime search, or use\n\t * specified parameter.\n\t */\n\tif ((largebase = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\tif (start == NULL) {\n\t\tif (BN_rand(largebase, power, 1, 1) == 0)\n\t\t\tfatal(\"BN_rand failed\");\n\t} else {\n\t\tif (BN_copy(largebase, start) == NULL)\n\t\t\tfatal(\"BN_copy: failed\");\n\t}\n\n\t/* ensure odd */\n\tif (BN_set_bit(largebase, 0) == 0)\n\t\tfatal(\"BN_set_bit: failed\");\n\n\ttime(&time_start);\n\n\tlogit(\"%.24s Sieve next %u plus %u-bit\", ctime(&time_start),\n\t    largenumbers, power);\n\tdebug2(\"start point: 0x%s\", BN_bn2hex(largebase));\n\n\t/*\n\t * TinySieve\n\t */\n\tfor (i = 0; i < tinybits; i++) {\n\t\tif (BIT_TEST(TinySieve, i))\n\t\t\tcontinue; /* 2*i+3 is composite */\n\n\t\t/* The next tiny prime */\n\t\tt = 2 * i + 3;\n\n\t\t/* Mark all multiples of t */\n\t\tfor (j = i + t; j < tinybits; j += t)\n\t\t\tBIT_SET(TinySieve, j);\n\n\t\tsieve_large(t);\n\t}\n\n\t/*\n\t * Start the small block search at the next possible prime. To avoid\n\t * fencepost errors, the last pass is skipped.\n\t */\n\tfor (smallbase = TINY_NUMBER + 3;\n\t    smallbase < (SMALL_MAXIMUM - TINY_NUMBER);\n\t    smallbase += TINY_NUMBER) {\n\t\tfor (i = 0; i < tinybits; i++) {\n\t\t\tif (BIT_TEST(TinySieve, i))\n\t\t\t\tcontinue; /* 2*i+3 is composite */\n\n\t\t\t/* The next tiny prime */\n\t\t\tt = 2 * i + 3;\n\t\t\tr = smallbase % t;\n\n\t\t\tif (r == 0) {\n\t\t\t\ts = 0; /* t divides into smallbase exactly */\n\t\t\t} else {\n\t\t\t\t/* smallbase+s is first entry divisible by t */\n\t\t\t\ts = t - r;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The sieve omits even numbers, so ensure that\n\t\t\t * smallbase+s is odd. Then, step through the sieve\n\t\t\t * in increments of 2*t\n\t\t\t */\n\t\t\tif (s & 1)\n\t\t\t\ts += t; /* Make smallbase+s odd, and s even */\n\n\t\t\t/* Mark all multiples of 2*t */\n\t\t\tfor (s /= 2; s < smallbits; s += t)\n\t\t\t\tBIT_SET(SmallSieve, s);\n\t\t}\n\n\t\t/*\n\t\t * SmallSieve\n\t\t */\n\t\tfor (i = 0; i < smallbits; i++) {\n\t\t\tif (BIT_TEST(SmallSieve, i))\n\t\t\t\tcontinue; /* 2*i+smallbase is composite */\n\n\t\t\t/* The next small prime */\n\t\t\tsieve_large((2 * i) + smallbase);\n\t\t}\n\n\t\tmemset(SmallSieve, 0, smallwords << SHIFT_BYTE);\n\t}\n\n\ttime(&time_stop);\n\n\tlogit(\"%.24s Sieved with %u small primes in %lld seconds\",\n\t    ctime(&time_stop), largetries, (long long)(time_stop - time_start));\n\n\tfor (j = r = 0; j < largebits; j++) {\n\t\tif (BIT_TEST(LargeSieve, j))\n\t\t\tcontinue; /* Definitely composite, skip */\n\n\t\tdebug2(\"test q = largebase+%u\", 2 * j);\n\t\tif (BN_set_word(q, 2 * j) == 0)\n\t\t\tfatal(\"BN_set_word failed\");\n\t\tif (BN_add(q, q, largebase) == 0)\n\t\t\tfatal(\"BN_add failed\");\n\t\tif (qfileout(out, MODULI_TYPE_SOPHIE_GERMAIN,\n\t\t    MODULI_TESTS_SIEVE, largetries,\n\t\t    (power - 1) /* MSB */, (0), q) == -1) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tr++; /* count q */\n\t}\n\n\ttime(&time_stop);\n\n\tfree(LargeSieve);\n\tfree(SmallSieve);\n\tfree(TinySieve);\n\n\tlogit(\"%.24s Found %u candidates\", ctime(&time_stop), r);\n\n\treturn (ret);\n}"
  },
  {
    "function_name": "sieve_large",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
    "lines": "184-235",
    "snippet": "static void\nsieve_large(u_int32_t s)\n{\n\tu_int32_t r, u;\n\n\tdebug3(\"sieve_large %u\", s);\n\tlargetries++;\n\t/* r = largebase mod s */\n\tr = BN_mod_word(largebase, s);\n\tif (r == 0)\n\t\tu = 0; /* s divides into largebase exactly */\n\telse\n\t\tu = s - r; /* largebase+u is first entry divisible by s */\n\n\tif (u < largebits * 2) {\n\t\t/*\n\t\t * The sieve omits p's and q's divisible by 2, so ensure that\n\t\t * largebase+u is odd. Then, step through the sieve in\n\t\t * increments of 2*s\n\t\t */\n\t\tif (u & 0x1)\n\t\t\tu += s; /* Make largebase+u odd, and u even */\n\n\t\t/* Mark all multiples of 2*s */\n\t\tfor (u /= 2; u < largebits; u += s)\n\t\t\tBIT_SET(LargeSieve, u);\n\t}\n\n\t/* r = p mod s */\n\tr = (2 * r + 1) % s;\n\tif (r == 0)\n\t\tu = 0; /* s divides p exactly */\n\telse\n\t\tu = s - r; /* p+u is first entry divisible by s */\n\n\tif (u < largebits * 4) {\n\t\t/*\n\t\t * The sieve omits p's divisible by 4, so ensure that\n\t\t * largebase+u is not. Then, step through the sieve in\n\t\t * increments of 4*s\n\t\t */\n\t\twhile (u & 0x3) {\n\t\t\tif (SMALL_MAXIMUM - u < s)\n\t\t\t\treturn;\n\t\t\tu += s;\n\t\t}\n\n\t\t/* Mark all multiples of 4*s */\n\t\tfor (u /= 4; u < largebits; u += s)\n\t\t\tBIT_SET(LargeSieve, u);\n\t}\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"dh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <openssl/dh.h>",
      "#include <openssl/bn.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SMALL_MAXIMUM\t(0xffffffffUL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BIT_SET",
          "args": [
            "LargeSieve",
            "u"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT_SET",
          "args": [
            "LargeSieve",
            "u"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_mod_word",
          "args": [
            "largebase",
            "s"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"sieve_large %u\"",
            "s"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SMALL_MAXIMUM\t(0xffffffffUL)\n\nstatic void\nsieve_large(u_int32_t s)\n{\n\tu_int32_t r, u;\n\n\tdebug3(\"sieve_large %u\", s);\n\tlargetries++;\n\t/* r = largebase mod s */\n\tr = BN_mod_word(largebase, s);\n\tif (r == 0)\n\t\tu = 0; /* s divides into largebase exactly */\n\telse\n\t\tu = s - r; /* largebase+u is first entry divisible by s */\n\n\tif (u < largebits * 2) {\n\t\t/*\n\t\t * The sieve omits p's and q's divisible by 2, so ensure that\n\t\t * largebase+u is odd. Then, step through the sieve in\n\t\t * increments of 2*s\n\t\t */\n\t\tif (u & 0x1)\n\t\t\tu += s; /* Make largebase+u odd, and u even */\n\n\t\t/* Mark all multiples of 2*s */\n\t\tfor (u /= 2; u < largebits; u += s)\n\t\t\tBIT_SET(LargeSieve, u);\n\t}\n\n\t/* r = p mod s */\n\tr = (2 * r + 1) % s;\n\tif (r == 0)\n\t\tu = 0; /* s divides p exactly */\n\telse\n\t\tu = s - r; /* p+u is first entry divisible by s */\n\n\tif (u < largebits * 4) {\n\t\t/*\n\t\t * The sieve omits p's divisible by 4, so ensure that\n\t\t * largebase+u is not. Then, step through the sieve in\n\t\t * increments of 4*s\n\t\t */\n\t\twhile (u & 0x3) {\n\t\t\tif (SMALL_MAXIMUM - u < s)\n\t\t\t\treturn;\n\t\t\tu += s;\n\t\t}\n\n\t\t/* Mark all multiples of 4*s */\n\t\tfor (u /= 4; u < largebits; u += s)\n\t\t\tBIT_SET(LargeSieve, u);\n\t}\n}"
  },
  {
    "function_name": "qfileout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
    "lines": "152-178",
    "snippet": "static int\nqfileout(FILE * ofile, u_int32_t otype, u_int32_t otests, u_int32_t otries,\n    u_int32_t osize, u_int32_t ogenerator, BIGNUM * omodulus)\n{\n\tstruct tm *gtm;\n\ttime_t time_now;\n\tint res;\n\n\ttime(&time_now);\n\tgtm = gmtime(&time_now);\n\n\tres = fprintf(ofile, \"%04d%02d%02d%02d%02d%02d %u %u %u %u %x \",\n\t    gtm->tm_year + 1900, gtm->tm_mon + 1, gtm->tm_mday,\n\t    gtm->tm_hour, gtm->tm_min, gtm->tm_sec,\n\t    otype, otests, otries, osize, ogenerator);\n\n\tif (res < 0)\n\t\treturn (-1);\n\n\tif (BN_print_fp(ofile, omodulus) < 1)\n\t\treturn (-1);\n\n\tres = fprintf(ofile, \"\\n\");\n\tfflush(ofile);\n\n\treturn (res > 0 ? 0 : -1);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"dh.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <openssl/dh.h>",
      "#include <openssl/bn.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "ofile"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "_ssh_compat_fflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "314-326",
          "snippet": "int _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ofile",
            "\"\\n\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_print_fp",
          "args": [
            "ofile",
            "omodulus"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ofile",
            "\"%04d%02d%02d%02d%02d%02d %u %u %u %u %x \"",
            "gtm->tm_year + 1900",
            "gtm->tm_mon + 1",
            "gtm->tm_mday",
            "gtm->tm_hour",
            "gtm->tm_min",
            "gtm->tm_sec",
            "otype",
            "otests",
            "otries",
            "osize",
            "ogenerator"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gmtime",
          "args": [
            "&time_now"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "&time_now"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
          "lines": "512-526",
          "snippet": "static char *\nfmt_time(time_t seconds)\n{\n\tint day, hr, min;\n\tstatic char buf[128];\n\n\tmin = (seconds / 60) % 60;\n\thr = (seconds / 60 / 60) % 24;\n\tday = seconds / 60 / 60 / 24;\n\tif (day > 0)\n\t\tsnprintf(buf, sizeof buf, \"%dd %d:%02d\", day, hr, min);\n\telse\n\t\tsnprintf(buf, sizeof buf, \"%d:%02d\", hr, min);\n\treturn buf;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"dh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nfmt_time(time_t seconds)\n{\n\tint day, hr, min;\n\tstatic char buf[128];\n\n\tmin = (seconds / 60) % 60;\n\thr = (seconds / 60 / 60) % 24;\n\tday = seconds / 60 / 60 / 24;\n\tif (day > 0)\n\t\tsnprintf(buf, sizeof buf, \"%dd %d:%02d\", day, hr, min);\n\telse\n\t\tsnprintf(buf, sizeof buf, \"%d:%02d\", hr, min);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nqfileout(FILE * ofile, u_int32_t otype, u_int32_t otests, u_int32_t otries,\n    u_int32_t osize, u_int32_t ogenerator, BIGNUM * omodulus)\n{\n\tstruct tm *gtm;\n\ttime_t time_now;\n\tint res;\n\n\ttime(&time_now);\n\tgtm = gmtime(&time_now);\n\n\tres = fprintf(ofile, \"%04d%02d%02d%02d%02d%02d %u %u %u %u %x \",\n\t    gtm->tm_year + 1900, gtm->tm_mon + 1, gtm->tm_mday,\n\t    gtm->tm_hour, gtm->tm_min, gtm->tm_sec,\n\t    otype, otests, otries, osize, ogenerator);\n\n\tif (res < 0)\n\t\treturn (-1);\n\n\tif (BN_print_fp(ofile, omodulus) < 1)\n\t\treturn (-1);\n\n\tres = fprintf(ofile, \"\\n\");\n\tfflush(ofile);\n\n\treturn (res > 0 ? 0 : -1);\n}"
  }
]