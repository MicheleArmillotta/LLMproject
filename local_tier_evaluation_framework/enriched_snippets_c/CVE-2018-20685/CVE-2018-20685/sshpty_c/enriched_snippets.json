[
  {
    "function_name": "disconnect_controlling_tty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
    "lines": "218-229",
    "snippet": "void\ndisconnect_controlling_tty(void)\n{\n#ifdef TIOCNOTTY\n\tint fd;\n\n\tif ((fd = open(_PATH_TTY, O_RDWR | O_NOCTTY)) >= 0) {\n\t\t(void) ioctl(fd, TIOCNOTTY, NULL);\n\t\tclose(fd);\n\t}\n#endif /* TIOCNOTTY */\n}",
    "includes": [
      "# include <AvailabilityMacros.h>",
      "# include <pty.h>",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshpty.h\"",
      "#include <unistd.h>",
      "# include <util.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define O_NOCTTY 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "TIOCNOTTY",
            "NULL"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_TTY",
            "O_RDWR | O_NOCTTY"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      }
    ],
    "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define O_NOCTTY 0\n\nvoid\ndisconnect_controlling_tty(void)\n{\n#ifdef TIOCNOTTY\n\tint fd;\n\n\tif ((fd = open(_PATH_TTY, O_RDWR | O_NOCTTY)) >= 0) {\n\t\t(void) ioctl(fd, TIOCNOTTY, NULL);\n\t\tclose(fd);\n\t}\n#endif /* TIOCNOTTY */\n}"
  },
  {
    "function_name": "pty_setowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
    "lines": "164-215",
    "snippet": "void\npty_setowner(struct passwd *pw, const char *tty)\n{\n\tstruct group *grp;\n\tgid_t gid;\n\tmode_t mode;\n\tstruct stat st;\n\n\t/* Determine the group to make the owner of the tty. */\n\tgrp = getgrnam(\"tty\");\n\tgid = (grp != NULL) ? grp->gr_gid : pw->pw_gid;\n\tmode = (grp != NULL) ? 0620 : 0600;\n\n\t/*\n\t * Change owner and mode of the tty as required.\n\t * Warn but continue if filesystem is read-only and the uids match/\n\t * tty is owned by root.\n\t */\n\tif (stat(tty, &st))\n\t\tfatal(\"stat(%.100s) failed: %.100s\", tty,\n\t\t    strerror(errno));\n\n#ifdef WITH_SELINUX\n\tssh_selinux_setup_pty(pw->pw_name, tty);\n#endif\n\n\tif (st.st_uid != pw->pw_uid || st.st_gid != gid) {\n\t\tif (chown(tty, pw->pw_uid, gid) < 0) {\n\t\t\tif (errno == EROFS &&\n\t\t\t    (st.st_uid == pw->pw_uid || st.st_uid == 0))\n\t\t\t\tdebug(\"chown(%.100s, %u, %u) failed: %.100s\",\n\t\t\t\t    tty, (u_int)pw->pw_uid, (u_int)gid,\n\t\t\t\t    strerror(errno));\n\t\t\telse\n\t\t\t\tfatal(\"chown(%.100s, %u, %u) failed: %.100s\",\n\t\t\t\t    tty, (u_int)pw->pw_uid, (u_int)gid,\n\t\t\t\t    strerror(errno));\n\t\t}\n\t}\n\n\tif ((st.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) != mode) {\n\t\tif (chmod(tty, mode) < 0) {\n\t\t\tif (errno == EROFS &&\n\t\t\t    (st.st_mode & (S_IRGRP | S_IROTH)) == 0)\n\t\t\t\tdebug(\"chmod(%.100s, 0%o) failed: %.100s\",\n\t\t\t\t    tty, (u_int)mode, strerror(errno));\n\t\t\telse\n\t\t\t\tfatal(\"chmod(%.100s, 0%o) failed: %.100s\",\n\t\t\t\t    tty, (u_int)mode, strerror(errno));\n\t\t}\n\t}\n}",
    "includes": [
      "# include <AvailabilityMacros.h>",
      "# include <pty.h>",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshpty.h\"",
      "#include <unistd.h>",
      "# include <util.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"chmod(%.100s, 0%o) failed: %.100s\"",
            "tty",
            "(u_int)mode",
            "strerror(errno)"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"chmod(%.100s, 0%o) failed: %.100s\"",
            "tty",
            "(u_int)mode",
            "strerror(errno)"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "tty",
            "mode"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "tty",
            "pw->pw_uid",
            "gid"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_selinux_setup_pty",
          "args": [
            "pw->pw_name",
            "tty"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_selinux_setup_pty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-linux.c",
          "lines": "136-178",
          "snippet": "void\nssh_selinux_setup_pty(char *pwname, const char *tty)\n{\n\tsecurity_context_t new_tty_ctx = NULL;\n\tsecurity_context_t user_ctx = NULL;\n\tsecurity_context_t old_tty_ctx = NULL;\n\tsecurity_class_t chrclass;\n\n\tif (!ssh_selinux_enabled())\n\t\treturn;\n\n\tdebug3(\"%s: setting TTY context on %s\", __func__, tty);\n\n\tuser_ctx = ssh_selinux_getctxbyname(pwname);\n\n\t/* XXX: should these calls fatal() upon failure in enforcing mode? */\n\n\tif (getfilecon(tty, &old_tty_ctx) == -1) {\n\t\terror(\"%s: getfilecon: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif ((chrclass = string_to_security_class(\"chr_file\")) == 0) {\n\t\terror(\"%s: couldn't get security class for chr_file\", __func__);\n\t\tgoto out;\n\t}\n\tif (security_compute_relabel(user_ctx, old_tty_ctx,\n\t    chrclass, &new_tty_ctx) != 0) {\n\t\terror(\"%s: security_compute_relabel: %s\",\n\t\t    __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tif (setfilecon(tty, new_tty_ctx) != 0)\n\t\terror(\"%s: setfilecon: %s\", __func__, strerror(errno));\n out:\n\tif (new_tty_ctx != NULL)\n\t\tfreecon(new_tty_ctx);\n\tif (old_tty_ctx != NULL)\n\t\tfreecon(old_tty_ctx);\n\tif (user_ctx != NULL)\n\t\tfreecon(user_ctx);\n\tdebug3(\"%s: done\", __func__);\n}",
          "includes": [
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"port-linux.h\"",
            "#include \"xmalloc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"port-linux.h\"\n#include \"xmalloc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nssh_selinux_setup_pty(char *pwname, const char *tty)\n{\n\tsecurity_context_t new_tty_ctx = NULL;\n\tsecurity_context_t user_ctx = NULL;\n\tsecurity_context_t old_tty_ctx = NULL;\n\tsecurity_class_t chrclass;\n\n\tif (!ssh_selinux_enabled())\n\t\treturn;\n\n\tdebug3(\"%s: setting TTY context on %s\", __func__, tty);\n\n\tuser_ctx = ssh_selinux_getctxbyname(pwname);\n\n\t/* XXX: should these calls fatal() upon failure in enforcing mode? */\n\n\tif (getfilecon(tty, &old_tty_ctx) == -1) {\n\t\terror(\"%s: getfilecon: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif ((chrclass = string_to_security_class(\"chr_file\")) == 0) {\n\t\terror(\"%s: couldn't get security class for chr_file\", __func__);\n\t\tgoto out;\n\t}\n\tif (security_compute_relabel(user_ctx, old_tty_ctx,\n\t    chrclass, &new_tty_ctx) != 0) {\n\t\terror(\"%s: security_compute_relabel: %s\",\n\t\t    __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tif (setfilecon(tty, new_tty_ctx) != 0)\n\t\terror(\"%s: setfilecon: %s\", __func__, strerror(errno));\n out:\n\tif (new_tty_ctx != NULL)\n\t\tfreecon(new_tty_ctx);\n\tif (old_tty_ctx != NULL)\n\t\tfreecon(old_tty_ctx);\n\tif (user_ctx != NULL)\n\t\tfreecon(user_ctx);\n\tdebug3(\"%s: done\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "tty",
            "&st"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgrnam",
          "args": [
            "\"tty\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\npty_setowner(struct passwd *pw, const char *tty)\n{\n\tstruct group *grp;\n\tgid_t gid;\n\tmode_t mode;\n\tstruct stat st;\n\n\t/* Determine the group to make the owner of the tty. */\n\tgrp = getgrnam(\"tty\");\n\tgid = (grp != NULL) ? grp->gr_gid : pw->pw_gid;\n\tmode = (grp != NULL) ? 0620 : 0600;\n\n\t/*\n\t * Change owner and mode of the tty as required.\n\t * Warn but continue if filesystem is read-only and the uids match/\n\t * tty is owned by root.\n\t */\n\tif (stat(tty, &st))\n\t\tfatal(\"stat(%.100s) failed: %.100s\", tty,\n\t\t    strerror(errno));\n\n#ifdef WITH_SELINUX\n\tssh_selinux_setup_pty(pw->pw_name, tty);\n#endif\n\n\tif (st.st_uid != pw->pw_uid || st.st_gid != gid) {\n\t\tif (chown(tty, pw->pw_uid, gid) < 0) {\n\t\t\tif (errno == EROFS &&\n\t\t\t    (st.st_uid == pw->pw_uid || st.st_uid == 0))\n\t\t\t\tdebug(\"chown(%.100s, %u, %u) failed: %.100s\",\n\t\t\t\t    tty, (u_int)pw->pw_uid, (u_int)gid,\n\t\t\t\t    strerror(errno));\n\t\t\telse\n\t\t\t\tfatal(\"chown(%.100s, %u, %u) failed: %.100s\",\n\t\t\t\t    tty, (u_int)pw->pw_uid, (u_int)gid,\n\t\t\t\t    strerror(errno));\n\t\t}\n\t}\n\n\tif ((st.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) != mode) {\n\t\tif (chmod(tty, mode) < 0) {\n\t\t\tif (errno == EROFS &&\n\t\t\t    (st.st_mode & (S_IRGRP | S_IROTH)) == 0)\n\t\t\t\tdebug(\"chmod(%.100s, 0%o) failed: %.100s\",\n\t\t\t\t    tty, (u_int)mode, strerror(errno));\n\t\t\telse\n\t\t\t\tfatal(\"chmod(%.100s, 0%o) failed: %.100s\",\n\t\t\t\t    tty, (u_int)mode, strerror(errno));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pty_change_window_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
    "lines": "150-162",
    "snippet": "void\npty_change_window_size(int ptyfd, u_int row, u_int col,\n\tu_int xpixel, u_int ypixel)\n{\n\tstruct winsize w;\n\n\t/* may truncate u_int -> u_short */\n\tw.ws_row = row;\n\tw.ws_col = col;\n\tw.ws_xpixel = xpixel;\n\tw.ws_ypixel = ypixel;\n\t(void) ioctl(ptyfd, TIOCSWINSZ, &w);\n}",
    "includes": [
      "# include <AvailabilityMacros.h>",
      "# include <pty.h>",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshpty.h\"",
      "#include <unistd.h>",
      "# include <util.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "ptyfd",
            "TIOCSWINSZ",
            "&w"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\npty_change_window_size(int ptyfd, u_int row, u_int col,\n\tu_int xpixel, u_int ypixel)\n{\n\tstruct winsize w;\n\n\t/* may truncate u_int -> u_short */\n\tw.ws_row = row;\n\tw.ws_col = col;\n\tw.ws_xpixel = xpixel;\n\tw.ws_ypixel = ypixel;\n\t(void) ioctl(ptyfd, TIOCSWINSZ, &w);\n}"
  },
  {
    "function_name": "pty_make_controlling_tty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
    "lines": "98-146",
    "snippet": "void\npty_make_controlling_tty(int *ttyfd, const char *tty)\n{\n\tint fd;\n\n\t/* First disconnect from the old controlling tty. */\n#ifdef TIOCNOTTY\n\tfd = open(_PATH_TTY, O_RDWR | O_NOCTTY);\n\tif (fd >= 0) {\n\t\t(void) ioctl(fd, TIOCNOTTY, NULL);\n\t\tclose(fd);\n\t}\n#endif /* TIOCNOTTY */\n\tif (setsid() < 0)\n\t\terror(\"setsid: %.100s\", strerror(errno));\n\n\t/*\n\t * Verify that we are successfully disconnected from the controlling\n\t * tty.\n\t */\n\tfd = open(_PATH_TTY, O_RDWR | O_NOCTTY);\n\tif (fd >= 0) {\n\t\terror(\"Failed to disconnect from controlling tty.\");\n\t\tclose(fd);\n\t}\n\t/* Make it our controlling tty. */\n#ifdef TIOCSCTTY\n\tdebug(\"Setting controlling tty using TIOCSCTTY.\");\n\tif (ioctl(*ttyfd, TIOCSCTTY, NULL) < 0)\n\t\terror(\"ioctl(TIOCSCTTY): %.100s\", strerror(errno));\n#endif /* TIOCSCTTY */\n#ifdef NEED_SETPGRP\n\tif (setpgrp(0,0) < 0)\n\t\terror(\"SETPGRP %s\",strerror(errno));\n#endif /* NEED_SETPGRP */\n\tfd = open(tty, O_RDWR);\n\tif (fd < 0)\n\t\terror(\"%.100s: %.100s\", tty, strerror(errno));\n\telse\n\t\tclose(fd);\n\n\t/* Verify that we now have a controlling tty. */\n\tfd = open(_PATH_TTY, O_WRONLY);\n\tif (fd < 0)\n\t\terror(\"open /dev/tty failed - could not set controlling tty: %.100s\",\n\t\t    strerror(errno));\n\telse\n\t\tclose(fd);\n}",
    "includes": [
      "# include <AvailabilityMacros.h>",
      "# include <pty.h>",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshpty.h\"",
      "#include <unistd.h>",
      "# include <util.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define O_NOCTTY 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"open /dev/tty failed - could not set controlling tty: %.100s\"",
            "strerror(errno)"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_TTY",
            "O_WRONLY"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setpgrp",
          "args": [
            "0",
            "0"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "tcsetpgrp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-nextstep.c",
          "lines": "75-78",
          "snippet": "int tcsetpgrp(int fd, pid_t pgrp)\n{\n\treturn (ioctl(fd, TIOCSPGRP, &pgrp));\n}",
          "includes": [
            "#include \"bsd-nextstep.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-nextstep.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint tcsetpgrp(int fd, pid_t pgrp)\n{\n\treturn (ioctl(fd, TIOCSPGRP, &pgrp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "*ttyfd",
            "TIOCSCTTY",
            "NULL"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Setting controlling tty using TIOCSCTTY.\""
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "TIOCNOTTY",
            "NULL"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define O_NOCTTY 0\n\nvoid\npty_make_controlling_tty(int *ttyfd, const char *tty)\n{\n\tint fd;\n\n\t/* First disconnect from the old controlling tty. */\n#ifdef TIOCNOTTY\n\tfd = open(_PATH_TTY, O_RDWR | O_NOCTTY);\n\tif (fd >= 0) {\n\t\t(void) ioctl(fd, TIOCNOTTY, NULL);\n\t\tclose(fd);\n\t}\n#endif /* TIOCNOTTY */\n\tif (setsid() < 0)\n\t\terror(\"setsid: %.100s\", strerror(errno));\n\n\t/*\n\t * Verify that we are successfully disconnected from the controlling\n\t * tty.\n\t */\n\tfd = open(_PATH_TTY, O_RDWR | O_NOCTTY);\n\tif (fd >= 0) {\n\t\terror(\"Failed to disconnect from controlling tty.\");\n\t\tclose(fd);\n\t}\n\t/* Make it our controlling tty. */\n#ifdef TIOCSCTTY\n\tdebug(\"Setting controlling tty using TIOCSCTTY.\");\n\tif (ioctl(*ttyfd, TIOCSCTTY, NULL) < 0)\n\t\terror(\"ioctl(TIOCSCTTY): %.100s\", strerror(errno));\n#endif /* TIOCSCTTY */\n#ifdef NEED_SETPGRP\n\tif (setpgrp(0,0) < 0)\n\t\terror(\"SETPGRP %s\",strerror(errno));\n#endif /* NEED_SETPGRP */\n\tfd = open(tty, O_RDWR);\n\tif (fd < 0)\n\t\terror(\"%.100s: %.100s\", tty, strerror(errno));\n\telse\n\t\tclose(fd);\n\n\t/* Verify that we now have a controlling tty. */\n\tfd = open(_PATH_TTY, O_WRONLY);\n\tif (fd < 0)\n\t\terror(\"open /dev/tty failed - could not set controlling tty: %.100s\",\n\t\t    strerror(errno));\n\telse\n\t\tclose(fd);\n}"
  },
  {
    "function_name": "pty_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
    "lines": "85-94",
    "snippet": "void\npty_release(const char *tty)\n{\n#if !defined(__APPLE_PRIVPTY__) && !defined(HAVE_OPENPTY)\n\tif (chown(tty, (uid_t) 0, (gid_t) 0) < 0)\n\t\terror(\"chown %.100s 0 0 failed: %.100s\", tty, strerror(errno));\n\tif (chmod(tty, (mode_t) 0666) < 0)\n\t\terror(\"chmod %.100s 0666 failed: %.100s\", tty, strerror(errno));\n#endif /* !__APPLE_PRIVPTY__ && !HAVE_OPENPTY */\n}",
    "includes": [
      "# include <AvailabilityMacros.h>",
      "# include <pty.h>",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshpty.h\"",
      "#include <unistd.h>",
      "# include <util.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"chmod %.100s 0666 failed: %.100s\"",
            "tty",
            "strerror(errno)"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "tty",
            "(mode_t) 0666"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "tty",
            "(uid_t) 0",
            "(gid_t) 0"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\npty_release(const char *tty)\n{\n#if !defined(__APPLE_PRIVPTY__) && !defined(HAVE_OPENPTY)\n\tif (chown(tty, (uid_t) 0, (gid_t) 0) < 0)\n\t\terror(\"chown %.100s 0 0 failed: %.100s\", tty, strerror(errno));\n\tif (chmod(tty, (mode_t) 0666) < 0)\n\t\terror(\"chmod %.100s 0666 failed: %.100s\", tty, strerror(errno));\n#endif /* !__APPLE_PRIVPTY__ && !HAVE_OPENPTY */\n}"
  },
  {
    "function_name": "pty_allocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
    "lines": "63-81",
    "snippet": "int\npty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)\n{\n\t/* openpty(3) exists in OSF/1 and some other os'es */\n\tchar *name;\n\tint i;\n\n\ti = openpty(ptyfd, ttyfd, NULL, NULL, NULL);\n\tif (i < 0) {\n\t\terror(\"openpty: %.100s\", strerror(errno));\n\t\treturn 0;\n\t}\n\tname = ttyname(*ttyfd);\n\tif (!name)\n\t\tfatal(\"openpty returns device for which ttyname fails.\");\n\n\tstrlcpy(namebuf, name, namebuflen);\t/* possible truncation */\n\treturn 1;\n}",
    "includes": [
      "# include <AvailabilityMacros.h>",
      "# include <pty.h>",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshpty.h\"",
      "#include <unistd.h>",
      "# include <util.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "namebuf",
            "name",
            "namebuflen"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"openpty returns device for which ttyname fails.\""
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttyname",
          "args": [
            "*ttyfd"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"openpty: %.100s\"",
            "strerror(errno)"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openpty",
          "args": [
            "ptyfd",
            "ttyfd",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "openpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-openpty.c",
          "lines": "72-192",
          "snippet": "int\nopenpty(int *amaster, int *aslave, char *name, struct termios *termp,\n   struct winsize *winp)\n{\n#if defined(HAVE__GETPTY)\n\t/*\n\t * _getpty(3) exists in SGI Irix 4.x, 5.x & 6.x -- it generates more\n\t * pty's automagically when needed\n\t */\n\tchar *slave;\n\n\tif ((slave = _getpty(amaster, O_RDWR, 0622, 0)) == NULL)\n\t\treturn (-1);\n\n\t/* Open the slave side. */\n\tif ((*aslave = open(slave, O_RDWR | O_NOCTTY)) == -1) {\n\t\tclose(*amaster);\n\t\treturn (-1);\n\t}\n\treturn (0);\n\n#elif defined(HAVE_DEV_PTMX)\n\t/*\n\t * This code is used e.g. on Solaris 2.x.  (Note that Solaris 2.3\n\t * also has bsd-style ptys, but they simply do not work.)\n\t */\n\tint ptm;\n\tchar *pts;\n\tmysig_t old_signal;\n\n\tif ((ptm = open(\"/dev/ptmx\", O_RDWR | O_NOCTTY)) == -1)\n\t\treturn (-1);\n\n\t/* XXX: need to close ptm on error? */\n\told_signal = signal(SIGCHLD, SIG_DFL);\n\tif (grantpt(ptm) < 0)\n\t\treturn (-1);\n\tsignal(SIGCHLD, old_signal);\n\n\tif (unlockpt(ptm) < 0)\n\t\treturn (-1);\n\n\tif ((pts = ptsname(ptm)) == NULL)\n\t\treturn (-1);\n\t*amaster = ptm;\n\n\t/* Open the slave side. */\n\tif ((*aslave = open(pts, O_RDWR | O_NOCTTY)) == -1) {\n\t\tclose(*amaster);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Try to push the appropriate streams modules, as described\n\t * in Solaris pts(7).\n\t */\n\tioctl(*aslave, I_PUSH, \"ptem\");\n\tioctl(*aslave, I_PUSH, \"ldterm\");\n# ifndef __hpux\n\tioctl(*aslave, I_PUSH, \"ttcompat\");\n# endif /* __hpux */\n\n\treturn (0);\n\n#elif defined(HAVE_DEV_PTS_AND_PTC)\n\t/* AIX-style pty code. */\n\tconst char *ttname;\n\n\tif ((*amaster = open(\"/dev/ptc\", O_RDWR | O_NOCTTY)) == -1)\n\t\treturn (-1);\n\tif ((ttname = ttyname(*amaster)) == NULL)\n\t\treturn (-1);\n\tif ((*aslave = open(ttname, O_RDWR | O_NOCTTY)) == -1) {\n\t\tclose(*amaster);\n\t\treturn (-1);\n\t}\n\treturn (0);\n\n#else\n\t/* BSD-style pty code. */\n\tchar ptbuf[64], ttbuf[64];\n\tint i;\n\tconst char *ptymajors = \"pqrstuvwxyzabcdefghijklmno\"\n\t    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\tconst char *ptyminors = \"0123456789abcdef\";\n\tint num_minors = strlen(ptyminors);\n\tint num_ptys = strlen(ptymajors) * num_minors;\n\tstruct termios tio;\n\n\tfor (i = 0; i < num_ptys; i++) {\n\t\tsnprintf(ptbuf, sizeof(ptbuf), \"/dev/pty%c%c\",\n\t\t    ptymajors[i / num_minors], ptyminors[i % num_minors]);\n\t\tsnprintf(ttbuf, sizeof(ttbuf), \"/dev/tty%c%c\",\n\t\t    ptymajors[i / num_minors], ptyminors[i % num_minors]);\n\n\t\tif ((*amaster = open(ptbuf, O_RDWR | O_NOCTTY)) == -1) {\n\t\t\t/* Try SCO style naming */\n\t\t\tsnprintf(ptbuf, sizeof(ptbuf), \"/dev/ptyp%d\", i);\n\t\t\tsnprintf(ttbuf, sizeof(ttbuf), \"/dev/ttyp%d\", i);\n\t\t\tif ((*amaster = open(ptbuf, O_RDWR | O_NOCTTY)) == -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Open the slave side. */\n\t\tif ((*aslave = open(ttbuf, O_RDWR | O_NOCTTY)) == -1) {\n\t\t\tclose(*amaster);\n\t\t\treturn (-1);\n\t\t}\n\t\t/* set tty modes to a sane state for broken clients */\n\t\tif (tcgetattr(*amaster, &tio) != -1) {\n\t\t\ttio.c_lflag |= (ECHO | ISIG | ICANON);\n\t\t\ttio.c_oflag |= (OPOST | ONLCR);\n\t\t\ttio.c_iflag |= ICRNL;\n\t\t\ttcsetattr(*amaster, TCSANOW, &tio);\n\t\t}\n\n\t\treturn (0);\n\t}\n\treturn (-1);\n#endif\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "# include <sys/stropts.h>",
            "# include <pty.h>",
            "# include <util.h>",
            "# include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "# include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define O_NOCTTY 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n# include <sys/stropts.h>\n# include <pty.h>\n# include <util.h>\n# include <fcntl.h>\n# include <sys/ioctl.h>\n# include <sys/stat.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define O_NOCTTY 0\n\nint\nopenpty(int *amaster, int *aslave, char *name, struct termios *termp,\n   struct winsize *winp)\n{\n#if defined(HAVE__GETPTY)\n\t/*\n\t * _getpty(3) exists in SGI Irix 4.x, 5.x & 6.x -- it generates more\n\t * pty's automagically when needed\n\t */\n\tchar *slave;\n\n\tif ((slave = _getpty(amaster, O_RDWR, 0622, 0)) == NULL)\n\t\treturn (-1);\n\n\t/* Open the slave side. */\n\tif ((*aslave = open(slave, O_RDWR | O_NOCTTY)) == -1) {\n\t\tclose(*amaster);\n\t\treturn (-1);\n\t}\n\treturn (0);\n\n#elif defined(HAVE_DEV_PTMX)\n\t/*\n\t * This code is used e.g. on Solaris 2.x.  (Note that Solaris 2.3\n\t * also has bsd-style ptys, but they simply do not work.)\n\t */\n\tint ptm;\n\tchar *pts;\n\tmysig_t old_signal;\n\n\tif ((ptm = open(\"/dev/ptmx\", O_RDWR | O_NOCTTY)) == -1)\n\t\treturn (-1);\n\n\t/* XXX: need to close ptm on error? */\n\told_signal = signal(SIGCHLD, SIG_DFL);\n\tif (grantpt(ptm) < 0)\n\t\treturn (-1);\n\tsignal(SIGCHLD, old_signal);\n\n\tif (unlockpt(ptm) < 0)\n\t\treturn (-1);\n\n\tif ((pts = ptsname(ptm)) == NULL)\n\t\treturn (-1);\n\t*amaster = ptm;\n\n\t/* Open the slave side. */\n\tif ((*aslave = open(pts, O_RDWR | O_NOCTTY)) == -1) {\n\t\tclose(*amaster);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Try to push the appropriate streams modules, as described\n\t * in Solaris pts(7).\n\t */\n\tioctl(*aslave, I_PUSH, \"ptem\");\n\tioctl(*aslave, I_PUSH, \"ldterm\");\n# ifndef __hpux\n\tioctl(*aslave, I_PUSH, \"ttcompat\");\n# endif /* __hpux */\n\n\treturn (0);\n\n#elif defined(HAVE_DEV_PTS_AND_PTC)\n\t/* AIX-style pty code. */\n\tconst char *ttname;\n\n\tif ((*amaster = open(\"/dev/ptc\", O_RDWR | O_NOCTTY)) == -1)\n\t\treturn (-1);\n\tif ((ttname = ttyname(*amaster)) == NULL)\n\t\treturn (-1);\n\tif ((*aslave = open(ttname, O_RDWR | O_NOCTTY)) == -1) {\n\t\tclose(*amaster);\n\t\treturn (-1);\n\t}\n\treturn (0);\n\n#else\n\t/* BSD-style pty code. */\n\tchar ptbuf[64], ttbuf[64];\n\tint i;\n\tconst char *ptymajors = \"pqrstuvwxyzabcdefghijklmno\"\n\t    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\tconst char *ptyminors = \"0123456789abcdef\";\n\tint num_minors = strlen(ptyminors);\n\tint num_ptys = strlen(ptymajors) * num_minors;\n\tstruct termios tio;\n\n\tfor (i = 0; i < num_ptys; i++) {\n\t\tsnprintf(ptbuf, sizeof(ptbuf), \"/dev/pty%c%c\",\n\t\t    ptymajors[i / num_minors], ptyminors[i % num_minors]);\n\t\tsnprintf(ttbuf, sizeof(ttbuf), \"/dev/tty%c%c\",\n\t\t    ptymajors[i / num_minors], ptyminors[i % num_minors]);\n\n\t\tif ((*amaster = open(ptbuf, O_RDWR | O_NOCTTY)) == -1) {\n\t\t\t/* Try SCO style naming */\n\t\t\tsnprintf(ptbuf, sizeof(ptbuf), \"/dev/ptyp%d\", i);\n\t\t\tsnprintf(ttbuf, sizeof(ttbuf), \"/dev/ttyp%d\", i);\n\t\t\tif ((*amaster = open(ptbuf, O_RDWR | O_NOCTTY)) == -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Open the slave side. */\n\t\tif ((*aslave = open(ttbuf, O_RDWR | O_NOCTTY)) == -1) {\n\t\t\tclose(*amaster);\n\t\t\treturn (-1);\n\t\t}\n\t\t/* set tty modes to a sane state for broken clients */\n\t\tif (tcgetattr(*amaster, &tio) != -1) {\n\t\t\ttio.c_lflag |= (ECHO | ISIG | ICANON);\n\t\t\ttio.c_oflag |= (OPOST | ONLCR);\n\t\t\ttio.c_iflag |= ICRNL;\n\t\t\ttcsetattr(*amaster, TCSANOW, &tio);\n\t\t}\n\n\t\treturn (0);\n\t}\n\treturn (-1);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)\n{\n\t/* openpty(3) exists in OSF/1 and some other os'es */\n\tchar *name;\n\tint i;\n\n\ti = openpty(ptyfd, ttyfd, NULL, NULL, NULL);\n\tif (i < 0) {\n\t\terror(\"openpty: %.100s\", strerror(errno));\n\t\treturn 0;\n\t}\n\tname = ttyname(*ttyfd);\n\tif (!name)\n\t\tfatal(\"openpty returns device for which ttyname fails.\");\n\n\tstrlcpy(namebuf, name, namebuflen);\t/* possible truncation */\n\treturn 1;\n}"
  }
]