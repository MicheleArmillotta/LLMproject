[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "2347-2572",
    "snippet": "int\nmain(int argc, char **argv)\n{\n\tint in, out, ch, err, tmp, port = -1;\n\tchar *host = NULL, *user, *cp, *file2 = NULL;\n\tint debug_level = 0, sshver = 2;\n\tchar *file1 = NULL, *sftp_server = NULL;\n\tchar *ssh_program = _PATH_SSH_PROGRAM, *sftp_direct = NULL;\n\tconst char *errstr;\n\tLogLevel ll = SYSLOG_LEVEL_INFO;\n\targlist args;\n\textern int optind;\n\textern char *optarg;\n\tstruct sftp_conn *conn;\n\tsize_t copy_buffer_len = DEFAULT_COPY_BUFLEN;\n\tsize_t num_requests = DEFAULT_NUM_REQUESTS;\n\tlong long limit_kbps = 0;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\tmsetlocale();\n\n\t__progname = ssh_get_progname(argv[0]);\n\tmemset(&args, '\\0', sizeof(args));\n\targs.list = NULL;\n\taddargs(&args, \"%s\", ssh_program);\n\taddargs(&args, \"-oForwardX11 no\");\n\taddargs(&args, \"-oForwardAgent no\");\n\taddargs(&args, \"-oPermitLocalCommand no\");\n\taddargs(&args, \"-oClearAllForwardings yes\");\n\n\tll = SYSLOG_LEVEL_INFO;\n\tinfile = stdin;\n\n\twhile ((ch = getopt(argc, argv,\n\t    \"1246afhpqrvCc:D:i:l:o:s:S:b:B:F:P:R:\")) != -1) {\n\t\tswitch (ch) {\n\t\t/* Passed through to ssh(1) */\n\t\tcase '4':\n\t\tcase '6':\n\t\tcase 'C':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\tbreak;\n\t\t/* Passed through to ssh(1) with argument */\n\t\tcase 'F':\n\t\tcase 'c':\n\t\tcase 'i':\n\t\tcase 'o':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&args, \"%s\", optarg);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tll = SYSLOG_LEVEL_ERROR;\n\t\t\tquiet = 1;\n\t\t\tshowprogress = 0;\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tport = a2port(optarg);\n\t\t\tif (port <= 0)\n\t\t\t\tfatal(\"Bad port \\\"%s\\\"\\n\", optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (debug_level < 3) {\n\t\t\t\taddargs(&args, \"-v\");\n\t\t\t\tll = SYSLOG_LEVEL_DEBUG1 + debug_level;\n\t\t\t}\n\t\t\tdebug_level++;\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tsshver = 1;\n\t\t\tif (sftp_server == NULL)\n\t\t\t\tsftp_server = _PATH_SFTP_SERVER;\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tsshver = 2;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tglobal_aflag = 1;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tcopy_buffer_len = strtol(optarg, &cp, 10);\n\t\t\tif (copy_buffer_len == 0 || *cp != '\\0')\n\t\t\t\tfatal(\"Invalid buffer size \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (batchmode)\n\t\t\t\tfatal(\"Batch file already specified.\");\n\n\t\t\t/* Allow \"-\" as stdin */\n\t\t\tif (strcmp(optarg, \"-\") != 0 &&\n\t\t\t    (infile = fopen(optarg, \"r\")) == NULL)\n\t\t\t\tfatal(\"%s (%s).\", strerror(errno), optarg);\n\t\t\tshowprogress = 0;\n\t\t\tquiet = batchmode = 1;\n\t\t\taddargs(&args, \"-obatchmode yes\");\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tglobal_fflag = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tglobal_pflag = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tsftp_direct = optarg;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlimit_kbps = strtonum(optarg, 1, 100 * 1024 * 1024,\n\t\t\t    &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tusage();\n\t\t\tlimit_kbps *= 1024; /* kbps */\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tglobal_rflag = 1;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tnum_requests = strtol(optarg, &cp, 10);\n\t\t\tif (num_requests == 0 || *cp != '\\0')\n\t\t\t\tfatal(\"Invalid number of requests \\\"%s\\\"\",\n\t\t\t\t    optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsftp_server = optarg;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tssh_program = optarg;\n\t\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\tif (!isatty(STDERR_FILENO))\n\t\tshowprogress = 0;\n\n\tlog_init(argv[0], ll, SYSLOG_FACILITY_USER, 1);\n\n\tif (sftp_direct == NULL) {\n\t\tif (optind == argc || argc > (optind + 2))\n\t\t\tusage();\n\t\targv += optind;\n\n\t\tswitch (parse_uri(\"sftp\", *argv, &user, &host, &tmp, &file1)) {\n\t\tcase -1:\n\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tif (tmp != -1)\n\t\t\t\tport = tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (parse_user_host_path(*argv, &user, &host,\n\t\t\t    &file1) == -1) {\n\t\t\t\t/* Treat as a plain hostname. */\n\t\t\t\thost = xstrdup(*argv);\n\t\t\t\thost = cleanhostname(host);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfile2 = *(argv + 1);\n\n\t\tif (!*host) {\n\t\t\tfprintf(stderr, \"Missing hostname\\n\");\n\t\t\tusage();\n\t\t}\n\n\t\tif (port != -1)\n\t\t\taddargs(&args, \"-oPort %d\", port);\n\t\tif (user != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", user);\n\t\t}\n\t\taddargs(&args, \"-oProtocol %d\", sshver);\n\n\t\t/* no subsystem if the server-spec contains a '/' */\n\t\tif (sftp_server == NULL || strchr(sftp_server, '/') == NULL)\n\t\t\taddargs(&args, \"-s\");\n\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", (sftp_server != NULL ?\n\t\t    sftp_server : \"sftp\"));\n\n\t\tconnect_to_server(ssh_program, args.list, &in, &out);\n\t} else {\n\t\targs.list = NULL;\n\t\taddargs(&args, \"sftp-server\");\n\n\t\tconnect_to_server(sftp_direct, args.list, &in, &out);\n\t}\n\tfreeargs(&args);\n\n\tconn = do_init(in, out, copy_buffer_len, num_requests, limit_kbps);\n\tif (conn == NULL)\n\t\tfatal(\"Couldn't initialise connection to server\");\n\n\tif (!quiet) {\n\t\tif (sftp_direct == NULL)\n\t\t\tfprintf(stderr, \"Connected to %s.\\n\", host);\n\t\telse\n\t\t\tfprintf(stderr, \"Attached to %s.\\n\", sftp_direct);\n\t}\n\n\terr = interactive_loop(conn, file1, file2);\n\n#if !defined(USE_PIPES)\n\tshutdown(in, SHUT_RDWR);\n\tshutdown(out, SHUT_RDWR);\n#endif\n\n\tclose(in);\n\tclose(out);\n\tif (batchmode)\n\t\tfclose(infile);\n\n\twhile (waitpid(sshpid, NULL, 0) == -1 && sshpid > 1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for ssh process: %s\",\n\t\t\t    strerror(errno));\n\n\texit(err == 0 ? 0 : 1);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define DEFAULT_NUM_REQUESTS\t64\t/* # concurrent outstanding requests */",
      "#define DEFAULT_COPY_BUFLEN\t32768\t/* Size of buffer for up/download */"
    ],
    "globals_used": [
      "FILE* infile;",
      "int batchmode = 0;",
      "static volatile pid_t sshpid = -1;",
      "int quiet = 0;",
      "int showprogress = 1;",
      "int global_rflag = 0;",
      "int global_aflag = 0;",
      "int global_pflag = 0;",
      "int global_fflag = 0;",
      "extern char *__progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "err == 0 ? 0 : 1"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Couldn't wait for ssh process: %s\"",
            "strerror(errno)"
          ],
          "line": 2568
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "sshpid",
            "NULL",
            "0"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "infile"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "out"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "out",
            "SHUT_RDWR"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "chan_shutdown_extended_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "429-446",
          "snippet": "static void\nchan_shutdown_extended_read(struct ssh *ssh, Channel *c)\n{\n\tif (c->type == SSH_CHANNEL_LARVAL || c->efd == -1)\n\t\treturn;\n\tif (c->extended_usage != CHAN_EXTENDED_READ &&\n\t    c->extended_usage != CHAN_EXTENDED_IGNORE)\n\t\treturn;\n\tdebug2(\"channel %d: %s (i%d o%d sock %d wfd %d efd %d [%s])\",\n\t    c->self, __func__, c->istate, c->ostate, c->sock, c->rfd, c->efd,\n\t    channel_format_extended_usage(c));\n\tif (channel_close_fd(ssh, &c->efd) < 0) {\n\t\tlogit(\"channel %d: %s: close() failed for \"\n\t\t    \"extended fd %d [i%d o%d]: %.100s\",\n\t\t    c->self, __func__, c->efd, c->istate, c->ostate,\n\t\t    strerror(errno));\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nstatic void\nchan_shutdown_extended_read(struct ssh *ssh, Channel *c)\n{\n\tif (c->type == SSH_CHANNEL_LARVAL || c->efd == -1)\n\t\treturn;\n\tif (c->extended_usage != CHAN_EXTENDED_READ &&\n\t    c->extended_usage != CHAN_EXTENDED_IGNORE)\n\t\treturn;\n\tdebug2(\"channel %d: %s (i%d o%d sock %d wfd %d efd %d [%s])\",\n\t    c->self, __func__, c->istate, c->ostate, c->sock, c->rfd, c->efd,\n\t    channel_format_extended_usage(c));\n\tif (channel_close_fd(ssh, &c->efd) < 0) {\n\t\tlogit(\"channel %d: %s: close() failed for \"\n\t\t    \"extended fd %d [i%d o%d]: %.100s\",\n\t\t    c->self, __func__, c->efd, c->istate, c->ostate,\n\t\t    strerror(errno));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "interactive_loop",
          "args": [
            "conn",
            "file1",
            "file2"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "interactive_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "2128-2268",
          "snippet": "static int\ninteractive_loop(struct sftp_conn *conn, char *file1, char *file2)\n{\n\tchar *remote_path;\n\tchar *dir = NULL, *startdir = NULL;\n\tchar cmd[2048];\n\tint err, interactive;\n\tEditLine *el = NULL;\n#ifdef USE_LIBEDIT\n\tHistory *hl = NULL;\n\tHistEvent hev;\n\textern char *__progname;\n\tstruct complete_ctx complete_ctx;\n\n\tif (!batchmode && isatty(STDIN_FILENO)) {\n\t\tif ((el = el_init(__progname, stdin, stdout, stderr)) == NULL)\n\t\t\tfatal(\"Couldn't initialise editline\");\n\t\tif ((hl = history_init()) == NULL)\n\t\t\tfatal(\"Couldn't initialise editline history\");\n\t\thistory(hl, &hev, H_SETSIZE, 100);\n\t\tel_set(el, EL_HIST, history, hl);\n\n\t\tel_set(el, EL_PROMPT, prompt);\n\t\tel_set(el, EL_EDITOR, \"emacs\");\n\t\tel_set(el, EL_TERMINAL, NULL);\n\t\tel_set(el, EL_SIGNAL, 1);\n\t\tel_source(el, NULL);\n\n\t\t/* Tab Completion */\n\t\tel_set(el, EL_ADDFN, \"ftp-complete\",\n\t\t    \"Context sensitive argument completion\", complete);\n\t\tcomplete_ctx.conn = conn;\n\t\tcomplete_ctx.remote_pathp = &remote_path;\n\t\tel_set(el, EL_CLIENTDATA, (void*)&complete_ctx);\n\t\tel_set(el, EL_BIND, \"^I\", \"ftp-complete\", NULL);\n\t\t/* enable ctrl-left-arrow and ctrl-right-arrow */\n\t\tel_set(el, EL_BIND, \"\\\\e[1;5C\", \"em-next-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e[5C\", \"em-next-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e[1;5D\", \"ed-prev-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e\\\\e[D\", \"ed-prev-word\", NULL);\n\t\t/* make ^w match ksh behaviour */\n\t\tel_set(el, EL_BIND, \"^w\", \"ed-delete-prev-word\", NULL);\n\t}\n#endif /* USE_LIBEDIT */\n\n\tremote_path = do_realpath(conn, \".\");\n\tif (remote_path == NULL)\n\t\tfatal(\"Need cwd\");\n\tstartdir = xstrdup(remote_path);\n\n\tif (file1 != NULL) {\n\t\tdir = xstrdup(file1);\n\t\tdir = make_absolute(dir, remote_path);\n\n\t\tif (remote_is_dir(conn, dir) && file2 == NULL) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Changing to: %s\\n\", dir);\n\t\t\tsnprintf(cmd, sizeof cmd, \"cd \\\"%s\\\"\", dir);\n\t\t\tif (parse_dispatch_command(conn, cmd,\n\t\t\t    &remote_path, startdir, 1, 0) != 0) {\n\t\t\t\tfree(dir);\n\t\t\t\tfree(startdir);\n\t\t\t\tfree(remote_path);\n\t\t\t\tfree(conn);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t} else {\n\t\t\t/* XXX this is wrong wrt quoting */\n\t\t\tsnprintf(cmd, sizeof cmd, \"get%s %s%s%s\",\n\t\t\t    global_aflag ? \" -a\" : \"\", dir,\n\t\t\t    file2 == NULL ? \"\" : \" \",\n\t\t\t    file2 == NULL ? \"\" : file2);\n\t\t\terr = parse_dispatch_command(conn, cmd,\n\t\t\t    &remote_path, startdir, 1, 0);\n\t\t\tfree(dir);\n\t\t\tfree(startdir);\n\t\t\tfree(remote_path);\n\t\t\tfree(conn);\n\t\t\treturn (err);\n\t\t}\n\t\tfree(dir);\n\t}\n\n\tsetvbuf(stdout, NULL, _IOLBF, 0);\n\tsetvbuf(infile, NULL, _IOLBF, 0);\n\n\tinteractive = !batchmode && isatty(STDIN_FILENO);\n\terr = 0;\n\tfor (;;) {\n\t\tsignal(SIGINT, SIG_IGN);\n\n\t\tif (el == NULL) {\n\t\t\tif (interactive)\n\t\t\t\tprintf(\"sftp> \");\n\t\t\tif (fgets(cmd, sizeof(cmd), infile) == NULL) {\n\t\t\t\tif (interactive)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n#ifdef USE_LIBEDIT\n\t\t\tconst char *line;\n\t\t\tint count = 0;\n\n\t\t\tif ((line = el_gets(el, &count)) == NULL ||\n\t\t\t    count <= 0) {\n\t\t\t\tprintf(\"\\n\");\n \t\t\t\tbreak;\n\t\t\t}\n\t\t\thistory(hl, &hev, H_ENTER, line);\n\t\t\tif (strlcpy(cmd, line, sizeof(cmd)) >= sizeof(cmd)) {\n\t\t\t\tfprintf(stderr, \"Error: input line too long\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n#endif /* USE_LIBEDIT */\n\t\t}\n\n\t\tcmd[strcspn(cmd, \"\\n\")] = '\\0';\n\n\t\t/* Handle user interrupts gracefully during commands */\n\t\tinterrupted = 0;\n\t\tsignal(SIGINT, cmd_interrupt);\n\n\t\terr = parse_dispatch_command(conn, cmd, &remote_path,\n\t\t    startdir, batchmode, !interactive && el == NULL);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t}\n\tsignal(SIGCHLD, SIG_DFL);\n\tfree(remote_path);\n\tfree(startdir);\n\tfree(conn);\n\n#ifdef USE_LIBEDIT\n\tif (el != NULL)\n\t\tel_end(el);\n#endif /* USE_LIBEDIT */\n\n\t/* err == 1 signifies normal \"quit\" exit */\n\treturn (err >= 0 ? 0 : -1);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "FILE* infile;",
            "int batchmode = 0;",
            "int quiet = 0;",
            "int global_aflag = 0;",
            "volatile sig_atomic_t interrupted = 0;",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nFILE* infile;\nint batchmode = 0;\nint quiet = 0;\nint global_aflag = 0;\nvolatile sig_atomic_t interrupted = 0;\nextern char *__progname;\n\nstatic int\ninteractive_loop(struct sftp_conn *conn, char *file1, char *file2)\n{\n\tchar *remote_path;\n\tchar *dir = NULL, *startdir = NULL;\n\tchar cmd[2048];\n\tint err, interactive;\n\tEditLine *el = NULL;\n#ifdef USE_LIBEDIT\n\tHistory *hl = NULL;\n\tHistEvent hev;\n\textern char *__progname;\n\tstruct complete_ctx complete_ctx;\n\n\tif (!batchmode && isatty(STDIN_FILENO)) {\n\t\tif ((el = el_init(__progname, stdin, stdout, stderr)) == NULL)\n\t\t\tfatal(\"Couldn't initialise editline\");\n\t\tif ((hl = history_init()) == NULL)\n\t\t\tfatal(\"Couldn't initialise editline history\");\n\t\thistory(hl, &hev, H_SETSIZE, 100);\n\t\tel_set(el, EL_HIST, history, hl);\n\n\t\tel_set(el, EL_PROMPT, prompt);\n\t\tel_set(el, EL_EDITOR, \"emacs\");\n\t\tel_set(el, EL_TERMINAL, NULL);\n\t\tel_set(el, EL_SIGNAL, 1);\n\t\tel_source(el, NULL);\n\n\t\t/* Tab Completion */\n\t\tel_set(el, EL_ADDFN, \"ftp-complete\",\n\t\t    \"Context sensitive argument completion\", complete);\n\t\tcomplete_ctx.conn = conn;\n\t\tcomplete_ctx.remote_pathp = &remote_path;\n\t\tel_set(el, EL_CLIENTDATA, (void*)&complete_ctx);\n\t\tel_set(el, EL_BIND, \"^I\", \"ftp-complete\", NULL);\n\t\t/* enable ctrl-left-arrow and ctrl-right-arrow */\n\t\tel_set(el, EL_BIND, \"\\\\e[1;5C\", \"em-next-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e[5C\", \"em-next-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e[1;5D\", \"ed-prev-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e\\\\e[D\", \"ed-prev-word\", NULL);\n\t\t/* make ^w match ksh behaviour */\n\t\tel_set(el, EL_BIND, \"^w\", \"ed-delete-prev-word\", NULL);\n\t}\n#endif /* USE_LIBEDIT */\n\n\tremote_path = do_realpath(conn, \".\");\n\tif (remote_path == NULL)\n\t\tfatal(\"Need cwd\");\n\tstartdir = xstrdup(remote_path);\n\n\tif (file1 != NULL) {\n\t\tdir = xstrdup(file1);\n\t\tdir = make_absolute(dir, remote_path);\n\n\t\tif (remote_is_dir(conn, dir) && file2 == NULL) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Changing to: %s\\n\", dir);\n\t\t\tsnprintf(cmd, sizeof cmd, \"cd \\\"%s\\\"\", dir);\n\t\t\tif (parse_dispatch_command(conn, cmd,\n\t\t\t    &remote_path, startdir, 1, 0) != 0) {\n\t\t\t\tfree(dir);\n\t\t\t\tfree(startdir);\n\t\t\t\tfree(remote_path);\n\t\t\t\tfree(conn);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t} else {\n\t\t\t/* XXX this is wrong wrt quoting */\n\t\t\tsnprintf(cmd, sizeof cmd, \"get%s %s%s%s\",\n\t\t\t    global_aflag ? \" -a\" : \"\", dir,\n\t\t\t    file2 == NULL ? \"\" : \" \",\n\t\t\t    file2 == NULL ? \"\" : file2);\n\t\t\terr = parse_dispatch_command(conn, cmd,\n\t\t\t    &remote_path, startdir, 1, 0);\n\t\t\tfree(dir);\n\t\t\tfree(startdir);\n\t\t\tfree(remote_path);\n\t\t\tfree(conn);\n\t\t\treturn (err);\n\t\t}\n\t\tfree(dir);\n\t}\n\n\tsetvbuf(stdout, NULL, _IOLBF, 0);\n\tsetvbuf(infile, NULL, _IOLBF, 0);\n\n\tinteractive = !batchmode && isatty(STDIN_FILENO);\n\terr = 0;\n\tfor (;;) {\n\t\tsignal(SIGINT, SIG_IGN);\n\n\t\tif (el == NULL) {\n\t\t\tif (interactive)\n\t\t\t\tprintf(\"sftp> \");\n\t\t\tif (fgets(cmd, sizeof(cmd), infile) == NULL) {\n\t\t\t\tif (interactive)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n#ifdef USE_LIBEDIT\n\t\t\tconst char *line;\n\t\t\tint count = 0;\n\n\t\t\tif ((line = el_gets(el, &count)) == NULL ||\n\t\t\t    count <= 0) {\n\t\t\t\tprintf(\"\\n\");\n \t\t\t\tbreak;\n\t\t\t}\n\t\t\thistory(hl, &hev, H_ENTER, line);\n\t\t\tif (strlcpy(cmd, line, sizeof(cmd)) >= sizeof(cmd)) {\n\t\t\t\tfprintf(stderr, \"Error: input line too long\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n#endif /* USE_LIBEDIT */\n\t\t}\n\n\t\tcmd[strcspn(cmd, \"\\n\")] = '\\0';\n\n\t\t/* Handle user interrupts gracefully during commands */\n\t\tinterrupted = 0;\n\t\tsignal(SIGINT, cmd_interrupt);\n\n\t\terr = parse_dispatch_command(conn, cmd, &remote_path,\n\t\t    startdir, batchmode, !interactive && el == NULL);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t}\n\tsignal(SIGCHLD, SIG_DFL);\n\tfree(remote_path);\n\tfree(startdir);\n\tfree(conn);\n\n#ifdef USE_LIBEDIT\n\tif (el != NULL)\n\t\tel_end(el);\n#endif /* USE_LIBEDIT */\n\n\t/* err == 1 signifies normal \"quit\" exit */\n\treturn (err >= 0 ? 0 : -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Attached to %s.\\n\"",
            "sftp_direct"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Connected to %s.\\n\"",
            "host"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Couldn't initialise connection to server\""
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_init",
          "args": [
            "in",
            "out",
            "copy_buffer_len",
            "num_requests",
            "limit_kbps"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "do_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "392-492",
          "snippet": "struct sftp_conn *\ndo_init(int fd_in, int fd_out, u_int transfer_buflen, u_int num_requests,\n    u_int64_t limit_kbps)\n{\n\tu_char type;\n\tstruct sshbuf *msg;\n\tstruct sftp_conn *ret;\n\tint r;\n\n\tret = xcalloc(1, sizeof(*ret));\n\tret->msg_id = 1;\n\tret->fd_in = fd_in;\n\tret->fd_out = fd_out;\n\tret->transfer_buflen = transfer_buflen;\n\tret->num_requests = num_requests;\n\tret->exts = 0;\n\tret->limit_kbps = 0;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_INIT)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FILEXFER_VERSION)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(ret, msg);\n\n\tsshbuf_reset(msg);\n\n\tget_msg_extended(ret, msg, 1);\n\n\t/* Expecting a VERSION reply */\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_FXP_VERSION) {\n\t\terror(\"Invalid packet back from SSH2_FXP_INIT (type %u)\",\n\t\t    type);\n\t\tsshbuf_free(msg);\n\t\tfree(ret);\n\t\treturn(NULL);\n\t}\n\tif ((r = sshbuf_get_u32(msg, &ret->version)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug2(\"Remote version: %u\", ret->version);\n\n\t/* Check for extensions */\n\twhile (sshbuf_len(msg) > 0) {\n\t\tchar *name;\n\t\tu_char *value;\n\t\tsize_t vlen;\n\t\tint known = 0;\n\n\t\tif ((r = sshbuf_get_cstring(msg, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string(msg, &value, &vlen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (strcmp(name, \"posix-rename@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_POSIX_RENAME;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"statvfs@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"2\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_STATVFS;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"fstatvfs@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"2\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_FSTATVFS;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"hardlink@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_HARDLINK;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"fsync@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_FSYNC;\n\t\t\tknown = 1;\n\t\t}\n\t\tif (known) {\n\t\t\tdebug2(\"Server supports extension \\\"%s\\\" revision %s\",\n\t\t\t    name, value);\n\t\t} else {\n\t\t\tdebug2(\"Unrecognised server extension \\\"%s\\\"\", name);\n\t\t}\n\t\tfree(name);\n\t\tfree(value);\n\t}\n\n\tsshbuf_free(msg);\n\n\t/* Some filexfer v.0 servers don't support large packets */\n\tif (ret->version == 0)\n\t\tret->transfer_buflen = MINIMUM(ret->transfer_buflen, 20480);\n\n\tret->limit_kbps = limit_kbps;\n\tif (ret->limit_kbps > 0) {\n\t\tbandwidth_limit_init(&ret->bwlimit_in, ret->limit_kbps,\n\t\t    ret->transfer_buflen);\n\t\tbandwidth_limit_init(&ret->bwlimit_out, ret->limit_kbps,\n\t\t    ret->transfer_buflen);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SFTP_EXT_FSYNC\t\t0x00000010",
            "#define SFTP_EXT_HARDLINK\t0x00000008",
            "#define SFTP_EXT_FSTATVFS\t0x00000004",
            "#define SFTP_EXT_STATVFS\t0x00000002",
            "#define SFTP_EXT_POSIX_RENAME\t0x00000001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SFTP_EXT_FSYNC\t\t0x00000010\n#define SFTP_EXT_HARDLINK\t0x00000008\n#define SFTP_EXT_FSTATVFS\t0x00000004\n#define SFTP_EXT_STATVFS\t0x00000002\n#define SFTP_EXT_POSIX_RENAME\t0x00000001\n\nstruct sftp_conn *\ndo_init(int fd_in, int fd_out, u_int transfer_buflen, u_int num_requests,\n    u_int64_t limit_kbps)\n{\n\tu_char type;\n\tstruct sshbuf *msg;\n\tstruct sftp_conn *ret;\n\tint r;\n\n\tret = xcalloc(1, sizeof(*ret));\n\tret->msg_id = 1;\n\tret->fd_in = fd_in;\n\tret->fd_out = fd_out;\n\tret->transfer_buflen = transfer_buflen;\n\tret->num_requests = num_requests;\n\tret->exts = 0;\n\tret->limit_kbps = 0;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_INIT)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FILEXFER_VERSION)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(ret, msg);\n\n\tsshbuf_reset(msg);\n\n\tget_msg_extended(ret, msg, 1);\n\n\t/* Expecting a VERSION reply */\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_FXP_VERSION) {\n\t\terror(\"Invalid packet back from SSH2_FXP_INIT (type %u)\",\n\t\t    type);\n\t\tsshbuf_free(msg);\n\t\tfree(ret);\n\t\treturn(NULL);\n\t}\n\tif ((r = sshbuf_get_u32(msg, &ret->version)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug2(\"Remote version: %u\", ret->version);\n\n\t/* Check for extensions */\n\twhile (sshbuf_len(msg) > 0) {\n\t\tchar *name;\n\t\tu_char *value;\n\t\tsize_t vlen;\n\t\tint known = 0;\n\n\t\tif ((r = sshbuf_get_cstring(msg, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string(msg, &value, &vlen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (strcmp(name, \"posix-rename@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_POSIX_RENAME;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"statvfs@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"2\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_STATVFS;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"fstatvfs@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"2\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_FSTATVFS;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"hardlink@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_HARDLINK;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"fsync@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_FSYNC;\n\t\t\tknown = 1;\n\t\t}\n\t\tif (known) {\n\t\t\tdebug2(\"Server supports extension \\\"%s\\\" revision %s\",\n\t\t\t    name, value);\n\t\t} else {\n\t\t\tdebug2(\"Unrecognised server extension \\\"%s\\\"\", name);\n\t\t}\n\t\tfree(name);\n\t\tfree(value);\n\t}\n\n\tsshbuf_free(msg);\n\n\t/* Some filexfer v.0 servers don't support large packets */\n\tif (ret->version == 0)\n\t\tret->transfer_buflen = MINIMUM(ret->transfer_buflen, 20480);\n\n\tret->limit_kbps = limit_kbps;\n\tif (ret->limit_kbps > 0) {\n\t\tbandwidth_limit_init(&ret->bwlimit_in, ret->limit_kbps,\n\t\t    ret->transfer_buflen);\n\t\tbandwidth_limit_init(&ret->bwlimit_out, ret->limit_kbps,\n\t\t    ret->transfer_buflen);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeargs",
          "args": [
            "&args"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "freeargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "908-920",
          "snippet": "void\nfreeargs(arglist *args)\n{\n\tu_int i;\n\n\tif (args->list != NULL) {\n\t\tfor (i = 0; i < args->num; i++)\n\t\t\tfree(args->list[i]);\n\t\tfree(args->list);\n\t\targs->nalloc = args->num = 0;\n\t\targs->list = NULL;\n\t}\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfreeargs(arglist *args)\n{\n\tu_int i;\n\n\tif (args->list != NULL) {\n\t\tfor (i = 0; i < args->num; i++)\n\t\t\tfree(args->list[i]);\n\t\tfree(args->list);\n\t\targs->nalloc = args->num = 0;\n\t\targs->list = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_to_server",
          "args": [
            "sftp_direct",
            "args.list",
            "&in",
            "&out"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "connect_to_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "2270-2329",
          "snippet": "static void\nconnect_to_server(char *path, char **args, int *in, int *out)\n{\n\tint c_in, c_out;\n\n#ifdef USE_PIPES\n\tint pin[2], pout[2];\n\n\tif ((pipe(pin) == -1) || (pipe(pout) == -1))\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\t*in = pin[0];\n\t*out = pout[1];\n\tc_in = pout[0];\n\tc_out = pin[1];\n#else /* USE_PIPES */\n\tint inout[2];\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) == -1)\n\t\tfatal(\"socketpair: %s\", strerror(errno));\n\t*in = *out = inout[0];\n\tc_in = c_out = inout[1];\n#endif /* USE_PIPES */\n\n\tif ((sshpid = fork()) == -1)\n\t\tfatal(\"fork: %s\", strerror(errno));\n\telse if (sshpid == 0) {\n\t\tif ((dup2(c_in, STDIN_FILENO) == -1) ||\n\t\t    (dup2(c_out, STDOUT_FILENO) == -1)) {\n\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclose(*in);\n\t\tclose(*out);\n\t\tclose(c_in);\n\t\tclose(c_out);\n\n\t\t/*\n\t\t * The underlying ssh is in the same process group, so we must\n\t\t * ignore SIGINT if we want to gracefully abort commands,\n\t\t * otherwise the signal will make it to the ssh process and\n\t\t * kill it too.  Contrawise, since sftp sends SIGTERMs to the\n\t\t * underlying ssh, it must *not* ignore that signal.\n\t\t */\n\t\tsignal(SIGINT, SIG_IGN);\n\t\tsignal(SIGTERM, SIG_DFL);\n\t\texecvp(path, args);\n\t\tfprintf(stderr, \"exec: %s: %s\\n\", path, strerror(errno));\n\t\t_exit(1);\n\t}\n\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\tsignal(SIGTSTP, suspchild);\n\tsignal(SIGTTIN, suspchild);\n\tsignal(SIGTTOU, suspchild);\n\tsignal(SIGCHLD, sigchld_handler);\n\tclose(c_in);\n\tclose(c_out);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile pid_t sshpid = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile pid_t sshpid = -1;\n\nstatic void\nconnect_to_server(char *path, char **args, int *in, int *out)\n{\n\tint c_in, c_out;\n\n#ifdef USE_PIPES\n\tint pin[2], pout[2];\n\n\tif ((pipe(pin) == -1) || (pipe(pout) == -1))\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\t*in = pin[0];\n\t*out = pout[1];\n\tc_in = pout[0];\n\tc_out = pin[1];\n#else /* USE_PIPES */\n\tint inout[2];\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) == -1)\n\t\tfatal(\"socketpair: %s\", strerror(errno));\n\t*in = *out = inout[0];\n\tc_in = c_out = inout[1];\n#endif /* USE_PIPES */\n\n\tif ((sshpid = fork()) == -1)\n\t\tfatal(\"fork: %s\", strerror(errno));\n\telse if (sshpid == 0) {\n\t\tif ((dup2(c_in, STDIN_FILENO) == -1) ||\n\t\t    (dup2(c_out, STDOUT_FILENO) == -1)) {\n\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclose(*in);\n\t\tclose(*out);\n\t\tclose(c_in);\n\t\tclose(c_out);\n\n\t\t/*\n\t\t * The underlying ssh is in the same process group, so we must\n\t\t * ignore SIGINT if we want to gracefully abort commands,\n\t\t * otherwise the signal will make it to the ssh process and\n\t\t * kill it too.  Contrawise, since sftp sends SIGTERMs to the\n\t\t * underlying ssh, it must *not* ignore that signal.\n\t\t */\n\t\tsignal(SIGINT, SIG_IGN);\n\t\tsignal(SIGTERM, SIG_DFL);\n\t\texecvp(path, args);\n\t\tfprintf(stderr, \"exec: %s: %s\\n\", path, strerror(errno));\n\t\t_exit(1);\n\t}\n\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\tsignal(SIGTSTP, suspchild);\n\tsignal(SIGTTIN, suspchild);\n\tsignal(SIGTTOU, suspchild);\n\tsignal(SIGCHLD, sigchld_handler);\n\tclose(c_in);\n\tclose(c_out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addargs",
          "args": [
            "&args",
            "\"sftp-server\""
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "addargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "861-886",
          "snippet": "void\naddargs(arglist *args, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tu_int nalloc;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"addargs: argument too long\");\n\n\tnalloc = args->nalloc;\n\tif (args->list == NULL) {\n\t\tnalloc = 32;\n\t\targs->num = 0;\n\t} else if (args->num+2 >= nalloc)\n\t\tnalloc *= 2;\n\n\targs->list = xrecallocarray(args->list, args->nalloc, nalloc, sizeof(char *));\n\targs->nalloc = nalloc;\n\targs->list[args->num++] = cp;\n\targs->list[args->num] = NULL;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\naddargs(arglist *args, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tu_int nalloc;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"addargs: argument too long\");\n\n\tnalloc = args->nalloc;\n\tif (args->list == NULL) {\n\t\tnalloc = 32;\n\t\targs->num = 0;\n\t} else if (args->num+2 >= nalloc)\n\t\tnalloc *= 2;\n\n\targs->list = xrecallocarray(args->list, args->nalloc, nalloc, sizeof(char *));\n\targs->nalloc = nalloc;\n\targs->list[args->num++] = cp;\n\targs->list[args->num] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "sftp_server",
            "'/'"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 2514
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "2331-2345",
          "snippet": "static void\nusage(void)\n{\n\textern char *__progname;\n\n\tfprintf(stderr,\n\t    \"usage: %s [-46aCfpqrv] [-B buffer_size] [-b batchfile] [-c cipher]\\n\"\n\t    \"          [-D sftp_server_path] [-F ssh_config] \"\n\t    \"[-i identity_file] [-l limit]\\n\"\n\t    \"          [-o ssh_option] [-P port] [-R num_requests] \"\n\t    \"[-S program]\\n\"\n\t    \"          [-s subsystem | sftp_server] destination\\n\",\n\t    __progname);\n\texit(1);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *__progname;\n\nstatic void\nusage(void)\n{\n\textern char *__progname;\n\n\tfprintf(stderr,\n\t    \"usage: %s [-46aCfpqrv] [-B buffer_size] [-b batchfile] [-c cipher]\\n\"\n\t    \"          [-D sftp_server_path] [-F ssh_config] \"\n\t    \"[-i identity_file] [-l limit]\\n\"\n\t    \"          [-o ssh_option] [-P port] [-R num_requests] \"\n\t    \"[-S program]\\n\"\n\t    \"          [-s subsystem | sftp_server] destination\\n\",\n\t    __progname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Missing hostname\\n\""
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleanhostname",
          "args": [
            "host"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "cleanhostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "535-543",
          "snippet": "char *\ncleanhostname(char *host)\n{\n\tif (*host == '[' && host[strlen(host) - 1] == ']') {\n\t\thost[strlen(host) - 1] = '\\0';\n\t\treturn (host + 1);\n\t} else\n\t\treturn host;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ncleanhostname(char *host)\n{\n\tif (*host == '[' && host[strlen(host) - 1] == ']') {\n\t\thost[strlen(host) - 1] = '\\0';\n\t\treturn (host + 1);\n\t} else\n\t\treturn host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "*argv"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_user_host_path",
          "args": [
            "*argv",
            "&user",
            "&host",
            "&file1"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "parse_user_host_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "577-635",
          "snippet": "int\nparse_user_host_path(const char *s, char **userp, char **hostp, char **pathp)\n{\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tchar *sdup, *tmp;\n\tint ret = -1;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (pathp != NULL)\n\t\t*pathp = NULL;\n\n\tsdup = xstrdup(s);\n\n\t/* Check for remote syntax: [user@]host:[path] */\n\tif ((tmp = colon(sdup)) == NULL)\n\t\tgoto out;\n\n\t/* Extract optional path */\n\t*tmp++ = '\\0';\n\tif (*tmp == '\\0')\n\t\ttmp = \".\";\n\tpath = xstrdup(tmp);\n\n\t/* Extract optional user and mandatory host */\n\ttmp = strrchr(sdup, '@');\n\tif (tmp != NULL) {\n\t\t*tmp++ = '\\0';\n\t\thost = xstrdup(cleanhostname(tmp));\n\t\tif (*sdup != '\\0')\n\t\t\tuser = xstrdup(sdup);\n\t} else {\n\t\thost = xstrdup(cleanhostname(sdup));\n\t\tuser = NULL;\n\t}\n\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (pathp != NULL) {\n\t\t*pathp = path;\n\t\tpath = NULL;\n\t}\n\tret = 0;\nout:\n\tfree(sdup);\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_user_host_path(const char *s, char **userp, char **hostp, char **pathp)\n{\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tchar *sdup, *tmp;\n\tint ret = -1;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (pathp != NULL)\n\t\t*pathp = NULL;\n\n\tsdup = xstrdup(s);\n\n\t/* Check for remote syntax: [user@]host:[path] */\n\tif ((tmp = colon(sdup)) == NULL)\n\t\tgoto out;\n\n\t/* Extract optional path */\n\t*tmp++ = '\\0';\n\tif (*tmp == '\\0')\n\t\ttmp = \".\";\n\tpath = xstrdup(tmp);\n\n\t/* Extract optional user and mandatory host */\n\ttmp = strrchr(sdup, '@');\n\tif (tmp != NULL) {\n\t\t*tmp++ = '\\0';\n\t\thost = xstrdup(cleanhostname(tmp));\n\t\tif (*sdup != '\\0')\n\t\t\tuser = xstrdup(sdup);\n\t} else {\n\t\thost = xstrdup(cleanhostname(sdup));\n\t\tuser = NULL;\n\t}\n\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (pathp != NULL) {\n\t\t*pathp = path;\n\t\tpath = NULL;\n\t}\n\tret = 0;\nout:\n\tfree(sdup);\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_uri",
          "args": [
            "\"sftp\"",
            "*argv",
            "&user",
            "&host",
            "&tmp",
            "&file1"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uri",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "769-858",
          "snippet": "int\nparse_uri(const char *scheme, const char *uri, char **userp, char **hostp,\n    int *portp, char **pathp)\n{\n\tchar *uridup, *cp, *tmp, ch;\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tint port = -1, ret = -1;\n\tsize_t len;\n\n\tlen = strlen(scheme);\n\tif (strncmp(uri, scheme, len) != 0 || strncmp(uri + len, \"://\", 3) != 0)\n\t\treturn 1;\n\turi += len + 3;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (portp != NULL)\n\t\t*portp = -1;\n\tif (pathp != NULL)\n\t\t*pathp = NULL;\n\n\turidup = tmp = xstrdup(uri);\n\n\t/* Extract optional ssh-info (username + connection params) */\n\tif ((cp = strchr(tmp, '@')) != NULL) {\n\t\tchar *delim;\n\n\t\t*cp = '\\0';\n\t\t/* Extract username and connection params */\n\t\tif ((delim = strchr(tmp, ';')) != NULL) {\n\t\t\t/* Just ignore connection params for now */\n\t\t\t*delim = '\\0';\n\t\t}\n\t\tif (*tmp == '\\0') {\n\t\t\t/* Empty username */\n\t\t\tgoto out;\n\t\t}\n\t\tif ((user = urldecode(tmp)) == NULL)\n\t\t\tgoto out;\n\t\ttmp = cp + 1;\n\t}\n\n\t/* Extract mandatory hostname */\n\tif ((cp = hpdelim2(&tmp, &ch)) == NULL || *cp == '\\0')\n\t\tgoto out;\n\thost = xstrdup(cleanhostname(cp));\n\tif (!valid_domain(host, 0, NULL))\n\t\tgoto out;\n\n\tif (tmp != NULL && *tmp != '\\0') {\n\t\tif (ch == ':') {\n\t\t\t/* Convert and verify port. */\n\t\t\tif ((cp = strchr(tmp, '/')) != NULL)\n\t\t\t\t*cp = '\\0';\n\t\t\tif ((port = a2port(tmp)) <= 0)\n\t\t\t\tgoto out;\n\t\t\ttmp = cp ? cp + 1 : NULL;\n\t\t}\n\t\tif (tmp != NULL && *tmp != '\\0') {\n\t\t\t/* Extract optional path */\n\t\t\tif ((path = urldecode(tmp)) == NULL)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (portp != NULL)\n\t\t*portp = port;\n\tif (pathp != NULL) {\n\t\t*pathp = path;\n\t\tpath = NULL;\n\t}\n\tret = 0;\n out:\n\tfree(uridup);\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_uri(const char *scheme, const char *uri, char **userp, char **hostp,\n    int *portp, char **pathp)\n{\n\tchar *uridup, *cp, *tmp, ch;\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tint port = -1, ret = -1;\n\tsize_t len;\n\n\tlen = strlen(scheme);\n\tif (strncmp(uri, scheme, len) != 0 || strncmp(uri + len, \"://\", 3) != 0)\n\t\treturn 1;\n\turi += len + 3;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (portp != NULL)\n\t\t*portp = -1;\n\tif (pathp != NULL)\n\t\t*pathp = NULL;\n\n\turidup = tmp = xstrdup(uri);\n\n\t/* Extract optional ssh-info (username + connection params) */\n\tif ((cp = strchr(tmp, '@')) != NULL) {\n\t\tchar *delim;\n\n\t\t*cp = '\\0';\n\t\t/* Extract username and connection params */\n\t\tif ((delim = strchr(tmp, ';')) != NULL) {\n\t\t\t/* Just ignore connection params for now */\n\t\t\t*delim = '\\0';\n\t\t}\n\t\tif (*tmp == '\\0') {\n\t\t\t/* Empty username */\n\t\t\tgoto out;\n\t\t}\n\t\tif ((user = urldecode(tmp)) == NULL)\n\t\t\tgoto out;\n\t\ttmp = cp + 1;\n\t}\n\n\t/* Extract mandatory hostname */\n\tif ((cp = hpdelim2(&tmp, &ch)) == NULL || *cp == '\\0')\n\t\tgoto out;\n\thost = xstrdup(cleanhostname(cp));\n\tif (!valid_domain(host, 0, NULL))\n\t\tgoto out;\n\n\tif (tmp != NULL && *tmp != '\\0') {\n\t\tif (ch == ':') {\n\t\t\t/* Convert and verify port. */\n\t\t\tif ((cp = strchr(tmp, '/')) != NULL)\n\t\t\t\t*cp = '\\0';\n\t\t\tif ((port = a2port(tmp)) <= 0)\n\t\t\t\tgoto out;\n\t\t\ttmp = cp ? cp + 1 : NULL;\n\t\t}\n\t\tif (tmp != NULL && *tmp != '\\0') {\n\t\t\t/* Extract optional path */\n\t\t\tif ((path = urldecode(tmp)) == NULL)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (portp != NULL)\n\t\t*portp = port;\n\tif (pathp != NULL) {\n\t\t*pathp = path;\n\t\tpath = NULL;\n\t}\n\tret = 0;\n out:\n\tfree(uridup);\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_init",
          "args": [
            "argv[0]",
            "ll",
            "SYSLOG_FACILITY_USER",
            "1"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "256-336",
          "snippet": "void\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int log_on_stderr = 1;",
            "static int log_facility = LOG_AUTH;",
            "static char *argv0;",
            "static log_handler_fn *log_handler;",
            "static void *log_handler_ctx;",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int log_on_stderr = 1;\nstatic int log_facility = LOG_AUTH;\nstatic char *argv0;\nstatic log_handler_fn *log_handler;\nstatic void *log_handler_ctx;\nextern char *__progname;\n\nvoid\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDERR_FILENO"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacearg",
          "args": [
            "&args",
            "0",
            "\"%s\"",
            "ssh_program"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "replacearg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "888-906",
          "snippet": "void\nreplacearg(arglist *args, u_int which, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"replacearg: argument too long\");\n\n\tif (which >= args->num)\n\t\tfatal(\"replacearg: tried to replace invalid arg %d >= %d\",\n\t\t    which, args->num);\n\tfree(args->list[which]);\n\targs->list[which] = cp;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nreplacearg(arglist *args, u_int which, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"replacearg: argument too long\");\n\n\tif (which >= args->num)\n\t\tfatal(\"replacearg: tried to replace invalid arg %d >= %d\",\n\t\t    which, args->num);\n\tfree(args->list[which]);\n\targs->list[which] = cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "optarg",
            "&cp",
            "10"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "strtoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtoll.c",
          "lines": "49-147",
          "snippet": "long long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nlong long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtonum",
          "args": [
            "optarg",
            "1",
            "100 * 1024 * 1024",
            "&errstr"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "strtonum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtonum.c",
          "lines": "33-70",
          "snippet": "long long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define TOOLARGE \t3",
            "#define TOOSMALL \t2",
            "#define INVALID \t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\n#define TOOLARGE \t3\n#define TOOSMALL \t2\n#define INVALID \t1\n\nlong long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "optarg",
            "\"r\""
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "optarg",
            "\"-\""
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "a2port",
          "args": [
            "optarg"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "a2port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "333-346",
          "snippet": "int\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"1246afhpqrvCc:D:i:l:o:s:S:b:B:F:P:R:\""
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "'\\0'",
            "sizeof(args)"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_get_progname",
          "args": [
            "argv[0]"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_get_progname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "43-64",
          "snippet": "char *ssh_get_progname(char *argv0)\n{\n\tchar *p, *q;\n#ifdef HAVE___PROGNAME\n\textern char *__progname;\n\n\tp = __progname;\n#else\n\tif (argv0 == NULL)\n\t\treturn (\"unknown\");\t/* XXX */\n\tp = strrchr(argv0, '/');\n\tif (p == NULL)\n\t\tp = argv0;\n\telse\n\t\tp++;\n#endif\n\tif ((q = strdup(p)) == NULL) {\n\t\tperror(\"strdup\");\n\t\texit(1);\n\t}\n\treturn q;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *ssh_get_progname(char *argv0)\n{\n\tchar *p, *q;\n#ifdef HAVE___PROGNAME\n\textern char *__progname;\n\n\tp = __progname;\n#else\n\tif (argv0 == NULL)\n\t\treturn (\"unknown\");\t/* XXX */\n\tp = strrchr(argv0, '/');\n\tif (p == NULL)\n\t\tp = argv0;\n\telse\n\t\tp++;\n#endif\n\tif ((q = strdup(p)) == NULL) {\n\t\tperror(\"strdup\");\n\t\texit(1);\n\t}\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msetlocale",
          "args": [],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "msetlocale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "310-340",
          "snippet": "void\nmsetlocale(void)\n{\n\tconst char *vars[] = { \"LC_ALL\", \"LC_CTYPE\", \"LANG\", NULL };\n\tchar *cp;\n\tint i;\n\n\t/*\n\t * We can't yet cope with dotless/dotted I in Turkish locales,\n\t * so fall back to the C locale for these.\n\t */\n\tfor (i = 0; vars[i] != NULL; i++) {\n\t\tif ((cp = getenv(vars[i])) == NULL)\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"TR\", 2) != 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * If we're in a UTF-8 locale then prefer to use\n\t\t * the C.UTF-8 locale (or equivalent) if it exists.\n\t\t */\n\t\tif ((strcasestr(cp, \"UTF-8\") != NULL ||\n\t\t    strcasestr(cp, \"UTF8\") != NULL) &&\n\t\t    (setlocale(LC_CTYPE, \"C.UTF-8\") != NULL ||\n\t\t    setlocale(LC_CTYPE, \"POSIX.UTF-8\") != NULL))\n\t\t\treturn;\n\t\tsetlocale(LC_CTYPE, \"C\");\n\t\treturn;\n\t}\n\t/* We can handle this locale */\n\tsetlocale(LC_CTYPE, \"\");\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmsetlocale(void)\n{\n\tconst char *vars[] = { \"LC_ALL\", \"LC_CTYPE\", \"LANG\", NULL };\n\tchar *cp;\n\tint i;\n\n\t/*\n\t * We can't yet cope with dotless/dotted I in Turkish locales,\n\t * so fall back to the C locale for these.\n\t */\n\tfor (i = 0; vars[i] != NULL; i++) {\n\t\tif ((cp = getenv(vars[i])) == NULL)\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"TR\", 2) != 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * If we're in a UTF-8 locale then prefer to use\n\t\t * the C.UTF-8 locale (or equivalent) if it exists.\n\t\t */\n\t\tif ((strcasestr(cp, \"UTF-8\") != NULL ||\n\t\t    strcasestr(cp, \"UTF8\") != NULL) &&\n\t\t    (setlocale(LC_CTYPE, \"C.UTF-8\") != NULL ||\n\t\t    setlocale(LC_CTYPE, \"POSIX.UTF-8\") != NULL))\n\t\t\treturn;\n\t\tsetlocale(LC_CTYPE, \"C\");\n\t\treturn;\n\t}\n\t/* We can handle this locale */\n\tsetlocale(LC_CTYPE, \"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanitise_stdfd",
          "args": [],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "sanitise_stdfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1109-1130",
          "snippet": "void\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_malloc_init",
          "args": [],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_malloc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "29-37",
          "snippet": "void\nssh_malloc_init(void)\n{\n#if defined(__OpenBSD__)\n\textern char *malloc_options;\n\n\tmalloc_options = \"S\";\n#endif /* __OpenBSD__ */\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nssh_malloc_init(void)\n{\n#if defined(__OpenBSD__)\n\textern char *malloc_options;\n\n\tmalloc_options = \"S\";\n#endif /* __OpenBSD__ */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define DEFAULT_NUM_REQUESTS\t64\t/* # concurrent outstanding requests */\n#define DEFAULT_COPY_BUFLEN\t32768\t/* Size of buffer for up/download */\n\nFILE* infile;\nint batchmode = 0;\nstatic volatile pid_t sshpid = -1;\nint quiet = 0;\nint showprogress = 1;\nint global_rflag = 0;\nint global_aflag = 0;\nint global_pflag = 0;\nint global_fflag = 0;\nextern char *__progname;\n\nint\nmain(int argc, char **argv)\n{\n\tint in, out, ch, err, tmp, port = -1;\n\tchar *host = NULL, *user, *cp, *file2 = NULL;\n\tint debug_level = 0, sshver = 2;\n\tchar *file1 = NULL, *sftp_server = NULL;\n\tchar *ssh_program = _PATH_SSH_PROGRAM, *sftp_direct = NULL;\n\tconst char *errstr;\n\tLogLevel ll = SYSLOG_LEVEL_INFO;\n\targlist args;\n\textern int optind;\n\textern char *optarg;\n\tstruct sftp_conn *conn;\n\tsize_t copy_buffer_len = DEFAULT_COPY_BUFLEN;\n\tsize_t num_requests = DEFAULT_NUM_REQUESTS;\n\tlong long limit_kbps = 0;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\tmsetlocale();\n\n\t__progname = ssh_get_progname(argv[0]);\n\tmemset(&args, '\\0', sizeof(args));\n\targs.list = NULL;\n\taddargs(&args, \"%s\", ssh_program);\n\taddargs(&args, \"-oForwardX11 no\");\n\taddargs(&args, \"-oForwardAgent no\");\n\taddargs(&args, \"-oPermitLocalCommand no\");\n\taddargs(&args, \"-oClearAllForwardings yes\");\n\n\tll = SYSLOG_LEVEL_INFO;\n\tinfile = stdin;\n\n\twhile ((ch = getopt(argc, argv,\n\t    \"1246afhpqrvCc:D:i:l:o:s:S:b:B:F:P:R:\")) != -1) {\n\t\tswitch (ch) {\n\t\t/* Passed through to ssh(1) */\n\t\tcase '4':\n\t\tcase '6':\n\t\tcase 'C':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\tbreak;\n\t\t/* Passed through to ssh(1) with argument */\n\t\tcase 'F':\n\t\tcase 'c':\n\t\tcase 'i':\n\t\tcase 'o':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&args, \"%s\", optarg);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tll = SYSLOG_LEVEL_ERROR;\n\t\t\tquiet = 1;\n\t\t\tshowprogress = 0;\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tport = a2port(optarg);\n\t\t\tif (port <= 0)\n\t\t\t\tfatal(\"Bad port \\\"%s\\\"\\n\", optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (debug_level < 3) {\n\t\t\t\taddargs(&args, \"-v\");\n\t\t\t\tll = SYSLOG_LEVEL_DEBUG1 + debug_level;\n\t\t\t}\n\t\t\tdebug_level++;\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tsshver = 1;\n\t\t\tif (sftp_server == NULL)\n\t\t\t\tsftp_server = _PATH_SFTP_SERVER;\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tsshver = 2;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tglobal_aflag = 1;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tcopy_buffer_len = strtol(optarg, &cp, 10);\n\t\t\tif (copy_buffer_len == 0 || *cp != '\\0')\n\t\t\t\tfatal(\"Invalid buffer size \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (batchmode)\n\t\t\t\tfatal(\"Batch file already specified.\");\n\n\t\t\t/* Allow \"-\" as stdin */\n\t\t\tif (strcmp(optarg, \"-\") != 0 &&\n\t\t\t    (infile = fopen(optarg, \"r\")) == NULL)\n\t\t\t\tfatal(\"%s (%s).\", strerror(errno), optarg);\n\t\t\tshowprogress = 0;\n\t\t\tquiet = batchmode = 1;\n\t\t\taddargs(&args, \"-obatchmode yes\");\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tglobal_fflag = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tglobal_pflag = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tsftp_direct = optarg;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlimit_kbps = strtonum(optarg, 1, 100 * 1024 * 1024,\n\t\t\t    &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tusage();\n\t\t\tlimit_kbps *= 1024; /* kbps */\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tglobal_rflag = 1;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tnum_requests = strtol(optarg, &cp, 10);\n\t\t\tif (num_requests == 0 || *cp != '\\0')\n\t\t\t\tfatal(\"Invalid number of requests \\\"%s\\\"\",\n\t\t\t\t    optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsftp_server = optarg;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tssh_program = optarg;\n\t\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\tif (!isatty(STDERR_FILENO))\n\t\tshowprogress = 0;\n\n\tlog_init(argv[0], ll, SYSLOG_FACILITY_USER, 1);\n\n\tif (sftp_direct == NULL) {\n\t\tif (optind == argc || argc > (optind + 2))\n\t\t\tusage();\n\t\targv += optind;\n\n\t\tswitch (parse_uri(\"sftp\", *argv, &user, &host, &tmp, &file1)) {\n\t\tcase -1:\n\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tif (tmp != -1)\n\t\t\t\tport = tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (parse_user_host_path(*argv, &user, &host,\n\t\t\t    &file1) == -1) {\n\t\t\t\t/* Treat as a plain hostname. */\n\t\t\t\thost = xstrdup(*argv);\n\t\t\t\thost = cleanhostname(host);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfile2 = *(argv + 1);\n\n\t\tif (!*host) {\n\t\t\tfprintf(stderr, \"Missing hostname\\n\");\n\t\t\tusage();\n\t\t}\n\n\t\tif (port != -1)\n\t\t\taddargs(&args, \"-oPort %d\", port);\n\t\tif (user != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", user);\n\t\t}\n\t\taddargs(&args, \"-oProtocol %d\", sshver);\n\n\t\t/* no subsystem if the server-spec contains a '/' */\n\t\tif (sftp_server == NULL || strchr(sftp_server, '/') == NULL)\n\t\t\taddargs(&args, \"-s\");\n\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", (sftp_server != NULL ?\n\t\t    sftp_server : \"sftp\"));\n\n\t\tconnect_to_server(ssh_program, args.list, &in, &out);\n\t} else {\n\t\targs.list = NULL;\n\t\taddargs(&args, \"sftp-server\");\n\n\t\tconnect_to_server(sftp_direct, args.list, &in, &out);\n\t}\n\tfreeargs(&args);\n\n\tconn = do_init(in, out, copy_buffer_len, num_requests, limit_kbps);\n\tif (conn == NULL)\n\t\tfatal(\"Couldn't initialise connection to server\");\n\n\tif (!quiet) {\n\t\tif (sftp_direct == NULL)\n\t\t\tfprintf(stderr, \"Connected to %s.\\n\", host);\n\t\telse\n\t\t\tfprintf(stderr, \"Attached to %s.\\n\", sftp_direct);\n\t}\n\n\terr = interactive_loop(conn, file1, file2);\n\n#if !defined(USE_PIPES)\n\tshutdown(in, SHUT_RDWR);\n\tshutdown(out, SHUT_RDWR);\n#endif\n\n\tclose(in);\n\tclose(out);\n\tif (batchmode)\n\t\tfclose(infile);\n\n\twhile (waitpid(sshpid, NULL, 0) == -1 && sshpid > 1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for ssh process: %s\",\n\t\t\t    strerror(errno));\n\n\texit(err == 0 ? 0 : 1);\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "2331-2345",
    "snippet": "static void\nusage(void)\n{\n\textern char *__progname;\n\n\tfprintf(stderr,\n\t    \"usage: %s [-46aCfpqrv] [-B buffer_size] [-b batchfile] [-c cipher]\\n\"\n\t    \"          [-D sftp_server_path] [-F ssh_config] \"\n\t    \"[-i identity_file] [-l limit]\\n\"\n\t    \"          [-o ssh_option] [-P port] [-R num_requests] \"\n\t    \"[-S program]\\n\"\n\t    \"          [-s subsystem | sftp_server] destination\\n\",\n\t    __progname);\n\texit(1);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *__progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"usage: %s [-46aCfpqrv] [-B buffer_size] [-b batchfile] [-c cipher]\\n\"\n\t    \"          [-D sftp_server_path] [-F ssh_config] \"\n\t    \"[-i identity_file] [-l limit]\\n\"\n\t    \"          [-o ssh_option] [-P port] [-R num_requests] \"\n\t    \"[-S program]\\n\"\n\t    \"          [-s subsystem | sftp_server] destination\\n\"",
            "__progname"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *__progname;\n\nstatic void\nusage(void)\n{\n\textern char *__progname;\n\n\tfprintf(stderr,\n\t    \"usage: %s [-46aCfpqrv] [-B buffer_size] [-b batchfile] [-c cipher]\\n\"\n\t    \"          [-D sftp_server_path] [-F ssh_config] \"\n\t    \"[-i identity_file] [-l limit]\\n\"\n\t    \"          [-o ssh_option] [-P port] [-R num_requests] \"\n\t    \"[-S program]\\n\"\n\t    \"          [-s subsystem | sftp_server] destination\\n\",\n\t    __progname);\n\texit(1);\n}"
  },
  {
    "function_name": "connect_to_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "2270-2329",
    "snippet": "static void\nconnect_to_server(char *path, char **args, int *in, int *out)\n{\n\tint c_in, c_out;\n\n#ifdef USE_PIPES\n\tint pin[2], pout[2];\n\n\tif ((pipe(pin) == -1) || (pipe(pout) == -1))\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\t*in = pin[0];\n\t*out = pout[1];\n\tc_in = pout[0];\n\tc_out = pin[1];\n#else /* USE_PIPES */\n\tint inout[2];\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) == -1)\n\t\tfatal(\"socketpair: %s\", strerror(errno));\n\t*in = *out = inout[0];\n\tc_in = c_out = inout[1];\n#endif /* USE_PIPES */\n\n\tif ((sshpid = fork()) == -1)\n\t\tfatal(\"fork: %s\", strerror(errno));\n\telse if (sshpid == 0) {\n\t\tif ((dup2(c_in, STDIN_FILENO) == -1) ||\n\t\t    (dup2(c_out, STDOUT_FILENO) == -1)) {\n\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclose(*in);\n\t\tclose(*out);\n\t\tclose(c_in);\n\t\tclose(c_out);\n\n\t\t/*\n\t\t * The underlying ssh is in the same process group, so we must\n\t\t * ignore SIGINT if we want to gracefully abort commands,\n\t\t * otherwise the signal will make it to the ssh process and\n\t\t * kill it too.  Contrawise, since sftp sends SIGTERMs to the\n\t\t * underlying ssh, it must *not* ignore that signal.\n\t\t */\n\t\tsignal(SIGINT, SIG_IGN);\n\t\tsignal(SIGTERM, SIG_DFL);\n\t\texecvp(path, args);\n\t\tfprintf(stderr, \"exec: %s: %s\\n\", path, strerror(errno));\n\t\t_exit(1);\n\t}\n\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\tsignal(SIGTSTP, suspchild);\n\tsignal(SIGTTIN, suspchild);\n\tsignal(SIGTTOU, suspchild);\n\tsignal(SIGCHLD, sigchld_handler);\n\tclose(c_in);\n\tclose(c_out);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile pid_t sshpid = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "c_out"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGCHLD",
            "sigchld_handler"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"exec: %s: %s\\n\"",
            "path",
            "strerror(errno)"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "path",
            "args"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"dup2: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "c_out",
            "STDOUT_FILENO"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "c_in",
            "STDIN_FILENO"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"fork: %s\"",
            "strerror(errno)"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0",
            "inout"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pout"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pin"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile pid_t sshpid = -1;\n\nstatic void\nconnect_to_server(char *path, char **args, int *in, int *out)\n{\n\tint c_in, c_out;\n\n#ifdef USE_PIPES\n\tint pin[2], pout[2];\n\n\tif ((pipe(pin) == -1) || (pipe(pout) == -1))\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\t*in = pin[0];\n\t*out = pout[1];\n\tc_in = pout[0];\n\tc_out = pin[1];\n#else /* USE_PIPES */\n\tint inout[2];\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) == -1)\n\t\tfatal(\"socketpair: %s\", strerror(errno));\n\t*in = *out = inout[0];\n\tc_in = c_out = inout[1];\n#endif /* USE_PIPES */\n\n\tif ((sshpid = fork()) == -1)\n\t\tfatal(\"fork: %s\", strerror(errno));\n\telse if (sshpid == 0) {\n\t\tif ((dup2(c_in, STDIN_FILENO) == -1) ||\n\t\t    (dup2(c_out, STDOUT_FILENO) == -1)) {\n\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclose(*in);\n\t\tclose(*out);\n\t\tclose(c_in);\n\t\tclose(c_out);\n\n\t\t/*\n\t\t * The underlying ssh is in the same process group, so we must\n\t\t * ignore SIGINT if we want to gracefully abort commands,\n\t\t * otherwise the signal will make it to the ssh process and\n\t\t * kill it too.  Contrawise, since sftp sends SIGTERMs to the\n\t\t * underlying ssh, it must *not* ignore that signal.\n\t\t */\n\t\tsignal(SIGINT, SIG_IGN);\n\t\tsignal(SIGTERM, SIG_DFL);\n\t\texecvp(path, args);\n\t\tfprintf(stderr, \"exec: %s: %s\\n\", path, strerror(errno));\n\t\t_exit(1);\n\t}\n\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\tsignal(SIGTSTP, suspchild);\n\tsignal(SIGTTIN, suspchild);\n\tsignal(SIGTTOU, suspchild);\n\tsignal(SIGCHLD, sigchld_handler);\n\tclose(c_in);\n\tclose(c_out);\n}"
  },
  {
    "function_name": "interactive_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "2128-2268",
    "snippet": "static int\ninteractive_loop(struct sftp_conn *conn, char *file1, char *file2)\n{\n\tchar *remote_path;\n\tchar *dir = NULL, *startdir = NULL;\n\tchar cmd[2048];\n\tint err, interactive;\n\tEditLine *el = NULL;\n#ifdef USE_LIBEDIT\n\tHistory *hl = NULL;\n\tHistEvent hev;\n\textern char *__progname;\n\tstruct complete_ctx complete_ctx;\n\n\tif (!batchmode && isatty(STDIN_FILENO)) {\n\t\tif ((el = el_init(__progname, stdin, stdout, stderr)) == NULL)\n\t\t\tfatal(\"Couldn't initialise editline\");\n\t\tif ((hl = history_init()) == NULL)\n\t\t\tfatal(\"Couldn't initialise editline history\");\n\t\thistory(hl, &hev, H_SETSIZE, 100);\n\t\tel_set(el, EL_HIST, history, hl);\n\n\t\tel_set(el, EL_PROMPT, prompt);\n\t\tel_set(el, EL_EDITOR, \"emacs\");\n\t\tel_set(el, EL_TERMINAL, NULL);\n\t\tel_set(el, EL_SIGNAL, 1);\n\t\tel_source(el, NULL);\n\n\t\t/* Tab Completion */\n\t\tel_set(el, EL_ADDFN, \"ftp-complete\",\n\t\t    \"Context sensitive argument completion\", complete);\n\t\tcomplete_ctx.conn = conn;\n\t\tcomplete_ctx.remote_pathp = &remote_path;\n\t\tel_set(el, EL_CLIENTDATA, (void*)&complete_ctx);\n\t\tel_set(el, EL_BIND, \"^I\", \"ftp-complete\", NULL);\n\t\t/* enable ctrl-left-arrow and ctrl-right-arrow */\n\t\tel_set(el, EL_BIND, \"\\\\e[1;5C\", \"em-next-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e[5C\", \"em-next-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e[1;5D\", \"ed-prev-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e\\\\e[D\", \"ed-prev-word\", NULL);\n\t\t/* make ^w match ksh behaviour */\n\t\tel_set(el, EL_BIND, \"^w\", \"ed-delete-prev-word\", NULL);\n\t}\n#endif /* USE_LIBEDIT */\n\n\tremote_path = do_realpath(conn, \".\");\n\tif (remote_path == NULL)\n\t\tfatal(\"Need cwd\");\n\tstartdir = xstrdup(remote_path);\n\n\tif (file1 != NULL) {\n\t\tdir = xstrdup(file1);\n\t\tdir = make_absolute(dir, remote_path);\n\n\t\tif (remote_is_dir(conn, dir) && file2 == NULL) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Changing to: %s\\n\", dir);\n\t\t\tsnprintf(cmd, sizeof cmd, \"cd \\\"%s\\\"\", dir);\n\t\t\tif (parse_dispatch_command(conn, cmd,\n\t\t\t    &remote_path, startdir, 1, 0) != 0) {\n\t\t\t\tfree(dir);\n\t\t\t\tfree(startdir);\n\t\t\t\tfree(remote_path);\n\t\t\t\tfree(conn);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t} else {\n\t\t\t/* XXX this is wrong wrt quoting */\n\t\t\tsnprintf(cmd, sizeof cmd, \"get%s %s%s%s\",\n\t\t\t    global_aflag ? \" -a\" : \"\", dir,\n\t\t\t    file2 == NULL ? \"\" : \" \",\n\t\t\t    file2 == NULL ? \"\" : file2);\n\t\t\terr = parse_dispatch_command(conn, cmd,\n\t\t\t    &remote_path, startdir, 1, 0);\n\t\t\tfree(dir);\n\t\t\tfree(startdir);\n\t\t\tfree(remote_path);\n\t\t\tfree(conn);\n\t\t\treturn (err);\n\t\t}\n\t\tfree(dir);\n\t}\n\n\tsetvbuf(stdout, NULL, _IOLBF, 0);\n\tsetvbuf(infile, NULL, _IOLBF, 0);\n\n\tinteractive = !batchmode && isatty(STDIN_FILENO);\n\terr = 0;\n\tfor (;;) {\n\t\tsignal(SIGINT, SIG_IGN);\n\n\t\tif (el == NULL) {\n\t\t\tif (interactive)\n\t\t\t\tprintf(\"sftp> \");\n\t\t\tif (fgets(cmd, sizeof(cmd), infile) == NULL) {\n\t\t\t\tif (interactive)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n#ifdef USE_LIBEDIT\n\t\t\tconst char *line;\n\t\t\tint count = 0;\n\n\t\t\tif ((line = el_gets(el, &count)) == NULL ||\n\t\t\t    count <= 0) {\n\t\t\t\tprintf(\"\\n\");\n \t\t\t\tbreak;\n\t\t\t}\n\t\t\thistory(hl, &hev, H_ENTER, line);\n\t\t\tif (strlcpy(cmd, line, sizeof(cmd)) >= sizeof(cmd)) {\n\t\t\t\tfprintf(stderr, \"Error: input line too long\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n#endif /* USE_LIBEDIT */\n\t\t}\n\n\t\tcmd[strcspn(cmd, \"\\n\")] = '\\0';\n\n\t\t/* Handle user interrupts gracefully during commands */\n\t\tinterrupted = 0;\n\t\tsignal(SIGINT, cmd_interrupt);\n\n\t\terr = parse_dispatch_command(conn, cmd, &remote_path,\n\t\t    startdir, batchmode, !interactive && el == NULL);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t}\n\tsignal(SIGCHLD, SIG_DFL);\n\tfree(remote_path);\n\tfree(startdir);\n\tfree(conn);\n\n#ifdef USE_LIBEDIT\n\tif (el != NULL)\n\t\tel_end(el);\n#endif /* USE_LIBEDIT */\n\n\t/* err == 1 signifies normal \"quit\" exit */\n\treturn (err >= 0 ? 0 : -1);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "FILE* infile;",
      "int batchmode = 0;",
      "int quiet = 0;",
      "int global_aflag = 0;",
      "volatile sig_atomic_t interrupted = 0;",
      "extern char *__progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "el_end",
          "args": [
            "el"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "conn"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGCHLD",
            "SIG_DFL"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_dispatch_command",
          "args": [
            "conn",
            "cmd",
            "&remote_path",
            "startdir",
            "batchmode",
            "!interactive && el == NULL"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "parse_dispatch_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "1502-1764",
          "snippet": "static int\nparse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd,\n    const char *startdir, int err_abort, int echo_command)\n{\n\tconst char *ocmd = cmd;\n\tchar *path1, *path2, *tmp;\n\tint ignore_errors = 0, disable_echo = 1;\n\tint aflag = 0, fflag = 0, hflag = 0, iflag = 0;\n\tint lflag = 0, pflag = 0, rflag = 0, sflag = 0;\n\tint cmdnum, i;\n\tunsigned long n_arg = 0;\n\tAttrib a, *aa;\n\tchar path_buf[PATH_MAX];\n\tint err = 0;\n\tglob_t g;\n\n\tpath1 = path2 = NULL;\n\tcmdnum = parse_args(&cmd, &ignore_errors, &disable_echo, &aflag, &fflag,\n\t    &hflag, &iflag, &lflag, &pflag, &rflag, &sflag, &n_arg,\n\t    &path1, &path2);\n\tif (ignore_errors != 0)\n\t\terr_abort = 0;\n\n\tif (echo_command && !disable_echo)\n\t\tmprintf(\"sftp> %s\\n\", ocmd);\n\n\tmemset(&g, 0, sizeof(g));\n\n\t/* Perform command */\n\tswitch (cmdnum) {\n\tcase 0:\n\t\t/* Blank line */\n\t\tbreak;\n\tcase -1:\n\t\t/* Unrecognized command */\n\t\terr = -1;\n\t\tbreak;\n\tcase I_REGET:\n\t\taflag = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_GET:\n\t\terr = process_get(conn, path1, path2, *pwd, pflag,\n\t\t    rflag, aflag, fflag);\n\t\tbreak;\n\tcase I_REPUT:\n\t\taflag = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_PUT:\n\t\terr = process_put(conn, path1, path2, *pwd, pflag,\n\t\t    rflag, aflag, fflag);\n\t\tbreak;\n\tcase I_RENAME:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tpath2 = make_absolute(path2, *pwd);\n\t\terr = do_rename(conn, path1, path2, lflag);\n\t\tbreak;\n\tcase I_SYMLINK:\n\t\tsflag = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_LINK:\n\t\tif (!sflag)\n\t\t\tpath1 = make_absolute(path1, *pwd);\n\t\tpath2 = make_absolute(path2, *pwd);\n\t\terr = (sflag ? do_symlink : do_hardlink)(conn, path1, path2);\n\t\tbreak;\n\tcase I_RM:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tremote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Removing %s\\n\", g.gl_pathv[i]);\n\t\t\terr = do_rm(conn, g.gl_pathv[i]);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_MKDIR:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tattrib_clear(&a);\n\t\ta.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\t\ta.perm = 0777;\n\t\terr = do_mkdir(conn, path1, &a, 1);\n\t\tbreak;\n\tcase I_RMDIR:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\terr = do_rmdir(conn, path1);\n\t\tbreak;\n\tcase I_CHDIR:\n\t\tif (path1 == NULL || *path1 == '\\0')\n\t\t\tpath1 = xstrdup(startdir);\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tif ((tmp = do_realpath(conn, path1)) == NULL) {\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((aa = do_stat(conn, tmp, 0)) == NULL) {\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(aa->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)) {\n\t\t\terror(\"Can't change directory: Can't check target\");\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!S_ISDIR(aa->perm)) {\n\t\t\terror(\"Can't change directory: \\\"%s\\\" is not \"\n\t\t\t    \"a directory\", tmp);\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tfree(*pwd);\n\t\t*pwd = tmp;\n\t\tbreak;\n\tcase I_LS:\n\t\tif (!path1) {\n\t\t\tdo_ls_dir(conn, *pwd, *pwd, lflag);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Strip pwd off beginning of non-absolute paths */\n\t\ttmp = NULL;\n\t\tif (*path1 != '/')\n\t\t\ttmp = *pwd;\n\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\terr = do_globbed_ls(conn, path1, tmp, lflag);\n\t\tbreak;\n\tcase I_DF:\n\t\t/* Default to current directory if no path specified */\n\t\tif (path1 == NULL)\n\t\t\tpath1 = xstrdup(*pwd);\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\terr = do_df(conn, path1, hflag, iflag);\n\t\tbreak;\n\tcase I_LCHDIR:\n\t\tif (path1 == NULL || *path1 == '\\0')\n\t\t\tpath1 = xstrdup(\"~\");\n\t\ttmp = tilde_expand_filename(path1, getuid());\n\t\tfree(path1);\n\t\tpath1 = tmp;\n\t\tif (chdir(path1) == -1) {\n\t\t\terror(\"Couldn't change local directory to \"\n\t\t\t    \"\\\"%s\\\": %s\", path1, strerror(errno));\n\t\t\terr = 1;\n\t\t}\n\t\tbreak;\n\tcase I_LMKDIR:\n\t\tif (mkdir(path1, 0777) == -1) {\n\t\t\terror(\"Couldn't create local directory \"\n\t\t\t    \"\\\"%s\\\": %s\", path1, strerror(errno));\n\t\t\terr = 1;\n\t\t}\n\t\tbreak;\n\tcase I_LLS:\n\t\tlocal_do_ls(cmd);\n\t\tbreak;\n\tcase I_SHELL:\n\t\tlocal_do_shell(cmd);\n\t\tbreak;\n\tcase I_LUMASK:\n\t\tumask(n_arg);\n\t\tprintf(\"Local umask: %03lo\\n\", n_arg);\n\t\tbreak;\n\tcase I_CHMOD:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tattrib_clear(&a);\n\t\ta.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\t\ta.perm = n_arg;\n\t\tremote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Changing mode on %s\\n\",\n\t\t\t\t    g.gl_pathv[i]);\n\t\t\terr = do_setstat(conn, g.gl_pathv[i], &a);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_CHOWN:\n\tcase I_CHGRP:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tremote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif (!(aa = do_stat(conn, g.gl_pathv[i], 0))) {\n\t\t\t\tif (err_abort) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {\n\t\t\t\terror(\"Can't get current ownership of \"\n\t\t\t\t    \"remote file \\\"%s\\\"\", g.gl_pathv[i]);\n\t\t\t\tif (err_abort) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taa->flags &= SSH2_FILEXFER_ATTR_UIDGID;\n\t\t\tif (cmdnum == I_CHOWN) {\n\t\t\t\tif (!quiet)\n\t\t\t\t\tmprintf(\"Changing owner on %s\\n\",\n\t\t\t\t\t    g.gl_pathv[i]);\n\t\t\t\taa->uid = n_arg;\n\t\t\t} else {\n\t\t\t\tif (!quiet)\n\t\t\t\t\tmprintf(\"Changing group on %s\\n\",\n\t\t\t\t\t    g.gl_pathv[i]);\n\t\t\t\taa->gid = n_arg;\n\t\t\t}\n\t\t\terr = do_setstat(conn, g.gl_pathv[i], aa);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_PWD:\n\t\tmprintf(\"Remote working directory: %s\\n\", *pwd);\n\t\tbreak;\n\tcase I_LPWD:\n\t\tif (!getcwd(path_buf, sizeof(path_buf))) {\n\t\t\terror(\"Couldn't get local cwd: %s\", strerror(errno));\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\t\tmprintf(\"Local working directory: %s\\n\", path_buf);\n\t\tbreak;\n\tcase I_QUIT:\n\t\t/* Processed below */\n\t\tbreak;\n\tcase I_HELP:\n\t\thelp();\n\t\tbreak;\n\tcase I_VERSION:\n\t\tprintf(\"SFTP protocol version %u\\n\", sftp_proto_version(conn));\n\t\tbreak;\n\tcase I_PROGRESS:\n\t\tshowprogress = !showprogress;\n\t\tif (showprogress)\n\t\t\tprintf(\"Progress meter enabled\\n\");\n\t\telse\n\t\t\tprintf(\"Progress meter disabled\\n\");\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%d is not implemented\", cmdnum);\n\t}\n\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(path1);\n\tfree(path2);\n\n\t/* If an unignored error occurs in batch mode we should abort. */\n\tif (err_abort && err != 0)\n\t\treturn (-1);\n\telse if (cmdnum == I_QUIT)\n\t\treturn (1);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int quiet = 0;",
            "int showprogress = 1;",
            "volatile sig_atomic_t interrupted = 0;",
            "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint quiet = 0;\nint showprogress = 1;\nvolatile sig_atomic_t interrupted = 0;\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\n\nstatic int\nparse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd,\n    const char *startdir, int err_abort, int echo_command)\n{\n\tconst char *ocmd = cmd;\n\tchar *path1, *path2, *tmp;\n\tint ignore_errors = 0, disable_echo = 1;\n\tint aflag = 0, fflag = 0, hflag = 0, iflag = 0;\n\tint lflag = 0, pflag = 0, rflag = 0, sflag = 0;\n\tint cmdnum, i;\n\tunsigned long n_arg = 0;\n\tAttrib a, *aa;\n\tchar path_buf[PATH_MAX];\n\tint err = 0;\n\tglob_t g;\n\n\tpath1 = path2 = NULL;\n\tcmdnum = parse_args(&cmd, &ignore_errors, &disable_echo, &aflag, &fflag,\n\t    &hflag, &iflag, &lflag, &pflag, &rflag, &sflag, &n_arg,\n\t    &path1, &path2);\n\tif (ignore_errors != 0)\n\t\terr_abort = 0;\n\n\tif (echo_command && !disable_echo)\n\t\tmprintf(\"sftp> %s\\n\", ocmd);\n\n\tmemset(&g, 0, sizeof(g));\n\n\t/* Perform command */\n\tswitch (cmdnum) {\n\tcase 0:\n\t\t/* Blank line */\n\t\tbreak;\n\tcase -1:\n\t\t/* Unrecognized command */\n\t\terr = -1;\n\t\tbreak;\n\tcase I_REGET:\n\t\taflag = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_GET:\n\t\terr = process_get(conn, path1, path2, *pwd, pflag,\n\t\t    rflag, aflag, fflag);\n\t\tbreak;\n\tcase I_REPUT:\n\t\taflag = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_PUT:\n\t\terr = process_put(conn, path1, path2, *pwd, pflag,\n\t\t    rflag, aflag, fflag);\n\t\tbreak;\n\tcase I_RENAME:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tpath2 = make_absolute(path2, *pwd);\n\t\terr = do_rename(conn, path1, path2, lflag);\n\t\tbreak;\n\tcase I_SYMLINK:\n\t\tsflag = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_LINK:\n\t\tif (!sflag)\n\t\t\tpath1 = make_absolute(path1, *pwd);\n\t\tpath2 = make_absolute(path2, *pwd);\n\t\terr = (sflag ? do_symlink : do_hardlink)(conn, path1, path2);\n\t\tbreak;\n\tcase I_RM:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tremote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Removing %s\\n\", g.gl_pathv[i]);\n\t\t\terr = do_rm(conn, g.gl_pathv[i]);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_MKDIR:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tattrib_clear(&a);\n\t\ta.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\t\ta.perm = 0777;\n\t\terr = do_mkdir(conn, path1, &a, 1);\n\t\tbreak;\n\tcase I_RMDIR:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\terr = do_rmdir(conn, path1);\n\t\tbreak;\n\tcase I_CHDIR:\n\t\tif (path1 == NULL || *path1 == '\\0')\n\t\t\tpath1 = xstrdup(startdir);\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tif ((tmp = do_realpath(conn, path1)) == NULL) {\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((aa = do_stat(conn, tmp, 0)) == NULL) {\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(aa->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)) {\n\t\t\terror(\"Can't change directory: Can't check target\");\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!S_ISDIR(aa->perm)) {\n\t\t\terror(\"Can't change directory: \\\"%s\\\" is not \"\n\t\t\t    \"a directory\", tmp);\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tfree(*pwd);\n\t\t*pwd = tmp;\n\t\tbreak;\n\tcase I_LS:\n\t\tif (!path1) {\n\t\t\tdo_ls_dir(conn, *pwd, *pwd, lflag);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Strip pwd off beginning of non-absolute paths */\n\t\ttmp = NULL;\n\t\tif (*path1 != '/')\n\t\t\ttmp = *pwd;\n\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\terr = do_globbed_ls(conn, path1, tmp, lflag);\n\t\tbreak;\n\tcase I_DF:\n\t\t/* Default to current directory if no path specified */\n\t\tif (path1 == NULL)\n\t\t\tpath1 = xstrdup(*pwd);\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\terr = do_df(conn, path1, hflag, iflag);\n\t\tbreak;\n\tcase I_LCHDIR:\n\t\tif (path1 == NULL || *path1 == '\\0')\n\t\t\tpath1 = xstrdup(\"~\");\n\t\ttmp = tilde_expand_filename(path1, getuid());\n\t\tfree(path1);\n\t\tpath1 = tmp;\n\t\tif (chdir(path1) == -1) {\n\t\t\terror(\"Couldn't change local directory to \"\n\t\t\t    \"\\\"%s\\\": %s\", path1, strerror(errno));\n\t\t\terr = 1;\n\t\t}\n\t\tbreak;\n\tcase I_LMKDIR:\n\t\tif (mkdir(path1, 0777) == -1) {\n\t\t\terror(\"Couldn't create local directory \"\n\t\t\t    \"\\\"%s\\\": %s\", path1, strerror(errno));\n\t\t\terr = 1;\n\t\t}\n\t\tbreak;\n\tcase I_LLS:\n\t\tlocal_do_ls(cmd);\n\t\tbreak;\n\tcase I_SHELL:\n\t\tlocal_do_shell(cmd);\n\t\tbreak;\n\tcase I_LUMASK:\n\t\tumask(n_arg);\n\t\tprintf(\"Local umask: %03lo\\n\", n_arg);\n\t\tbreak;\n\tcase I_CHMOD:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tattrib_clear(&a);\n\t\ta.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\t\ta.perm = n_arg;\n\t\tremote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Changing mode on %s\\n\",\n\t\t\t\t    g.gl_pathv[i]);\n\t\t\terr = do_setstat(conn, g.gl_pathv[i], &a);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_CHOWN:\n\tcase I_CHGRP:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tremote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif (!(aa = do_stat(conn, g.gl_pathv[i], 0))) {\n\t\t\t\tif (err_abort) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {\n\t\t\t\terror(\"Can't get current ownership of \"\n\t\t\t\t    \"remote file \\\"%s\\\"\", g.gl_pathv[i]);\n\t\t\t\tif (err_abort) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taa->flags &= SSH2_FILEXFER_ATTR_UIDGID;\n\t\t\tif (cmdnum == I_CHOWN) {\n\t\t\t\tif (!quiet)\n\t\t\t\t\tmprintf(\"Changing owner on %s\\n\",\n\t\t\t\t\t    g.gl_pathv[i]);\n\t\t\t\taa->uid = n_arg;\n\t\t\t} else {\n\t\t\t\tif (!quiet)\n\t\t\t\t\tmprintf(\"Changing group on %s\\n\",\n\t\t\t\t\t    g.gl_pathv[i]);\n\t\t\t\taa->gid = n_arg;\n\t\t\t}\n\t\t\terr = do_setstat(conn, g.gl_pathv[i], aa);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_PWD:\n\t\tmprintf(\"Remote working directory: %s\\n\", *pwd);\n\t\tbreak;\n\tcase I_LPWD:\n\t\tif (!getcwd(path_buf, sizeof(path_buf))) {\n\t\t\terror(\"Couldn't get local cwd: %s\", strerror(errno));\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\t\tmprintf(\"Local working directory: %s\\n\", path_buf);\n\t\tbreak;\n\tcase I_QUIT:\n\t\t/* Processed below */\n\t\tbreak;\n\tcase I_HELP:\n\t\thelp();\n\t\tbreak;\n\tcase I_VERSION:\n\t\tprintf(\"SFTP protocol version %u\\n\", sftp_proto_version(conn));\n\t\tbreak;\n\tcase I_PROGRESS:\n\t\tshowprogress = !showprogress;\n\t\tif (showprogress)\n\t\t\tprintf(\"Progress meter enabled\\n\");\n\t\telse\n\t\t\tprintf(\"Progress meter disabled\\n\");\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%d is not implemented\", cmdnum);\n\t}\n\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(path1);\n\tfree(path2);\n\n\t/* If an unignored error occurs in batch mode we should abort. */\n\tif (err_abort && err != 0)\n\t\treturn (-1);\n\telse if (cmdnum == I_QUIT)\n\t\treturn (1);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "cmd",
            "\"\\n\""
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: input line too long\\n\""
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "cmd",
            "line",
            "sizeof(cmd)"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "history",
          "args": [
            "hl",
            "&hev",
            "H_ENTER",
            "line"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "el_gets",
          "args": [
            "el",
            "&count"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "cmd",
            "sizeof(cmd)",
            "infile"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setvbuf",
          "args": [
            "infile",
            "NULL",
            "_IOLBF",
            "0"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setvbuf",
          "args": [
            "stdout",
            "NULL",
            "_IOLBF",
            "0"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cmd",
            "sizeof cmd",
            "\"get%s %s%s%s\"",
            "global_aflag ? \" -a\" : \"\"",
            "dir",
            "file2 == NULL ? \"\" : \" \"",
            "file2 == NULL ? \"\" : file2"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remote_is_dir",
          "args": [
            "conn",
            "dir"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "remote_is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "596-607",
          "snippet": "static int\nremote_is_dir(struct sftp_conn *conn, const char *path)\n{\n\tAttrib *a;\n\n\t/* XXX: report errors? */\n\tif ((a = do_stat(conn, path, 1)) == NULL)\n\t\treturn(0);\n\tif (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))\n\t\treturn(0);\n\treturn(S_ISDIR(a->perm));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nremote_is_dir(struct sftp_conn *conn, const char *path)\n{\n\tAttrib *a;\n\n\t/* XXX: report errors? */\n\tif ((a = do_stat(conn, path, 1)) == NULL)\n\t\treturn(0);\n\tif (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))\n\t\treturn(0);\n\treturn(S_ISDIR(a->perm));\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_absolute",
          "args": [
            "dir",
            "remote_path"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "make_absolute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "386-398",
          "snippet": "static char *\nmake_absolute(char *p, const char *pwd)\n{\n\tchar *abs_str;\n\n\t/* Derelativise */\n\tif (p && p[0] != '/') {\n\t\tabs_str = path_append(pwd, p);\n\t\tfree(p);\n\t\treturn(abs_str);\n\t} else\n\t\treturn(p);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nmake_absolute(char *p, const char *pwd)\n{\n\tchar *abs_str;\n\n\t/* Derelativise */\n\tif (p && p[0] != '/') {\n\t\tabs_str = path_append(pwd, p);\n\t\tfree(p);\n\t\treturn(abs_str);\n\t} else\n\t\treturn(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "file1"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Need cwd\""
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_realpath",
          "args": [
            "conn",
            "\".\""
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "do_realpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "825-880",
          "snippet": "char *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "el_set",
          "args": [
            "el",
            "EL_BIND",
            "\"^w\"",
            "\"ed-delete-prev-word\"",
            "NULL"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "channel_setup_fwd_listener_tcpip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3348-3506",
          "snippet": "static int\nchannel_setup_fwd_listener_tcpip(struct ssh *ssh, int type,\n    struct Forward *fwd, int *allocated_listen_port,\n    struct ForwardOptions *fwd_opts)\n{\n\tChannel *c;\n\tint sock, r, success = 0, wildcard = 0, is_client;\n\tstruct addrinfo hints, *ai, *aitop;\n\tconst char *host, *addr;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tin_port_t *lport_p;\n\n\tis_client = (type == SSH_CHANNEL_PORT_LISTENER);\n\n\tif (is_client && fwd->connect_path != NULL) {\n\t\thost = fwd->connect_path;\n\t} else {\n\t\thost = (type == SSH_CHANNEL_RPORT_LISTENER) ?\n\t\t    fwd->listen_host : fwd->connect_host;\n\t\tif (host == NULL) {\n\t\t\terror(\"No forward host name.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (strlen(host) >= NI_MAXHOST) {\n\t\t\terror(\"Forward host name too long.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Determine the bind address, cf. channel_fwd_bind_addr() comment */\n\taddr = channel_fwd_bind_addr(fwd->listen_host, &wildcard,\n\t    is_client, fwd_opts);\n\tdebug3(\"%s: type %d wildcard %d addr %s\", __func__,\n\t    type, wildcard, (addr == NULL) ? \"NULL\" : addr);\n\n\t/*\n\t * getaddrinfo returns a loopback address if the hostname is\n\t * set to NULL and hints.ai_flags is not AI_PASSIVE\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = ssh->chanctxt->IPv4or6;\n\thints.ai_flags = wildcard ? AI_PASSIVE : 0;\n\thints.ai_socktype = SOCK_STREAM;\n\tsnprintf(strport, sizeof strport, \"%d\", fwd->listen_port);\n\tif ((r = getaddrinfo(addr, strport, &hints, &aitop)) != 0) {\n\t\tif (addr == NULL) {\n\t\t\t/* This really shouldn't happen */\n\t\t\tpacket_disconnect(\"getaddrinfo: fatal error: %s\",\n\t\t\t    ssh_gai_strerror(r));\n\t\t} else {\n\t\t\terror(\"%s: getaddrinfo(%.64s): %s\", __func__, addr,\n\t\t\t    ssh_gai_strerror(r));\n\t\t}\n\t\treturn 0;\n\t}\n\tif (allocated_listen_port != NULL)\n\t\t*allocated_listen_port = 0;\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\tswitch (ai->ai_family) {\n\t\tcase AF_INET:\n\t\t\tlport_p = &((struct sockaddr_in *)ai->ai_addr)->\n\t\t\t    sin_port;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tlport_p = &((struct sockaddr_in6 *)ai->ai_addr)->\n\t\t\t    sin6_port;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If allocating a port for -R forwards, then use the\n\t\t * same port for all address families.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port > 0)\n\t\t\t*lport_p = htons(*allocated_listen_port);\n\n\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop, sizeof(ntop),\n\t\t    strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\terror(\"%s: getnameinfo failed\", __func__);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Create a port to listen for the host. */\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0) {\n\t\t\t/* this is no error since kernel may not support ipv6 */\n\t\t\tverbose(\"socket [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_reuseaddr(sock);\n\t\tif (ai->ai_family == AF_INET6)\n\t\t\tsock_set_v6only(sock);\n\n\t\tdebug(\"Local forwarding listening on %s port %s.\",\n\t\t    ntop, strport);\n\n\t\t/* Bind the socket to the address. */\n\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\t/*\n\t\t\t * address can be in if use ipv6 address is\n\t\t\t * already bound\n\t\t\t */\n\t\t\tif (!ai->ai_next)\n\t\t\t\terror(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Start listening for connections on the socket. */\n\t\tif (listen(sock, SSH_LISTEN_BACKLOG) < 0) {\n\t\t\terror(\"listen: %.100s\", strerror(errno));\n\t\t\terror(\"listen [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * fwd->listen_port == 0 requests a dynamically allocated port -\n\t\t * record what we got.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 &&\n\t\t    allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port == 0) {\n\t\t\t*allocated_listen_port = get_local_port(sock);\n\t\t\tdebug(\"Allocated listen port %d\",\n\t\t\t    *allocated_listen_port);\n\t\t}\n\n\t\t/* Allocate a channel number for the socket. */\n\t\tc = channel_new(ssh, \"port listener\", type, sock, sock, -1,\n\t\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t\t    0, \"port listener\", 1);\n\t\tc->path = xstrdup(host);\n\t\tc->host_port = fwd->connect_port;\n\t\tc->listening_addr = addr == NULL ? NULL : xstrdup(addr);\n\t\tif (fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    !(datafellows & SSH_BUG_DYNAMIC_RPORT))\n\t\t\tc->listening_port = *allocated_listen_port;\n\t\telse\n\t\t\tc->listening_port = fwd->listen_port;\n\t\tsuccess = 1;\n\t}\n\tif (success == 0)\n\t\terror(\"%s: cannot listen to port: %d\", __func__,\n\t\t    fwd->listen_port);\n\tfreeaddrinfo(aitop);\n\treturn success;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_setup_fwd_listener_tcpip(struct ssh *ssh, int type,\n    struct Forward *fwd, int *allocated_listen_port,\n    struct ForwardOptions *fwd_opts)\n{\n\tChannel *c;\n\tint sock, r, success = 0, wildcard = 0, is_client;\n\tstruct addrinfo hints, *ai, *aitop;\n\tconst char *host, *addr;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tin_port_t *lport_p;\n\n\tis_client = (type == SSH_CHANNEL_PORT_LISTENER);\n\n\tif (is_client && fwd->connect_path != NULL) {\n\t\thost = fwd->connect_path;\n\t} else {\n\t\thost = (type == SSH_CHANNEL_RPORT_LISTENER) ?\n\t\t    fwd->listen_host : fwd->connect_host;\n\t\tif (host == NULL) {\n\t\t\terror(\"No forward host name.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (strlen(host) >= NI_MAXHOST) {\n\t\t\terror(\"Forward host name too long.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Determine the bind address, cf. channel_fwd_bind_addr() comment */\n\taddr = channel_fwd_bind_addr(fwd->listen_host, &wildcard,\n\t    is_client, fwd_opts);\n\tdebug3(\"%s: type %d wildcard %d addr %s\", __func__,\n\t    type, wildcard, (addr == NULL) ? \"NULL\" : addr);\n\n\t/*\n\t * getaddrinfo returns a loopback address if the hostname is\n\t * set to NULL and hints.ai_flags is not AI_PASSIVE\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = ssh->chanctxt->IPv4or6;\n\thints.ai_flags = wildcard ? AI_PASSIVE : 0;\n\thints.ai_socktype = SOCK_STREAM;\n\tsnprintf(strport, sizeof strport, \"%d\", fwd->listen_port);\n\tif ((r = getaddrinfo(addr, strport, &hints, &aitop)) != 0) {\n\t\tif (addr == NULL) {\n\t\t\t/* This really shouldn't happen */\n\t\t\tpacket_disconnect(\"getaddrinfo: fatal error: %s\",\n\t\t\t    ssh_gai_strerror(r));\n\t\t} else {\n\t\t\terror(\"%s: getaddrinfo(%.64s): %s\", __func__, addr,\n\t\t\t    ssh_gai_strerror(r));\n\t\t}\n\t\treturn 0;\n\t}\n\tif (allocated_listen_port != NULL)\n\t\t*allocated_listen_port = 0;\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\tswitch (ai->ai_family) {\n\t\tcase AF_INET:\n\t\t\tlport_p = &((struct sockaddr_in *)ai->ai_addr)->\n\t\t\t    sin_port;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tlport_p = &((struct sockaddr_in6 *)ai->ai_addr)->\n\t\t\t    sin6_port;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If allocating a port for -R forwards, then use the\n\t\t * same port for all address families.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port > 0)\n\t\t\t*lport_p = htons(*allocated_listen_port);\n\n\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop, sizeof(ntop),\n\t\t    strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\terror(\"%s: getnameinfo failed\", __func__);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Create a port to listen for the host. */\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0) {\n\t\t\t/* this is no error since kernel may not support ipv6 */\n\t\t\tverbose(\"socket [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_reuseaddr(sock);\n\t\tif (ai->ai_family == AF_INET6)\n\t\t\tsock_set_v6only(sock);\n\n\t\tdebug(\"Local forwarding listening on %s port %s.\",\n\t\t    ntop, strport);\n\n\t\t/* Bind the socket to the address. */\n\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\t/*\n\t\t\t * address can be in if use ipv6 address is\n\t\t\t * already bound\n\t\t\t */\n\t\t\tif (!ai->ai_next)\n\t\t\t\terror(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Start listening for connections on the socket. */\n\t\tif (listen(sock, SSH_LISTEN_BACKLOG) < 0) {\n\t\t\terror(\"listen: %.100s\", strerror(errno));\n\t\t\terror(\"listen [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * fwd->listen_port == 0 requests a dynamically allocated port -\n\t\t * record what we got.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 &&\n\t\t    allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port == 0) {\n\t\t\t*allocated_listen_port = get_local_port(sock);\n\t\t\tdebug(\"Allocated listen port %d\",\n\t\t\t    *allocated_listen_port);\n\t\t}\n\n\t\t/* Allocate a channel number for the socket. */\n\t\tc = channel_new(ssh, \"port listener\", type, sock, sock, -1,\n\t\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t\t    0, \"port listener\", 1);\n\t\tc->path = xstrdup(host);\n\t\tc->host_port = fwd->connect_port;\n\t\tc->listening_addr = addr == NULL ? NULL : xstrdup(addr);\n\t\tif (fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    !(datafellows & SSH_BUG_DYNAMIC_RPORT))\n\t\t\tc->listening_port = *allocated_listen_port;\n\t\telse\n\t\t\tc->listening_port = fwd->listen_port;\n\t\tsuccess = 1;\n\t}\n\tif (success == 0)\n\t\terror(\"%s: cannot listen to port: %d\", __func__,\n\t\t    fwd->listen_port);\n\tfreeaddrinfo(aitop);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "el_set",
          "args": [
            "el",
            "EL_CLIENTDATA",
            "(void*)&complete_ctx"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "channel_setup_local_fwd_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3714-3725",
          "snippet": "int\nchannel_setup_local_fwd_listener(struct ssh *ssh,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_UNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_PORT_LISTENER, fwd, NULL, fwd_opts);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_setup_local_fwd_listener(struct ssh *ssh,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_UNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_PORT_LISTENER, fwd, NULL, fwd_opts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "el_source",
          "args": [
            "el",
            "NULL"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "el_set",
          "args": [
            "el",
            "EL_HIST",
            "history",
            "hl"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "channel_setup_remote_fwd_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3791-3807",
          "snippet": "int\nchannel_setup_remote_fwd_listener(struct ssh *ssh, struct Forward *fwd,\n    int *allocated_listen_port, struct ForwardOptions *fwd_opts)\n{\n\tif (!check_rfwd_permission(ssh, fwd)) {\n\t\tpacket_send_debug(\"port forwarding refused\");\n\t\treturn 0;\n\t}\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_RUNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_RPORT_LISTENER, fwd, allocated_listen_port,\n\t\t    fwd_opts);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_setup_remote_fwd_listener(struct ssh *ssh, struct Forward *fwd,\n    int *allocated_listen_port, struct ForwardOptions *fwd_opts)\n{\n\tif (!check_rfwd_permission(ssh, fwd)) {\n\t\tpacket_send_debug(\"port forwarding refused\");\n\t\treturn 0;\n\t}\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_RUNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_RPORT_LISTENER, fwd, allocated_listen_port,\n\t\t    fwd_opts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "history",
          "args": [
            "hl",
            "&hev",
            "H_SETSIZE",
            "100"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "history_init",
          "args": [],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "el_init",
          "args": [
            "__progname",
            "stdin",
            "stdout",
            "stderr"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_rijndael_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher-aes.c",
          "lines": "49-68",
          "snippet": "static int\nssh_rijndael_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,\n    int enc)\n{\n\tstruct ssh_rijndael_ctx *c;\n\n\tif ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {\n\t\tc = xmalloc(sizeof(*c));\n\t\tEVP_CIPHER_CTX_set_app_data(ctx, c);\n\t}\n\tif (key != NULL) {\n\t\tif (enc == -1)\n\t\t\tenc = ctx->encrypt;\n\t\trijndael_set_key(&c->r_ctx, (u_char *)key,\n\t\t    8*EVP_CIPHER_CTX_key_length(ctx), enc);\n\t}\n\tif (iv != NULL)\n\t\tmemcpy(c->r_iv, iv, RIJNDAEL_BLOCKSIZE);\n\treturn (1);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"rijndael.h\"",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <openssl/evp.h>",
            "#include <sys/types.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define RIJNDAEL_BLOCKSIZE 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"rijndael.h\"\n#include <string.h>\n#include <stdarg.h>\n#include <openssl/evp.h>\n#include <sys/types.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"includes.h\"\n\n#define RIJNDAEL_BLOCKSIZE 16\n\nstatic int\nssh_rijndael_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,\n    int enc)\n{\n\tstruct ssh_rijndael_ctx *c;\n\n\tif ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {\n\t\tc = xmalloc(sizeof(*c));\n\t\tEVP_CIPHER_CTX_set_app_data(ctx, c);\n\t}\n\tif (key != NULL) {\n\t\tif (enc == -1)\n\t\t\tenc = ctx->encrypt;\n\t\trijndael_set_key(&c->r_ctx, (u_char *)key,\n\t\t    8*EVP_CIPHER_CTX_key_length(ctx), enc);\n\t}\n\tif (iv != NULL)\n\t\tmemcpy(c->r_iv, iv, RIJNDAEL_BLOCKSIZE);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nFILE* infile;\nint batchmode = 0;\nint quiet = 0;\nint global_aflag = 0;\nvolatile sig_atomic_t interrupted = 0;\nextern char *__progname;\n\nstatic int\ninteractive_loop(struct sftp_conn *conn, char *file1, char *file2)\n{\n\tchar *remote_path;\n\tchar *dir = NULL, *startdir = NULL;\n\tchar cmd[2048];\n\tint err, interactive;\n\tEditLine *el = NULL;\n#ifdef USE_LIBEDIT\n\tHistory *hl = NULL;\n\tHistEvent hev;\n\textern char *__progname;\n\tstruct complete_ctx complete_ctx;\n\n\tif (!batchmode && isatty(STDIN_FILENO)) {\n\t\tif ((el = el_init(__progname, stdin, stdout, stderr)) == NULL)\n\t\t\tfatal(\"Couldn't initialise editline\");\n\t\tif ((hl = history_init()) == NULL)\n\t\t\tfatal(\"Couldn't initialise editline history\");\n\t\thistory(hl, &hev, H_SETSIZE, 100);\n\t\tel_set(el, EL_HIST, history, hl);\n\n\t\tel_set(el, EL_PROMPT, prompt);\n\t\tel_set(el, EL_EDITOR, \"emacs\");\n\t\tel_set(el, EL_TERMINAL, NULL);\n\t\tel_set(el, EL_SIGNAL, 1);\n\t\tel_source(el, NULL);\n\n\t\t/* Tab Completion */\n\t\tel_set(el, EL_ADDFN, \"ftp-complete\",\n\t\t    \"Context sensitive argument completion\", complete);\n\t\tcomplete_ctx.conn = conn;\n\t\tcomplete_ctx.remote_pathp = &remote_path;\n\t\tel_set(el, EL_CLIENTDATA, (void*)&complete_ctx);\n\t\tel_set(el, EL_BIND, \"^I\", \"ftp-complete\", NULL);\n\t\t/* enable ctrl-left-arrow and ctrl-right-arrow */\n\t\tel_set(el, EL_BIND, \"\\\\e[1;5C\", \"em-next-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e[5C\", \"em-next-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e[1;5D\", \"ed-prev-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e\\\\e[D\", \"ed-prev-word\", NULL);\n\t\t/* make ^w match ksh behaviour */\n\t\tel_set(el, EL_BIND, \"^w\", \"ed-delete-prev-word\", NULL);\n\t}\n#endif /* USE_LIBEDIT */\n\n\tremote_path = do_realpath(conn, \".\");\n\tif (remote_path == NULL)\n\t\tfatal(\"Need cwd\");\n\tstartdir = xstrdup(remote_path);\n\n\tif (file1 != NULL) {\n\t\tdir = xstrdup(file1);\n\t\tdir = make_absolute(dir, remote_path);\n\n\t\tif (remote_is_dir(conn, dir) && file2 == NULL) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Changing to: %s\\n\", dir);\n\t\t\tsnprintf(cmd, sizeof cmd, \"cd \\\"%s\\\"\", dir);\n\t\t\tif (parse_dispatch_command(conn, cmd,\n\t\t\t    &remote_path, startdir, 1, 0) != 0) {\n\t\t\t\tfree(dir);\n\t\t\t\tfree(startdir);\n\t\t\t\tfree(remote_path);\n\t\t\t\tfree(conn);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t} else {\n\t\t\t/* XXX this is wrong wrt quoting */\n\t\t\tsnprintf(cmd, sizeof cmd, \"get%s %s%s%s\",\n\t\t\t    global_aflag ? \" -a\" : \"\", dir,\n\t\t\t    file2 == NULL ? \"\" : \" \",\n\t\t\t    file2 == NULL ? \"\" : file2);\n\t\t\terr = parse_dispatch_command(conn, cmd,\n\t\t\t    &remote_path, startdir, 1, 0);\n\t\t\tfree(dir);\n\t\t\tfree(startdir);\n\t\t\tfree(remote_path);\n\t\t\tfree(conn);\n\t\t\treturn (err);\n\t\t}\n\t\tfree(dir);\n\t}\n\n\tsetvbuf(stdout, NULL, _IOLBF, 0);\n\tsetvbuf(infile, NULL, _IOLBF, 0);\n\n\tinteractive = !batchmode && isatty(STDIN_FILENO);\n\terr = 0;\n\tfor (;;) {\n\t\tsignal(SIGINT, SIG_IGN);\n\n\t\tif (el == NULL) {\n\t\t\tif (interactive)\n\t\t\t\tprintf(\"sftp> \");\n\t\t\tif (fgets(cmd, sizeof(cmd), infile) == NULL) {\n\t\t\t\tif (interactive)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n#ifdef USE_LIBEDIT\n\t\t\tconst char *line;\n\t\t\tint count = 0;\n\n\t\t\tif ((line = el_gets(el, &count)) == NULL ||\n\t\t\t    count <= 0) {\n\t\t\t\tprintf(\"\\n\");\n \t\t\t\tbreak;\n\t\t\t}\n\t\t\thistory(hl, &hev, H_ENTER, line);\n\t\t\tif (strlcpy(cmd, line, sizeof(cmd)) >= sizeof(cmd)) {\n\t\t\t\tfprintf(stderr, \"Error: input line too long\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n#endif /* USE_LIBEDIT */\n\t\t}\n\n\t\tcmd[strcspn(cmd, \"\\n\")] = '\\0';\n\n\t\t/* Handle user interrupts gracefully during commands */\n\t\tinterrupted = 0;\n\t\tsignal(SIGINT, cmd_interrupt);\n\n\t\terr = parse_dispatch_command(conn, cmd, &remote_path,\n\t\t    startdir, batchmode, !interactive && el == NULL);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t}\n\tsignal(SIGCHLD, SIG_DFL);\n\tfree(remote_path);\n\tfree(startdir);\n\tfree(conn);\n\n#ifdef USE_LIBEDIT\n\tif (el != NULL)\n\t\tel_end(el);\n#endif /* USE_LIBEDIT */\n\n\t/* err == 1 signifies normal \"quit\" exit */\n\treturn (err >= 0 ? 0 : -1);\n}"
  },
  {
    "function_name": "complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "2064-2125",
    "snippet": "static unsigned char\ncomplete(EditLine *el, int ch)\n{\n\tchar **argv, *line, quote;\n\tint argc, carg;\n\tu_int cursor, len, terminated, ret = CC_ERROR;\n\tconst LineInfo *lf;\n\tstruct complete_ctx *complete_ctx;\n\n\tlf = el_line(el);\n\tif (el_get(el, EL_CLIENTDATA, (void**)&complete_ctx) != 0)\n\t\tfatal(\"%s: el_get failed\", __func__);\n\n\t/* Figure out which argument the cursor points to */\n\tcursor = lf->cursor - lf->buffer;\n\tline = xmalloc(cursor + 1);\n\tmemcpy(line, lf->buffer, cursor);\n\tline[cursor] = '\\0';\n\targv = makeargv(line, &carg, 1, &quote, &terminated);\n\tfree(line);\n\n\t/* Get all the arguments on the line */\n\tlen = lf->lastchar - lf->buffer;\n\tline = xmalloc(len + 1);\n\tmemcpy(line, lf->buffer, len);\n\tline[len] = '\\0';\n\targv = makeargv(line, &argc, 1, NULL, NULL);\n\n\t/* Ensure cursor is at EOL or a argument boundary */\n\tif (line[cursor] != ' ' && line[cursor] != '\\0' &&\n\t    line[cursor] != '\\n') {\n\t\tfree(line);\n\t\treturn ret;\n\t}\n\n\tif (carg == 0) {\n\t\t/* Show all available commands */\n\t\tcomplete_cmd_parse(el, NULL, argc == carg, '\\0', 1);\n\t\tret = CC_REDISPLAY;\n\t} else if (carg == 1 && cursor > 0 && line[cursor - 1] != ' ')  {\n\t\t/* Handle the command parsing */\n\t\tif (complete_cmd_parse(el, argv[0], argc == carg,\n\t\t    quote, terminated) != 0)\n\t\t\tret = CC_REDISPLAY;\n\t} else if (carg >= 1) {\n\t\t/* Handle file parsing */\n\t\tint remote = complete_is_remote(argv[0]);\n\t\tchar *filematch = NULL;\n\n\t\tif (carg > 1 && line[cursor-1] != ' ')\n\t\t\tfilematch = argv[carg - 1];\n\n\t\tif (remote != 0 &&\n\t\t    complete_match(el, complete_ctx->conn,\n\t\t    *complete_ctx->remote_pathp, filematch,\n\t\t    remote, carg == argc, quote, terminated) != 0)\n\t\t\tret = CC_REDISPLAY;\n\t}\n\n\tfree(line);\n\treturn ret;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete_match",
          "args": [
            "el",
            "complete_ctx->conn",
            "*complete_ctx->remote_pathp",
            "filematch",
            "remote",
            "carg == argc",
            "quote",
            "terminated"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "complete_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "1937-2061",
          "snippet": "static int\ncomplete_match(EditLine *el, struct sftp_conn *conn, char *remote_path,\n    char *file, int remote, int lastarg, char quote, int terminated)\n{\n\tglob_t g;\n\tchar *tmp, *tmp2, ins[8];\n\tu_int i, hadglob, pwdlen, len, tmplen, filelen, cesc, isesc, isabs;\n\tint clen;\n\tconst LineInfo *lf;\n\n\t/* Glob from \"file\" location */\n\tif (file == NULL)\n\t\ttmp = xstrdup(\"*\");\n\telse\n\t\txasprintf(&tmp, \"%s*\", file);\n\n\t/* Check if the path is absolute. */\n\tisabs = tmp[0] == '/';\n\n\tmemset(&g, 0, sizeof(g));\n\tif (remote != LOCAL) {\n\t\ttmp = make_absolute(tmp, remote_path);\n\t\tremote_glob(conn, tmp, GLOB_DOOFFS|GLOB_MARK, NULL, &g);\n\t} else\n\t\tglob(tmp, GLOB_DOOFFS|GLOB_MARK, NULL, &g);\n\n\t/* Determine length of pwd so we can trim completion display */\n\tfor (hadglob = tmplen = pwdlen = 0; tmp[tmplen] != 0; tmplen++) {\n\t\t/* Terminate counting on first unescaped glob metacharacter */\n\t\tif (tmp[tmplen] == '*' || tmp[tmplen] == '?') {\n\t\t\tif (tmp[tmplen] != '*' || tmp[tmplen + 1] != '\\0')\n\t\t\t\thadglob = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (tmp[tmplen] == '\\\\' && tmp[tmplen + 1] != '\\0')\n\t\t\ttmplen++;\n\t\tif (tmp[tmplen] == '/')\n\t\t\tpwdlen = tmplen + 1;\t/* track last seen '/' */\n\t}\n\tfree(tmp);\n\ttmp = NULL;\n\n\tif (g.gl_matchc == 0)\n\t\tgoto out;\n\n\tif (g.gl_matchc > 1)\n\t\tcomplete_display(g.gl_pathv, pwdlen);\n\n\t/* Don't try to extend globs */\n\tif (file == NULL || hadglob)\n\t\tgoto out;\n\n\ttmp2 = complete_ambiguous(file, g.gl_pathv, g.gl_matchc);\n\ttmp = path_strip(tmp2, isabs ? NULL : remote_path);\n\tfree(tmp2);\n\n\tif (tmp == NULL)\n\t\tgoto out;\n\n\ttmplen = strlen(tmp);\n\tfilelen = strlen(file);\n\n\t/* Count the number of escaped characters in the input string. */\n\tcesc = isesc = 0;\n\tfor (i = 0; i < filelen; i++) {\n\t\tif (!isesc && file[i] == '\\\\' && i + 1 < filelen){\n\t\t\tisesc = 1;\n\t\t\tcesc++;\n\t\t} else\n\t\t\tisesc = 0;\n\t}\n\n\tif (tmplen > (filelen - cesc)) {\n\t\ttmp2 = tmp + filelen - cesc;\n\t\tlen = strlen(tmp2);\n\t\t/* quote argument on way out */\n\t\tfor (i = 0; i < len; i += clen) {\n\t\t\tif ((clen = mblen(tmp2 + i, len - i)) < 0 ||\n\t\t\t    (size_t)clen > sizeof(ins) - 2)\n\t\t\t\tfatal(\"invalid multibyte character\");\n\t\t\tins[0] = '\\\\';\n\t\t\tmemcpy(ins + 1, tmp2 + i, clen);\n\t\t\tins[clen + 1] = '\\0';\n\t\t\tswitch (tmp2[i]) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '\\\\':\n\t\t\tcase '\\t':\n\t\t\tcase '[':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\tcase '*':\n\t\t\t\tif (quote == '\\0' || tmp2[i] == quote) {\n\t\t\t\t\tif (el_insertstr(el, ins) == -1)\n\t\t\t\t\t\tfatal(\"el_insertstr \"\n\t\t\t\t\t\t    \"failed.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tif (el_insertstr(el, ins + 1) == -1)\n\t\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlf = el_line(el);\n\tif (g.gl_matchc == 1) {\n\t\ti = 0;\n\t\tif (!terminated && quote != '\\0')\n\t\t\tins[i++] = quote;\n\t\tif (*(lf->cursor - 1) != '/' &&\n\t\t    (lastarg || *(lf->cursor) != ' '))\n\t\t\tins[i++] = ' ';\n\t\tins[i] = '\\0';\n\t\tif (i > 0 && el_insertstr(el, ins) == -1)\n\t\t\tfatal(\"el_insertstr failed.\");\n\t}\n\tfree(tmp);\n\n out:\n\tglobfree(&g);\n\treturn g.gl_matchc;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define LOCAL\t2"
          ],
          "globals_used": [
            "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define LOCAL\t2\n\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\n\nstatic int\ncomplete_match(EditLine *el, struct sftp_conn *conn, char *remote_path,\n    char *file, int remote, int lastarg, char quote, int terminated)\n{\n\tglob_t g;\n\tchar *tmp, *tmp2, ins[8];\n\tu_int i, hadglob, pwdlen, len, tmplen, filelen, cesc, isesc, isabs;\n\tint clen;\n\tconst LineInfo *lf;\n\n\t/* Glob from \"file\" location */\n\tif (file == NULL)\n\t\ttmp = xstrdup(\"*\");\n\telse\n\t\txasprintf(&tmp, \"%s*\", file);\n\n\t/* Check if the path is absolute. */\n\tisabs = tmp[0] == '/';\n\n\tmemset(&g, 0, sizeof(g));\n\tif (remote != LOCAL) {\n\t\ttmp = make_absolute(tmp, remote_path);\n\t\tremote_glob(conn, tmp, GLOB_DOOFFS|GLOB_MARK, NULL, &g);\n\t} else\n\t\tglob(tmp, GLOB_DOOFFS|GLOB_MARK, NULL, &g);\n\n\t/* Determine length of pwd so we can trim completion display */\n\tfor (hadglob = tmplen = pwdlen = 0; tmp[tmplen] != 0; tmplen++) {\n\t\t/* Terminate counting on first unescaped glob metacharacter */\n\t\tif (tmp[tmplen] == '*' || tmp[tmplen] == '?') {\n\t\t\tif (tmp[tmplen] != '*' || tmp[tmplen + 1] != '\\0')\n\t\t\t\thadglob = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (tmp[tmplen] == '\\\\' && tmp[tmplen + 1] != '\\0')\n\t\t\ttmplen++;\n\t\tif (tmp[tmplen] == '/')\n\t\t\tpwdlen = tmplen + 1;\t/* track last seen '/' */\n\t}\n\tfree(tmp);\n\ttmp = NULL;\n\n\tif (g.gl_matchc == 0)\n\t\tgoto out;\n\n\tif (g.gl_matchc > 1)\n\t\tcomplete_display(g.gl_pathv, pwdlen);\n\n\t/* Don't try to extend globs */\n\tif (file == NULL || hadglob)\n\t\tgoto out;\n\n\ttmp2 = complete_ambiguous(file, g.gl_pathv, g.gl_matchc);\n\ttmp = path_strip(tmp2, isabs ? NULL : remote_path);\n\tfree(tmp2);\n\n\tif (tmp == NULL)\n\t\tgoto out;\n\n\ttmplen = strlen(tmp);\n\tfilelen = strlen(file);\n\n\t/* Count the number of escaped characters in the input string. */\n\tcesc = isesc = 0;\n\tfor (i = 0; i < filelen; i++) {\n\t\tif (!isesc && file[i] == '\\\\' && i + 1 < filelen){\n\t\t\tisesc = 1;\n\t\t\tcesc++;\n\t\t} else\n\t\t\tisesc = 0;\n\t}\n\n\tif (tmplen > (filelen - cesc)) {\n\t\ttmp2 = tmp + filelen - cesc;\n\t\tlen = strlen(tmp2);\n\t\t/* quote argument on way out */\n\t\tfor (i = 0; i < len; i += clen) {\n\t\t\tif ((clen = mblen(tmp2 + i, len - i)) < 0 ||\n\t\t\t    (size_t)clen > sizeof(ins) - 2)\n\t\t\t\tfatal(\"invalid multibyte character\");\n\t\t\tins[0] = '\\\\';\n\t\t\tmemcpy(ins + 1, tmp2 + i, clen);\n\t\t\tins[clen + 1] = '\\0';\n\t\t\tswitch (tmp2[i]) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '\\\\':\n\t\t\tcase '\\t':\n\t\t\tcase '[':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\tcase '*':\n\t\t\t\tif (quote == '\\0' || tmp2[i] == quote) {\n\t\t\t\t\tif (el_insertstr(el, ins) == -1)\n\t\t\t\t\t\tfatal(\"el_insertstr \"\n\t\t\t\t\t\t    \"failed.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tif (el_insertstr(el, ins + 1) == -1)\n\t\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlf = el_line(el);\n\tif (g.gl_matchc == 1) {\n\t\ti = 0;\n\t\tif (!terminated && quote != '\\0')\n\t\t\tins[i++] = quote;\n\t\tif (*(lf->cursor - 1) != '/' &&\n\t\t    (lastarg || *(lf->cursor) != ' '))\n\t\t\tins[i++] = ' ';\n\t\tins[i] = '\\0';\n\t\tif (i > 0 && el_insertstr(el, ins) == -1)\n\t\t\tfatal(\"el_insertstr failed.\");\n\t}\n\tfree(tmp);\n\n out:\n\tglobfree(&g);\n\treturn g.gl_matchc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete_is_remote",
          "args": [
            "argv[0]"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "complete_is_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "1921-1934",
          "snippet": "static int\ncomplete_is_remote(char *cmd) {\n\tint i;\n\n\tif (cmd == NULL)\n\t\treturn -1;\n\n\tfor (i = 0; cmds[i].c; i++) {\n\t\tif (!strncasecmp(cmd, cmds[i].c, strlen(cmds[i].c)))\n\t\t\treturn cmds[i].t;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct CMD cmds[] = {\n\t{ \"bye\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"cd\",\t\tI_CHDIR,\tREMOTE\t},\n\t{ \"chdir\",\tI_CHDIR,\tREMOTE\t},\n\t{ \"chgrp\",\tI_CHGRP,\tREMOTE\t},\n\t{ \"chmod\",\tI_CHMOD,\tREMOTE\t},\n\t{ \"chown\",\tI_CHOWN,\tREMOTE\t},\n\t{ \"df\",\t\tI_DF,\t\tREMOTE\t},\n\t{ \"dir\",\tI_LS,\t\tREMOTE\t},\n\t{ \"exit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"get\",\tI_GET,\t\tREMOTE\t},\n\t{ \"help\",\tI_HELP,\t\tNOARGS\t},\n\t{ \"lcd\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lchdir\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lls\",\tI_LLS,\t\tLOCAL\t},\n\t{ \"lmkdir\",\tI_LMKDIR,\tLOCAL\t},\n\t{ \"ln\",\t\tI_LINK,\t\tREMOTE\t},\n\t{ \"lpwd\",\tI_LPWD,\t\tLOCAL\t},\n\t{ \"ls\",\t\tI_LS,\t\tREMOTE\t},\n\t{ \"lumask\",\tI_LUMASK,\tNOARGS\t},\n\t{ \"mkdir\",\tI_MKDIR,\tREMOTE\t},\n\t{ \"mget\",\tI_GET,\t\tREMOTE\t},\n\t{ \"mput\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"progress\",\tI_PROGRESS,\tNOARGS\t},\n\t{ \"put\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"pwd\",\tI_PWD,\t\tREMOTE\t},\n\t{ \"quit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"reget\",\tI_REGET,\tREMOTE\t},\n\t{ \"rename\",\tI_RENAME,\tREMOTE\t},\n\t{ \"reput\",\tI_REPUT,\tLOCAL\t},\n\t{ \"rm\",\t\tI_RM,\t\tREMOTE\t},\n\t{ \"rmdir\",\tI_RMDIR,\tREMOTE\t},\n\t{ \"symlink\",\tI_SYMLINK,\tREMOTE\t},\n\t{ \"version\",\tI_VERSION,\tNOARGS\t},\n\t{ \"!\",\t\tI_SHELL,\tNOARGS\t},\n\t{ \"?\",\t\tI_HELP,\t\tNOARGS\t},\n\t{ NULL,\t\t-1,\t\t-1\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct CMD cmds[] = {\n\t{ \"bye\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"cd\",\t\tI_CHDIR,\tREMOTE\t},\n\t{ \"chdir\",\tI_CHDIR,\tREMOTE\t},\n\t{ \"chgrp\",\tI_CHGRP,\tREMOTE\t},\n\t{ \"chmod\",\tI_CHMOD,\tREMOTE\t},\n\t{ \"chown\",\tI_CHOWN,\tREMOTE\t},\n\t{ \"df\",\t\tI_DF,\t\tREMOTE\t},\n\t{ \"dir\",\tI_LS,\t\tREMOTE\t},\n\t{ \"exit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"get\",\tI_GET,\t\tREMOTE\t},\n\t{ \"help\",\tI_HELP,\t\tNOARGS\t},\n\t{ \"lcd\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lchdir\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lls\",\tI_LLS,\t\tLOCAL\t},\n\t{ \"lmkdir\",\tI_LMKDIR,\tLOCAL\t},\n\t{ \"ln\",\t\tI_LINK,\t\tREMOTE\t},\n\t{ \"lpwd\",\tI_LPWD,\t\tLOCAL\t},\n\t{ \"ls\",\t\tI_LS,\t\tREMOTE\t},\n\t{ \"lumask\",\tI_LUMASK,\tNOARGS\t},\n\t{ \"mkdir\",\tI_MKDIR,\tREMOTE\t},\n\t{ \"mget\",\tI_GET,\t\tREMOTE\t},\n\t{ \"mput\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"progress\",\tI_PROGRESS,\tNOARGS\t},\n\t{ \"put\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"pwd\",\tI_PWD,\t\tREMOTE\t},\n\t{ \"quit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"reget\",\tI_REGET,\tREMOTE\t},\n\t{ \"rename\",\tI_RENAME,\tREMOTE\t},\n\t{ \"reput\",\tI_REPUT,\tLOCAL\t},\n\t{ \"rm\",\t\tI_RM,\t\tREMOTE\t},\n\t{ \"rmdir\",\tI_RMDIR,\tREMOTE\t},\n\t{ \"symlink\",\tI_SYMLINK,\tREMOTE\t},\n\t{ \"version\",\tI_VERSION,\tNOARGS\t},\n\t{ \"!\",\t\tI_SHELL,\tNOARGS\t},\n\t{ \"?\",\t\tI_HELP,\t\tNOARGS\t},\n\t{ NULL,\t\t-1,\t\t-1\t}\n};\n\nstatic int\ncomplete_is_remote(char *cmd) {\n\tint i;\n\n\tif (cmd == NULL)\n\t\treturn -1;\n\n\tfor (i = 0; cmds[i].c; i++) {\n\t\tif (!strncasecmp(cmd, cmds[i].c, strlen(cmds[i].c)))\n\t\t\treturn cmds[i].t;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete_cmd_parse",
          "args": [
            "el",
            "argv[0]",
            "argc == carg",
            "quote",
            "terminated"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "complete_cmd_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "1846-1915",
          "snippet": "static int\ncomplete_cmd_parse(EditLine *el, char *cmd, int lastarg, char quote,\n    int terminated)\n{\n\tu_int y, count = 0, cmdlen, tmplen;\n\tchar *tmp, **list, argterm[3];\n\tconst LineInfo *lf;\n\n\tlist = xcalloc((sizeof(cmds) / sizeof(*cmds)) + 1, sizeof(char *));\n\n\t/* No command specified: display all available commands */\n\tif (cmd == NULL) {\n\t\tfor (y = 0; cmds[y].c; y++)\n\t\t\tlist[count++] = xstrdup(cmds[y].c);\n\n\t\tlist[count] = NULL;\n\t\tcomplete_display(list, 0);\n\n\t\tfor (y = 0; list[y] != NULL; y++)\n\t\t\tfree(list[y]);\n\t\tfree(list);\n\t\treturn count;\n\t}\n\n\t/* Prepare subset of commands that start with \"cmd\" */\n\tcmdlen = strlen(cmd);\n\tfor (y = 0; cmds[y].c; y++)  {\n\t\tif (!strncasecmp(cmd, cmds[y].c, cmdlen))\n\t\t\tlist[count++] = xstrdup(cmds[y].c);\n\t}\n\tlist[count] = NULL;\n\n\tif (count == 0) {\n\t\tfree(list);\n\t\treturn 0;\n\t}\n\n\t/* Complete ambiguous command */\n\ttmp = complete_ambiguous(cmd, list, count);\n\tif (count > 1)\n\t\tcomplete_display(list, 0);\n\n\tfor (y = 0; list[y]; y++)\n\t\tfree(list[y]);\n\tfree(list);\n\n\tif (tmp != NULL) {\n\t\ttmplen = strlen(tmp);\n\t\tcmdlen = strlen(cmd);\n\t\t/* If cmd may be extended then do so */\n\t\tif (tmplen > cmdlen)\n\t\t\tif (el_insertstr(el, tmp + cmdlen) == -1)\n\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\tlf = el_line(el);\n\t\t/* Terminate argument cleanly */\n\t\tif (count == 1) {\n\t\t\ty = 0;\n\t\t\tif (!terminated)\n\t\t\t\targterm[y++] = quote;\n\t\t\tif (lastarg || *(lf->cursor) != ' ')\n\t\t\t\targterm[y++] = ' ';\n\t\t\targterm[y] = '\\0';\n\t\t\tif (y > 0 && el_insertstr(el, argterm) == -1)\n\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\t}\n\t\tfree(tmp);\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct CMD cmds[] = {\n\t{ \"bye\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"cd\",\t\tI_CHDIR,\tREMOTE\t},\n\t{ \"chdir\",\tI_CHDIR,\tREMOTE\t},\n\t{ \"chgrp\",\tI_CHGRP,\tREMOTE\t},\n\t{ \"chmod\",\tI_CHMOD,\tREMOTE\t},\n\t{ \"chown\",\tI_CHOWN,\tREMOTE\t},\n\t{ \"df\",\t\tI_DF,\t\tREMOTE\t},\n\t{ \"dir\",\tI_LS,\t\tREMOTE\t},\n\t{ \"exit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"get\",\tI_GET,\t\tREMOTE\t},\n\t{ \"help\",\tI_HELP,\t\tNOARGS\t},\n\t{ \"lcd\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lchdir\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lls\",\tI_LLS,\t\tLOCAL\t},\n\t{ \"lmkdir\",\tI_LMKDIR,\tLOCAL\t},\n\t{ \"ln\",\t\tI_LINK,\t\tREMOTE\t},\n\t{ \"lpwd\",\tI_LPWD,\t\tLOCAL\t},\n\t{ \"ls\",\t\tI_LS,\t\tREMOTE\t},\n\t{ \"lumask\",\tI_LUMASK,\tNOARGS\t},\n\t{ \"mkdir\",\tI_MKDIR,\tREMOTE\t},\n\t{ \"mget\",\tI_GET,\t\tREMOTE\t},\n\t{ \"mput\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"progress\",\tI_PROGRESS,\tNOARGS\t},\n\t{ \"put\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"pwd\",\tI_PWD,\t\tREMOTE\t},\n\t{ \"quit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"reget\",\tI_REGET,\tREMOTE\t},\n\t{ \"rename\",\tI_RENAME,\tREMOTE\t},\n\t{ \"reput\",\tI_REPUT,\tLOCAL\t},\n\t{ \"rm\",\t\tI_RM,\t\tREMOTE\t},\n\t{ \"rmdir\",\tI_RMDIR,\tREMOTE\t},\n\t{ \"symlink\",\tI_SYMLINK,\tREMOTE\t},\n\t{ \"version\",\tI_VERSION,\tNOARGS\t},\n\t{ \"!\",\t\tI_SHELL,\tNOARGS\t},\n\t{ \"?\",\t\tI_HELP,\t\tNOARGS\t},\n\t{ NULL,\t\t-1,\t\t-1\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct CMD cmds[] = {\n\t{ \"bye\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"cd\",\t\tI_CHDIR,\tREMOTE\t},\n\t{ \"chdir\",\tI_CHDIR,\tREMOTE\t},\n\t{ \"chgrp\",\tI_CHGRP,\tREMOTE\t},\n\t{ \"chmod\",\tI_CHMOD,\tREMOTE\t},\n\t{ \"chown\",\tI_CHOWN,\tREMOTE\t},\n\t{ \"df\",\t\tI_DF,\t\tREMOTE\t},\n\t{ \"dir\",\tI_LS,\t\tREMOTE\t},\n\t{ \"exit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"get\",\tI_GET,\t\tREMOTE\t},\n\t{ \"help\",\tI_HELP,\t\tNOARGS\t},\n\t{ \"lcd\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lchdir\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lls\",\tI_LLS,\t\tLOCAL\t},\n\t{ \"lmkdir\",\tI_LMKDIR,\tLOCAL\t},\n\t{ \"ln\",\t\tI_LINK,\t\tREMOTE\t},\n\t{ \"lpwd\",\tI_LPWD,\t\tLOCAL\t},\n\t{ \"ls\",\t\tI_LS,\t\tREMOTE\t},\n\t{ \"lumask\",\tI_LUMASK,\tNOARGS\t},\n\t{ \"mkdir\",\tI_MKDIR,\tREMOTE\t},\n\t{ \"mget\",\tI_GET,\t\tREMOTE\t},\n\t{ \"mput\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"progress\",\tI_PROGRESS,\tNOARGS\t},\n\t{ \"put\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"pwd\",\tI_PWD,\t\tREMOTE\t},\n\t{ \"quit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"reget\",\tI_REGET,\tREMOTE\t},\n\t{ \"rename\",\tI_RENAME,\tREMOTE\t},\n\t{ \"reput\",\tI_REPUT,\tLOCAL\t},\n\t{ \"rm\",\t\tI_RM,\t\tREMOTE\t},\n\t{ \"rmdir\",\tI_RMDIR,\tREMOTE\t},\n\t{ \"symlink\",\tI_SYMLINK,\tREMOTE\t},\n\t{ \"version\",\tI_VERSION,\tNOARGS\t},\n\t{ \"!\",\t\tI_SHELL,\tNOARGS\t},\n\t{ \"?\",\t\tI_HELP,\t\tNOARGS\t},\n\t{ NULL,\t\t-1,\t\t-1\t}\n};\n\nstatic int\ncomplete_cmd_parse(EditLine *el, char *cmd, int lastarg, char quote,\n    int terminated)\n{\n\tu_int y, count = 0, cmdlen, tmplen;\n\tchar *tmp, **list, argterm[3];\n\tconst LineInfo *lf;\n\n\tlist = xcalloc((sizeof(cmds) / sizeof(*cmds)) + 1, sizeof(char *));\n\n\t/* No command specified: display all available commands */\n\tif (cmd == NULL) {\n\t\tfor (y = 0; cmds[y].c; y++)\n\t\t\tlist[count++] = xstrdup(cmds[y].c);\n\n\t\tlist[count] = NULL;\n\t\tcomplete_display(list, 0);\n\n\t\tfor (y = 0; list[y] != NULL; y++)\n\t\t\tfree(list[y]);\n\t\tfree(list);\n\t\treturn count;\n\t}\n\n\t/* Prepare subset of commands that start with \"cmd\" */\n\tcmdlen = strlen(cmd);\n\tfor (y = 0; cmds[y].c; y++)  {\n\t\tif (!strncasecmp(cmd, cmds[y].c, cmdlen))\n\t\t\tlist[count++] = xstrdup(cmds[y].c);\n\t}\n\tlist[count] = NULL;\n\n\tif (count == 0) {\n\t\tfree(list);\n\t\treturn 0;\n\t}\n\n\t/* Complete ambiguous command */\n\ttmp = complete_ambiguous(cmd, list, count);\n\tif (count > 1)\n\t\tcomplete_display(list, 0);\n\n\tfor (y = 0; list[y]; y++)\n\t\tfree(list[y]);\n\tfree(list);\n\n\tif (tmp != NULL) {\n\t\ttmplen = strlen(tmp);\n\t\tcmdlen = strlen(cmd);\n\t\t/* If cmd may be extended then do so */\n\t\tif (tmplen > cmdlen)\n\t\t\tif (el_insertstr(el, tmp + cmdlen) == -1)\n\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\tlf = el_line(el);\n\t\t/* Terminate argument cleanly */\n\t\tif (count == 1) {\n\t\t\ty = 0;\n\t\t\tif (!terminated)\n\t\t\t\targterm[y++] = quote;\n\t\t\tif (lastarg || *(lf->cursor) != ' ')\n\t\t\t\targterm[y++] = ' ';\n\t\t\targterm[y] = '\\0';\n\t\t\tif (y > 0 && el_insertstr(el, argterm) == -1)\n\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\t}\n\t\tfree(tmp);\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeargv",
          "args": [
            "line",
            "&argc",
            "1",
            "NULL",
            "NULL"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "makeargv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "1151-1296",
          "snippet": "static char **\nmakeargv(const char *arg, int *argcp, int sloppy, char *lastquote,\n    u_int *terminated)\n{\n\tint argc, quot;\n\tsize_t i, j;\n\tstatic char argvs[MAXARGLEN];\n\tstatic char *argv[MAXARGS + 1];\n\tenum { MA_START, MA_SQUOTE, MA_DQUOTE, MA_UNQUOTED } state, q;\n\n\t*argcp = argc = 0;\n\tif (strlen(arg) > sizeof(argvs) - 1) {\n args_too_longs:\n\t\terror(\"string too long\");\n\t\treturn NULL;\n\t}\n\tif (terminated != NULL)\n\t\t*terminated = 1;\n\tif (lastquote != NULL)\n\t\t*lastquote = '\\0';\n\tstate = MA_START;\n\ti = j = 0;\n\tfor (;;) {\n\t\tif ((size_t)argc >= sizeof(argv) / sizeof(*argv)){\n\t\t\terror(\"Too many arguments.\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (isspace((unsigned char)arg[i])) {\n\t\t\tif (state == MA_UNQUOTED) {\n\t\t\t\t/* Terminate current argument */\n\t\t\t\targvs[j++] = '\\0';\n\t\t\t\targc++;\n\t\t\t\tstate = MA_START;\n\t\t\t} else if (state != MA_START)\n\t\t\t\targvs[j++] = arg[i];\n\t\t} else if (arg[i] == '\"' || arg[i] == '\\'') {\n\t\t\tq = arg[i] == '\"' ? MA_DQUOTE : MA_SQUOTE;\n\t\t\tif (state == MA_START) {\n\t\t\t\targv[argc] = argvs + j;\n\t\t\t\tstate = q;\n\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t*lastquote = arg[i];\n\t\t\t} else if (state == MA_UNQUOTED)\n\t\t\t\tstate = q;\n\t\t\telse if (state == q)\n\t\t\t\tstate = MA_UNQUOTED;\n\t\t\telse\n\t\t\t\targvs[j++] = arg[i];\n\t\t} else if (arg[i] == '\\\\') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE) {\n\t\t\t\tquot = state == MA_SQUOTE ? '\\'' : '\"';\n\t\t\t\t/* Unescape quote we are in */\n\t\t\t\t/* XXX support \\n and friends? */\n\t\t\t\tif (arg[i + 1] == quot) {\n\t\t\t\t\ti++;\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else if (arg[i + 1] == '?' ||\n\t\t\t\t    arg[i + 1] == '[' || arg[i + 1] == '*') {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special case for sftp: append\n\t\t\t\t\t * double-escaped glob sequence -\n\t\t\t\t\t * glob will undo one level of\n\t\t\t\t\t * escaping. NB. string can grow here.\n\t\t\t\t\t */\n\t\t\t\t\tif (j >= sizeof(argvs) - 5)\n\t\t\t\t\t\tgoto args_too_longs;\n\t\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else {\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (state == MA_START) {\n\t\t\t\t\targv[argc] = argvs + j;\n\t\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t\t*lastquote = '\\0';\n\t\t\t\t}\n\t\t\t\tif (arg[i + 1] == '?' || arg[i + 1] == '[' ||\n\t\t\t\t    arg[i + 1] == '*' || arg[i + 1] == '\\\\') {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special case for sftp: append\n\t\t\t\t\t * escaped glob sequence -\n\t\t\t\t\t * glob will undo one level of\n\t\t\t\t\t * escaping.\n\t\t\t\t\t */\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else {\n\t\t\t\t\t/* Unescape everything */\n\t\t\t\t\t/* XXX support \\n and friends? */\n\t\t\t\t\ti++;\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arg[i] == '#') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE)\n\t\t\t\targvs[j++] = arg[i];\n\t\t\telse\n\t\t\t\tgoto string_done;\n\t\t} else if (arg[i] == '\\0') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE) {\n\t\t\t\tif (sloppy) {\n\t\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\t\tif (terminated != NULL)\n\t\t\t\t\t\t*terminated = 0;\n\t\t\t\t\tgoto string_done;\n\t\t\t\t}\n\t\t\t\terror(\"Unterminated quoted argument\");\n\t\t\t\treturn NULL;\n\t\t\t}\n string_done:\n\t\t\tif (state == MA_UNQUOTED) {\n\t\t\t\targvs[j++] = '\\0';\n\t\t\t\targc++;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (state == MA_START) {\n\t\t\t\targv[argc] = argvs + j;\n\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t*lastquote = '\\0';\n\t\t\t}\n\t\t\tif ((state == MA_SQUOTE || state == MA_DQUOTE) &&\n\t\t\t    (arg[i] == '?' || arg[i] == '[' || arg[i] == '*')) {\n\t\t\t\t/*\n\t\t\t\t * Special case for sftp: escape quoted\n\t\t\t\t * glob(3) wildcards. NB. string can grow\n\t\t\t\t * here.\n\t\t\t\t */\n\t\t\t\tif (j >= sizeof(argvs) - 3)\n\t\t\t\t\tgoto args_too_longs;\n\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\targvs[j++] = arg[i];\n\t\t\t} else\n\t\t\t\targvs[j++] = arg[i];\n\t\t}\n\t\ti++;\n\t}\n\t*argcp = argc;\n\treturn argv;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAXARGLEN\t8192",
            "#define MAXARGS \t128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAXARGLEN\t8192\n#define MAXARGS \t128\n\nstatic char **\nmakeargv(const char *arg, int *argcp, int sloppy, char *lastquote,\n    u_int *terminated)\n{\n\tint argc, quot;\n\tsize_t i, j;\n\tstatic char argvs[MAXARGLEN];\n\tstatic char *argv[MAXARGS + 1];\n\tenum { MA_START, MA_SQUOTE, MA_DQUOTE, MA_UNQUOTED } state, q;\n\n\t*argcp = argc = 0;\n\tif (strlen(arg) > sizeof(argvs) - 1) {\n args_too_longs:\n\t\terror(\"string too long\");\n\t\treturn NULL;\n\t}\n\tif (terminated != NULL)\n\t\t*terminated = 1;\n\tif (lastquote != NULL)\n\t\t*lastquote = '\\0';\n\tstate = MA_START;\n\ti = j = 0;\n\tfor (;;) {\n\t\tif ((size_t)argc >= sizeof(argv) / sizeof(*argv)){\n\t\t\terror(\"Too many arguments.\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (isspace((unsigned char)arg[i])) {\n\t\t\tif (state == MA_UNQUOTED) {\n\t\t\t\t/* Terminate current argument */\n\t\t\t\targvs[j++] = '\\0';\n\t\t\t\targc++;\n\t\t\t\tstate = MA_START;\n\t\t\t} else if (state != MA_START)\n\t\t\t\targvs[j++] = arg[i];\n\t\t} else if (arg[i] == '\"' || arg[i] == '\\'') {\n\t\t\tq = arg[i] == '\"' ? MA_DQUOTE : MA_SQUOTE;\n\t\t\tif (state == MA_START) {\n\t\t\t\targv[argc] = argvs + j;\n\t\t\t\tstate = q;\n\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t*lastquote = arg[i];\n\t\t\t} else if (state == MA_UNQUOTED)\n\t\t\t\tstate = q;\n\t\t\telse if (state == q)\n\t\t\t\tstate = MA_UNQUOTED;\n\t\t\telse\n\t\t\t\targvs[j++] = arg[i];\n\t\t} else if (arg[i] == '\\\\') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE) {\n\t\t\t\tquot = state == MA_SQUOTE ? '\\'' : '\"';\n\t\t\t\t/* Unescape quote we are in */\n\t\t\t\t/* XXX support \\n and friends? */\n\t\t\t\tif (arg[i + 1] == quot) {\n\t\t\t\t\ti++;\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else if (arg[i + 1] == '?' ||\n\t\t\t\t    arg[i + 1] == '[' || arg[i + 1] == '*') {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special case for sftp: append\n\t\t\t\t\t * double-escaped glob sequence -\n\t\t\t\t\t * glob will undo one level of\n\t\t\t\t\t * escaping. NB. string can grow here.\n\t\t\t\t\t */\n\t\t\t\t\tif (j >= sizeof(argvs) - 5)\n\t\t\t\t\t\tgoto args_too_longs;\n\t\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else {\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (state == MA_START) {\n\t\t\t\t\targv[argc] = argvs + j;\n\t\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t\t*lastquote = '\\0';\n\t\t\t\t}\n\t\t\t\tif (arg[i + 1] == '?' || arg[i + 1] == '[' ||\n\t\t\t\t    arg[i + 1] == '*' || arg[i + 1] == '\\\\') {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special case for sftp: append\n\t\t\t\t\t * escaped glob sequence -\n\t\t\t\t\t * glob will undo one level of\n\t\t\t\t\t * escaping.\n\t\t\t\t\t */\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else {\n\t\t\t\t\t/* Unescape everything */\n\t\t\t\t\t/* XXX support \\n and friends? */\n\t\t\t\t\ti++;\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arg[i] == '#') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE)\n\t\t\t\targvs[j++] = arg[i];\n\t\t\telse\n\t\t\t\tgoto string_done;\n\t\t} else if (arg[i] == '\\0') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE) {\n\t\t\t\tif (sloppy) {\n\t\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\t\tif (terminated != NULL)\n\t\t\t\t\t\t*terminated = 0;\n\t\t\t\t\tgoto string_done;\n\t\t\t\t}\n\t\t\t\terror(\"Unterminated quoted argument\");\n\t\t\t\treturn NULL;\n\t\t\t}\n string_done:\n\t\t\tif (state == MA_UNQUOTED) {\n\t\t\t\targvs[j++] = '\\0';\n\t\t\t\targc++;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (state == MA_START) {\n\t\t\t\targv[argc] = argvs + j;\n\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t*lastquote = '\\0';\n\t\t\t}\n\t\t\tif ((state == MA_SQUOTE || state == MA_DQUOTE) &&\n\t\t\t    (arg[i] == '?' || arg[i] == '[' || arg[i] == '*')) {\n\t\t\t\t/*\n\t\t\t\t * Special case for sftp: escape quoted\n\t\t\t\t * glob(3) wildcards. NB. string can grow\n\t\t\t\t * here.\n\t\t\t\t */\n\t\t\t\tif (j >= sizeof(argvs) - 3)\n\t\t\t\t\tgoto args_too_longs;\n\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\targvs[j++] = arg[i];\n\t\t\t} else\n\t\t\t\targvs[j++] = arg[i];\n\t\t}\n\t\ti++;\n\t}\n\t*argcp = argc;\n\treturn argv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "line",
            "lf->buffer",
            "len"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "len + 1"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "line",
            "lf->buffer",
            "cursor"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: el_get failed\"",
            "__func__"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "el_get",
          "args": [
            "el",
            "EL_CLIENTDATA",
            "(void**)&complete_ctx"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "el_line",
          "args": [
            "el"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic unsigned char\ncomplete(EditLine *el, int ch)\n{\n\tchar **argv, *line, quote;\n\tint argc, carg;\n\tu_int cursor, len, terminated, ret = CC_ERROR;\n\tconst LineInfo *lf;\n\tstruct complete_ctx *complete_ctx;\n\n\tlf = el_line(el);\n\tif (el_get(el, EL_CLIENTDATA, (void**)&complete_ctx) != 0)\n\t\tfatal(\"%s: el_get failed\", __func__);\n\n\t/* Figure out which argument the cursor points to */\n\tcursor = lf->cursor - lf->buffer;\n\tline = xmalloc(cursor + 1);\n\tmemcpy(line, lf->buffer, cursor);\n\tline[cursor] = '\\0';\n\targv = makeargv(line, &carg, 1, &quote, &terminated);\n\tfree(line);\n\n\t/* Get all the arguments on the line */\n\tlen = lf->lastchar - lf->buffer;\n\tline = xmalloc(len + 1);\n\tmemcpy(line, lf->buffer, len);\n\tline[len] = '\\0';\n\targv = makeargv(line, &argc, 1, NULL, NULL);\n\n\t/* Ensure cursor is at EOL or a argument boundary */\n\tif (line[cursor] != ' ' && line[cursor] != '\\0' &&\n\t    line[cursor] != '\\n') {\n\t\tfree(line);\n\t\treturn ret;\n\t}\n\n\tif (carg == 0) {\n\t\t/* Show all available commands */\n\t\tcomplete_cmd_parse(el, NULL, argc == carg, '\\0', 1);\n\t\tret = CC_REDISPLAY;\n\t} else if (carg == 1 && cursor > 0 && line[cursor - 1] != ' ')  {\n\t\t/* Handle the command parsing */\n\t\tif (complete_cmd_parse(el, argv[0], argc == carg,\n\t\t    quote, terminated) != 0)\n\t\t\tret = CC_REDISPLAY;\n\t} else if (carg >= 1) {\n\t\t/* Handle file parsing */\n\t\tint remote = complete_is_remote(argv[0]);\n\t\tchar *filematch = NULL;\n\n\t\tif (carg > 1 && line[cursor-1] != ' ')\n\t\t\tfilematch = argv[carg - 1];\n\n\t\tif (remote != 0 &&\n\t\t    complete_match(el, complete_ctx->conn,\n\t\t    *complete_ctx->remote_pathp, filematch,\n\t\t    remote, carg == argc, quote, terminated) != 0)\n\t\t\tret = CC_REDISPLAY;\n\t}\n\n\tfree(line);\n\treturn ret;\n}"
  },
  {
    "function_name": "complete_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "1937-2061",
    "snippet": "static int\ncomplete_match(EditLine *el, struct sftp_conn *conn, char *remote_path,\n    char *file, int remote, int lastarg, char quote, int terminated)\n{\n\tglob_t g;\n\tchar *tmp, *tmp2, ins[8];\n\tu_int i, hadglob, pwdlen, len, tmplen, filelen, cesc, isesc, isabs;\n\tint clen;\n\tconst LineInfo *lf;\n\n\t/* Glob from \"file\" location */\n\tif (file == NULL)\n\t\ttmp = xstrdup(\"*\");\n\telse\n\t\txasprintf(&tmp, \"%s*\", file);\n\n\t/* Check if the path is absolute. */\n\tisabs = tmp[0] == '/';\n\n\tmemset(&g, 0, sizeof(g));\n\tif (remote != LOCAL) {\n\t\ttmp = make_absolute(tmp, remote_path);\n\t\tremote_glob(conn, tmp, GLOB_DOOFFS|GLOB_MARK, NULL, &g);\n\t} else\n\t\tglob(tmp, GLOB_DOOFFS|GLOB_MARK, NULL, &g);\n\n\t/* Determine length of pwd so we can trim completion display */\n\tfor (hadglob = tmplen = pwdlen = 0; tmp[tmplen] != 0; tmplen++) {\n\t\t/* Terminate counting on first unescaped glob metacharacter */\n\t\tif (tmp[tmplen] == '*' || tmp[tmplen] == '?') {\n\t\t\tif (tmp[tmplen] != '*' || tmp[tmplen + 1] != '\\0')\n\t\t\t\thadglob = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (tmp[tmplen] == '\\\\' && tmp[tmplen + 1] != '\\0')\n\t\t\ttmplen++;\n\t\tif (tmp[tmplen] == '/')\n\t\t\tpwdlen = tmplen + 1;\t/* track last seen '/' */\n\t}\n\tfree(tmp);\n\ttmp = NULL;\n\n\tif (g.gl_matchc == 0)\n\t\tgoto out;\n\n\tif (g.gl_matchc > 1)\n\t\tcomplete_display(g.gl_pathv, pwdlen);\n\n\t/* Don't try to extend globs */\n\tif (file == NULL || hadglob)\n\t\tgoto out;\n\n\ttmp2 = complete_ambiguous(file, g.gl_pathv, g.gl_matchc);\n\ttmp = path_strip(tmp2, isabs ? NULL : remote_path);\n\tfree(tmp2);\n\n\tif (tmp == NULL)\n\t\tgoto out;\n\n\ttmplen = strlen(tmp);\n\tfilelen = strlen(file);\n\n\t/* Count the number of escaped characters in the input string. */\n\tcesc = isesc = 0;\n\tfor (i = 0; i < filelen; i++) {\n\t\tif (!isesc && file[i] == '\\\\' && i + 1 < filelen){\n\t\t\tisesc = 1;\n\t\t\tcesc++;\n\t\t} else\n\t\t\tisesc = 0;\n\t}\n\n\tif (tmplen > (filelen - cesc)) {\n\t\ttmp2 = tmp + filelen - cesc;\n\t\tlen = strlen(tmp2);\n\t\t/* quote argument on way out */\n\t\tfor (i = 0; i < len; i += clen) {\n\t\t\tif ((clen = mblen(tmp2 + i, len - i)) < 0 ||\n\t\t\t    (size_t)clen > sizeof(ins) - 2)\n\t\t\t\tfatal(\"invalid multibyte character\");\n\t\t\tins[0] = '\\\\';\n\t\t\tmemcpy(ins + 1, tmp2 + i, clen);\n\t\t\tins[clen + 1] = '\\0';\n\t\t\tswitch (tmp2[i]) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '\\\\':\n\t\t\tcase '\\t':\n\t\t\tcase '[':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\tcase '*':\n\t\t\t\tif (quote == '\\0' || tmp2[i] == quote) {\n\t\t\t\t\tif (el_insertstr(el, ins) == -1)\n\t\t\t\t\t\tfatal(\"el_insertstr \"\n\t\t\t\t\t\t    \"failed.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tif (el_insertstr(el, ins + 1) == -1)\n\t\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlf = el_line(el);\n\tif (g.gl_matchc == 1) {\n\t\ti = 0;\n\t\tif (!terminated && quote != '\\0')\n\t\t\tins[i++] = quote;\n\t\tif (*(lf->cursor - 1) != '/' &&\n\t\t    (lastarg || *(lf->cursor) != ' '))\n\t\t\tins[i++] = ' ';\n\t\tins[i] = '\\0';\n\t\tif (i > 0 && el_insertstr(el, ins) == -1)\n\t\t\tfatal(\"el_insertstr failed.\");\n\t}\n\tfree(tmp);\n\n out:\n\tglobfree(&g);\n\treturn g.gl_matchc;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define LOCAL\t2"
    ],
    "globals_used": [
      "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "globfree",
          "args": [
            "&g"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "globfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "959-981",
          "snippet": "void\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nvoid\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"el_insertstr failed.\""
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "el_insertstr",
          "args": [
            "el",
            "ins"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "el_line",
          "args": [
            "el"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "el_insertstr",
          "args": [
            "el",
            "ins + 1"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "el_insertstr",
          "args": [
            "el",
            "ins"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ins + 1",
            "tmp2 + i",
            "clen"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mblen",
          "args": [
            "tmp2 + i",
            "len - i"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp2"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "file"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_strip",
          "args": [
            "tmp2",
            "isabs ? NULL : remote_path"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "path_strip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "368-384",
          "snippet": "static char *\npath_strip(const char *path, const char *strip)\n{\n\tsize_t len;\n\n\tif (strip == NULL)\n\t\treturn (xstrdup(path));\n\n\tlen = strlen(strip);\n\tif (strncmp(path, strip, len) == 0) {\n\t\tif (strip[len - 1] != '/' && path[len] == '/')\n\t\t\tlen++;\n\t\treturn (xstrdup(path + len));\n\t}\n\n\treturn (xstrdup(path));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\npath_strip(const char *path, const char *strip)\n{\n\tsize_t len;\n\n\tif (strip == NULL)\n\t\treturn (xstrdup(path));\n\n\tlen = strlen(strip);\n\tif (strncmp(path, strip, len) == 0) {\n\t\tif (strip[len - 1] != '/' && path[len] == '/')\n\t\t\tlen++;\n\t\treturn (xstrdup(path + len));\n\t}\n\n\treturn (xstrdup(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete_ambiguous",
          "args": [
            "file",
            "g.gl_pathv",
            "g.gl_matchc"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "complete_ambiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "1814-1843",
          "snippet": "static char *\ncomplete_ambiguous(const char *word, char **list, size_t count)\n{\n\tif (word == NULL)\n\t\treturn NULL;\n\n\tif (count > 0) {\n\t\tu_int y, matchlen = strlen(list[0]);\n\n\t\t/* Find length of common stem */\n\t\tfor (y = 1; list[y]; y++) {\n\t\t\tu_int x;\n\n\t\t\tfor (x = 0; x < matchlen; x++)\n\t\t\t\tif (list[0][x] != list[y][x])\n\t\t\t\t\tbreak;\n\n\t\t\tmatchlen = x;\n\t\t}\n\n\t\tif (matchlen > strlen(word)) {\n\t\t\tchar *tmp = xstrdup(list[0]);\n\n\t\t\ttmp[matchlen] = '\\0';\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\treturn xstrdup(word);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\ncomplete_ambiguous(const char *word, char **list, size_t count)\n{\n\tif (word == NULL)\n\t\treturn NULL;\n\n\tif (count > 0) {\n\t\tu_int y, matchlen = strlen(list[0]);\n\n\t\t/* Find length of common stem */\n\t\tfor (y = 1; list[y]; y++) {\n\t\t\tu_int x;\n\n\t\t\tfor (x = 0; x < matchlen; x++)\n\t\t\t\tif (list[0][x] != list[y][x])\n\t\t\t\t\tbreak;\n\n\t\t\tmatchlen = x;\n\t\t}\n\n\t\tif (matchlen > strlen(word)) {\n\t\t\tchar *tmp = xstrdup(list[0]);\n\n\t\t\ttmp[matchlen] = '\\0';\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\treturn xstrdup(word);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete_display",
          "args": [
            "g.gl_pathv",
            "pwdlen"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "complete_display",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "1774-1807",
          "snippet": "static void\ncomplete_display(char **list, u_int len)\n{\n\tu_int y, m = 0, width = 80, columns = 1, colspace = 0, llen;\n\tstruct winsize ws;\n\tchar *tmp;\n\n\t/* Count entries for sort and find longest */\n\tfor (y = 0; list[y]; y++)\n\t\tm = MAXIMUM(m, strlen(list[y]));\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tm = m > len ? m - len : 0;\n\tcolumns = width / (m + 2);\n\tcolumns = MAXIMUM(columns, 1);\n\tcolspace = width / columns;\n\tcolspace = MINIMUM(colspace, width);\n\n\tprintf(\"\\n\");\n\tm = 1;\n\tfor (y = 0; list[y]; y++) {\n\t\tllen = strlen(list[y]);\n\t\ttmp = llen > len ? list[y] + len : \"\";\n\t\tmprintf(\"%-*s\", colspace, tmp);\n\t\tif (m >= columns) {\n\t\t\tprintf(\"\\n\");\n\t\t\tm = 1;\n\t\t} else\n\t\t\tm++;\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncomplete_display(char **list, u_int len)\n{\n\tu_int y, m = 0, width = 80, columns = 1, colspace = 0, llen;\n\tstruct winsize ws;\n\tchar *tmp;\n\n\t/* Count entries for sort and find longest */\n\tfor (y = 0; list[y]; y++)\n\t\tm = MAXIMUM(m, strlen(list[y]));\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tm = m > len ? m - len : 0;\n\tcolumns = width / (m + 2);\n\tcolumns = MAXIMUM(columns, 1);\n\tcolspace = width / columns;\n\tcolspace = MINIMUM(colspace, width);\n\n\tprintf(\"\\n\");\n\tm = 1;\n\tfor (y = 0; list[y]; y++) {\n\t\tllen = strlen(list[y]);\n\t\ttmp = llen > len ? list[y] + len : \"\";\n\t\tmprintf(\"%-*s\", colspace, tmp);\n\t\tif (m >= columns) {\n\t\t\tprintf(\"\\n\");\n\t\t\tm = 1;\n\t\t} else\n\t\t\tm++;\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "glob",
          "args": [
            "tmp",
            "GLOB_DOOFFS|GLOB_MARK",
            "NULL",
            "&g"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "do_globbed_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "929-1033",
          "snippet": "static int\ndo_globbed_ls(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tchar *fname, *lname;\n\tglob_t g;\n\tint err, r;\n\tstruct winsize ws;\n\tu_int i, j, nentries, *indices = NULL, c = 1;\n\tu_int colspace = 0, columns = 1, m = 0, width = 80;\n\n\tmemset(&g, 0, sizeof(g));\n\n\tif ((r = remote_glob(conn, path,\n\t    GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE|GLOB_KEEPSTAT|GLOB_NOSORT,\n\t    NULL, &g)) != 0 ||\n\t    (g.gl_pathc && !g.gl_matchc)) {\n\t\tif (g.gl_pathc)\n\t\t\tglobfree(&g);\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Can't ls: Too many matches for \\\"%s\\\"\", path);\n\t\t} else {\n\t\t\terror(\"Can't ls: \\\"%s\\\" not found\", path);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (interrupted)\n\t\tgoto out;\n\n\t/*\n\t * If the glob returns a single match and it is a directory,\n\t * then just list its contents.\n\t */\n\tif (g.gl_matchc == 1 && g.gl_statv[0] != NULL &&\n\t    S_ISDIR(g.gl_statv[0]->st_mode)) {\n\t\terr = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);\n\t\tglobfree(&g);\n\t\treturn err;\n\t}\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (i = 0; g.gl_pathv[i]; i++)\n\t\t\tm = MAXIMUM(m, strlen(g.gl_pathv[i]));\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t}\n\n\t/*\n\t * Sorting: rather than mess with the contents of glob_t, prepare\n\t * an array of indices into it and sort that. For the usual\n\t * unsorted case, the indices are just the identity 1=1, 2=2, etc.\n\t */\n\tfor (nentries = 0; g.gl_pathv[nentries] != NULL; nentries++)\n\t\t;\t/* count entries */\n\tindices = calloc(nentries, sizeof(*indices));\n\tfor (i = 0; i < nentries; i++)\n\t\tindices[i] = i;\n\n\tif (lflag & SORT_FLAGS) {\n\t\tsort_glob = &g;\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(indices, nentries, sizeof(*indices), sglob_comp);\n\t\tsort_glob = NULL;\n\t}\n\n\tfor (j = 0; j < nentries && !interrupted; j++) {\n\t\ti = indices[j];\n\t\tfname = path_strip(g.gl_pathv[i], strip_path);\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (g.gl_statv[i] == NULL) {\n\t\t\t\terror(\"no stat information for %s\", fname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlname = ls_file(fname, g.gl_statv[i], 1,\n\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\tfree(lname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n out:\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(indices);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)",
            "#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */",
            "#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */",
            "#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */",
            "#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */"
          ],
          "globals_used": [
            "volatile sig_atomic_t interrupted = 0;",
            "int sort_flag;",
            "glob_t *sort_glob;",
            "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)\n#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */\n#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */\n#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */\n#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */\n\nvolatile sig_atomic_t interrupted = 0;\nint sort_flag;\nglob_t *sort_glob;\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\n\nstatic int\ndo_globbed_ls(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tchar *fname, *lname;\n\tglob_t g;\n\tint err, r;\n\tstruct winsize ws;\n\tu_int i, j, nentries, *indices = NULL, c = 1;\n\tu_int colspace = 0, columns = 1, m = 0, width = 80;\n\n\tmemset(&g, 0, sizeof(g));\n\n\tif ((r = remote_glob(conn, path,\n\t    GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE|GLOB_KEEPSTAT|GLOB_NOSORT,\n\t    NULL, &g)) != 0 ||\n\t    (g.gl_pathc && !g.gl_matchc)) {\n\t\tif (g.gl_pathc)\n\t\t\tglobfree(&g);\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Can't ls: Too many matches for \\\"%s\\\"\", path);\n\t\t} else {\n\t\t\terror(\"Can't ls: \\\"%s\\\" not found\", path);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (interrupted)\n\t\tgoto out;\n\n\t/*\n\t * If the glob returns a single match and it is a directory,\n\t * then just list its contents.\n\t */\n\tif (g.gl_matchc == 1 && g.gl_statv[0] != NULL &&\n\t    S_ISDIR(g.gl_statv[0]->st_mode)) {\n\t\terr = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);\n\t\tglobfree(&g);\n\t\treturn err;\n\t}\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (i = 0; g.gl_pathv[i]; i++)\n\t\t\tm = MAXIMUM(m, strlen(g.gl_pathv[i]));\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t}\n\n\t/*\n\t * Sorting: rather than mess with the contents of glob_t, prepare\n\t * an array of indices into it and sort that. For the usual\n\t * unsorted case, the indices are just the identity 1=1, 2=2, etc.\n\t */\n\tfor (nentries = 0; g.gl_pathv[nentries] != NULL; nentries++)\n\t\t;\t/* count entries */\n\tindices = calloc(nentries, sizeof(*indices));\n\tfor (i = 0; i < nentries; i++)\n\t\tindices[i] = i;\n\n\tif (lflag & SORT_FLAGS) {\n\t\tsort_glob = &g;\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(indices, nentries, sizeof(*indices), sglob_comp);\n\t\tsort_glob = NULL;\n\t}\n\n\tfor (j = 0; j < nentries && !interrupted; j++) {\n\t\ti = indices[j];\n\t\tfname = path_strip(g.gl_pathv[i], strip_path);\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (g.gl_statv[i] == NULL) {\n\t\t\t\terror(\"no stat information for %s\", fname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlname = ls_file(fname, g.gl_statv[i], 1,\n\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\tfree(lname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n out:\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(indices);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remote_glob",
          "args": [
            "conn",
            "tmp",
            "GLOB_DOOFFS|GLOB_MARK",
            "NULL",
            "&g"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "remote_glob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-glob.c",
          "lines": "136-150",
          "snippet": "int\nremote_glob(struct sftp_conn *conn, const char *pattern, int flags,\n    int (*errfunc)(const char *, int), glob_t *pglob)\n{\n\tpglob->gl_opendir = fudge_opendir;\n\tpglob->gl_readdir = (struct dirent *(*)(void *))fudge_readdir;\n\tpglob->gl_closedir = (void (*)(void *))fudge_closedir;\n\tpglob->gl_lstat = fudge_lstat;\n\tpglob->gl_stat = fudge_stat;\n\n\tmemset(&cur, 0, sizeof(cur));\n\tcur.conn = conn;\n\n\treturn(glob(pattern, flags | GLOB_ALTDIRFUNC, errfunc, pglob));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <dirent.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);",
            "static struct {\n\tstruct sftp_conn *conn;\n} cur;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <dirent.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\nstatic struct {\n\tstruct sftp_conn *conn;\n} cur;\n\nint\nremote_glob(struct sftp_conn *conn, const char *pattern, int flags,\n    int (*errfunc)(const char *, int), glob_t *pglob)\n{\n\tpglob->gl_opendir = fudge_opendir;\n\tpglob->gl_readdir = (struct dirent *(*)(void *))fudge_readdir;\n\tpglob->gl_closedir = (void (*)(void *))fudge_closedir;\n\tpglob->gl_lstat = fudge_lstat;\n\tpglob->gl_stat = fudge_stat;\n\n\tmemset(&cur, 0, sizeof(cur));\n\tcur.conn = conn;\n\n\treturn(glob(pattern, flags | GLOB_ALTDIRFUNC, errfunc, pglob));\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_absolute",
          "args": [
            "tmp",
            "remote_path"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "make_absolute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "386-398",
          "snippet": "static char *\nmake_absolute(char *p, const char *pwd)\n{\n\tchar *abs_str;\n\n\t/* Derelativise */\n\tif (p && p[0] != '/') {\n\t\tabs_str = path_append(pwd, p);\n\t\tfree(p);\n\t\treturn(abs_str);\n\t} else\n\t\treturn(p);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nmake_absolute(char *p, const char *pwd)\n{\n\tchar *abs_str;\n\n\t/* Derelativise */\n\tif (p && p[0] != '/') {\n\t\tabs_str = path_append(pwd, p);\n\t\tfree(p);\n\t\treturn(abs_str);\n\t} else\n\t\treturn(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&g",
            "0",
            "sizeof(g)"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&tmp",
            "\"%s*\"",
            "file"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"*\""
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define LOCAL\t2\n\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\n\nstatic int\ncomplete_match(EditLine *el, struct sftp_conn *conn, char *remote_path,\n    char *file, int remote, int lastarg, char quote, int terminated)\n{\n\tglob_t g;\n\tchar *tmp, *tmp2, ins[8];\n\tu_int i, hadglob, pwdlen, len, tmplen, filelen, cesc, isesc, isabs;\n\tint clen;\n\tconst LineInfo *lf;\n\n\t/* Glob from \"file\" location */\n\tif (file == NULL)\n\t\ttmp = xstrdup(\"*\");\n\telse\n\t\txasprintf(&tmp, \"%s*\", file);\n\n\t/* Check if the path is absolute. */\n\tisabs = tmp[0] == '/';\n\n\tmemset(&g, 0, sizeof(g));\n\tif (remote != LOCAL) {\n\t\ttmp = make_absolute(tmp, remote_path);\n\t\tremote_glob(conn, tmp, GLOB_DOOFFS|GLOB_MARK, NULL, &g);\n\t} else\n\t\tglob(tmp, GLOB_DOOFFS|GLOB_MARK, NULL, &g);\n\n\t/* Determine length of pwd so we can trim completion display */\n\tfor (hadglob = tmplen = pwdlen = 0; tmp[tmplen] != 0; tmplen++) {\n\t\t/* Terminate counting on first unescaped glob metacharacter */\n\t\tif (tmp[tmplen] == '*' || tmp[tmplen] == '?') {\n\t\t\tif (tmp[tmplen] != '*' || tmp[tmplen + 1] != '\\0')\n\t\t\t\thadglob = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (tmp[tmplen] == '\\\\' && tmp[tmplen + 1] != '\\0')\n\t\t\ttmplen++;\n\t\tif (tmp[tmplen] == '/')\n\t\t\tpwdlen = tmplen + 1;\t/* track last seen '/' */\n\t}\n\tfree(tmp);\n\ttmp = NULL;\n\n\tif (g.gl_matchc == 0)\n\t\tgoto out;\n\n\tif (g.gl_matchc > 1)\n\t\tcomplete_display(g.gl_pathv, pwdlen);\n\n\t/* Don't try to extend globs */\n\tif (file == NULL || hadglob)\n\t\tgoto out;\n\n\ttmp2 = complete_ambiguous(file, g.gl_pathv, g.gl_matchc);\n\ttmp = path_strip(tmp2, isabs ? NULL : remote_path);\n\tfree(tmp2);\n\n\tif (tmp == NULL)\n\t\tgoto out;\n\n\ttmplen = strlen(tmp);\n\tfilelen = strlen(file);\n\n\t/* Count the number of escaped characters in the input string. */\n\tcesc = isesc = 0;\n\tfor (i = 0; i < filelen; i++) {\n\t\tif (!isesc && file[i] == '\\\\' && i + 1 < filelen){\n\t\t\tisesc = 1;\n\t\t\tcesc++;\n\t\t} else\n\t\t\tisesc = 0;\n\t}\n\n\tif (tmplen > (filelen - cesc)) {\n\t\ttmp2 = tmp + filelen - cesc;\n\t\tlen = strlen(tmp2);\n\t\t/* quote argument on way out */\n\t\tfor (i = 0; i < len; i += clen) {\n\t\t\tif ((clen = mblen(tmp2 + i, len - i)) < 0 ||\n\t\t\t    (size_t)clen > sizeof(ins) - 2)\n\t\t\t\tfatal(\"invalid multibyte character\");\n\t\t\tins[0] = '\\\\';\n\t\t\tmemcpy(ins + 1, tmp2 + i, clen);\n\t\t\tins[clen + 1] = '\\0';\n\t\t\tswitch (tmp2[i]) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '\\\\':\n\t\t\tcase '\\t':\n\t\t\tcase '[':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\tcase '*':\n\t\t\t\tif (quote == '\\0' || tmp2[i] == quote) {\n\t\t\t\t\tif (el_insertstr(el, ins) == -1)\n\t\t\t\t\t\tfatal(\"el_insertstr \"\n\t\t\t\t\t\t    \"failed.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tif (el_insertstr(el, ins + 1) == -1)\n\t\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlf = el_line(el);\n\tif (g.gl_matchc == 1) {\n\t\ti = 0;\n\t\tif (!terminated && quote != '\\0')\n\t\t\tins[i++] = quote;\n\t\tif (*(lf->cursor - 1) != '/' &&\n\t\t    (lastarg || *(lf->cursor) != ' '))\n\t\t\tins[i++] = ' ';\n\t\tins[i] = '\\0';\n\t\tif (i > 0 && el_insertstr(el, ins) == -1)\n\t\t\tfatal(\"el_insertstr failed.\");\n\t}\n\tfree(tmp);\n\n out:\n\tglobfree(&g);\n\treturn g.gl_matchc;\n}"
  },
  {
    "function_name": "complete_is_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "1921-1934",
    "snippet": "static int\ncomplete_is_remote(char *cmd) {\n\tint i;\n\n\tif (cmd == NULL)\n\t\treturn -1;\n\n\tfor (i = 0; cmds[i].c; i++) {\n\t\tif (!strncasecmp(cmd, cmds[i].c, strlen(cmds[i].c)))\n\t\t\treturn cmds[i].t;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct CMD cmds[] = {\n\t{ \"bye\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"cd\",\t\tI_CHDIR,\tREMOTE\t},\n\t{ \"chdir\",\tI_CHDIR,\tREMOTE\t},\n\t{ \"chgrp\",\tI_CHGRP,\tREMOTE\t},\n\t{ \"chmod\",\tI_CHMOD,\tREMOTE\t},\n\t{ \"chown\",\tI_CHOWN,\tREMOTE\t},\n\t{ \"df\",\t\tI_DF,\t\tREMOTE\t},\n\t{ \"dir\",\tI_LS,\t\tREMOTE\t},\n\t{ \"exit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"get\",\tI_GET,\t\tREMOTE\t},\n\t{ \"help\",\tI_HELP,\t\tNOARGS\t},\n\t{ \"lcd\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lchdir\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lls\",\tI_LLS,\t\tLOCAL\t},\n\t{ \"lmkdir\",\tI_LMKDIR,\tLOCAL\t},\n\t{ \"ln\",\t\tI_LINK,\t\tREMOTE\t},\n\t{ \"lpwd\",\tI_LPWD,\t\tLOCAL\t},\n\t{ \"ls\",\t\tI_LS,\t\tREMOTE\t},\n\t{ \"lumask\",\tI_LUMASK,\tNOARGS\t},\n\t{ \"mkdir\",\tI_MKDIR,\tREMOTE\t},\n\t{ \"mget\",\tI_GET,\t\tREMOTE\t},\n\t{ \"mput\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"progress\",\tI_PROGRESS,\tNOARGS\t},\n\t{ \"put\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"pwd\",\tI_PWD,\t\tREMOTE\t},\n\t{ \"quit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"reget\",\tI_REGET,\tREMOTE\t},\n\t{ \"rename\",\tI_RENAME,\tREMOTE\t},\n\t{ \"reput\",\tI_REPUT,\tLOCAL\t},\n\t{ \"rm\",\t\tI_RM,\t\tREMOTE\t},\n\t{ \"rmdir\",\tI_RMDIR,\tREMOTE\t},\n\t{ \"symlink\",\tI_SYMLINK,\tREMOTE\t},\n\t{ \"version\",\tI_VERSION,\tNOARGS\t},\n\t{ \"!\",\t\tI_SHELL,\tNOARGS\t},\n\t{ \"?\",\t\tI_HELP,\t\tNOARGS\t},\n\t{ NULL,\t\t-1,\t\t-1\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "cmd",
            "cmds[i].c",
            "strlen(cmds[i].c)"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmds[i].c"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct CMD cmds[] = {\n\t{ \"bye\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"cd\",\t\tI_CHDIR,\tREMOTE\t},\n\t{ \"chdir\",\tI_CHDIR,\tREMOTE\t},\n\t{ \"chgrp\",\tI_CHGRP,\tREMOTE\t},\n\t{ \"chmod\",\tI_CHMOD,\tREMOTE\t},\n\t{ \"chown\",\tI_CHOWN,\tREMOTE\t},\n\t{ \"df\",\t\tI_DF,\t\tREMOTE\t},\n\t{ \"dir\",\tI_LS,\t\tREMOTE\t},\n\t{ \"exit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"get\",\tI_GET,\t\tREMOTE\t},\n\t{ \"help\",\tI_HELP,\t\tNOARGS\t},\n\t{ \"lcd\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lchdir\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lls\",\tI_LLS,\t\tLOCAL\t},\n\t{ \"lmkdir\",\tI_LMKDIR,\tLOCAL\t},\n\t{ \"ln\",\t\tI_LINK,\t\tREMOTE\t},\n\t{ \"lpwd\",\tI_LPWD,\t\tLOCAL\t},\n\t{ \"ls\",\t\tI_LS,\t\tREMOTE\t},\n\t{ \"lumask\",\tI_LUMASK,\tNOARGS\t},\n\t{ \"mkdir\",\tI_MKDIR,\tREMOTE\t},\n\t{ \"mget\",\tI_GET,\t\tREMOTE\t},\n\t{ \"mput\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"progress\",\tI_PROGRESS,\tNOARGS\t},\n\t{ \"put\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"pwd\",\tI_PWD,\t\tREMOTE\t},\n\t{ \"quit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"reget\",\tI_REGET,\tREMOTE\t},\n\t{ \"rename\",\tI_RENAME,\tREMOTE\t},\n\t{ \"reput\",\tI_REPUT,\tLOCAL\t},\n\t{ \"rm\",\t\tI_RM,\t\tREMOTE\t},\n\t{ \"rmdir\",\tI_RMDIR,\tREMOTE\t},\n\t{ \"symlink\",\tI_SYMLINK,\tREMOTE\t},\n\t{ \"version\",\tI_VERSION,\tNOARGS\t},\n\t{ \"!\",\t\tI_SHELL,\tNOARGS\t},\n\t{ \"?\",\t\tI_HELP,\t\tNOARGS\t},\n\t{ NULL,\t\t-1,\t\t-1\t}\n};\n\nstatic int\ncomplete_is_remote(char *cmd) {\n\tint i;\n\n\tif (cmd == NULL)\n\t\treturn -1;\n\n\tfor (i = 0; cmds[i].c; i++) {\n\t\tif (!strncasecmp(cmd, cmds[i].c, strlen(cmds[i].c)))\n\t\t\treturn cmds[i].t;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "complete_cmd_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "1846-1915",
    "snippet": "static int\ncomplete_cmd_parse(EditLine *el, char *cmd, int lastarg, char quote,\n    int terminated)\n{\n\tu_int y, count = 0, cmdlen, tmplen;\n\tchar *tmp, **list, argterm[3];\n\tconst LineInfo *lf;\n\n\tlist = xcalloc((sizeof(cmds) / sizeof(*cmds)) + 1, sizeof(char *));\n\n\t/* No command specified: display all available commands */\n\tif (cmd == NULL) {\n\t\tfor (y = 0; cmds[y].c; y++)\n\t\t\tlist[count++] = xstrdup(cmds[y].c);\n\n\t\tlist[count] = NULL;\n\t\tcomplete_display(list, 0);\n\n\t\tfor (y = 0; list[y] != NULL; y++)\n\t\t\tfree(list[y]);\n\t\tfree(list);\n\t\treturn count;\n\t}\n\n\t/* Prepare subset of commands that start with \"cmd\" */\n\tcmdlen = strlen(cmd);\n\tfor (y = 0; cmds[y].c; y++)  {\n\t\tif (!strncasecmp(cmd, cmds[y].c, cmdlen))\n\t\t\tlist[count++] = xstrdup(cmds[y].c);\n\t}\n\tlist[count] = NULL;\n\n\tif (count == 0) {\n\t\tfree(list);\n\t\treturn 0;\n\t}\n\n\t/* Complete ambiguous command */\n\ttmp = complete_ambiguous(cmd, list, count);\n\tif (count > 1)\n\t\tcomplete_display(list, 0);\n\n\tfor (y = 0; list[y]; y++)\n\t\tfree(list[y]);\n\tfree(list);\n\n\tif (tmp != NULL) {\n\t\ttmplen = strlen(tmp);\n\t\tcmdlen = strlen(cmd);\n\t\t/* If cmd may be extended then do so */\n\t\tif (tmplen > cmdlen)\n\t\t\tif (el_insertstr(el, tmp + cmdlen) == -1)\n\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\tlf = el_line(el);\n\t\t/* Terminate argument cleanly */\n\t\tif (count == 1) {\n\t\t\ty = 0;\n\t\t\tif (!terminated)\n\t\t\t\targterm[y++] = quote;\n\t\t\tif (lastarg || *(lf->cursor) != ' ')\n\t\t\t\targterm[y++] = ' ';\n\t\t\targterm[y] = '\\0';\n\t\t\tif (y > 0 && el_insertstr(el, argterm) == -1)\n\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\t}\n\t\tfree(tmp);\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct CMD cmds[] = {\n\t{ \"bye\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"cd\",\t\tI_CHDIR,\tREMOTE\t},\n\t{ \"chdir\",\tI_CHDIR,\tREMOTE\t},\n\t{ \"chgrp\",\tI_CHGRP,\tREMOTE\t},\n\t{ \"chmod\",\tI_CHMOD,\tREMOTE\t},\n\t{ \"chown\",\tI_CHOWN,\tREMOTE\t},\n\t{ \"df\",\t\tI_DF,\t\tREMOTE\t},\n\t{ \"dir\",\tI_LS,\t\tREMOTE\t},\n\t{ \"exit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"get\",\tI_GET,\t\tREMOTE\t},\n\t{ \"help\",\tI_HELP,\t\tNOARGS\t},\n\t{ \"lcd\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lchdir\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lls\",\tI_LLS,\t\tLOCAL\t},\n\t{ \"lmkdir\",\tI_LMKDIR,\tLOCAL\t},\n\t{ \"ln\",\t\tI_LINK,\t\tREMOTE\t},\n\t{ \"lpwd\",\tI_LPWD,\t\tLOCAL\t},\n\t{ \"ls\",\t\tI_LS,\t\tREMOTE\t},\n\t{ \"lumask\",\tI_LUMASK,\tNOARGS\t},\n\t{ \"mkdir\",\tI_MKDIR,\tREMOTE\t},\n\t{ \"mget\",\tI_GET,\t\tREMOTE\t},\n\t{ \"mput\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"progress\",\tI_PROGRESS,\tNOARGS\t},\n\t{ \"put\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"pwd\",\tI_PWD,\t\tREMOTE\t},\n\t{ \"quit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"reget\",\tI_REGET,\tREMOTE\t},\n\t{ \"rename\",\tI_RENAME,\tREMOTE\t},\n\t{ \"reput\",\tI_REPUT,\tLOCAL\t},\n\t{ \"rm\",\t\tI_RM,\t\tREMOTE\t},\n\t{ \"rmdir\",\tI_RMDIR,\tREMOTE\t},\n\t{ \"symlink\",\tI_SYMLINK,\tREMOTE\t},\n\t{ \"version\",\tI_VERSION,\tNOARGS\t},\n\t{ \"!\",\t\tI_SHELL,\tNOARGS\t},\n\t{ \"?\",\t\tI_HELP,\t\tNOARGS\t},\n\t{ NULL,\t\t-1,\t\t-1\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"el_insertstr failed.\""
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "el_insertstr",
          "args": [
            "el",
            "argterm"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "el_line",
          "args": [
            "el"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "el_insertstr",
          "args": [
            "el",
            "tmp + cmdlen"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete_display",
          "args": [
            "list",
            "0"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "complete_display",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "1774-1807",
          "snippet": "static void\ncomplete_display(char **list, u_int len)\n{\n\tu_int y, m = 0, width = 80, columns = 1, colspace = 0, llen;\n\tstruct winsize ws;\n\tchar *tmp;\n\n\t/* Count entries for sort and find longest */\n\tfor (y = 0; list[y]; y++)\n\t\tm = MAXIMUM(m, strlen(list[y]));\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tm = m > len ? m - len : 0;\n\tcolumns = width / (m + 2);\n\tcolumns = MAXIMUM(columns, 1);\n\tcolspace = width / columns;\n\tcolspace = MINIMUM(colspace, width);\n\n\tprintf(\"\\n\");\n\tm = 1;\n\tfor (y = 0; list[y]; y++) {\n\t\tllen = strlen(list[y]);\n\t\ttmp = llen > len ? list[y] + len : \"\";\n\t\tmprintf(\"%-*s\", colspace, tmp);\n\t\tif (m >= columns) {\n\t\t\tprintf(\"\\n\");\n\t\t\tm = 1;\n\t\t} else\n\t\t\tm++;\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncomplete_display(char **list, u_int len)\n{\n\tu_int y, m = 0, width = 80, columns = 1, colspace = 0, llen;\n\tstruct winsize ws;\n\tchar *tmp;\n\n\t/* Count entries for sort and find longest */\n\tfor (y = 0; list[y]; y++)\n\t\tm = MAXIMUM(m, strlen(list[y]));\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tm = m > len ? m - len : 0;\n\tcolumns = width / (m + 2);\n\tcolumns = MAXIMUM(columns, 1);\n\tcolspace = width / columns;\n\tcolspace = MINIMUM(colspace, width);\n\n\tprintf(\"\\n\");\n\tm = 1;\n\tfor (y = 0; list[y]; y++) {\n\t\tllen = strlen(list[y]);\n\t\ttmp = llen > len ? list[y] + len : \"\";\n\t\tmprintf(\"%-*s\", colspace, tmp);\n\t\tif (m >= columns) {\n\t\t\tprintf(\"\\n\");\n\t\t\tm = 1;\n\t\t} else\n\t\t\tm++;\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete_ambiguous",
          "args": [
            "cmd",
            "list",
            "count"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "complete_ambiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "1814-1843",
          "snippet": "static char *\ncomplete_ambiguous(const char *word, char **list, size_t count)\n{\n\tif (word == NULL)\n\t\treturn NULL;\n\n\tif (count > 0) {\n\t\tu_int y, matchlen = strlen(list[0]);\n\n\t\t/* Find length of common stem */\n\t\tfor (y = 1; list[y]; y++) {\n\t\t\tu_int x;\n\n\t\t\tfor (x = 0; x < matchlen; x++)\n\t\t\t\tif (list[0][x] != list[y][x])\n\t\t\t\t\tbreak;\n\n\t\t\tmatchlen = x;\n\t\t}\n\n\t\tif (matchlen > strlen(word)) {\n\t\t\tchar *tmp = xstrdup(list[0]);\n\n\t\t\ttmp[matchlen] = '\\0';\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\treturn xstrdup(word);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\ncomplete_ambiguous(const char *word, char **list, size_t count)\n{\n\tif (word == NULL)\n\t\treturn NULL;\n\n\tif (count > 0) {\n\t\tu_int y, matchlen = strlen(list[0]);\n\n\t\t/* Find length of common stem */\n\t\tfor (y = 1; list[y]; y++) {\n\t\t\tu_int x;\n\n\t\t\tfor (x = 0; x < matchlen; x++)\n\t\t\t\tif (list[0][x] != list[y][x])\n\t\t\t\t\tbreak;\n\n\t\t\tmatchlen = x;\n\t\t}\n\n\t\tif (matchlen > strlen(word)) {\n\t\t\tchar *tmp = xstrdup(list[0]);\n\n\t\t\ttmp[matchlen] = '\\0';\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\treturn xstrdup(word);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "cmds[y].c"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "cmd",
            "cmds[y].c",
            "cmdlen"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "(sizeof(cmds) / sizeof(*cmds)) + 1",
            "sizeof(char *)"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct CMD cmds[] = {\n\t{ \"bye\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"cd\",\t\tI_CHDIR,\tREMOTE\t},\n\t{ \"chdir\",\tI_CHDIR,\tREMOTE\t},\n\t{ \"chgrp\",\tI_CHGRP,\tREMOTE\t},\n\t{ \"chmod\",\tI_CHMOD,\tREMOTE\t},\n\t{ \"chown\",\tI_CHOWN,\tREMOTE\t},\n\t{ \"df\",\t\tI_DF,\t\tREMOTE\t},\n\t{ \"dir\",\tI_LS,\t\tREMOTE\t},\n\t{ \"exit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"get\",\tI_GET,\t\tREMOTE\t},\n\t{ \"help\",\tI_HELP,\t\tNOARGS\t},\n\t{ \"lcd\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lchdir\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lls\",\tI_LLS,\t\tLOCAL\t},\n\t{ \"lmkdir\",\tI_LMKDIR,\tLOCAL\t},\n\t{ \"ln\",\t\tI_LINK,\t\tREMOTE\t},\n\t{ \"lpwd\",\tI_LPWD,\t\tLOCAL\t},\n\t{ \"ls\",\t\tI_LS,\t\tREMOTE\t},\n\t{ \"lumask\",\tI_LUMASK,\tNOARGS\t},\n\t{ \"mkdir\",\tI_MKDIR,\tREMOTE\t},\n\t{ \"mget\",\tI_GET,\t\tREMOTE\t},\n\t{ \"mput\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"progress\",\tI_PROGRESS,\tNOARGS\t},\n\t{ \"put\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"pwd\",\tI_PWD,\t\tREMOTE\t},\n\t{ \"quit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"reget\",\tI_REGET,\tREMOTE\t},\n\t{ \"rename\",\tI_RENAME,\tREMOTE\t},\n\t{ \"reput\",\tI_REPUT,\tLOCAL\t},\n\t{ \"rm\",\t\tI_RM,\t\tREMOTE\t},\n\t{ \"rmdir\",\tI_RMDIR,\tREMOTE\t},\n\t{ \"symlink\",\tI_SYMLINK,\tREMOTE\t},\n\t{ \"version\",\tI_VERSION,\tNOARGS\t},\n\t{ \"!\",\t\tI_SHELL,\tNOARGS\t},\n\t{ \"?\",\t\tI_HELP,\t\tNOARGS\t},\n\t{ NULL,\t\t-1,\t\t-1\t}\n};\n\nstatic int\ncomplete_cmd_parse(EditLine *el, char *cmd, int lastarg, char quote,\n    int terminated)\n{\n\tu_int y, count = 0, cmdlen, tmplen;\n\tchar *tmp, **list, argterm[3];\n\tconst LineInfo *lf;\n\n\tlist = xcalloc((sizeof(cmds) / sizeof(*cmds)) + 1, sizeof(char *));\n\n\t/* No command specified: display all available commands */\n\tif (cmd == NULL) {\n\t\tfor (y = 0; cmds[y].c; y++)\n\t\t\tlist[count++] = xstrdup(cmds[y].c);\n\n\t\tlist[count] = NULL;\n\t\tcomplete_display(list, 0);\n\n\t\tfor (y = 0; list[y] != NULL; y++)\n\t\t\tfree(list[y]);\n\t\tfree(list);\n\t\treturn count;\n\t}\n\n\t/* Prepare subset of commands that start with \"cmd\" */\n\tcmdlen = strlen(cmd);\n\tfor (y = 0; cmds[y].c; y++)  {\n\t\tif (!strncasecmp(cmd, cmds[y].c, cmdlen))\n\t\t\tlist[count++] = xstrdup(cmds[y].c);\n\t}\n\tlist[count] = NULL;\n\n\tif (count == 0) {\n\t\tfree(list);\n\t\treturn 0;\n\t}\n\n\t/* Complete ambiguous command */\n\ttmp = complete_ambiguous(cmd, list, count);\n\tif (count > 1)\n\t\tcomplete_display(list, 0);\n\n\tfor (y = 0; list[y]; y++)\n\t\tfree(list[y]);\n\tfree(list);\n\n\tif (tmp != NULL) {\n\t\ttmplen = strlen(tmp);\n\t\tcmdlen = strlen(cmd);\n\t\t/* If cmd may be extended then do so */\n\t\tif (tmplen > cmdlen)\n\t\t\tif (el_insertstr(el, tmp + cmdlen) == -1)\n\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\tlf = el_line(el);\n\t\t/* Terminate argument cleanly */\n\t\tif (count == 1) {\n\t\t\ty = 0;\n\t\t\tif (!terminated)\n\t\t\t\targterm[y++] = quote;\n\t\t\tif (lastarg || *(lf->cursor) != ' ')\n\t\t\t\targterm[y++] = ' ';\n\t\t\targterm[y] = '\\0';\n\t\t\tif (y > 0 && el_insertstr(el, argterm) == -1)\n\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\t}\n\t\tfree(tmp);\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "complete_ambiguous",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "1814-1843",
    "snippet": "static char *\ncomplete_ambiguous(const char *word, char **list, size_t count)\n{\n\tif (word == NULL)\n\t\treturn NULL;\n\n\tif (count > 0) {\n\t\tu_int y, matchlen = strlen(list[0]);\n\n\t\t/* Find length of common stem */\n\t\tfor (y = 1; list[y]; y++) {\n\t\t\tu_int x;\n\n\t\t\tfor (x = 0; x < matchlen; x++)\n\t\t\t\tif (list[0][x] != list[y][x])\n\t\t\t\t\tbreak;\n\n\t\t\tmatchlen = x;\n\t\t}\n\n\t\tif (matchlen > strlen(word)) {\n\t\t\tchar *tmp = xstrdup(list[0]);\n\n\t\t\ttmp[matchlen] = '\\0';\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\treturn xstrdup(word);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "word"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "word"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "list[0]"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\ncomplete_ambiguous(const char *word, char **list, size_t count)\n{\n\tif (word == NULL)\n\t\treturn NULL;\n\n\tif (count > 0) {\n\t\tu_int y, matchlen = strlen(list[0]);\n\n\t\t/* Find length of common stem */\n\t\tfor (y = 1; list[y]; y++) {\n\t\t\tu_int x;\n\n\t\t\tfor (x = 0; x < matchlen; x++)\n\t\t\t\tif (list[0][x] != list[y][x])\n\t\t\t\t\tbreak;\n\n\t\t\tmatchlen = x;\n\t\t}\n\n\t\tif (matchlen > strlen(word)) {\n\t\t\tchar *tmp = xstrdup(list[0]);\n\n\t\t\ttmp[matchlen] = '\\0';\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\treturn xstrdup(word);\n}"
  },
  {
    "function_name": "complete_display",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "1774-1807",
    "snippet": "static void\ncomplete_display(char **list, u_int len)\n{\n\tu_int y, m = 0, width = 80, columns = 1, colspace = 0, llen;\n\tstruct winsize ws;\n\tchar *tmp;\n\n\t/* Count entries for sort and find longest */\n\tfor (y = 0; list[y]; y++)\n\t\tm = MAXIMUM(m, strlen(list[y]));\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tm = m > len ? m - len : 0;\n\tcolumns = width / (m + 2);\n\tcolumns = MAXIMUM(columns, 1);\n\tcolspace = width / columns;\n\tcolspace = MINIMUM(colspace, width);\n\n\tprintf(\"\\n\");\n\tm = 1;\n\tfor (y = 0; list[y]; y++) {\n\t\tllen = strlen(list[y]);\n\t\ttmp = llen > len ? list[y] + len : \"\";\n\t\tmprintf(\"%-*s\", colspace, tmp);\n\t\tif (m >= columns) {\n\t\t\tprintf(\"\\n\");\n\t\t\tm = 1;\n\t\t} else\n\t\t\tm++;\n\t}\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "list[y]"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "colspace",
            "width"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "columns",
            "1"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fileno(stdin)",
            "TIOCGWINSZ",
            "&ws"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "m",
            "strlen(list[y])"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "list[y]"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncomplete_display(char **list, u_int len)\n{\n\tu_int y, m = 0, width = 80, columns = 1, colspace = 0, llen;\n\tstruct winsize ws;\n\tchar *tmp;\n\n\t/* Count entries for sort and find longest */\n\tfor (y = 0; list[y]; y++)\n\t\tm = MAXIMUM(m, strlen(list[y]));\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tm = m > len ? m - len : 0;\n\tcolumns = width / (m + 2);\n\tcolumns = MAXIMUM(columns, 1);\n\tcolspace = width / columns;\n\tcolspace = MINIMUM(colspace, width);\n\n\tprintf(\"\\n\");\n\tm = 1;\n\tfor (y = 0; list[y]; y++) {\n\t\tllen = strlen(list[y]);\n\t\ttmp = llen > len ? list[y] + len : \"\";\n\t\tmprintf(\"%-*s\", colspace, tmp);\n\t\tif (m >= columns) {\n\t\t\tprintf(\"\\n\");\n\t\t\tm = 1;\n\t\t} else\n\t\t\tm++;\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "prompt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "1767-1771",
    "snippet": "static char *\nprompt(EditLine *el)\n{\n\treturn (\"sftp> \");\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nprompt(EditLine *el)\n{\n\treturn (\"sftp> \");\n}"
  },
  {
    "function_name": "parse_dispatch_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "1502-1764",
    "snippet": "static int\nparse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd,\n    const char *startdir, int err_abort, int echo_command)\n{\n\tconst char *ocmd = cmd;\n\tchar *path1, *path2, *tmp;\n\tint ignore_errors = 0, disable_echo = 1;\n\tint aflag = 0, fflag = 0, hflag = 0, iflag = 0;\n\tint lflag = 0, pflag = 0, rflag = 0, sflag = 0;\n\tint cmdnum, i;\n\tunsigned long n_arg = 0;\n\tAttrib a, *aa;\n\tchar path_buf[PATH_MAX];\n\tint err = 0;\n\tglob_t g;\n\n\tpath1 = path2 = NULL;\n\tcmdnum = parse_args(&cmd, &ignore_errors, &disable_echo, &aflag, &fflag,\n\t    &hflag, &iflag, &lflag, &pflag, &rflag, &sflag, &n_arg,\n\t    &path1, &path2);\n\tif (ignore_errors != 0)\n\t\terr_abort = 0;\n\n\tif (echo_command && !disable_echo)\n\t\tmprintf(\"sftp> %s\\n\", ocmd);\n\n\tmemset(&g, 0, sizeof(g));\n\n\t/* Perform command */\n\tswitch (cmdnum) {\n\tcase 0:\n\t\t/* Blank line */\n\t\tbreak;\n\tcase -1:\n\t\t/* Unrecognized command */\n\t\terr = -1;\n\t\tbreak;\n\tcase I_REGET:\n\t\taflag = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_GET:\n\t\terr = process_get(conn, path1, path2, *pwd, pflag,\n\t\t    rflag, aflag, fflag);\n\t\tbreak;\n\tcase I_REPUT:\n\t\taflag = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_PUT:\n\t\terr = process_put(conn, path1, path2, *pwd, pflag,\n\t\t    rflag, aflag, fflag);\n\t\tbreak;\n\tcase I_RENAME:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tpath2 = make_absolute(path2, *pwd);\n\t\terr = do_rename(conn, path1, path2, lflag);\n\t\tbreak;\n\tcase I_SYMLINK:\n\t\tsflag = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_LINK:\n\t\tif (!sflag)\n\t\t\tpath1 = make_absolute(path1, *pwd);\n\t\tpath2 = make_absolute(path2, *pwd);\n\t\terr = (sflag ? do_symlink : do_hardlink)(conn, path1, path2);\n\t\tbreak;\n\tcase I_RM:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tremote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Removing %s\\n\", g.gl_pathv[i]);\n\t\t\terr = do_rm(conn, g.gl_pathv[i]);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_MKDIR:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tattrib_clear(&a);\n\t\ta.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\t\ta.perm = 0777;\n\t\terr = do_mkdir(conn, path1, &a, 1);\n\t\tbreak;\n\tcase I_RMDIR:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\terr = do_rmdir(conn, path1);\n\t\tbreak;\n\tcase I_CHDIR:\n\t\tif (path1 == NULL || *path1 == '\\0')\n\t\t\tpath1 = xstrdup(startdir);\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tif ((tmp = do_realpath(conn, path1)) == NULL) {\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((aa = do_stat(conn, tmp, 0)) == NULL) {\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(aa->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)) {\n\t\t\terror(\"Can't change directory: Can't check target\");\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!S_ISDIR(aa->perm)) {\n\t\t\terror(\"Can't change directory: \\\"%s\\\" is not \"\n\t\t\t    \"a directory\", tmp);\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tfree(*pwd);\n\t\t*pwd = tmp;\n\t\tbreak;\n\tcase I_LS:\n\t\tif (!path1) {\n\t\t\tdo_ls_dir(conn, *pwd, *pwd, lflag);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Strip pwd off beginning of non-absolute paths */\n\t\ttmp = NULL;\n\t\tif (*path1 != '/')\n\t\t\ttmp = *pwd;\n\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\terr = do_globbed_ls(conn, path1, tmp, lflag);\n\t\tbreak;\n\tcase I_DF:\n\t\t/* Default to current directory if no path specified */\n\t\tif (path1 == NULL)\n\t\t\tpath1 = xstrdup(*pwd);\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\terr = do_df(conn, path1, hflag, iflag);\n\t\tbreak;\n\tcase I_LCHDIR:\n\t\tif (path1 == NULL || *path1 == '\\0')\n\t\t\tpath1 = xstrdup(\"~\");\n\t\ttmp = tilde_expand_filename(path1, getuid());\n\t\tfree(path1);\n\t\tpath1 = tmp;\n\t\tif (chdir(path1) == -1) {\n\t\t\terror(\"Couldn't change local directory to \"\n\t\t\t    \"\\\"%s\\\": %s\", path1, strerror(errno));\n\t\t\terr = 1;\n\t\t}\n\t\tbreak;\n\tcase I_LMKDIR:\n\t\tif (mkdir(path1, 0777) == -1) {\n\t\t\terror(\"Couldn't create local directory \"\n\t\t\t    \"\\\"%s\\\": %s\", path1, strerror(errno));\n\t\t\terr = 1;\n\t\t}\n\t\tbreak;\n\tcase I_LLS:\n\t\tlocal_do_ls(cmd);\n\t\tbreak;\n\tcase I_SHELL:\n\t\tlocal_do_shell(cmd);\n\t\tbreak;\n\tcase I_LUMASK:\n\t\tumask(n_arg);\n\t\tprintf(\"Local umask: %03lo\\n\", n_arg);\n\t\tbreak;\n\tcase I_CHMOD:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tattrib_clear(&a);\n\t\ta.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\t\ta.perm = n_arg;\n\t\tremote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Changing mode on %s\\n\",\n\t\t\t\t    g.gl_pathv[i]);\n\t\t\terr = do_setstat(conn, g.gl_pathv[i], &a);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_CHOWN:\n\tcase I_CHGRP:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tremote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif (!(aa = do_stat(conn, g.gl_pathv[i], 0))) {\n\t\t\t\tif (err_abort) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {\n\t\t\t\terror(\"Can't get current ownership of \"\n\t\t\t\t    \"remote file \\\"%s\\\"\", g.gl_pathv[i]);\n\t\t\t\tif (err_abort) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taa->flags &= SSH2_FILEXFER_ATTR_UIDGID;\n\t\t\tif (cmdnum == I_CHOWN) {\n\t\t\t\tif (!quiet)\n\t\t\t\t\tmprintf(\"Changing owner on %s\\n\",\n\t\t\t\t\t    g.gl_pathv[i]);\n\t\t\t\taa->uid = n_arg;\n\t\t\t} else {\n\t\t\t\tif (!quiet)\n\t\t\t\t\tmprintf(\"Changing group on %s\\n\",\n\t\t\t\t\t    g.gl_pathv[i]);\n\t\t\t\taa->gid = n_arg;\n\t\t\t}\n\t\t\terr = do_setstat(conn, g.gl_pathv[i], aa);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_PWD:\n\t\tmprintf(\"Remote working directory: %s\\n\", *pwd);\n\t\tbreak;\n\tcase I_LPWD:\n\t\tif (!getcwd(path_buf, sizeof(path_buf))) {\n\t\t\terror(\"Couldn't get local cwd: %s\", strerror(errno));\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\t\tmprintf(\"Local working directory: %s\\n\", path_buf);\n\t\tbreak;\n\tcase I_QUIT:\n\t\t/* Processed below */\n\t\tbreak;\n\tcase I_HELP:\n\t\thelp();\n\t\tbreak;\n\tcase I_VERSION:\n\t\tprintf(\"SFTP protocol version %u\\n\", sftp_proto_version(conn));\n\t\tbreak;\n\tcase I_PROGRESS:\n\t\tshowprogress = !showprogress;\n\t\tif (showprogress)\n\t\t\tprintf(\"Progress meter enabled\\n\");\n\t\telse\n\t\t\tprintf(\"Progress meter disabled\\n\");\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%d is not implemented\", cmdnum);\n\t}\n\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(path1);\n\tfree(path2);\n\n\t/* If an unignored error occurs in batch mode we should abort. */\n\tif (err_abort && err != 0)\n\t\treturn (-1);\n\telse if (cmdnum == I_QUIT)\n\t\treturn (1);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int quiet = 0;",
      "int showprogress = 1;",
      "volatile sig_atomic_t interrupted = 0;",
      "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path2"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "globfree",
          "args": [
            "&g"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "globfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "959-981",
          "snippet": "void\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nvoid\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%d is not implemented\"",
            "cmdnum"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Progress meter disabled\\n\""
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"SFTP protocol version %u\\n\"",
            "sftp_proto_version(conn)"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sftp_proto_version",
          "args": [
            "conn"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_proto_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "494-498",
          "snippet": "u_int\nsftp_proto_version(struct sftp_conn *conn)\n{\n\treturn conn->version;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\nsftp_proto_version(struct sftp_conn *conn)\n{\n\treturn conn->version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "help",
          "args": [],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "help",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "275-311",
          "snippet": "static void\nhelp(void)\n{\n\tprintf(\"Available commands:\\n\"\n\t    \"bye                                Quit sftp\\n\"\n\t    \"cd path                            Change remote directory to 'path'\\n\"\n\t    \"chgrp grp path                     Change group of file 'path' to 'grp'\\n\"\n\t    \"chmod mode path                    Change permissions of file 'path' to 'mode'\\n\"\n\t    \"chown own path                     Change owner of file 'path' to 'own'\\n\"\n\t    \"df [-hi] [path]                    Display statistics for current directory or\\n\"\n\t    \"                                   filesystem containing 'path'\\n\"\n\t    \"exit                               Quit sftp\\n\"\n\t    \"get [-afPpRr] remote [local]       Download file\\n\"\n\t    \"reget [-fPpRr] remote [local]      Resume download file\\n\"\n\t    \"reput [-fPpRr] [local] remote      Resume upload file\\n\"\n\t    \"help                               Display this help text\\n\"\n\t    \"lcd path                           Change local directory to 'path'\\n\"\n\t    \"lls [ls-options [path]]            Display local directory listing\\n\"\n\t    \"lmkdir path                        Create local directory\\n\"\n\t    \"ln [-s] oldpath newpath            Link remote file (-s for symlink)\\n\"\n\t    \"lpwd                               Print local working directory\\n\"\n\t    \"ls [-1afhlnrSt] [path]             Display remote directory listing\\n\"\n\t    \"lumask umask                       Set local umask to 'umask'\\n\"\n\t    \"mkdir path                         Create remote directory\\n\"\n\t    \"progress                           Toggle display of progress meter\\n\"\n\t    \"put [-afPpRr] local [remote]       Upload file\\n\"\n\t    \"pwd                                Display remote working directory\\n\"\n\t    \"quit                               Quit sftp\\n\"\n\t    \"rename oldpath newpath             Rename remote file\\n\"\n\t    \"rm path                            Delete remote file\\n\"\n\t    \"rmdir path                         Remove remote directory\\n\"\n\t    \"symlink oldpath newpath            Symlink remote file\\n\"\n\t    \"version                            Show SFTP version\\n\"\n\t    \"!command                           Execute 'command' in local shell\\n\"\n\t    \"!                                  Escape to local shell\\n\"\n\t    \"?                                  Synonym for help\\n\");\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhelp(void)\n{\n\tprintf(\"Available commands:\\n\"\n\t    \"bye                                Quit sftp\\n\"\n\t    \"cd path                            Change remote directory to 'path'\\n\"\n\t    \"chgrp grp path                     Change group of file 'path' to 'grp'\\n\"\n\t    \"chmod mode path                    Change permissions of file 'path' to 'mode'\\n\"\n\t    \"chown own path                     Change owner of file 'path' to 'own'\\n\"\n\t    \"df [-hi] [path]                    Display statistics for current directory or\\n\"\n\t    \"                                   filesystem containing 'path'\\n\"\n\t    \"exit                               Quit sftp\\n\"\n\t    \"get [-afPpRr] remote [local]       Download file\\n\"\n\t    \"reget [-fPpRr] remote [local]      Resume download file\\n\"\n\t    \"reput [-fPpRr] [local] remote      Resume upload file\\n\"\n\t    \"help                               Display this help text\\n\"\n\t    \"lcd path                           Change local directory to 'path'\\n\"\n\t    \"lls [ls-options [path]]            Display local directory listing\\n\"\n\t    \"lmkdir path                        Create local directory\\n\"\n\t    \"ln [-s] oldpath newpath            Link remote file (-s for symlink)\\n\"\n\t    \"lpwd                               Print local working directory\\n\"\n\t    \"ls [-1afhlnrSt] [path]             Display remote directory listing\\n\"\n\t    \"lumask umask                       Set local umask to 'umask'\\n\"\n\t    \"mkdir path                         Create remote directory\\n\"\n\t    \"progress                           Toggle display of progress meter\\n\"\n\t    \"put [-afPpRr] local [remote]       Upload file\\n\"\n\t    \"pwd                                Display remote working directory\\n\"\n\t    \"quit                               Quit sftp\\n\"\n\t    \"rename oldpath newpath             Rename remote file\\n\"\n\t    \"rm path                            Delete remote file\\n\"\n\t    \"rmdir path                         Remove remote directory\\n\"\n\t    \"symlink oldpath newpath            Symlink remote file\\n\"\n\t    \"version                            Show SFTP version\\n\"\n\t    \"!command                           Execute 'command' in local shell\\n\"\n\t    \"!                                  Escape to local shell\\n\"\n\t    \"?                                  Synonym for help\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't get local cwd: %s\"",
            "strerror(errno)"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getcwd",
          "args": [
            "path_buf",
            "sizeof(path_buf)"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "getcwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getcwd.c",
          "lines": "51-238",
          "snippet": "char *\ngetcwd(char *pt, size_t size)\n{\n\tstruct dirent *dp;\n\tDIR *dir = NULL;\n\tdev_t dev;\n\tino_t ino;\n\tint first;\n\tchar *bpt, *bup;\n\tstruct stat s;\n\tdev_t root_dev;\n\tino_t root_ino;\n\tsize_t ptsize, upsize;\n\tint save_errno;\n\tchar *ept, *eup, *up;\n\n\t/*\n\t * If no buffer specified by the user, allocate one as necessary.\n\t * If a buffer is specified, the size has to be non-zero.  The path\n\t * is built from the end of the buffer backwards.\n\t */\n\tif (pt) {\n\t\tptsize = 0;\n\t\tif (!size) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\tept = pt + size;\n\t} else {\n\t\tif ((pt = malloc(ptsize = MAXPATHLEN)) == NULL)\n\t\t\treturn (NULL);\n\t\tept = pt + ptsize;\n\t}\n\tbpt = ept - 1;\n\t*bpt = '\\0';\n\n\t/*\n\t * Allocate bytes for the string of \"../\"'s.\n\t * Should always be enough (it's 340 levels).  If it's not, allocate\n\t * as necessary.  Special * case the first stat, it's \".\", not \"..\".\n\t */\n\tif ((up = malloc(upsize = MAXPATHLEN)) == NULL)\n\t\tgoto err;\n\teup = up + upsize;\n\tbup = up;\n\tup[0] = '.';\n\tup[1] = '\\0';\n\n\t/* Save root values, so know when to stop. */\n\tif (stat(\"/\", &s))\n\t\tgoto err;\n\troot_dev = s.st_dev;\n\troot_ino = s.st_ino;\n\n\terrno = 0;\t\t\t/* XXX readdir has no error return. */\n\n\tfor (first = 1;; first = 0) {\n\t\t/* Stat the current level. */\n\t\tif (lstat(up, &s))\n\t\t\tgoto err;\n\n\t\t/* Save current node values. */\n\t\tino = s.st_ino;\n\t\tdev = s.st_dev;\n\n\t\t/* Check for reaching root. */\n\t\tif (root_dev == dev && root_ino == ino) {\n\t\t\t*--bpt = '/';\n\t\t\t/*\n\t\t\t * It's unclear that it's a requirement to copy the\n\t\t\t * path to the beginning of the buffer, but it's always\n\t\t\t * been that way and stuff would probably break.\n\t\t\t */\n\t\t\tmemmove(pt, bpt, ept - bpt);\n\t\t\tfree(up);\n\t\t\treturn (pt);\n\t\t}\n\n\t\t/*\n\t\t * Build pointer to the parent directory, allocating memory\n\t\t * as necessary.  Max length is 3 for \"../\", the largest\n\t\t * possible component name, plus a trailing NUL.\n\t\t */\n\t\tif (bup + 3  + MAXNAMLEN + 1 >= eup) {\n\t\t\tchar *nup;\n\n\t\t\tif ((nup = realloc(up, upsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbup = nup + (bup - up);\n\t\t\tup = nup;\n\t\t\teup = up + upsize;\n\t\t}\n\t\t*bup++ = '.';\n\t\t*bup++ = '.';\n\t\t*bup = '\\0';\n\n\t\t/* Open and stat parent directory. */\n\t\tif (!(dir = opendir(up)) || fstat(dirfd(dir), &s))\n\t\t\tgoto err;\n\n\t\t/* Add trailing slash for next directory. */\n\t\t*bup++ = '/';\n\n\t\t/*\n\t\t * If it's a mount point, have to stat each element because\n\t\t * the inode number in the directory is for the entry in the\n\t\t * parent directory, not the inode number of the mounted file.\n\t\t */\n\t\tsave_errno = 0;\n\t\tif (s.st_dev == dev) {\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (dp->d_fileno == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (ISDOT(dp))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(bup, dp->d_name, dp->d_namlen + 1);\n\n\t\t\t\t/* Save the first error for later. */\n\t\t\t\tif (lstat(up, &s)) {\n\t\t\t\t\tif (!save_errno)\n\t\t\t\t\t\tsave_errno = errno;\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s.st_dev == dev && s.st_ino == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t/*\n\t\t * Check for length of the current name, preceding slash,\n\t\t * leading slash.\n\t\t */\n\t\tif (bpt - pt < dp->d_namlen + (first ? 1 : 2)) {\n\t\t\tsize_t len;\n\t\t\tchar *npt;\n\n\t\t\tif (!ptsize) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tlen = ept - bpt;\n\t\t\tif ((npt = realloc(pt, ptsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbpt = npt + (bpt - pt);\n\t\t\tpt = npt;\n\t\t\tept = pt + ptsize;\n\t\t\tmemmove(ept - len, bpt, len);\n\t\t\tbpt = ept - len;\n\t\t}\n\t\tif (!first)\n\t\t\t*--bpt = '/';\n\t\tbpt -= dp->d_namlen;\n\t\tmemcpy(bpt, dp->d_name, dp->d_namlen);\n\t\t(void)closedir(dir);\n\n\t\t/* Truncate any file name. */\n\t\t*bup = '\\0';\n\t}\n\nnotfound:\n\t/*\n\t * If readdir set errno, use it, not any saved error; otherwise,\n\t * didn't find the current directory in its parent directory, set\n\t * errno to ENOENT.\n\t */\n\tif (!errno)\n\t\terrno = save_errno ? save_errno : ENOENT;\n\t/* FALLTHROUGH */\nerr:\n\tsave_errno = errno;\n\n\tif (ptsize)\n\t\tfree(pt);\n\tfree(up);\n\tif (dir)\n\t\t(void)closedir(dir);\n\n\terrno = save_errno;\n\n\treturn (NULL);\n}",
          "includes": [
            "#include \"includes.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/dir.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"includes.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/dir.h>\n#include <dirent.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nchar *\ngetcwd(char *pt, size_t size)\n{\n\tstruct dirent *dp;\n\tDIR *dir = NULL;\n\tdev_t dev;\n\tino_t ino;\n\tint first;\n\tchar *bpt, *bup;\n\tstruct stat s;\n\tdev_t root_dev;\n\tino_t root_ino;\n\tsize_t ptsize, upsize;\n\tint save_errno;\n\tchar *ept, *eup, *up;\n\n\t/*\n\t * If no buffer specified by the user, allocate one as necessary.\n\t * If a buffer is specified, the size has to be non-zero.  The path\n\t * is built from the end of the buffer backwards.\n\t */\n\tif (pt) {\n\t\tptsize = 0;\n\t\tif (!size) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\tept = pt + size;\n\t} else {\n\t\tif ((pt = malloc(ptsize = MAXPATHLEN)) == NULL)\n\t\t\treturn (NULL);\n\t\tept = pt + ptsize;\n\t}\n\tbpt = ept - 1;\n\t*bpt = '\\0';\n\n\t/*\n\t * Allocate bytes for the string of \"../\"'s.\n\t * Should always be enough (it's 340 levels).  If it's not, allocate\n\t * as necessary.  Special * case the first stat, it's \".\", not \"..\".\n\t */\n\tif ((up = malloc(upsize = MAXPATHLEN)) == NULL)\n\t\tgoto err;\n\teup = up + upsize;\n\tbup = up;\n\tup[0] = '.';\n\tup[1] = '\\0';\n\n\t/* Save root values, so know when to stop. */\n\tif (stat(\"/\", &s))\n\t\tgoto err;\n\troot_dev = s.st_dev;\n\troot_ino = s.st_ino;\n\n\terrno = 0;\t\t\t/* XXX readdir has no error return. */\n\n\tfor (first = 1;; first = 0) {\n\t\t/* Stat the current level. */\n\t\tif (lstat(up, &s))\n\t\t\tgoto err;\n\n\t\t/* Save current node values. */\n\t\tino = s.st_ino;\n\t\tdev = s.st_dev;\n\n\t\t/* Check for reaching root. */\n\t\tif (root_dev == dev && root_ino == ino) {\n\t\t\t*--bpt = '/';\n\t\t\t/*\n\t\t\t * It's unclear that it's a requirement to copy the\n\t\t\t * path to the beginning of the buffer, but it's always\n\t\t\t * been that way and stuff would probably break.\n\t\t\t */\n\t\t\tmemmove(pt, bpt, ept - bpt);\n\t\t\tfree(up);\n\t\t\treturn (pt);\n\t\t}\n\n\t\t/*\n\t\t * Build pointer to the parent directory, allocating memory\n\t\t * as necessary.  Max length is 3 for \"../\", the largest\n\t\t * possible component name, plus a trailing NUL.\n\t\t */\n\t\tif (bup + 3  + MAXNAMLEN + 1 >= eup) {\n\t\t\tchar *nup;\n\n\t\t\tif ((nup = realloc(up, upsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbup = nup + (bup - up);\n\t\t\tup = nup;\n\t\t\teup = up + upsize;\n\t\t}\n\t\t*bup++ = '.';\n\t\t*bup++ = '.';\n\t\t*bup = '\\0';\n\n\t\t/* Open and stat parent directory. */\n\t\tif (!(dir = opendir(up)) || fstat(dirfd(dir), &s))\n\t\t\tgoto err;\n\n\t\t/* Add trailing slash for next directory. */\n\t\t*bup++ = '/';\n\n\t\t/*\n\t\t * If it's a mount point, have to stat each element because\n\t\t * the inode number in the directory is for the entry in the\n\t\t * parent directory, not the inode number of the mounted file.\n\t\t */\n\t\tsave_errno = 0;\n\t\tif (s.st_dev == dev) {\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (dp->d_fileno == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (ISDOT(dp))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(bup, dp->d_name, dp->d_namlen + 1);\n\n\t\t\t\t/* Save the first error for later. */\n\t\t\t\tif (lstat(up, &s)) {\n\t\t\t\t\tif (!save_errno)\n\t\t\t\t\t\tsave_errno = errno;\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s.st_dev == dev && s.st_ino == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t/*\n\t\t * Check for length of the current name, preceding slash,\n\t\t * leading slash.\n\t\t */\n\t\tif (bpt - pt < dp->d_namlen + (first ? 1 : 2)) {\n\t\t\tsize_t len;\n\t\t\tchar *npt;\n\n\t\t\tif (!ptsize) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tlen = ept - bpt;\n\t\t\tif ((npt = realloc(pt, ptsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbpt = npt + (bpt - pt);\n\t\t\tpt = npt;\n\t\t\tept = pt + ptsize;\n\t\t\tmemmove(ept - len, bpt, len);\n\t\t\tbpt = ept - len;\n\t\t}\n\t\tif (!first)\n\t\t\t*--bpt = '/';\n\t\tbpt -= dp->d_namlen;\n\t\tmemcpy(bpt, dp->d_name, dp->d_namlen);\n\t\t(void)closedir(dir);\n\n\t\t/* Truncate any file name. */\n\t\t*bup = '\\0';\n\t}\n\nnotfound:\n\t/*\n\t * If readdir set errno, use it, not any saved error; otherwise,\n\t * didn't find the current directory in its parent directory, set\n\t * errno to ENOENT.\n\t */\n\tif (!errno)\n\t\terrno = save_errno ? save_errno : ENOENT;\n\t/* FALLTHROUGH */\nerr:\n\tsave_errno = errno;\n\n\tif (ptsize)\n\t\tfree(pt);\n\tfree(up);\n\tif (dir)\n\t\t(void)closedir(dir);\n\n\terrno = save_errno;\n\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_setstat",
          "args": [
            "conn",
            "g.gl_pathv[i]",
            "aa"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "do_setstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "791-806",
          "snippet": "int\ndo_setstat(struct sftp_conn *conn, const char *path, Attrib *a)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_SETSTAT, path,\n\t    strlen(path), a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't setstat on \\\"%s\\\": %s\", path,\n\t\t    fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_setstat(struct sftp_conn *conn, const char *path, Attrib *a)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_SETSTAT, path,\n\t    strlen(path), a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't setstat on \\\"%s\\\": %s\", path,\n\t\t    fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_stat",
          "args": [
            "conn",
            "g.gl_pathv[i]",
            "0"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "do_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "742-754",
          "snippet": "Attrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nAttrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}"
        }
      },
      {
        "call_info": {
          "callee": "remote_glob",
          "args": [
            "conn",
            "path1",
            "GLOB_NOCHECK",
            "NULL",
            "&g"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "remote_glob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-glob.c",
          "lines": "136-150",
          "snippet": "int\nremote_glob(struct sftp_conn *conn, const char *pattern, int flags,\n    int (*errfunc)(const char *, int), glob_t *pglob)\n{\n\tpglob->gl_opendir = fudge_opendir;\n\tpglob->gl_readdir = (struct dirent *(*)(void *))fudge_readdir;\n\tpglob->gl_closedir = (void (*)(void *))fudge_closedir;\n\tpglob->gl_lstat = fudge_lstat;\n\tpglob->gl_stat = fudge_stat;\n\n\tmemset(&cur, 0, sizeof(cur));\n\tcur.conn = conn;\n\n\treturn(glob(pattern, flags | GLOB_ALTDIRFUNC, errfunc, pglob));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <dirent.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);",
            "static struct {\n\tstruct sftp_conn *conn;\n} cur;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <dirent.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\nstatic struct {\n\tstruct sftp_conn *conn;\n} cur;\n\nint\nremote_glob(struct sftp_conn *conn, const char *pattern, int flags,\n    int (*errfunc)(const char *, int), glob_t *pglob)\n{\n\tpglob->gl_opendir = fudge_opendir;\n\tpglob->gl_readdir = (struct dirent *(*)(void *))fudge_readdir;\n\tpglob->gl_closedir = (void (*)(void *))fudge_closedir;\n\tpglob->gl_lstat = fudge_lstat;\n\tpglob->gl_stat = fudge_stat;\n\n\tmemset(&cur, 0, sizeof(cur));\n\tcur.conn = conn;\n\n\treturn(glob(pattern, flags | GLOB_ALTDIRFUNC, errfunc, pglob));\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_absolute",
          "args": [
            "path1",
            "*pwd"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "make_absolute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "386-398",
          "snippet": "static char *\nmake_absolute(char *p, const char *pwd)\n{\n\tchar *abs_str;\n\n\t/* Derelativise */\n\tif (p && p[0] != '/') {\n\t\tabs_str = path_append(pwd, p);\n\t\tfree(p);\n\t\treturn(abs_str);\n\t} else\n\t\treturn(p);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nmake_absolute(char *p, const char *pwd)\n{\n\tchar *abs_str;\n\n\t/* Derelativise */\n\tif (p && p[0] != '/') {\n\t\tabs_str = path_append(pwd, p);\n\t\tfree(p);\n\t\treturn(abs_str);\n\t} else\n\t\treturn(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "attrib_clear",
          "args": [
            "&a"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "attrib_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "53-63",
          "snippet": "void\nattrib_clear(Attrib *a)\n{\n\ta->flags = 0;\n\ta->size = 0;\n\ta->uid = 0;\n\ta->gid = 0;\n\ta->perm = 0;\n\ta->atime = 0;\n\ta->mtime = 0;\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nattrib_clear(Attrib *a)\n{\n\ta->flags = 0;\n\ta->size = 0;\n\ta->uid = 0;\n\ta->gid = 0;\n\ta->perm = 0;\n\ta->atime = 0;\n\ta->mtime = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "n_arg"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_do_shell",
          "args": [
            "cmd"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "local_do_shell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "313-349",
          "snippet": "static void\nlocal_do_shell(const char *args)\n{\n\tint status;\n\tchar *shell;\n\tpid_t pid;\n\n\tif (!*args)\n\t\targs = NULL;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"Couldn't fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\t/* XXX: child has pipe fds to ssh subproc open - issue? */\n\t\tif (args) {\n\t\t\tdebug3(\"Executing %s -c \\\"%s\\\"\", shell, args);\n\t\t\texecl(shell, shell, \"-c\", args, (char *)NULL);\n\t\t} else {\n\t\t\tdebug3(\"Executing %s\", shell);\n\t\t\texecl(shell, shell, (char *)NULL);\n\t\t}\n\t\tfprintf(stderr, \"Couldn't execute \\\"%s\\\": %s\\n\", shell,\n\t\t    strerror(errno));\n\t\t_exit(1);\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\tif (!WIFEXITED(status))\n\t\terror(\"Shell exited abnormally\");\n\telse if (WEXITSTATUS(status))\n\t\terror(\"Shell exited with status %d\", WEXITSTATUS(status));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nlocal_do_shell(const char *args)\n{\n\tint status;\n\tchar *shell;\n\tpid_t pid;\n\n\tif (!*args)\n\t\targs = NULL;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"Couldn't fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\t/* XXX: child has pipe fds to ssh subproc open - issue? */\n\t\tif (args) {\n\t\t\tdebug3(\"Executing %s -c \\\"%s\\\"\", shell, args);\n\t\t\texecl(shell, shell, \"-c\", args, (char *)NULL);\n\t\t} else {\n\t\t\tdebug3(\"Executing %s\", shell);\n\t\t\texecl(shell, shell, (char *)NULL);\n\t\t}\n\t\tfprintf(stderr, \"Couldn't execute \\\"%s\\\": %s\\n\", shell,\n\t\t    strerror(errno));\n\t\t_exit(1);\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\tif (!WIFEXITED(status))\n\t\terror(\"Shell exited abnormally\");\n\telse if (WEXITSTATUS(status))\n\t\terror(\"Shell exited with status %d\", WEXITSTATUS(status));\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_do_ls",
          "args": [
            "cmd"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "local_do_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "351-365",
          "snippet": "static void\nlocal_do_ls(const char *args)\n{\n\tif (!args || !*args)\n\t\tlocal_do_shell(_PATH_LS);\n\telse {\n\t\tint len = strlen(_PATH_LS \" \") + strlen(args) + 1;\n\t\tchar *buf = xmalloc(len);\n\n\t\t/* XXX: quoting - rip quoting code from ftp? */\n\t\tsnprintf(buf, len, _PATH_LS \" %s\", args);\n\t\tlocal_do_shell(buf);\n\t\tfree(buf);\n\t}\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nlocal_do_ls(const char *args)\n{\n\tif (!args || !*args)\n\t\tlocal_do_shell(_PATH_LS);\n\telse {\n\t\tint len = strlen(_PATH_LS \" \") + strlen(args) + 1;\n\t\tchar *buf = xmalloc(len);\n\n\t\t/* XXX: quoting - rip quoting code from ftp? */\n\t\tsnprintf(buf, len, _PATH_LS \" %s\", args);\n\t\tlocal_do_shell(buf);\n\t\tfree(buf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "path1",
            "0777"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "path1"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tilde_expand_filename",
          "args": [
            "path1",
            "getuid()"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "tilde_expand_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "926-965",
          "snippet": "char *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"~\""
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_df",
          "args": [
            "conn",
            "path1",
            "hflag",
            "iflag"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "do_df",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "1035-1091",
          "snippet": "static int\ndo_df(struct sftp_conn *conn, const char *path, int hflag, int iflag)\n{\n\tstruct sftp_statvfs st;\n\tchar s_used[FMT_SCALED_STRSIZE], s_avail[FMT_SCALED_STRSIZE];\n\tchar s_root[FMT_SCALED_STRSIZE], s_total[FMT_SCALED_STRSIZE];\n\tchar s_icapacity[16], s_dcapacity[16];\n\n\tif (do_statvfs(conn, path, &st, 1) == -1)\n\t\treturn -1;\n\tif (st.f_files == 0)\n\t\tstrlcpy(s_icapacity, \"ERR\", sizeof(s_icapacity));\n\telse {\n\t\tsnprintf(s_icapacity, sizeof(s_icapacity), \"%3llu%%\",\n\t\t    (unsigned long long)(100 * (st.f_files - st.f_ffree) /\n\t\t    st.f_files));\n\t}\n\tif (st.f_blocks == 0)\n\t\tstrlcpy(s_dcapacity, \"ERR\", sizeof(s_dcapacity));\n\telse {\n\t\tsnprintf(s_dcapacity, sizeof(s_dcapacity), \"%3llu%%\",\n\t\t    (unsigned long long)(100 * (st.f_blocks - st.f_bfree) /\n\t\t    st.f_blocks));\n\t}\n\tif (iflag) {\n\t\tprintf(\"     Inodes        Used       Avail      \"\n\t\t    \"(root)    %%Capacity\\n\");\n\t\tprintf(\"%11llu %11llu %11llu %11llu         %s\\n\",\n\t\t    (unsigned long long)st.f_files,\n\t\t    (unsigned long long)(st.f_files - st.f_ffree),\n\t\t    (unsigned long long)st.f_favail,\n\t\t    (unsigned long long)st.f_ffree, s_icapacity);\n\t} else if (hflag) {\n\t\tstrlcpy(s_used, \"error\", sizeof(s_used));\n\t\tstrlcpy(s_avail, \"error\", sizeof(s_avail));\n\t\tstrlcpy(s_root, \"error\", sizeof(s_root));\n\t\tstrlcpy(s_total, \"error\", sizeof(s_total));\n\t\tfmt_scaled((st.f_blocks - st.f_bfree) * st.f_frsize, s_used);\n\t\tfmt_scaled(st.f_bavail * st.f_frsize, s_avail);\n\t\tfmt_scaled(st.f_bfree * st.f_frsize, s_root);\n\t\tfmt_scaled(st.f_blocks * st.f_frsize, s_total);\n\t\tprintf(\"    Size     Used    Avail   (root)    %%Capacity\\n\");\n\t\tprintf(\"%7sB %7sB %7sB %7sB         %s\\n\",\n\t\t    s_total, s_used, s_avail, s_root, s_dcapacity);\n\t} else {\n\t\tprintf(\"        Size         Used        Avail       \"\n\t\t    \"(root)    %%Capacity\\n\");\n\t\tprintf(\"%12llu %12llu %12llu %12llu         %s\\n\",\n\t\t    (unsigned long long)(st.f_frsize * st.f_blocks / 1024),\n\t\t    (unsigned long long)(st.f_frsize *\n\t\t    (st.f_blocks - st.f_bfree) / 1024),\n\t\t    (unsigned long long)(st.f_frsize * st.f_bavail / 1024),\n\t\t    (unsigned long long)(st.f_frsize * st.f_bfree / 1024),\n\t\t    s_dcapacity);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndo_df(struct sftp_conn *conn, const char *path, int hflag, int iflag)\n{\n\tstruct sftp_statvfs st;\n\tchar s_used[FMT_SCALED_STRSIZE], s_avail[FMT_SCALED_STRSIZE];\n\tchar s_root[FMT_SCALED_STRSIZE], s_total[FMT_SCALED_STRSIZE];\n\tchar s_icapacity[16], s_dcapacity[16];\n\n\tif (do_statvfs(conn, path, &st, 1) == -1)\n\t\treturn -1;\n\tif (st.f_files == 0)\n\t\tstrlcpy(s_icapacity, \"ERR\", sizeof(s_icapacity));\n\telse {\n\t\tsnprintf(s_icapacity, sizeof(s_icapacity), \"%3llu%%\",\n\t\t    (unsigned long long)(100 * (st.f_files - st.f_ffree) /\n\t\t    st.f_files));\n\t}\n\tif (st.f_blocks == 0)\n\t\tstrlcpy(s_dcapacity, \"ERR\", sizeof(s_dcapacity));\n\telse {\n\t\tsnprintf(s_dcapacity, sizeof(s_dcapacity), \"%3llu%%\",\n\t\t    (unsigned long long)(100 * (st.f_blocks - st.f_bfree) /\n\t\t    st.f_blocks));\n\t}\n\tif (iflag) {\n\t\tprintf(\"     Inodes        Used       Avail      \"\n\t\t    \"(root)    %%Capacity\\n\");\n\t\tprintf(\"%11llu %11llu %11llu %11llu         %s\\n\",\n\t\t    (unsigned long long)st.f_files,\n\t\t    (unsigned long long)(st.f_files - st.f_ffree),\n\t\t    (unsigned long long)st.f_favail,\n\t\t    (unsigned long long)st.f_ffree, s_icapacity);\n\t} else if (hflag) {\n\t\tstrlcpy(s_used, \"error\", sizeof(s_used));\n\t\tstrlcpy(s_avail, \"error\", sizeof(s_avail));\n\t\tstrlcpy(s_root, \"error\", sizeof(s_root));\n\t\tstrlcpy(s_total, \"error\", sizeof(s_total));\n\t\tfmt_scaled((st.f_blocks - st.f_bfree) * st.f_frsize, s_used);\n\t\tfmt_scaled(st.f_bavail * st.f_frsize, s_avail);\n\t\tfmt_scaled(st.f_bfree * st.f_frsize, s_root);\n\t\tfmt_scaled(st.f_blocks * st.f_frsize, s_total);\n\t\tprintf(\"    Size     Used    Avail   (root)    %%Capacity\\n\");\n\t\tprintf(\"%7sB %7sB %7sB %7sB         %s\\n\",\n\t\t    s_total, s_used, s_avail, s_root, s_dcapacity);\n\t} else {\n\t\tprintf(\"        Size         Used        Avail       \"\n\t\t    \"(root)    %%Capacity\\n\");\n\t\tprintf(\"%12llu %12llu %12llu %12llu         %s\\n\",\n\t\t    (unsigned long long)(st.f_frsize * st.f_blocks / 1024),\n\t\t    (unsigned long long)(st.f_frsize *\n\t\t    (st.f_blocks - st.f_bfree) / 1024),\n\t\t    (unsigned long long)(st.f_frsize * st.f_bavail / 1024),\n\t\t    (unsigned long long)(st.f_frsize * st.f_bfree / 1024),\n\t\t    s_dcapacity);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_globbed_ls",
          "args": [
            "conn",
            "path1",
            "tmp",
            "lflag"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "do_globbed_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "929-1033",
          "snippet": "static int\ndo_globbed_ls(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tchar *fname, *lname;\n\tglob_t g;\n\tint err, r;\n\tstruct winsize ws;\n\tu_int i, j, nentries, *indices = NULL, c = 1;\n\tu_int colspace = 0, columns = 1, m = 0, width = 80;\n\n\tmemset(&g, 0, sizeof(g));\n\n\tif ((r = remote_glob(conn, path,\n\t    GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE|GLOB_KEEPSTAT|GLOB_NOSORT,\n\t    NULL, &g)) != 0 ||\n\t    (g.gl_pathc && !g.gl_matchc)) {\n\t\tif (g.gl_pathc)\n\t\t\tglobfree(&g);\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Can't ls: Too many matches for \\\"%s\\\"\", path);\n\t\t} else {\n\t\t\terror(\"Can't ls: \\\"%s\\\" not found\", path);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (interrupted)\n\t\tgoto out;\n\n\t/*\n\t * If the glob returns a single match and it is a directory,\n\t * then just list its contents.\n\t */\n\tif (g.gl_matchc == 1 && g.gl_statv[0] != NULL &&\n\t    S_ISDIR(g.gl_statv[0]->st_mode)) {\n\t\terr = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);\n\t\tglobfree(&g);\n\t\treturn err;\n\t}\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (i = 0; g.gl_pathv[i]; i++)\n\t\t\tm = MAXIMUM(m, strlen(g.gl_pathv[i]));\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t}\n\n\t/*\n\t * Sorting: rather than mess with the contents of glob_t, prepare\n\t * an array of indices into it and sort that. For the usual\n\t * unsorted case, the indices are just the identity 1=1, 2=2, etc.\n\t */\n\tfor (nentries = 0; g.gl_pathv[nentries] != NULL; nentries++)\n\t\t;\t/* count entries */\n\tindices = calloc(nentries, sizeof(*indices));\n\tfor (i = 0; i < nentries; i++)\n\t\tindices[i] = i;\n\n\tif (lflag & SORT_FLAGS) {\n\t\tsort_glob = &g;\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(indices, nentries, sizeof(*indices), sglob_comp);\n\t\tsort_glob = NULL;\n\t}\n\n\tfor (j = 0; j < nentries && !interrupted; j++) {\n\t\ti = indices[j];\n\t\tfname = path_strip(g.gl_pathv[i], strip_path);\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (g.gl_statv[i] == NULL) {\n\t\t\t\terror(\"no stat information for %s\", fname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlname = ls_file(fname, g.gl_statv[i], 1,\n\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\tfree(lname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n out:\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(indices);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)",
            "#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */",
            "#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */",
            "#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */",
            "#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */"
          ],
          "globals_used": [
            "volatile sig_atomic_t interrupted = 0;",
            "int sort_flag;",
            "glob_t *sort_glob;",
            "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)\n#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */\n#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */\n#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */\n#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */\n\nvolatile sig_atomic_t interrupted = 0;\nint sort_flag;\nglob_t *sort_glob;\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\n\nstatic int\ndo_globbed_ls(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tchar *fname, *lname;\n\tglob_t g;\n\tint err, r;\n\tstruct winsize ws;\n\tu_int i, j, nentries, *indices = NULL, c = 1;\n\tu_int colspace = 0, columns = 1, m = 0, width = 80;\n\n\tmemset(&g, 0, sizeof(g));\n\n\tif ((r = remote_glob(conn, path,\n\t    GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE|GLOB_KEEPSTAT|GLOB_NOSORT,\n\t    NULL, &g)) != 0 ||\n\t    (g.gl_pathc && !g.gl_matchc)) {\n\t\tif (g.gl_pathc)\n\t\t\tglobfree(&g);\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Can't ls: Too many matches for \\\"%s\\\"\", path);\n\t\t} else {\n\t\t\terror(\"Can't ls: \\\"%s\\\" not found\", path);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (interrupted)\n\t\tgoto out;\n\n\t/*\n\t * If the glob returns a single match and it is a directory,\n\t * then just list its contents.\n\t */\n\tif (g.gl_matchc == 1 && g.gl_statv[0] != NULL &&\n\t    S_ISDIR(g.gl_statv[0]->st_mode)) {\n\t\terr = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);\n\t\tglobfree(&g);\n\t\treturn err;\n\t}\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (i = 0; g.gl_pathv[i]; i++)\n\t\t\tm = MAXIMUM(m, strlen(g.gl_pathv[i]));\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t}\n\n\t/*\n\t * Sorting: rather than mess with the contents of glob_t, prepare\n\t * an array of indices into it and sort that. For the usual\n\t * unsorted case, the indices are just the identity 1=1, 2=2, etc.\n\t */\n\tfor (nentries = 0; g.gl_pathv[nentries] != NULL; nentries++)\n\t\t;\t/* count entries */\n\tindices = calloc(nentries, sizeof(*indices));\n\tfor (i = 0; i < nentries; i++)\n\t\tindices[i] = i;\n\n\tif (lflag & SORT_FLAGS) {\n\t\tsort_glob = &g;\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(indices, nentries, sizeof(*indices), sglob_comp);\n\t\tsort_glob = NULL;\n\t}\n\n\tfor (j = 0; j < nentries && !interrupted; j++) {\n\t\ti = indices[j];\n\t\tfname = path_strip(g.gl_pathv[i], strip_path);\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (g.gl_statv[i] == NULL) {\n\t\t\t\terror(\"no stat information for %s\", fname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlname = ls_file(fname, g.gl_statv[i], 1,\n\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\tfree(lname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n out:\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(indices);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_ls_dir",
          "args": [
            "conn",
            "*pwd",
            "*pwd",
            "lflag"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "do_ls_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "815-898",
          "snippet": "static int\ndo_ls_dir(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tint n;\n\tu_int c = 1, colspace = 0, columns = 1;\n\tSFTP_DIRENT **d;\n\n\tif ((n = do_readdir(conn, path, &d)) != 0)\n\t\treturn (n);\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\tu_int m = 0, width = 80;\n\t\tstruct winsize ws;\n\t\tchar *tmp;\n\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (n = 0; d[n] != NULL; n++) {\n\t\t\tif (d[n]->filename[0] != '.' || (lflag & LS_SHOW_ALL))\n\t\t\t\tm = MAXIMUM(m, strlen(d[n]->filename));\n\t\t}\n\n\t\t/* Add any subpath that also needs to be counted */\n\t\ttmp = path_strip(path, strip_path);\n\t\tm += strlen(tmp);\n\t\tfree(tmp);\n\n\t\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\t\twidth = ws.ws_col;\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t\tcolspace = MINIMUM(colspace, width);\n\t}\n\n\tif (lflag & SORT_FLAGS) {\n\t\tfor (n = 0; d[n] != NULL; n++)\n\t\t\t;\t/* count entries */\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(d, n, sizeof(*d), sdirent_comp);\n\t}\n\n\tfor (n = 0; d[n] != NULL && !interrupted; n++) {\n\t\tchar *tmp, *fname;\n\n\t\tif (d[n]->filename[0] == '.' && !(lflag & LS_SHOW_ALL))\n\t\t\tcontinue;\n\n\t\ttmp = path_append(path, d[n]->filename);\n\t\tfname = path_strip(tmp, strip_path);\n\t\tfree(tmp);\n\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (lflag & (LS_NUMERIC_VIEW|LS_SI_UNITS)) {\n\t\t\t\tchar *lname;\n\t\t\t\tstruct stat sb;\n\n\t\t\t\tmemset(&sb, 0, sizeof(sb));\n\t\t\t\tattrib_to_stat(&d[n]->a, &sb);\n\t\t\t\tlname = ls_file(fname, &sb, 1,\n\t\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\t\tfree(lname);\n\t\t\t} else\n\t\t\t\tmprintf(\"%s\\n\", d[n]->longname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n\tfree_sftp_dirents(d);\n\treturn (0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)",
            "#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */",
            "#define LS_SHOW_ALL\t0x0080\t/* Don't skip filenames starting with '.' */",
            "#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */",
            "#define LS_NUMERIC_VIEW\t0x0004\t/* Long view with numeric uid/gid */",
            "#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */",
            "#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */"
          ],
          "globals_used": [
            "volatile sig_atomic_t interrupted = 0;",
            "int sort_flag;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)\n#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */\n#define LS_SHOW_ALL\t0x0080\t/* Don't skip filenames starting with '.' */\n#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */\n#define LS_NUMERIC_VIEW\t0x0004\t/* Long view with numeric uid/gid */\n#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */\n#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */\n\nvolatile sig_atomic_t interrupted = 0;\nint sort_flag;\n\nstatic int\ndo_ls_dir(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tint n;\n\tu_int c = 1, colspace = 0, columns = 1;\n\tSFTP_DIRENT **d;\n\n\tif ((n = do_readdir(conn, path, &d)) != 0)\n\t\treturn (n);\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\tu_int m = 0, width = 80;\n\t\tstruct winsize ws;\n\t\tchar *tmp;\n\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (n = 0; d[n] != NULL; n++) {\n\t\t\tif (d[n]->filename[0] != '.' || (lflag & LS_SHOW_ALL))\n\t\t\t\tm = MAXIMUM(m, strlen(d[n]->filename));\n\t\t}\n\n\t\t/* Add any subpath that also needs to be counted */\n\t\ttmp = path_strip(path, strip_path);\n\t\tm += strlen(tmp);\n\t\tfree(tmp);\n\n\t\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\t\twidth = ws.ws_col;\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t\tcolspace = MINIMUM(colspace, width);\n\t}\n\n\tif (lflag & SORT_FLAGS) {\n\t\tfor (n = 0; d[n] != NULL; n++)\n\t\t\t;\t/* count entries */\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(d, n, sizeof(*d), sdirent_comp);\n\t}\n\n\tfor (n = 0; d[n] != NULL && !interrupted; n++) {\n\t\tchar *tmp, *fname;\n\n\t\tif (d[n]->filename[0] == '.' && !(lflag & LS_SHOW_ALL))\n\t\t\tcontinue;\n\n\t\ttmp = path_append(path, d[n]->filename);\n\t\tfname = path_strip(tmp, strip_path);\n\t\tfree(tmp);\n\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (lflag & (LS_NUMERIC_VIEW|LS_SI_UNITS)) {\n\t\t\t\tchar *lname;\n\t\t\t\tstruct stat sb;\n\n\t\t\t\tmemset(&sb, 0, sizeof(sb));\n\t\t\t\tattrib_to_stat(&d[n]->a, &sb);\n\t\t\t\tlname = ls_file(fname, &sb, 1,\n\t\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\t\tfree(lname);\n\t\t\t} else\n\t\t\t\tmprintf(\"%s\\n\", d[n]->longname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n\tfree_sftp_dirents(d);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "aa->perm"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_realpath",
          "args": [
            "conn",
            "path1"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "do_realpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "825-880",
          "snippet": "char *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_rmdir",
          "args": [
            "conn",
            "path1"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "do_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "726-740",
          "snippet": "int\ndo_rmdir(struct sftp_conn *conn, const char *path)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_RMDIR, path,\n\t    strlen(path));\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't remove directory: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_rmdir(struct sftp_conn *conn, const char *path)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_RMDIR, path,\n\t    strlen(path));\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't remove directory: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_mkdir",
          "args": [
            "conn",
            "path1",
            "&a",
            "1"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "do_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "710-724",
          "snippet": "int\ndo_mkdir(struct sftp_conn *conn, const char *path, Attrib *a, int print_flag)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_MKDIR, path,\n\t    strlen(path), a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK && print_flag)\n\t\terror(\"Couldn't create directory: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_mkdir(struct sftp_conn *conn, const char *path, Attrib *a, int print_flag)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_MKDIR, path,\n\t    strlen(path), a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK && print_flag)\n\t\terror(\"Couldn't create directory: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "conn",
            "path1",
            "path2"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_rename",
          "args": [
            "conn",
            "path1",
            "path2",
            "lflag"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "do_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "882-921",
          "snippet": "int\ndo_rename(struct sftp_conn *conn, const char *oldpath, const char *newpath,\n    int force_legacy)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r, use_ext = (conn->exts & SFTP_EXT_POSIX_RENAME) && !force_legacy;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\t/* Send rename request */\n\tid = conn->msg_id++;\n\tif (use_ext) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg,\n\t\t    \"posix-rename@openssh.com\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_RENAME)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif ((r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, newpath)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message %s \\\"%s\\\" -> \\\"%s\\\"\",\n\t    use_ext ? \"posix-rename@openssh.com\" :\n\t    \"SSH2_FXP_RENAME\", oldpath, newpath);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't rename file \\\"%s\\\" to \\\"%s\\\": %s\", oldpath,\n\t\t    newpath, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SFTP_EXT_POSIX_RENAME\t0x00000001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SFTP_EXT_POSIX_RENAME\t0x00000001\n\nint\ndo_rename(struct sftp_conn *conn, const char *oldpath, const char *newpath,\n    int force_legacy)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r, use_ext = (conn->exts & SFTP_EXT_POSIX_RENAME) && !force_legacy;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\t/* Send rename request */\n\tid = conn->msg_id++;\n\tif (use_ext) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg,\n\t\t    \"posix-rename@openssh.com\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_RENAME)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif ((r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, newpath)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message %s \\\"%s\\\" -> \\\"%s\\\"\",\n\t    use_ext ? \"posix-rename@openssh.com\" :\n\t    \"SSH2_FXP_RENAME\", oldpath, newpath);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't rename file \\\"%s\\\" to \\\"%s\\\": %s\", oldpath,\n\t\t    newpath, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_put",
          "args": [
            "conn",
            "path1",
            "path2",
            "*pwd",
            "pflag",
            "rflag",
            "aflag",
            "fflag"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "process_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "704-794",
          "snippet": "static int\nprocess_put(struct sftp_conn *conn, const char *src, const char *dst,\n    const char *pwd, int pflag, int rflag, int resume, int fflag)\n{\n\tchar *tmp_dst = NULL;\n\tchar *abs_dst = NULL;\n\tchar *tmp = NULL, *filename = NULL;\n\tglob_t g;\n\tint err = 0;\n\tint i, dst_is_dir = 1;\n\tstruct stat sb;\n\n\tif (dst) {\n\t\ttmp_dst = xstrdup(dst);\n\t\ttmp_dst = make_absolute(tmp_dst, pwd);\n\t}\n\n\tmemset(&g, 0, sizeof(g));\n\tdebug3(\"Looking up %s\", src);\n\tif (glob(src, GLOB_NOCHECK | GLOB_MARK, NULL, &g)) {\n\t\terror(\"File \\\"%s\\\" not found.\", src);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\t/* If we aren't fetching to pwd then stash this status for later */\n\tif (tmp_dst != NULL)\n\t\tdst_is_dir = remote_is_dir(conn, tmp_dst);\n\n\t/* If multiple matches, dst may be directory or unspecified */\n\tif (g.gl_matchc > 1 && tmp_dst && !dst_is_dir) {\n\t\terror(\"Multiple paths match, but destination \"\n\t\t    \"\\\"%s\\\" is not a directory\", tmp_dst);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\tif (stat(g.gl_pathv[i], &sb) == -1) {\n\t\t\terr = -1;\n\t\t\terror(\"stat %s: %s\", g.gl_pathv[i], strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp = xstrdup(g.gl_pathv[i]);\n\t\tif ((filename = basename(tmp)) == NULL) {\n\t\t\terror(\"basename %s: %s\", tmp, strerror(errno));\n\t\t\tfree(tmp);\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (g.gl_matchc == 1 && tmp_dst) {\n\t\t\t/* If directory specified, append filename */\n\t\t\tif (dst_is_dir)\n\t\t\t\tabs_dst = path_append(tmp_dst, filename);\n\t\t\telse\n\t\t\t\tabs_dst = xstrdup(tmp_dst);\n\t\t} else if (tmp_dst) {\n\t\t\tabs_dst = path_append(tmp_dst, filename);\n\t\t} else {\n\t\t\tabs_dst = make_absolute(xstrdup(filename), pwd);\n\t\t}\n\t\tfree(tmp);\n\n                resume |= global_aflag;\n\t\tif (!quiet && resume)\n\t\t\tmprintf(\"Resuming upload of %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\telse if (!quiet && !resume)\n\t\t\tmprintf(\"Uploading %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\tif (pathname_is_dir(g.gl_pathv[i]) && (rflag || global_rflag)) {\n\t\t\tif (upload_dir(conn, g.gl_pathv[i], abs_dst,\n\t\t\t    pflag || global_pflag, 1, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t} else {\n\t\t\tif (do_upload(conn, g.gl_pathv[i], abs_dst,\n\t\t\t    pflag || global_pflag, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t}\n\t}\n\nout:\n\tfree(abs_dst);\n\tfree(tmp_dst);\n\tglobfree(&g);\n\treturn(err);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int quiet = 0;",
            "int global_rflag = 0;",
            "int global_aflag = 0;",
            "int global_pflag = 0;",
            "int global_fflag = 0;",
            "volatile sig_atomic_t interrupted = 0;",
            "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint quiet = 0;\nint global_rflag = 0;\nint global_aflag = 0;\nint global_pflag = 0;\nint global_fflag = 0;\nvolatile sig_atomic_t interrupted = 0;\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\n\nstatic int\nprocess_put(struct sftp_conn *conn, const char *src, const char *dst,\n    const char *pwd, int pflag, int rflag, int resume, int fflag)\n{\n\tchar *tmp_dst = NULL;\n\tchar *abs_dst = NULL;\n\tchar *tmp = NULL, *filename = NULL;\n\tglob_t g;\n\tint err = 0;\n\tint i, dst_is_dir = 1;\n\tstruct stat sb;\n\n\tif (dst) {\n\t\ttmp_dst = xstrdup(dst);\n\t\ttmp_dst = make_absolute(tmp_dst, pwd);\n\t}\n\n\tmemset(&g, 0, sizeof(g));\n\tdebug3(\"Looking up %s\", src);\n\tif (glob(src, GLOB_NOCHECK | GLOB_MARK, NULL, &g)) {\n\t\terror(\"File \\\"%s\\\" not found.\", src);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\t/* If we aren't fetching to pwd then stash this status for later */\n\tif (tmp_dst != NULL)\n\t\tdst_is_dir = remote_is_dir(conn, tmp_dst);\n\n\t/* If multiple matches, dst may be directory or unspecified */\n\tif (g.gl_matchc > 1 && tmp_dst && !dst_is_dir) {\n\t\terror(\"Multiple paths match, but destination \"\n\t\t    \"\\\"%s\\\" is not a directory\", tmp_dst);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\tif (stat(g.gl_pathv[i], &sb) == -1) {\n\t\t\terr = -1;\n\t\t\terror(\"stat %s: %s\", g.gl_pathv[i], strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp = xstrdup(g.gl_pathv[i]);\n\t\tif ((filename = basename(tmp)) == NULL) {\n\t\t\terror(\"basename %s: %s\", tmp, strerror(errno));\n\t\t\tfree(tmp);\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (g.gl_matchc == 1 && tmp_dst) {\n\t\t\t/* If directory specified, append filename */\n\t\t\tif (dst_is_dir)\n\t\t\t\tabs_dst = path_append(tmp_dst, filename);\n\t\t\telse\n\t\t\t\tabs_dst = xstrdup(tmp_dst);\n\t\t} else if (tmp_dst) {\n\t\t\tabs_dst = path_append(tmp_dst, filename);\n\t\t} else {\n\t\t\tabs_dst = make_absolute(xstrdup(filename), pwd);\n\t\t}\n\t\tfree(tmp);\n\n                resume |= global_aflag;\n\t\tif (!quiet && resume)\n\t\t\tmprintf(\"Resuming upload of %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\telse if (!quiet && !resume)\n\t\t\tmprintf(\"Uploading %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\tif (pathname_is_dir(g.gl_pathv[i]) && (rflag || global_rflag)) {\n\t\t\tif (upload_dir(conn, g.gl_pathv[i], abs_dst,\n\t\t\t    pflag || global_pflag, 1, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t} else {\n\t\t\tif (do_upload(conn, g.gl_pathv[i], abs_dst,\n\t\t\t    pflag || global_pflag, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t}\n\t}\n\nout:\n\tfree(abs_dst);\n\tfree(tmp_dst);\n\tglobfree(&g);\n\treturn(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_get",
          "args": [
            "conn",
            "path1",
            "path2",
            "*pwd",
            "pflag",
            "rflag",
            "aflag",
            "fflag"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "process_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "618-702",
          "snippet": "static int\nprocess_get(struct sftp_conn *conn, const char *src, const char *dst,\n    const char *pwd, int pflag, int rflag, int resume, int fflag)\n{\n\tchar *abs_src = NULL;\n\tchar *abs_dst = NULL;\n\tglob_t g;\n\tchar *filename, *tmp=NULL;\n\tint i, r, err = 0;\n\n\tabs_src = xstrdup(src);\n\tabs_src = make_absolute(abs_src, pwd);\n\tmemset(&g, 0, sizeof(g));\n\n\tdebug3(\"Looking up %s\", abs_src);\n\tif ((r = remote_glob(conn, abs_src, GLOB_MARK, NULL, &g)) != 0) {\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Too many matches for \\\"%s\\\".\", abs_src);\n\t\t} else {\n\t\t\terror(\"File \\\"%s\\\" not found.\", abs_src);\n\t\t}\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If multiple matches then dst must be a directory or\n\t * unspecified.\n\t */\n\tif (g.gl_matchc > 1 && dst != NULL && !is_dir(dst)) {\n\t\terror(\"Multiple source paths, but destination \"\n\t\t    \"\\\"%s\\\" is not a directory\", dst);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\ttmp = xstrdup(g.gl_pathv[i]);\n\t\tif ((filename = basename(tmp)) == NULL) {\n\t\t\terror(\"basename %s: %s\", tmp, strerror(errno));\n\t\t\tfree(tmp);\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (g.gl_matchc == 1 && dst) {\n\t\t\tif (is_dir(dst)) {\n\t\t\t\tabs_dst = path_append(dst, filename);\n\t\t\t} else {\n\t\t\t\tabs_dst = xstrdup(dst);\n\t\t\t}\n\t\t} else if (dst) {\n\t\t\tabs_dst = path_append(dst, filename);\n\t\t} else {\n\t\t\tabs_dst = xstrdup(filename);\n\t\t}\n\t\tfree(tmp);\n\n\t\tresume |= global_aflag;\n\t\tif (!quiet && resume)\n\t\t\tmprintf(\"Resuming %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\telse if (!quiet && !resume)\n\t\t\tmprintf(\"Fetching %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\tif (pathname_is_dir(g.gl_pathv[i]) && (rflag || global_rflag)) {\n\t\t\tif (download_dir(conn, g.gl_pathv[i], abs_dst, NULL,\n\t\t\t    pflag || global_pflag, 1, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t} else {\n\t\t\tif (do_download(conn, g.gl_pathv[i], abs_dst, NULL,\n\t\t\t    pflag || global_pflag, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t}\n\t\tfree(abs_dst);\n\t\tabs_dst = NULL;\n\t}\n\nout:\n\tfree(abs_src);\n\tglobfree(&g);\n\treturn(err);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int quiet = 0;",
            "int global_rflag = 0;",
            "int global_aflag = 0;",
            "int global_pflag = 0;",
            "int global_fflag = 0;",
            "volatile sig_atomic_t interrupted = 0;",
            "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint quiet = 0;\nint global_rflag = 0;\nint global_aflag = 0;\nint global_pflag = 0;\nint global_fflag = 0;\nvolatile sig_atomic_t interrupted = 0;\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\n\nstatic int\nprocess_get(struct sftp_conn *conn, const char *src, const char *dst,\n    const char *pwd, int pflag, int rflag, int resume, int fflag)\n{\n\tchar *abs_src = NULL;\n\tchar *abs_dst = NULL;\n\tglob_t g;\n\tchar *filename, *tmp=NULL;\n\tint i, r, err = 0;\n\n\tabs_src = xstrdup(src);\n\tabs_src = make_absolute(abs_src, pwd);\n\tmemset(&g, 0, sizeof(g));\n\n\tdebug3(\"Looking up %s\", abs_src);\n\tif ((r = remote_glob(conn, abs_src, GLOB_MARK, NULL, &g)) != 0) {\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Too many matches for \\\"%s\\\".\", abs_src);\n\t\t} else {\n\t\t\terror(\"File \\\"%s\\\" not found.\", abs_src);\n\t\t}\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If multiple matches then dst must be a directory or\n\t * unspecified.\n\t */\n\tif (g.gl_matchc > 1 && dst != NULL && !is_dir(dst)) {\n\t\terror(\"Multiple source paths, but destination \"\n\t\t    \"\\\"%s\\\" is not a directory\", dst);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\ttmp = xstrdup(g.gl_pathv[i]);\n\t\tif ((filename = basename(tmp)) == NULL) {\n\t\t\terror(\"basename %s: %s\", tmp, strerror(errno));\n\t\t\tfree(tmp);\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (g.gl_matchc == 1 && dst) {\n\t\t\tif (is_dir(dst)) {\n\t\t\t\tabs_dst = path_append(dst, filename);\n\t\t\t} else {\n\t\t\t\tabs_dst = xstrdup(dst);\n\t\t\t}\n\t\t} else if (dst) {\n\t\t\tabs_dst = path_append(dst, filename);\n\t\t} else {\n\t\t\tabs_dst = xstrdup(filename);\n\t\t}\n\t\tfree(tmp);\n\n\t\tresume |= global_aflag;\n\t\tif (!quiet && resume)\n\t\t\tmprintf(\"Resuming %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\telse if (!quiet && !resume)\n\t\t\tmprintf(\"Fetching %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\tif (pathname_is_dir(g.gl_pathv[i]) && (rflag || global_rflag)) {\n\t\t\tif (download_dir(conn, g.gl_pathv[i], abs_dst, NULL,\n\t\t\t    pflag || global_pflag, 1, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t} else {\n\t\t\tif (do_download(conn, g.gl_pathv[i], abs_dst, NULL,\n\t\t\t    pflag || global_pflag, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t}\n\t\tfree(abs_dst);\n\t\tabs_dst = NULL;\n\t}\n\nout:\n\tfree(abs_src);\n\tglobfree(&g);\n\treturn(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&g",
            "0",
            "sizeof(g)"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_args",
          "args": [
            "&cmd",
            "&ignore_errors",
            "&disable_echo",
            "&aflag",
            "&fflag",
            "&hflag",
            "&iflag",
            "&lflag",
            "&pflag",
            "&rflag",
            "&sflag",
            "&n_arg",
            "&path1",
            "&path2"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "parse_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "1298-1500",
          "snippet": "static int\nparse_args(const char **cpp, int *ignore_errors, int *disable_echo, int *aflag,\n\t  int *fflag, int *hflag, int *iflag, int *lflag, int *pflag,\n\t  int *rflag, int *sflag,\n    unsigned long *n_arg, char **path1, char **path2)\n{\n\tconst char *cmd, *cp = *cpp;\n\tchar *cp2, **argv;\n\tint base = 0;\n\tlong l;\n\tint path1_mandatory = 0, i, cmdnum, optidx, argc;\n\n\t/* Skip leading whitespace */\n\tcp = cp + strspn(cp, WHITESPACE);\n\n\t/*\n\t * Check for leading '-' (disable error processing) and '@' (suppress\n\t * command echo)\n\t */\n\t*ignore_errors = 0;\n\t*disable_echo = 0;\n\tfor (;*cp != '\\0'; cp++) {\n\t\tif (*cp == '-') {\n\t\t\t*ignore_errors = 1;\n\t\t} else if (*cp == '@') {\n\t\t\t*disable_echo = 1;\n\t\t} else {\n\t\t\t/* all other characters terminate prefix processing */\n\t\t\tbreak;\n\t\t}\n\t}\n\tcp = cp + strspn(cp, WHITESPACE);\n\n\t/* Ignore blank lines and lines which begin with comment '#' char */\n\tif (*cp == '\\0' || *cp == '#')\n\t\treturn (0);\n\n\tif ((argv = makeargv(cp, &argc, 0, NULL, NULL)) == NULL)\n\t\treturn -1;\n\n\t/* Figure out which command we have */\n\tfor (i = 0; cmds[i].c != NULL; i++) {\n\t\tif (argv[0] != NULL && strcasecmp(cmds[i].c, argv[0]) == 0)\n\t\t\tbreak;\n\t}\n\tcmdnum = cmds[i].n;\n\tcmd = cmds[i].c;\n\n\t/* Special case */\n\tif (*cp == '!') {\n\t\tcp++;\n\t\tcmdnum = I_SHELL;\n\t} else if (cmdnum == -1) {\n\t\terror(\"Invalid command.\");\n\t\treturn -1;\n\t}\n\n\t/* Get arguments and parse flags */\n\t*aflag = *fflag = *hflag = *iflag = *lflag = *pflag = 0;\n\t*rflag = *sflag = 0;\n\t*path1 = *path2 = NULL;\n\toptidx = 1;\n\tswitch (cmdnum) {\n\tcase I_GET:\n\tcase I_REGET:\n\tcase I_REPUT:\n\tcase I_PUT:\n\t\tif ((optidx = parse_getput_flags(cmd, argv, argc,\n\t\t    aflag, fflag, pflag, rflag)) == -1)\n\t\t\treturn -1;\n\t\t/* Get first pathname (mandatory) */\n\t\tif (argc - optidx < 1) {\n\t\t\terror(\"You must specify at least one path after a \"\n\t\t\t    \"%s command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t/* Get second pathname (optional) */\n\t\tif (argc - optidx > 1) {\n\t\t\t*path2 = xstrdup(argv[optidx + 1]);\n\t\t\t/* Destination is not globbed */\n\t\t\tundo_glob_escape(*path2);\n\t\t}\n\t\tbreak;\n\tcase I_LINK:\n\t\tif ((optidx = parse_link_flags(cmd, argv, argc, sflag)) == -1)\n\t\t\treturn -1;\n\t\tgoto parse_two_paths;\n\tcase I_RENAME:\n\t\tif ((optidx = parse_rename_flags(cmd, argv, argc, lflag)) == -1)\n\t\t\treturn -1;\n\t\tgoto parse_two_paths;\n\tcase I_SYMLINK:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n parse_two_paths:\n\t\tif (argc - optidx < 2) {\n\t\t\terror(\"You must specify two paths after a %s \"\n\t\t\t    \"command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t*path2 = xstrdup(argv[optidx + 1]);\n\t\t/* Paths are not globbed */\n\t\tundo_glob_escape(*path1);\n\t\tundo_glob_escape(*path2);\n\t\tbreak;\n\tcase I_RM:\n\tcase I_MKDIR:\n\tcase I_RMDIR:\n\tcase I_LMKDIR:\n\t\tpath1_mandatory = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_CHDIR:\n\tcase I_LCHDIR:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\t/* Get pathname (mandatory) */\n\t\tif (argc - optidx < 1) {\n\t\t\tif (!path1_mandatory)\n\t\t\t\tbreak; /* return a NULL path1 */\n\t\t\terror(\"You must specify a path after a %s command.\",\n\t\t\t    cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t/* Only \"rm\" globs */\n\t\tif (cmdnum != I_RM)\n\t\t\tundo_glob_escape(*path1);\n\t\tbreak;\n\tcase I_DF:\n\t\tif ((optidx = parse_df_flags(cmd, argv, argc, hflag,\n\t\t    iflag)) == -1)\n\t\t\treturn -1;\n\t\t/* Default to current directory if no path specified */\n\t\tif (argc - optidx < 1)\n\t\t\t*path1 = NULL;\n\t\telse {\n\t\t\t*path1 = xstrdup(argv[optidx]);\n\t\t\tundo_glob_escape(*path1);\n\t\t}\n\t\tbreak;\n\tcase I_LS:\n\t\tif ((optidx = parse_ls_flags(argv, argc, lflag)) == -1)\n\t\t\treturn(-1);\n\t\t/* Path is optional */\n\t\tif (argc - optidx > 0)\n\t\t\t*path1 = xstrdup(argv[optidx]);\n\t\tbreak;\n\tcase I_LLS:\n\t\t/* Skip ls command and following whitespace */\n\t\tcp = cp + strlen(cmd) + strspn(cp, WHITESPACE);\n\tcase I_SHELL:\n\t\t/* Uses the rest of the line */\n\t\tbreak;\n\tcase I_LUMASK:\n\tcase I_CHMOD:\n\t\tbase = 8;\n\t\t/* FALLTHROUGH */\n\tcase I_CHOWN:\n\tcase I_CHGRP:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\t/* Get numeric arg (mandatory) */\n\t\tif (argc - optidx < 1)\n\t\t\tgoto need_num_arg;\n\t\terrno = 0;\n\t\tl = strtol(argv[optidx], &cp2, base);\n\t\tif (cp2 == argv[optidx] || *cp2 != '\\0' ||\n\t\t    ((l == LONG_MIN || l == LONG_MAX) && errno == ERANGE) ||\n\t\t    l < 0) {\n need_num_arg:\n\t\t\terror(\"You must supply a numeric argument \"\n\t\t\t    \"to the %s command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*n_arg = l;\n\t\tif (cmdnum == I_LUMASK)\n\t\t\tbreak;\n\t\t/* Get pathname (mandatory) */\n\t\tif (argc - optidx < 2) {\n\t\t\terror(\"You must specify a path after a %s command.\",\n\t\t\t    cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx + 1]);\n\t\tbreak;\n\tcase I_QUIT:\n\tcase I_PWD:\n\tcase I_LPWD:\n\tcase I_HELP:\n\tcase I_VERSION:\n\tcase I_PROGRESS:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"Command not implemented\");\n\t}\n\n\t*cpp = cp;\n\treturn(cmdnum);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define WHITESPACE \" \\t\\r\\n\""
          ],
          "globals_used": [
            "static const struct CMD cmds[] = {\n\t{ \"bye\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"cd\",\t\tI_CHDIR,\tREMOTE\t},\n\t{ \"chdir\",\tI_CHDIR,\tREMOTE\t},\n\t{ \"chgrp\",\tI_CHGRP,\tREMOTE\t},\n\t{ \"chmod\",\tI_CHMOD,\tREMOTE\t},\n\t{ \"chown\",\tI_CHOWN,\tREMOTE\t},\n\t{ \"df\",\t\tI_DF,\t\tREMOTE\t},\n\t{ \"dir\",\tI_LS,\t\tREMOTE\t},\n\t{ \"exit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"get\",\tI_GET,\t\tREMOTE\t},\n\t{ \"help\",\tI_HELP,\t\tNOARGS\t},\n\t{ \"lcd\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lchdir\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lls\",\tI_LLS,\t\tLOCAL\t},\n\t{ \"lmkdir\",\tI_LMKDIR,\tLOCAL\t},\n\t{ \"ln\",\t\tI_LINK,\t\tREMOTE\t},\n\t{ \"lpwd\",\tI_LPWD,\t\tLOCAL\t},\n\t{ \"ls\",\t\tI_LS,\t\tREMOTE\t},\n\t{ \"lumask\",\tI_LUMASK,\tNOARGS\t},\n\t{ \"mkdir\",\tI_MKDIR,\tREMOTE\t},\n\t{ \"mget\",\tI_GET,\t\tREMOTE\t},\n\t{ \"mput\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"progress\",\tI_PROGRESS,\tNOARGS\t},\n\t{ \"put\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"pwd\",\tI_PWD,\t\tREMOTE\t},\n\t{ \"quit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"reget\",\tI_REGET,\tREMOTE\t},\n\t{ \"rename\",\tI_RENAME,\tREMOTE\t},\n\t{ \"reput\",\tI_REPUT,\tLOCAL\t},\n\t{ \"rm\",\t\tI_RM,\t\tREMOTE\t},\n\t{ \"rmdir\",\tI_RMDIR,\tREMOTE\t},\n\t{ \"symlink\",\tI_SYMLINK,\tREMOTE\t},\n\t{ \"version\",\tI_VERSION,\tNOARGS\t},\n\t{ \"!\",\t\tI_SHELL,\tNOARGS\t},\n\t{ \"?\",\t\tI_HELP,\t\tNOARGS\t},\n\t{ NULL,\t\t-1,\t\t-1\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WHITESPACE \" \\t\\r\\n\"\n\nstatic const struct CMD cmds[] = {\n\t{ \"bye\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"cd\",\t\tI_CHDIR,\tREMOTE\t},\n\t{ \"chdir\",\tI_CHDIR,\tREMOTE\t},\n\t{ \"chgrp\",\tI_CHGRP,\tREMOTE\t},\n\t{ \"chmod\",\tI_CHMOD,\tREMOTE\t},\n\t{ \"chown\",\tI_CHOWN,\tREMOTE\t},\n\t{ \"df\",\t\tI_DF,\t\tREMOTE\t},\n\t{ \"dir\",\tI_LS,\t\tREMOTE\t},\n\t{ \"exit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"get\",\tI_GET,\t\tREMOTE\t},\n\t{ \"help\",\tI_HELP,\t\tNOARGS\t},\n\t{ \"lcd\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lchdir\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lls\",\tI_LLS,\t\tLOCAL\t},\n\t{ \"lmkdir\",\tI_LMKDIR,\tLOCAL\t},\n\t{ \"ln\",\t\tI_LINK,\t\tREMOTE\t},\n\t{ \"lpwd\",\tI_LPWD,\t\tLOCAL\t},\n\t{ \"ls\",\t\tI_LS,\t\tREMOTE\t},\n\t{ \"lumask\",\tI_LUMASK,\tNOARGS\t},\n\t{ \"mkdir\",\tI_MKDIR,\tREMOTE\t},\n\t{ \"mget\",\tI_GET,\t\tREMOTE\t},\n\t{ \"mput\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"progress\",\tI_PROGRESS,\tNOARGS\t},\n\t{ \"put\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"pwd\",\tI_PWD,\t\tREMOTE\t},\n\t{ \"quit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"reget\",\tI_REGET,\tREMOTE\t},\n\t{ \"rename\",\tI_RENAME,\tREMOTE\t},\n\t{ \"reput\",\tI_REPUT,\tLOCAL\t},\n\t{ \"rm\",\t\tI_RM,\t\tREMOTE\t},\n\t{ \"rmdir\",\tI_RMDIR,\tREMOTE\t},\n\t{ \"symlink\",\tI_SYMLINK,\tREMOTE\t},\n\t{ \"version\",\tI_VERSION,\tNOARGS\t},\n\t{ \"!\",\t\tI_SHELL,\tNOARGS\t},\n\t{ \"?\",\t\tI_HELP,\t\tNOARGS\t},\n\t{ NULL,\t\t-1,\t\t-1\t}\n};\n\nstatic int\nparse_args(const char **cpp, int *ignore_errors, int *disable_echo, int *aflag,\n\t  int *fflag, int *hflag, int *iflag, int *lflag, int *pflag,\n\t  int *rflag, int *sflag,\n    unsigned long *n_arg, char **path1, char **path2)\n{\n\tconst char *cmd, *cp = *cpp;\n\tchar *cp2, **argv;\n\tint base = 0;\n\tlong l;\n\tint path1_mandatory = 0, i, cmdnum, optidx, argc;\n\n\t/* Skip leading whitespace */\n\tcp = cp + strspn(cp, WHITESPACE);\n\n\t/*\n\t * Check for leading '-' (disable error processing) and '@' (suppress\n\t * command echo)\n\t */\n\t*ignore_errors = 0;\n\t*disable_echo = 0;\n\tfor (;*cp != '\\0'; cp++) {\n\t\tif (*cp == '-') {\n\t\t\t*ignore_errors = 1;\n\t\t} else if (*cp == '@') {\n\t\t\t*disable_echo = 1;\n\t\t} else {\n\t\t\t/* all other characters terminate prefix processing */\n\t\t\tbreak;\n\t\t}\n\t}\n\tcp = cp + strspn(cp, WHITESPACE);\n\n\t/* Ignore blank lines and lines which begin with comment '#' char */\n\tif (*cp == '\\0' || *cp == '#')\n\t\treturn (0);\n\n\tif ((argv = makeargv(cp, &argc, 0, NULL, NULL)) == NULL)\n\t\treturn -1;\n\n\t/* Figure out which command we have */\n\tfor (i = 0; cmds[i].c != NULL; i++) {\n\t\tif (argv[0] != NULL && strcasecmp(cmds[i].c, argv[0]) == 0)\n\t\t\tbreak;\n\t}\n\tcmdnum = cmds[i].n;\n\tcmd = cmds[i].c;\n\n\t/* Special case */\n\tif (*cp == '!') {\n\t\tcp++;\n\t\tcmdnum = I_SHELL;\n\t} else if (cmdnum == -1) {\n\t\terror(\"Invalid command.\");\n\t\treturn -1;\n\t}\n\n\t/* Get arguments and parse flags */\n\t*aflag = *fflag = *hflag = *iflag = *lflag = *pflag = 0;\n\t*rflag = *sflag = 0;\n\t*path1 = *path2 = NULL;\n\toptidx = 1;\n\tswitch (cmdnum) {\n\tcase I_GET:\n\tcase I_REGET:\n\tcase I_REPUT:\n\tcase I_PUT:\n\t\tif ((optidx = parse_getput_flags(cmd, argv, argc,\n\t\t    aflag, fflag, pflag, rflag)) == -1)\n\t\t\treturn -1;\n\t\t/* Get first pathname (mandatory) */\n\t\tif (argc - optidx < 1) {\n\t\t\terror(\"You must specify at least one path after a \"\n\t\t\t    \"%s command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t/* Get second pathname (optional) */\n\t\tif (argc - optidx > 1) {\n\t\t\t*path2 = xstrdup(argv[optidx + 1]);\n\t\t\t/* Destination is not globbed */\n\t\t\tundo_glob_escape(*path2);\n\t\t}\n\t\tbreak;\n\tcase I_LINK:\n\t\tif ((optidx = parse_link_flags(cmd, argv, argc, sflag)) == -1)\n\t\t\treturn -1;\n\t\tgoto parse_two_paths;\n\tcase I_RENAME:\n\t\tif ((optidx = parse_rename_flags(cmd, argv, argc, lflag)) == -1)\n\t\t\treturn -1;\n\t\tgoto parse_two_paths;\n\tcase I_SYMLINK:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n parse_two_paths:\n\t\tif (argc - optidx < 2) {\n\t\t\terror(\"You must specify two paths after a %s \"\n\t\t\t    \"command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t*path2 = xstrdup(argv[optidx + 1]);\n\t\t/* Paths are not globbed */\n\t\tundo_glob_escape(*path1);\n\t\tundo_glob_escape(*path2);\n\t\tbreak;\n\tcase I_RM:\n\tcase I_MKDIR:\n\tcase I_RMDIR:\n\tcase I_LMKDIR:\n\t\tpath1_mandatory = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_CHDIR:\n\tcase I_LCHDIR:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\t/* Get pathname (mandatory) */\n\t\tif (argc - optidx < 1) {\n\t\t\tif (!path1_mandatory)\n\t\t\t\tbreak; /* return a NULL path1 */\n\t\t\terror(\"You must specify a path after a %s command.\",\n\t\t\t    cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t/* Only \"rm\" globs */\n\t\tif (cmdnum != I_RM)\n\t\t\tundo_glob_escape(*path1);\n\t\tbreak;\n\tcase I_DF:\n\t\tif ((optidx = parse_df_flags(cmd, argv, argc, hflag,\n\t\t    iflag)) == -1)\n\t\t\treturn -1;\n\t\t/* Default to current directory if no path specified */\n\t\tif (argc - optidx < 1)\n\t\t\t*path1 = NULL;\n\t\telse {\n\t\t\t*path1 = xstrdup(argv[optidx]);\n\t\t\tundo_glob_escape(*path1);\n\t\t}\n\t\tbreak;\n\tcase I_LS:\n\t\tif ((optidx = parse_ls_flags(argv, argc, lflag)) == -1)\n\t\t\treturn(-1);\n\t\t/* Path is optional */\n\t\tif (argc - optidx > 0)\n\t\t\t*path1 = xstrdup(argv[optidx]);\n\t\tbreak;\n\tcase I_LLS:\n\t\t/* Skip ls command and following whitespace */\n\t\tcp = cp + strlen(cmd) + strspn(cp, WHITESPACE);\n\tcase I_SHELL:\n\t\t/* Uses the rest of the line */\n\t\tbreak;\n\tcase I_LUMASK:\n\tcase I_CHMOD:\n\t\tbase = 8;\n\t\t/* FALLTHROUGH */\n\tcase I_CHOWN:\n\tcase I_CHGRP:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\t/* Get numeric arg (mandatory) */\n\t\tif (argc - optidx < 1)\n\t\t\tgoto need_num_arg;\n\t\terrno = 0;\n\t\tl = strtol(argv[optidx], &cp2, base);\n\t\tif (cp2 == argv[optidx] || *cp2 != '\\0' ||\n\t\t    ((l == LONG_MIN || l == LONG_MAX) && errno == ERANGE) ||\n\t\t    l < 0) {\n need_num_arg:\n\t\t\terror(\"You must supply a numeric argument \"\n\t\t\t    \"to the %s command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*n_arg = l;\n\t\tif (cmdnum == I_LUMASK)\n\t\t\tbreak;\n\t\t/* Get pathname (mandatory) */\n\t\tif (argc - optidx < 2) {\n\t\t\terror(\"You must specify a path after a %s command.\",\n\t\t\t    cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx + 1]);\n\t\tbreak;\n\tcase I_QUIT:\n\tcase I_PWD:\n\tcase I_LPWD:\n\tcase I_HELP:\n\tcase I_VERSION:\n\tcase I_PROGRESS:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"Command not implemented\");\n\t}\n\n\t*cpp = cp;\n\treturn(cmdnum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint quiet = 0;\nint showprogress = 1;\nvolatile sig_atomic_t interrupted = 0;\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\n\nstatic int\nparse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd,\n    const char *startdir, int err_abort, int echo_command)\n{\n\tconst char *ocmd = cmd;\n\tchar *path1, *path2, *tmp;\n\tint ignore_errors = 0, disable_echo = 1;\n\tint aflag = 0, fflag = 0, hflag = 0, iflag = 0;\n\tint lflag = 0, pflag = 0, rflag = 0, sflag = 0;\n\tint cmdnum, i;\n\tunsigned long n_arg = 0;\n\tAttrib a, *aa;\n\tchar path_buf[PATH_MAX];\n\tint err = 0;\n\tglob_t g;\n\n\tpath1 = path2 = NULL;\n\tcmdnum = parse_args(&cmd, &ignore_errors, &disable_echo, &aflag, &fflag,\n\t    &hflag, &iflag, &lflag, &pflag, &rflag, &sflag, &n_arg,\n\t    &path1, &path2);\n\tif (ignore_errors != 0)\n\t\terr_abort = 0;\n\n\tif (echo_command && !disable_echo)\n\t\tmprintf(\"sftp> %s\\n\", ocmd);\n\n\tmemset(&g, 0, sizeof(g));\n\n\t/* Perform command */\n\tswitch (cmdnum) {\n\tcase 0:\n\t\t/* Blank line */\n\t\tbreak;\n\tcase -1:\n\t\t/* Unrecognized command */\n\t\terr = -1;\n\t\tbreak;\n\tcase I_REGET:\n\t\taflag = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_GET:\n\t\terr = process_get(conn, path1, path2, *pwd, pflag,\n\t\t    rflag, aflag, fflag);\n\t\tbreak;\n\tcase I_REPUT:\n\t\taflag = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_PUT:\n\t\terr = process_put(conn, path1, path2, *pwd, pflag,\n\t\t    rflag, aflag, fflag);\n\t\tbreak;\n\tcase I_RENAME:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tpath2 = make_absolute(path2, *pwd);\n\t\terr = do_rename(conn, path1, path2, lflag);\n\t\tbreak;\n\tcase I_SYMLINK:\n\t\tsflag = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_LINK:\n\t\tif (!sflag)\n\t\t\tpath1 = make_absolute(path1, *pwd);\n\t\tpath2 = make_absolute(path2, *pwd);\n\t\terr = (sflag ? do_symlink : do_hardlink)(conn, path1, path2);\n\t\tbreak;\n\tcase I_RM:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tremote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Removing %s\\n\", g.gl_pathv[i]);\n\t\t\terr = do_rm(conn, g.gl_pathv[i]);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_MKDIR:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tattrib_clear(&a);\n\t\ta.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\t\ta.perm = 0777;\n\t\terr = do_mkdir(conn, path1, &a, 1);\n\t\tbreak;\n\tcase I_RMDIR:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\terr = do_rmdir(conn, path1);\n\t\tbreak;\n\tcase I_CHDIR:\n\t\tif (path1 == NULL || *path1 == '\\0')\n\t\t\tpath1 = xstrdup(startdir);\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tif ((tmp = do_realpath(conn, path1)) == NULL) {\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((aa = do_stat(conn, tmp, 0)) == NULL) {\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(aa->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)) {\n\t\t\terror(\"Can't change directory: Can't check target\");\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!S_ISDIR(aa->perm)) {\n\t\t\terror(\"Can't change directory: \\\"%s\\\" is not \"\n\t\t\t    \"a directory\", tmp);\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tfree(*pwd);\n\t\t*pwd = tmp;\n\t\tbreak;\n\tcase I_LS:\n\t\tif (!path1) {\n\t\t\tdo_ls_dir(conn, *pwd, *pwd, lflag);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Strip pwd off beginning of non-absolute paths */\n\t\ttmp = NULL;\n\t\tif (*path1 != '/')\n\t\t\ttmp = *pwd;\n\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\terr = do_globbed_ls(conn, path1, tmp, lflag);\n\t\tbreak;\n\tcase I_DF:\n\t\t/* Default to current directory if no path specified */\n\t\tif (path1 == NULL)\n\t\t\tpath1 = xstrdup(*pwd);\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\terr = do_df(conn, path1, hflag, iflag);\n\t\tbreak;\n\tcase I_LCHDIR:\n\t\tif (path1 == NULL || *path1 == '\\0')\n\t\t\tpath1 = xstrdup(\"~\");\n\t\ttmp = tilde_expand_filename(path1, getuid());\n\t\tfree(path1);\n\t\tpath1 = tmp;\n\t\tif (chdir(path1) == -1) {\n\t\t\terror(\"Couldn't change local directory to \"\n\t\t\t    \"\\\"%s\\\": %s\", path1, strerror(errno));\n\t\t\terr = 1;\n\t\t}\n\t\tbreak;\n\tcase I_LMKDIR:\n\t\tif (mkdir(path1, 0777) == -1) {\n\t\t\terror(\"Couldn't create local directory \"\n\t\t\t    \"\\\"%s\\\": %s\", path1, strerror(errno));\n\t\t\terr = 1;\n\t\t}\n\t\tbreak;\n\tcase I_LLS:\n\t\tlocal_do_ls(cmd);\n\t\tbreak;\n\tcase I_SHELL:\n\t\tlocal_do_shell(cmd);\n\t\tbreak;\n\tcase I_LUMASK:\n\t\tumask(n_arg);\n\t\tprintf(\"Local umask: %03lo\\n\", n_arg);\n\t\tbreak;\n\tcase I_CHMOD:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tattrib_clear(&a);\n\t\ta.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\t\ta.perm = n_arg;\n\t\tremote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Changing mode on %s\\n\",\n\t\t\t\t    g.gl_pathv[i]);\n\t\t\terr = do_setstat(conn, g.gl_pathv[i], &a);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_CHOWN:\n\tcase I_CHGRP:\n\t\tpath1 = make_absolute(path1, *pwd);\n\t\tremote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif (!(aa = do_stat(conn, g.gl_pathv[i], 0))) {\n\t\t\t\tif (err_abort) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {\n\t\t\t\terror(\"Can't get current ownership of \"\n\t\t\t\t    \"remote file \\\"%s\\\"\", g.gl_pathv[i]);\n\t\t\t\tif (err_abort) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taa->flags &= SSH2_FILEXFER_ATTR_UIDGID;\n\t\t\tif (cmdnum == I_CHOWN) {\n\t\t\t\tif (!quiet)\n\t\t\t\t\tmprintf(\"Changing owner on %s\\n\",\n\t\t\t\t\t    g.gl_pathv[i]);\n\t\t\t\taa->uid = n_arg;\n\t\t\t} else {\n\t\t\t\tif (!quiet)\n\t\t\t\t\tmprintf(\"Changing group on %s\\n\",\n\t\t\t\t\t    g.gl_pathv[i]);\n\t\t\t\taa->gid = n_arg;\n\t\t\t}\n\t\t\terr = do_setstat(conn, g.gl_pathv[i], aa);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_PWD:\n\t\tmprintf(\"Remote working directory: %s\\n\", *pwd);\n\t\tbreak;\n\tcase I_LPWD:\n\t\tif (!getcwd(path_buf, sizeof(path_buf))) {\n\t\t\terror(\"Couldn't get local cwd: %s\", strerror(errno));\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\t\tmprintf(\"Local working directory: %s\\n\", path_buf);\n\t\tbreak;\n\tcase I_QUIT:\n\t\t/* Processed below */\n\t\tbreak;\n\tcase I_HELP:\n\t\thelp();\n\t\tbreak;\n\tcase I_VERSION:\n\t\tprintf(\"SFTP protocol version %u\\n\", sftp_proto_version(conn));\n\t\tbreak;\n\tcase I_PROGRESS:\n\t\tshowprogress = !showprogress;\n\t\tif (showprogress)\n\t\t\tprintf(\"Progress meter enabled\\n\");\n\t\telse\n\t\t\tprintf(\"Progress meter disabled\\n\");\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%d is not implemented\", cmdnum);\n\t}\n\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(path1);\n\tfree(path2);\n\n\t/* If an unignored error occurs in batch mode we should abort. */\n\tif (err_abort && err != 0)\n\t\treturn (-1);\n\telse if (cmdnum == I_QUIT)\n\t\treturn (1);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "parse_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "1298-1500",
    "snippet": "static int\nparse_args(const char **cpp, int *ignore_errors, int *disable_echo, int *aflag,\n\t  int *fflag, int *hflag, int *iflag, int *lflag, int *pflag,\n\t  int *rflag, int *sflag,\n    unsigned long *n_arg, char **path1, char **path2)\n{\n\tconst char *cmd, *cp = *cpp;\n\tchar *cp2, **argv;\n\tint base = 0;\n\tlong l;\n\tint path1_mandatory = 0, i, cmdnum, optidx, argc;\n\n\t/* Skip leading whitespace */\n\tcp = cp + strspn(cp, WHITESPACE);\n\n\t/*\n\t * Check for leading '-' (disable error processing) and '@' (suppress\n\t * command echo)\n\t */\n\t*ignore_errors = 0;\n\t*disable_echo = 0;\n\tfor (;*cp != '\\0'; cp++) {\n\t\tif (*cp == '-') {\n\t\t\t*ignore_errors = 1;\n\t\t} else if (*cp == '@') {\n\t\t\t*disable_echo = 1;\n\t\t} else {\n\t\t\t/* all other characters terminate prefix processing */\n\t\t\tbreak;\n\t\t}\n\t}\n\tcp = cp + strspn(cp, WHITESPACE);\n\n\t/* Ignore blank lines and lines which begin with comment '#' char */\n\tif (*cp == '\\0' || *cp == '#')\n\t\treturn (0);\n\n\tif ((argv = makeargv(cp, &argc, 0, NULL, NULL)) == NULL)\n\t\treturn -1;\n\n\t/* Figure out which command we have */\n\tfor (i = 0; cmds[i].c != NULL; i++) {\n\t\tif (argv[0] != NULL && strcasecmp(cmds[i].c, argv[0]) == 0)\n\t\t\tbreak;\n\t}\n\tcmdnum = cmds[i].n;\n\tcmd = cmds[i].c;\n\n\t/* Special case */\n\tif (*cp == '!') {\n\t\tcp++;\n\t\tcmdnum = I_SHELL;\n\t} else if (cmdnum == -1) {\n\t\terror(\"Invalid command.\");\n\t\treturn -1;\n\t}\n\n\t/* Get arguments and parse flags */\n\t*aflag = *fflag = *hflag = *iflag = *lflag = *pflag = 0;\n\t*rflag = *sflag = 0;\n\t*path1 = *path2 = NULL;\n\toptidx = 1;\n\tswitch (cmdnum) {\n\tcase I_GET:\n\tcase I_REGET:\n\tcase I_REPUT:\n\tcase I_PUT:\n\t\tif ((optidx = parse_getput_flags(cmd, argv, argc,\n\t\t    aflag, fflag, pflag, rflag)) == -1)\n\t\t\treturn -1;\n\t\t/* Get first pathname (mandatory) */\n\t\tif (argc - optidx < 1) {\n\t\t\terror(\"You must specify at least one path after a \"\n\t\t\t    \"%s command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t/* Get second pathname (optional) */\n\t\tif (argc - optidx > 1) {\n\t\t\t*path2 = xstrdup(argv[optidx + 1]);\n\t\t\t/* Destination is not globbed */\n\t\t\tundo_glob_escape(*path2);\n\t\t}\n\t\tbreak;\n\tcase I_LINK:\n\t\tif ((optidx = parse_link_flags(cmd, argv, argc, sflag)) == -1)\n\t\t\treturn -1;\n\t\tgoto parse_two_paths;\n\tcase I_RENAME:\n\t\tif ((optidx = parse_rename_flags(cmd, argv, argc, lflag)) == -1)\n\t\t\treturn -1;\n\t\tgoto parse_two_paths;\n\tcase I_SYMLINK:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n parse_two_paths:\n\t\tif (argc - optidx < 2) {\n\t\t\terror(\"You must specify two paths after a %s \"\n\t\t\t    \"command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t*path2 = xstrdup(argv[optidx + 1]);\n\t\t/* Paths are not globbed */\n\t\tundo_glob_escape(*path1);\n\t\tundo_glob_escape(*path2);\n\t\tbreak;\n\tcase I_RM:\n\tcase I_MKDIR:\n\tcase I_RMDIR:\n\tcase I_LMKDIR:\n\t\tpath1_mandatory = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_CHDIR:\n\tcase I_LCHDIR:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\t/* Get pathname (mandatory) */\n\t\tif (argc - optidx < 1) {\n\t\t\tif (!path1_mandatory)\n\t\t\t\tbreak; /* return a NULL path1 */\n\t\t\terror(\"You must specify a path after a %s command.\",\n\t\t\t    cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t/* Only \"rm\" globs */\n\t\tif (cmdnum != I_RM)\n\t\t\tundo_glob_escape(*path1);\n\t\tbreak;\n\tcase I_DF:\n\t\tif ((optidx = parse_df_flags(cmd, argv, argc, hflag,\n\t\t    iflag)) == -1)\n\t\t\treturn -1;\n\t\t/* Default to current directory if no path specified */\n\t\tif (argc - optidx < 1)\n\t\t\t*path1 = NULL;\n\t\telse {\n\t\t\t*path1 = xstrdup(argv[optidx]);\n\t\t\tundo_glob_escape(*path1);\n\t\t}\n\t\tbreak;\n\tcase I_LS:\n\t\tif ((optidx = parse_ls_flags(argv, argc, lflag)) == -1)\n\t\t\treturn(-1);\n\t\t/* Path is optional */\n\t\tif (argc - optidx > 0)\n\t\t\t*path1 = xstrdup(argv[optidx]);\n\t\tbreak;\n\tcase I_LLS:\n\t\t/* Skip ls command and following whitespace */\n\t\tcp = cp + strlen(cmd) + strspn(cp, WHITESPACE);\n\tcase I_SHELL:\n\t\t/* Uses the rest of the line */\n\t\tbreak;\n\tcase I_LUMASK:\n\tcase I_CHMOD:\n\t\tbase = 8;\n\t\t/* FALLTHROUGH */\n\tcase I_CHOWN:\n\tcase I_CHGRP:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\t/* Get numeric arg (mandatory) */\n\t\tif (argc - optidx < 1)\n\t\t\tgoto need_num_arg;\n\t\terrno = 0;\n\t\tl = strtol(argv[optidx], &cp2, base);\n\t\tif (cp2 == argv[optidx] || *cp2 != '\\0' ||\n\t\t    ((l == LONG_MIN || l == LONG_MAX) && errno == ERANGE) ||\n\t\t    l < 0) {\n need_num_arg:\n\t\t\terror(\"You must supply a numeric argument \"\n\t\t\t    \"to the %s command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*n_arg = l;\n\t\tif (cmdnum == I_LUMASK)\n\t\t\tbreak;\n\t\t/* Get pathname (mandatory) */\n\t\tif (argc - optidx < 2) {\n\t\t\terror(\"You must specify a path after a %s command.\",\n\t\t\t    cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx + 1]);\n\t\tbreak;\n\tcase I_QUIT:\n\tcase I_PWD:\n\tcase I_LPWD:\n\tcase I_HELP:\n\tcase I_VERSION:\n\tcase I_PROGRESS:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"Command not implemented\");\n\t}\n\n\t*cpp = cp;\n\treturn(cmdnum);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define WHITESPACE \" \\t\\r\\n\""
    ],
    "globals_used": [
      "static const struct CMD cmds[] = {\n\t{ \"bye\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"cd\",\t\tI_CHDIR,\tREMOTE\t},\n\t{ \"chdir\",\tI_CHDIR,\tREMOTE\t},\n\t{ \"chgrp\",\tI_CHGRP,\tREMOTE\t},\n\t{ \"chmod\",\tI_CHMOD,\tREMOTE\t},\n\t{ \"chown\",\tI_CHOWN,\tREMOTE\t},\n\t{ \"df\",\t\tI_DF,\t\tREMOTE\t},\n\t{ \"dir\",\tI_LS,\t\tREMOTE\t},\n\t{ \"exit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"get\",\tI_GET,\t\tREMOTE\t},\n\t{ \"help\",\tI_HELP,\t\tNOARGS\t},\n\t{ \"lcd\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lchdir\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lls\",\tI_LLS,\t\tLOCAL\t},\n\t{ \"lmkdir\",\tI_LMKDIR,\tLOCAL\t},\n\t{ \"ln\",\t\tI_LINK,\t\tREMOTE\t},\n\t{ \"lpwd\",\tI_LPWD,\t\tLOCAL\t},\n\t{ \"ls\",\t\tI_LS,\t\tREMOTE\t},\n\t{ \"lumask\",\tI_LUMASK,\tNOARGS\t},\n\t{ \"mkdir\",\tI_MKDIR,\tREMOTE\t},\n\t{ \"mget\",\tI_GET,\t\tREMOTE\t},\n\t{ \"mput\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"progress\",\tI_PROGRESS,\tNOARGS\t},\n\t{ \"put\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"pwd\",\tI_PWD,\t\tREMOTE\t},\n\t{ \"quit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"reget\",\tI_REGET,\tREMOTE\t},\n\t{ \"rename\",\tI_RENAME,\tREMOTE\t},\n\t{ \"reput\",\tI_REPUT,\tLOCAL\t},\n\t{ \"rm\",\t\tI_RM,\t\tREMOTE\t},\n\t{ \"rmdir\",\tI_RMDIR,\tREMOTE\t},\n\t{ \"symlink\",\tI_SYMLINK,\tREMOTE\t},\n\t{ \"version\",\tI_VERSION,\tNOARGS\t},\n\t{ \"!\",\t\tI_SHELL,\tNOARGS\t},\n\t{ \"?\",\t\tI_HELP,\t\tNOARGS\t},\n\t{ NULL,\t\t-1,\t\t-1\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Command not implemented\""
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_no_flags",
          "args": [
            "cmd",
            "argv",
            "argc"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "parse_no_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "564-582",
          "snippet": "static int\nparse_no_flags(const char *cmd, char **argv, int argc)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\twhile ((ch = getopt(argc, argv, \"\")) != -1) {\n\t\tswitch (ch) {\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_no_flags(const char *cmd, char **argv, int argc)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\twhile ((ch = getopt(argc, argv, \"\")) != -1) {\n\t\tswitch (ch) {\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "argv[optidx + 1]"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"You must specify a path after a %s command.\"",
            "cmd"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "argv[optidx]",
            "&cp2",
            "base"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "strtoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtoll.c",
          "lines": "49-147",
          "snippet": "long long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nlong long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "WHITESPACE"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_ls_flags",
          "args": [
            "argv",
            "argc",
            "lflag"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "parse_ls_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "484-535",
          "snippet": "static int\nparse_ls_flags(char **argv, int argc, int *lflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*lflag = LS_NAME_SORT;\n\twhile ((ch = getopt(argc, argv, \"1Safhlnrt\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase '1':\n\t\t\t*lflag &= ~VIEW_FLAGS;\n\t\t\t*lflag |= LS_SHORT_VIEW;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\t*lflag |= LS_SIZE_SORT;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t*lflag |= LS_SHOW_ALL;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\t*lflag |= LS_SI_UNITS;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t*lflag &= ~LS_SHORT_VIEW;\n\t\t\t*lflag |= LS_LONG_VIEW;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t*lflag &= ~LS_SHORT_VIEW;\n\t\t\t*lflag |= LS_NUMERIC_VIEW|LS_LONG_VIEW;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\t*lflag |= LS_REVERSE_SORT;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\t*lflag |= LS_TIME_SORT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"ls: Invalid flag -%c\", optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)",
            "#define VIEW_FLAGS\t(LS_LONG_VIEW|LS_SHORT_VIEW|LS_NUMERIC_VIEW|LS_SI_UNITS)",
            "#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */",
            "#define LS_SHOW_ALL\t0x0080\t/* Don't skip filenames starting with '.' */",
            "#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */",
            "#define LS_SIZE_SORT\t0x0020\t/* Sort by file size */",
            "#define LS_TIME_SORT\t0x0010\t/* Sort by mtime */",
            "#define LS_NAME_SORT\t0x0008\t/* Sort by name (default) */",
            "#define LS_NUMERIC_VIEW\t0x0004\t/* Long view with numeric uid/gid */",
            "#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */",
            "#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)\n#define VIEW_FLAGS\t(LS_LONG_VIEW|LS_SHORT_VIEW|LS_NUMERIC_VIEW|LS_SI_UNITS)\n#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */\n#define LS_SHOW_ALL\t0x0080\t/* Don't skip filenames starting with '.' */\n#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */\n#define LS_SIZE_SORT\t0x0020\t/* Sort by file size */\n#define LS_TIME_SORT\t0x0010\t/* Sort by mtime */\n#define LS_NAME_SORT\t0x0008\t/* Sort by name (default) */\n#define LS_NUMERIC_VIEW\t0x0004\t/* Long view with numeric uid/gid */\n#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */\n#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */\n\nstatic int\nparse_ls_flags(char **argv, int argc, int *lflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*lflag = LS_NAME_SORT;\n\twhile ((ch = getopt(argc, argv, \"1Safhlnrt\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase '1':\n\t\t\t*lflag &= ~VIEW_FLAGS;\n\t\t\t*lflag |= LS_SHORT_VIEW;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\t*lflag |= LS_SIZE_SORT;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t*lflag |= LS_SHOW_ALL;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\t*lflag |= LS_SI_UNITS;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t*lflag &= ~LS_SHORT_VIEW;\n\t\t\t*lflag |= LS_LONG_VIEW;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t*lflag &= ~LS_SHORT_VIEW;\n\t\t\t*lflag |= LS_NUMERIC_VIEW|LS_LONG_VIEW;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\t*lflag |= LS_REVERSE_SORT;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\t*lflag |= LS_TIME_SORT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"ls: Invalid flag -%c\", optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}"
        }
      },
      {
        "call_info": {
          "callee": "undo_glob_escape",
          "args": [
            "*path1"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "undo_glob_escape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "1098-1131",
          "snippet": "static void\nundo_glob_escape(char *s)\n{\n\tsize_t i, j;\n\n\tfor (i = j = 0;;) {\n\t\tif (s[i] == '\\0') {\n\t\t\ts[j] = '\\0';\n\t\t\treturn;\n\t\t}\n\t\tif (s[i] != '\\\\') {\n\t\t\ts[j++] = s[i++];\n\t\t\tcontinue;\n\t\t}\n\t\t/* s[i] == '\\\\' */\n\t\t++i;\n\t\tswitch (s[i]) {\n\t\tcase '?':\n\t\tcase '[':\n\t\tcase '*':\n\t\tcase '\\\\':\n\t\t\ts[j++] = s[i++];\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\ts[j++] = '\\\\';\n\t\t\ts[j] = '\\0';\n\t\t\treturn;\n\t\tdefault:\n\t\t\ts[j++] = '\\\\';\n\t\t\ts[j++] = s[i++];\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nundo_glob_escape(char *s)\n{\n\tsize_t i, j;\n\n\tfor (i = j = 0;;) {\n\t\tif (s[i] == '\\0') {\n\t\t\ts[j] = '\\0';\n\t\t\treturn;\n\t\t}\n\t\tif (s[i] != '\\\\') {\n\t\t\ts[j++] = s[i++];\n\t\t\tcontinue;\n\t\t}\n\t\t/* s[i] == '\\\\' */\n\t\t++i;\n\t\tswitch (s[i]) {\n\t\tcase '?':\n\t\tcase '[':\n\t\tcase '*':\n\t\tcase '\\\\':\n\t\t\ts[j++] = s[i++];\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\ts[j++] = '\\\\';\n\t\t\ts[j] = '\\0';\n\t\t\treturn;\n\t\tdefault:\n\t\t\ts[j++] = '\\\\';\n\t\t\ts[j++] = s[i++];\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_df_flags",
          "args": [
            "cmd",
            "argv",
            "argc",
            "hflag",
            "iflag"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "parse_df_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "537-562",
          "snippet": "static int\nparse_df_flags(const char *cmd, char **argv, int argc, int *hflag, int *iflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*hflag = *iflag = 0;\n\twhile ((ch = getopt(argc, argv, \"hi\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'h':\n\t\t\t*hflag = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\t*iflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_df_flags(const char *cmd, char **argv, int argc, int *hflag, int *iflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*hflag = *iflag = 0;\n\twhile ((ch = getopt(argc, argv, \"hi\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'h':\n\t\t\t*hflag = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\t*iflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_rename_flags",
          "args": [
            "cmd",
            "argv",
            "argc",
            "lflag"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "parse_rename_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "460-482",
          "snippet": "static int\nparse_rename_flags(const char *cmd, char **argv, int argc, int *lflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*lflag = 0;\n\twhile ((ch = getopt(argc, argv, \"l\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'l':\n\t\t\t*lflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_rename_flags(const char *cmd, char **argv, int argc, int *lflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*lflag = 0;\n\twhile ((ch = getopt(argc, argv, \"l\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'l':\n\t\t\t*lflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_link_flags",
          "args": [
            "cmd",
            "argv",
            "argc",
            "sflag"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "parse_link_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "436-458",
          "snippet": "static int\nparse_link_flags(const char *cmd, char **argv, int argc, int *sflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*sflag = 0;\n\twhile ((ch = getopt(argc, argv, \"s\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 's':\n\t\t\t*sflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_link_flags(const char *cmd, char **argv, int argc, int *sflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*sflag = 0;\n\twhile ((ch = getopt(argc, argv, \"s\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 's':\n\t\t\t*sflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_getput_flags",
          "args": [
            "cmd",
            "argv",
            "argc",
            "aflag",
            "fflag",
            "pflag",
            "rflag"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "parse_getput_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "400-434",
          "snippet": "static int\nparse_getput_flags(const char *cmd, char **argv, int argc,\n    int *aflag, int *fflag, int *pflag, int *rflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*aflag = *fflag = *rflag = *pflag = 0;\n\twhile ((ch = getopt(argc, argv, \"afPpRr\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\t*aflag = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t*fflag = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\t*pflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\tcase 'R':\n\t\t\t*rflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_getput_flags(const char *cmd, char **argv, int argc,\n    int *aflag, int *fflag, int *pflag, int *rflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*aflag = *fflag = *rflag = *pflag = 0;\n\twhile ((ch = getopt(argc, argv, \"afPpRr\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\t*aflag = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t*fflag = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\t*pflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\tcase 'R':\n\t\t\t*rflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "cmds[i].c",
            "argv[0]"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeargv",
          "args": [
            "cp",
            "&argc",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "makeargv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "1151-1296",
          "snippet": "static char **\nmakeargv(const char *arg, int *argcp, int sloppy, char *lastquote,\n    u_int *terminated)\n{\n\tint argc, quot;\n\tsize_t i, j;\n\tstatic char argvs[MAXARGLEN];\n\tstatic char *argv[MAXARGS + 1];\n\tenum { MA_START, MA_SQUOTE, MA_DQUOTE, MA_UNQUOTED } state, q;\n\n\t*argcp = argc = 0;\n\tif (strlen(arg) > sizeof(argvs) - 1) {\n args_too_longs:\n\t\terror(\"string too long\");\n\t\treturn NULL;\n\t}\n\tif (terminated != NULL)\n\t\t*terminated = 1;\n\tif (lastquote != NULL)\n\t\t*lastquote = '\\0';\n\tstate = MA_START;\n\ti = j = 0;\n\tfor (;;) {\n\t\tif ((size_t)argc >= sizeof(argv) / sizeof(*argv)){\n\t\t\terror(\"Too many arguments.\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (isspace((unsigned char)arg[i])) {\n\t\t\tif (state == MA_UNQUOTED) {\n\t\t\t\t/* Terminate current argument */\n\t\t\t\targvs[j++] = '\\0';\n\t\t\t\targc++;\n\t\t\t\tstate = MA_START;\n\t\t\t} else if (state != MA_START)\n\t\t\t\targvs[j++] = arg[i];\n\t\t} else if (arg[i] == '\"' || arg[i] == '\\'') {\n\t\t\tq = arg[i] == '\"' ? MA_DQUOTE : MA_SQUOTE;\n\t\t\tif (state == MA_START) {\n\t\t\t\targv[argc] = argvs + j;\n\t\t\t\tstate = q;\n\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t*lastquote = arg[i];\n\t\t\t} else if (state == MA_UNQUOTED)\n\t\t\t\tstate = q;\n\t\t\telse if (state == q)\n\t\t\t\tstate = MA_UNQUOTED;\n\t\t\telse\n\t\t\t\targvs[j++] = arg[i];\n\t\t} else if (arg[i] == '\\\\') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE) {\n\t\t\t\tquot = state == MA_SQUOTE ? '\\'' : '\"';\n\t\t\t\t/* Unescape quote we are in */\n\t\t\t\t/* XXX support \\n and friends? */\n\t\t\t\tif (arg[i + 1] == quot) {\n\t\t\t\t\ti++;\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else if (arg[i + 1] == '?' ||\n\t\t\t\t    arg[i + 1] == '[' || arg[i + 1] == '*') {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special case for sftp: append\n\t\t\t\t\t * double-escaped glob sequence -\n\t\t\t\t\t * glob will undo one level of\n\t\t\t\t\t * escaping. NB. string can grow here.\n\t\t\t\t\t */\n\t\t\t\t\tif (j >= sizeof(argvs) - 5)\n\t\t\t\t\t\tgoto args_too_longs;\n\t\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else {\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (state == MA_START) {\n\t\t\t\t\targv[argc] = argvs + j;\n\t\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t\t*lastquote = '\\0';\n\t\t\t\t}\n\t\t\t\tif (arg[i + 1] == '?' || arg[i + 1] == '[' ||\n\t\t\t\t    arg[i + 1] == '*' || arg[i + 1] == '\\\\') {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special case for sftp: append\n\t\t\t\t\t * escaped glob sequence -\n\t\t\t\t\t * glob will undo one level of\n\t\t\t\t\t * escaping.\n\t\t\t\t\t */\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else {\n\t\t\t\t\t/* Unescape everything */\n\t\t\t\t\t/* XXX support \\n and friends? */\n\t\t\t\t\ti++;\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arg[i] == '#') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE)\n\t\t\t\targvs[j++] = arg[i];\n\t\t\telse\n\t\t\t\tgoto string_done;\n\t\t} else if (arg[i] == '\\0') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE) {\n\t\t\t\tif (sloppy) {\n\t\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\t\tif (terminated != NULL)\n\t\t\t\t\t\t*terminated = 0;\n\t\t\t\t\tgoto string_done;\n\t\t\t\t}\n\t\t\t\terror(\"Unterminated quoted argument\");\n\t\t\t\treturn NULL;\n\t\t\t}\n string_done:\n\t\t\tif (state == MA_UNQUOTED) {\n\t\t\t\targvs[j++] = '\\0';\n\t\t\t\targc++;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (state == MA_START) {\n\t\t\t\targv[argc] = argvs + j;\n\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t*lastquote = '\\0';\n\t\t\t}\n\t\t\tif ((state == MA_SQUOTE || state == MA_DQUOTE) &&\n\t\t\t    (arg[i] == '?' || arg[i] == '[' || arg[i] == '*')) {\n\t\t\t\t/*\n\t\t\t\t * Special case for sftp: escape quoted\n\t\t\t\t * glob(3) wildcards. NB. string can grow\n\t\t\t\t * here.\n\t\t\t\t */\n\t\t\t\tif (j >= sizeof(argvs) - 3)\n\t\t\t\t\tgoto args_too_longs;\n\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\targvs[j++] = arg[i];\n\t\t\t} else\n\t\t\t\targvs[j++] = arg[i];\n\t\t}\n\t\ti++;\n\t}\n\t*argcp = argc;\n\treturn argv;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAXARGLEN\t8192",
            "#define MAXARGS \t128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAXARGLEN\t8192\n#define MAXARGS \t128\n\nstatic char **\nmakeargv(const char *arg, int *argcp, int sloppy, char *lastquote,\n    u_int *terminated)\n{\n\tint argc, quot;\n\tsize_t i, j;\n\tstatic char argvs[MAXARGLEN];\n\tstatic char *argv[MAXARGS + 1];\n\tenum { MA_START, MA_SQUOTE, MA_DQUOTE, MA_UNQUOTED } state, q;\n\n\t*argcp = argc = 0;\n\tif (strlen(arg) > sizeof(argvs) - 1) {\n args_too_longs:\n\t\terror(\"string too long\");\n\t\treturn NULL;\n\t}\n\tif (terminated != NULL)\n\t\t*terminated = 1;\n\tif (lastquote != NULL)\n\t\t*lastquote = '\\0';\n\tstate = MA_START;\n\ti = j = 0;\n\tfor (;;) {\n\t\tif ((size_t)argc >= sizeof(argv) / sizeof(*argv)){\n\t\t\terror(\"Too many arguments.\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (isspace((unsigned char)arg[i])) {\n\t\t\tif (state == MA_UNQUOTED) {\n\t\t\t\t/* Terminate current argument */\n\t\t\t\targvs[j++] = '\\0';\n\t\t\t\targc++;\n\t\t\t\tstate = MA_START;\n\t\t\t} else if (state != MA_START)\n\t\t\t\targvs[j++] = arg[i];\n\t\t} else if (arg[i] == '\"' || arg[i] == '\\'') {\n\t\t\tq = arg[i] == '\"' ? MA_DQUOTE : MA_SQUOTE;\n\t\t\tif (state == MA_START) {\n\t\t\t\targv[argc] = argvs + j;\n\t\t\t\tstate = q;\n\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t*lastquote = arg[i];\n\t\t\t} else if (state == MA_UNQUOTED)\n\t\t\t\tstate = q;\n\t\t\telse if (state == q)\n\t\t\t\tstate = MA_UNQUOTED;\n\t\t\telse\n\t\t\t\targvs[j++] = arg[i];\n\t\t} else if (arg[i] == '\\\\') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE) {\n\t\t\t\tquot = state == MA_SQUOTE ? '\\'' : '\"';\n\t\t\t\t/* Unescape quote we are in */\n\t\t\t\t/* XXX support \\n and friends? */\n\t\t\t\tif (arg[i + 1] == quot) {\n\t\t\t\t\ti++;\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else if (arg[i + 1] == '?' ||\n\t\t\t\t    arg[i + 1] == '[' || arg[i + 1] == '*') {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special case for sftp: append\n\t\t\t\t\t * double-escaped glob sequence -\n\t\t\t\t\t * glob will undo one level of\n\t\t\t\t\t * escaping. NB. string can grow here.\n\t\t\t\t\t */\n\t\t\t\t\tif (j >= sizeof(argvs) - 5)\n\t\t\t\t\t\tgoto args_too_longs;\n\t\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else {\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (state == MA_START) {\n\t\t\t\t\targv[argc] = argvs + j;\n\t\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t\t*lastquote = '\\0';\n\t\t\t\t}\n\t\t\t\tif (arg[i + 1] == '?' || arg[i + 1] == '[' ||\n\t\t\t\t    arg[i + 1] == '*' || arg[i + 1] == '\\\\') {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special case for sftp: append\n\t\t\t\t\t * escaped glob sequence -\n\t\t\t\t\t * glob will undo one level of\n\t\t\t\t\t * escaping.\n\t\t\t\t\t */\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else {\n\t\t\t\t\t/* Unescape everything */\n\t\t\t\t\t/* XXX support \\n and friends? */\n\t\t\t\t\ti++;\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arg[i] == '#') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE)\n\t\t\t\targvs[j++] = arg[i];\n\t\t\telse\n\t\t\t\tgoto string_done;\n\t\t} else if (arg[i] == '\\0') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE) {\n\t\t\t\tif (sloppy) {\n\t\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\t\tif (terminated != NULL)\n\t\t\t\t\t\t*terminated = 0;\n\t\t\t\t\tgoto string_done;\n\t\t\t\t}\n\t\t\t\terror(\"Unterminated quoted argument\");\n\t\t\t\treturn NULL;\n\t\t\t}\n string_done:\n\t\t\tif (state == MA_UNQUOTED) {\n\t\t\t\targvs[j++] = '\\0';\n\t\t\t\targc++;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (state == MA_START) {\n\t\t\t\targv[argc] = argvs + j;\n\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t*lastquote = '\\0';\n\t\t\t}\n\t\t\tif ((state == MA_SQUOTE || state == MA_DQUOTE) &&\n\t\t\t    (arg[i] == '?' || arg[i] == '[' || arg[i] == '*')) {\n\t\t\t\t/*\n\t\t\t\t * Special case for sftp: escape quoted\n\t\t\t\t * glob(3) wildcards. NB. string can grow\n\t\t\t\t * here.\n\t\t\t\t */\n\t\t\t\tif (j >= sizeof(argvs) - 3)\n\t\t\t\t\tgoto args_too_longs;\n\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\targvs[j++] = arg[i];\n\t\t\t} else\n\t\t\t\targvs[j++] = arg[i];\n\t\t}\n\t\ti++;\n\t}\n\t*argcp = argc;\n\treturn argv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "WHITESPACE"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "WHITESPACE"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WHITESPACE \" \\t\\r\\n\"\n\nstatic const struct CMD cmds[] = {\n\t{ \"bye\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"cd\",\t\tI_CHDIR,\tREMOTE\t},\n\t{ \"chdir\",\tI_CHDIR,\tREMOTE\t},\n\t{ \"chgrp\",\tI_CHGRP,\tREMOTE\t},\n\t{ \"chmod\",\tI_CHMOD,\tREMOTE\t},\n\t{ \"chown\",\tI_CHOWN,\tREMOTE\t},\n\t{ \"df\",\t\tI_DF,\t\tREMOTE\t},\n\t{ \"dir\",\tI_LS,\t\tREMOTE\t},\n\t{ \"exit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"get\",\tI_GET,\t\tREMOTE\t},\n\t{ \"help\",\tI_HELP,\t\tNOARGS\t},\n\t{ \"lcd\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lchdir\",\tI_LCHDIR,\tLOCAL\t},\n\t{ \"lls\",\tI_LLS,\t\tLOCAL\t},\n\t{ \"lmkdir\",\tI_LMKDIR,\tLOCAL\t},\n\t{ \"ln\",\t\tI_LINK,\t\tREMOTE\t},\n\t{ \"lpwd\",\tI_LPWD,\t\tLOCAL\t},\n\t{ \"ls\",\t\tI_LS,\t\tREMOTE\t},\n\t{ \"lumask\",\tI_LUMASK,\tNOARGS\t},\n\t{ \"mkdir\",\tI_MKDIR,\tREMOTE\t},\n\t{ \"mget\",\tI_GET,\t\tREMOTE\t},\n\t{ \"mput\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"progress\",\tI_PROGRESS,\tNOARGS\t},\n\t{ \"put\",\tI_PUT,\t\tLOCAL\t},\n\t{ \"pwd\",\tI_PWD,\t\tREMOTE\t},\n\t{ \"quit\",\tI_QUIT,\t\tNOARGS\t},\n\t{ \"reget\",\tI_REGET,\tREMOTE\t},\n\t{ \"rename\",\tI_RENAME,\tREMOTE\t},\n\t{ \"reput\",\tI_REPUT,\tLOCAL\t},\n\t{ \"rm\",\t\tI_RM,\t\tREMOTE\t},\n\t{ \"rmdir\",\tI_RMDIR,\tREMOTE\t},\n\t{ \"symlink\",\tI_SYMLINK,\tREMOTE\t},\n\t{ \"version\",\tI_VERSION,\tNOARGS\t},\n\t{ \"!\",\t\tI_SHELL,\tNOARGS\t},\n\t{ \"?\",\t\tI_HELP,\t\tNOARGS\t},\n\t{ NULL,\t\t-1,\t\t-1\t}\n};\n\nstatic int\nparse_args(const char **cpp, int *ignore_errors, int *disable_echo, int *aflag,\n\t  int *fflag, int *hflag, int *iflag, int *lflag, int *pflag,\n\t  int *rflag, int *sflag,\n    unsigned long *n_arg, char **path1, char **path2)\n{\n\tconst char *cmd, *cp = *cpp;\n\tchar *cp2, **argv;\n\tint base = 0;\n\tlong l;\n\tint path1_mandatory = 0, i, cmdnum, optidx, argc;\n\n\t/* Skip leading whitespace */\n\tcp = cp + strspn(cp, WHITESPACE);\n\n\t/*\n\t * Check for leading '-' (disable error processing) and '@' (suppress\n\t * command echo)\n\t */\n\t*ignore_errors = 0;\n\t*disable_echo = 0;\n\tfor (;*cp != '\\0'; cp++) {\n\t\tif (*cp == '-') {\n\t\t\t*ignore_errors = 1;\n\t\t} else if (*cp == '@') {\n\t\t\t*disable_echo = 1;\n\t\t} else {\n\t\t\t/* all other characters terminate prefix processing */\n\t\t\tbreak;\n\t\t}\n\t}\n\tcp = cp + strspn(cp, WHITESPACE);\n\n\t/* Ignore blank lines and lines which begin with comment '#' char */\n\tif (*cp == '\\0' || *cp == '#')\n\t\treturn (0);\n\n\tif ((argv = makeargv(cp, &argc, 0, NULL, NULL)) == NULL)\n\t\treturn -1;\n\n\t/* Figure out which command we have */\n\tfor (i = 0; cmds[i].c != NULL; i++) {\n\t\tif (argv[0] != NULL && strcasecmp(cmds[i].c, argv[0]) == 0)\n\t\t\tbreak;\n\t}\n\tcmdnum = cmds[i].n;\n\tcmd = cmds[i].c;\n\n\t/* Special case */\n\tif (*cp == '!') {\n\t\tcp++;\n\t\tcmdnum = I_SHELL;\n\t} else if (cmdnum == -1) {\n\t\terror(\"Invalid command.\");\n\t\treturn -1;\n\t}\n\n\t/* Get arguments and parse flags */\n\t*aflag = *fflag = *hflag = *iflag = *lflag = *pflag = 0;\n\t*rflag = *sflag = 0;\n\t*path1 = *path2 = NULL;\n\toptidx = 1;\n\tswitch (cmdnum) {\n\tcase I_GET:\n\tcase I_REGET:\n\tcase I_REPUT:\n\tcase I_PUT:\n\t\tif ((optidx = parse_getput_flags(cmd, argv, argc,\n\t\t    aflag, fflag, pflag, rflag)) == -1)\n\t\t\treturn -1;\n\t\t/* Get first pathname (mandatory) */\n\t\tif (argc - optidx < 1) {\n\t\t\terror(\"You must specify at least one path after a \"\n\t\t\t    \"%s command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t/* Get second pathname (optional) */\n\t\tif (argc - optidx > 1) {\n\t\t\t*path2 = xstrdup(argv[optidx + 1]);\n\t\t\t/* Destination is not globbed */\n\t\t\tundo_glob_escape(*path2);\n\t\t}\n\t\tbreak;\n\tcase I_LINK:\n\t\tif ((optidx = parse_link_flags(cmd, argv, argc, sflag)) == -1)\n\t\t\treturn -1;\n\t\tgoto parse_two_paths;\n\tcase I_RENAME:\n\t\tif ((optidx = parse_rename_flags(cmd, argv, argc, lflag)) == -1)\n\t\t\treturn -1;\n\t\tgoto parse_two_paths;\n\tcase I_SYMLINK:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n parse_two_paths:\n\t\tif (argc - optidx < 2) {\n\t\t\terror(\"You must specify two paths after a %s \"\n\t\t\t    \"command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t*path2 = xstrdup(argv[optidx + 1]);\n\t\t/* Paths are not globbed */\n\t\tundo_glob_escape(*path1);\n\t\tundo_glob_escape(*path2);\n\t\tbreak;\n\tcase I_RM:\n\tcase I_MKDIR:\n\tcase I_RMDIR:\n\tcase I_LMKDIR:\n\t\tpath1_mandatory = 1;\n\t\t/* FALLTHROUGH */\n\tcase I_CHDIR:\n\tcase I_LCHDIR:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\t/* Get pathname (mandatory) */\n\t\tif (argc - optidx < 1) {\n\t\t\tif (!path1_mandatory)\n\t\t\t\tbreak; /* return a NULL path1 */\n\t\t\terror(\"You must specify a path after a %s command.\",\n\t\t\t    cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t/* Only \"rm\" globs */\n\t\tif (cmdnum != I_RM)\n\t\t\tundo_glob_escape(*path1);\n\t\tbreak;\n\tcase I_DF:\n\t\tif ((optidx = parse_df_flags(cmd, argv, argc, hflag,\n\t\t    iflag)) == -1)\n\t\t\treturn -1;\n\t\t/* Default to current directory if no path specified */\n\t\tif (argc - optidx < 1)\n\t\t\t*path1 = NULL;\n\t\telse {\n\t\t\t*path1 = xstrdup(argv[optidx]);\n\t\t\tundo_glob_escape(*path1);\n\t\t}\n\t\tbreak;\n\tcase I_LS:\n\t\tif ((optidx = parse_ls_flags(argv, argc, lflag)) == -1)\n\t\t\treturn(-1);\n\t\t/* Path is optional */\n\t\tif (argc - optidx > 0)\n\t\t\t*path1 = xstrdup(argv[optidx]);\n\t\tbreak;\n\tcase I_LLS:\n\t\t/* Skip ls command and following whitespace */\n\t\tcp = cp + strlen(cmd) + strspn(cp, WHITESPACE);\n\tcase I_SHELL:\n\t\t/* Uses the rest of the line */\n\t\tbreak;\n\tcase I_LUMASK:\n\tcase I_CHMOD:\n\t\tbase = 8;\n\t\t/* FALLTHROUGH */\n\tcase I_CHOWN:\n\tcase I_CHGRP:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\t/* Get numeric arg (mandatory) */\n\t\tif (argc - optidx < 1)\n\t\t\tgoto need_num_arg;\n\t\terrno = 0;\n\t\tl = strtol(argv[optidx], &cp2, base);\n\t\tif (cp2 == argv[optidx] || *cp2 != '\\0' ||\n\t\t    ((l == LONG_MIN || l == LONG_MAX) && errno == ERANGE) ||\n\t\t    l < 0) {\n need_num_arg:\n\t\t\terror(\"You must supply a numeric argument \"\n\t\t\t    \"to the %s command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*n_arg = l;\n\t\tif (cmdnum == I_LUMASK)\n\t\t\tbreak;\n\t\t/* Get pathname (mandatory) */\n\t\tif (argc - optidx < 2) {\n\t\t\terror(\"You must specify a path after a %s command.\",\n\t\t\t    cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx + 1]);\n\t\tbreak;\n\tcase I_QUIT:\n\tcase I_PWD:\n\tcase I_LPWD:\n\tcase I_HELP:\n\tcase I_VERSION:\n\tcase I_PROGRESS:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"Command not implemented\");\n\t}\n\n\t*cpp = cp;\n\treturn(cmdnum);\n}"
  },
  {
    "function_name": "makeargv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "1151-1296",
    "snippet": "static char **\nmakeargv(const char *arg, int *argcp, int sloppy, char *lastquote,\n    u_int *terminated)\n{\n\tint argc, quot;\n\tsize_t i, j;\n\tstatic char argvs[MAXARGLEN];\n\tstatic char *argv[MAXARGS + 1];\n\tenum { MA_START, MA_SQUOTE, MA_DQUOTE, MA_UNQUOTED } state, q;\n\n\t*argcp = argc = 0;\n\tif (strlen(arg) > sizeof(argvs) - 1) {\n args_too_longs:\n\t\terror(\"string too long\");\n\t\treturn NULL;\n\t}\n\tif (terminated != NULL)\n\t\t*terminated = 1;\n\tif (lastquote != NULL)\n\t\t*lastquote = '\\0';\n\tstate = MA_START;\n\ti = j = 0;\n\tfor (;;) {\n\t\tif ((size_t)argc >= sizeof(argv) / sizeof(*argv)){\n\t\t\terror(\"Too many arguments.\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (isspace((unsigned char)arg[i])) {\n\t\t\tif (state == MA_UNQUOTED) {\n\t\t\t\t/* Terminate current argument */\n\t\t\t\targvs[j++] = '\\0';\n\t\t\t\targc++;\n\t\t\t\tstate = MA_START;\n\t\t\t} else if (state != MA_START)\n\t\t\t\targvs[j++] = arg[i];\n\t\t} else if (arg[i] == '\"' || arg[i] == '\\'') {\n\t\t\tq = arg[i] == '\"' ? MA_DQUOTE : MA_SQUOTE;\n\t\t\tif (state == MA_START) {\n\t\t\t\targv[argc] = argvs + j;\n\t\t\t\tstate = q;\n\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t*lastquote = arg[i];\n\t\t\t} else if (state == MA_UNQUOTED)\n\t\t\t\tstate = q;\n\t\t\telse if (state == q)\n\t\t\t\tstate = MA_UNQUOTED;\n\t\t\telse\n\t\t\t\targvs[j++] = arg[i];\n\t\t} else if (arg[i] == '\\\\') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE) {\n\t\t\t\tquot = state == MA_SQUOTE ? '\\'' : '\"';\n\t\t\t\t/* Unescape quote we are in */\n\t\t\t\t/* XXX support \\n and friends? */\n\t\t\t\tif (arg[i + 1] == quot) {\n\t\t\t\t\ti++;\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else if (arg[i + 1] == '?' ||\n\t\t\t\t    arg[i + 1] == '[' || arg[i + 1] == '*') {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special case for sftp: append\n\t\t\t\t\t * double-escaped glob sequence -\n\t\t\t\t\t * glob will undo one level of\n\t\t\t\t\t * escaping. NB. string can grow here.\n\t\t\t\t\t */\n\t\t\t\t\tif (j >= sizeof(argvs) - 5)\n\t\t\t\t\t\tgoto args_too_longs;\n\t\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else {\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (state == MA_START) {\n\t\t\t\t\targv[argc] = argvs + j;\n\t\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t\t*lastquote = '\\0';\n\t\t\t\t}\n\t\t\t\tif (arg[i + 1] == '?' || arg[i + 1] == '[' ||\n\t\t\t\t    arg[i + 1] == '*' || arg[i + 1] == '\\\\') {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special case for sftp: append\n\t\t\t\t\t * escaped glob sequence -\n\t\t\t\t\t * glob will undo one level of\n\t\t\t\t\t * escaping.\n\t\t\t\t\t */\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else {\n\t\t\t\t\t/* Unescape everything */\n\t\t\t\t\t/* XXX support \\n and friends? */\n\t\t\t\t\ti++;\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arg[i] == '#') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE)\n\t\t\t\targvs[j++] = arg[i];\n\t\t\telse\n\t\t\t\tgoto string_done;\n\t\t} else if (arg[i] == '\\0') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE) {\n\t\t\t\tif (sloppy) {\n\t\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\t\tif (terminated != NULL)\n\t\t\t\t\t\t*terminated = 0;\n\t\t\t\t\tgoto string_done;\n\t\t\t\t}\n\t\t\t\terror(\"Unterminated quoted argument\");\n\t\t\t\treturn NULL;\n\t\t\t}\n string_done:\n\t\t\tif (state == MA_UNQUOTED) {\n\t\t\t\targvs[j++] = '\\0';\n\t\t\t\targc++;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (state == MA_START) {\n\t\t\t\targv[argc] = argvs + j;\n\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t*lastquote = '\\0';\n\t\t\t}\n\t\t\tif ((state == MA_SQUOTE || state == MA_DQUOTE) &&\n\t\t\t    (arg[i] == '?' || arg[i] == '[' || arg[i] == '*')) {\n\t\t\t\t/*\n\t\t\t\t * Special case for sftp: escape quoted\n\t\t\t\t * glob(3) wildcards. NB. string can grow\n\t\t\t\t * here.\n\t\t\t\t */\n\t\t\t\tif (j >= sizeof(argvs) - 3)\n\t\t\t\t\tgoto args_too_longs;\n\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\targvs[j++] = arg[i];\n\t\t\t} else\n\t\t\t\targvs[j++] = arg[i];\n\t\t}\n\t\ti++;\n\t}\n\t*argcp = argc;\n\treturn argv;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MAXARGLEN\t8192",
      "#define MAXARGS \t128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unterminated quoted argument\""
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char)arg[i]"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "arg"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAXARGLEN\t8192\n#define MAXARGS \t128\n\nstatic char **\nmakeargv(const char *arg, int *argcp, int sloppy, char *lastquote,\n    u_int *terminated)\n{\n\tint argc, quot;\n\tsize_t i, j;\n\tstatic char argvs[MAXARGLEN];\n\tstatic char *argv[MAXARGS + 1];\n\tenum { MA_START, MA_SQUOTE, MA_DQUOTE, MA_UNQUOTED } state, q;\n\n\t*argcp = argc = 0;\n\tif (strlen(arg) > sizeof(argvs) - 1) {\n args_too_longs:\n\t\terror(\"string too long\");\n\t\treturn NULL;\n\t}\n\tif (terminated != NULL)\n\t\t*terminated = 1;\n\tif (lastquote != NULL)\n\t\t*lastquote = '\\0';\n\tstate = MA_START;\n\ti = j = 0;\n\tfor (;;) {\n\t\tif ((size_t)argc >= sizeof(argv) / sizeof(*argv)){\n\t\t\terror(\"Too many arguments.\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (isspace((unsigned char)arg[i])) {\n\t\t\tif (state == MA_UNQUOTED) {\n\t\t\t\t/* Terminate current argument */\n\t\t\t\targvs[j++] = '\\0';\n\t\t\t\targc++;\n\t\t\t\tstate = MA_START;\n\t\t\t} else if (state != MA_START)\n\t\t\t\targvs[j++] = arg[i];\n\t\t} else if (arg[i] == '\"' || arg[i] == '\\'') {\n\t\t\tq = arg[i] == '\"' ? MA_DQUOTE : MA_SQUOTE;\n\t\t\tif (state == MA_START) {\n\t\t\t\targv[argc] = argvs + j;\n\t\t\t\tstate = q;\n\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t*lastquote = arg[i];\n\t\t\t} else if (state == MA_UNQUOTED)\n\t\t\t\tstate = q;\n\t\t\telse if (state == q)\n\t\t\t\tstate = MA_UNQUOTED;\n\t\t\telse\n\t\t\t\targvs[j++] = arg[i];\n\t\t} else if (arg[i] == '\\\\') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE) {\n\t\t\t\tquot = state == MA_SQUOTE ? '\\'' : '\"';\n\t\t\t\t/* Unescape quote we are in */\n\t\t\t\t/* XXX support \\n and friends? */\n\t\t\t\tif (arg[i + 1] == quot) {\n\t\t\t\t\ti++;\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else if (arg[i + 1] == '?' ||\n\t\t\t\t    arg[i + 1] == '[' || arg[i + 1] == '*') {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special case for sftp: append\n\t\t\t\t\t * double-escaped glob sequence -\n\t\t\t\t\t * glob will undo one level of\n\t\t\t\t\t * escaping. NB. string can grow here.\n\t\t\t\t\t */\n\t\t\t\t\tif (j >= sizeof(argvs) - 5)\n\t\t\t\t\t\tgoto args_too_longs;\n\t\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else {\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (state == MA_START) {\n\t\t\t\t\targv[argc] = argvs + j;\n\t\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t\t*lastquote = '\\0';\n\t\t\t\t}\n\t\t\t\tif (arg[i + 1] == '?' || arg[i + 1] == '[' ||\n\t\t\t\t    arg[i + 1] == '*' || arg[i + 1] == '\\\\') {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special case for sftp: append\n\t\t\t\t\t * escaped glob sequence -\n\t\t\t\t\t * glob will undo one level of\n\t\t\t\t\t * escaping.\n\t\t\t\t\t */\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else {\n\t\t\t\t\t/* Unescape everything */\n\t\t\t\t\t/* XXX support \\n and friends? */\n\t\t\t\t\ti++;\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arg[i] == '#') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE)\n\t\t\t\targvs[j++] = arg[i];\n\t\t\telse\n\t\t\t\tgoto string_done;\n\t\t} else if (arg[i] == '\\0') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE) {\n\t\t\t\tif (sloppy) {\n\t\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\t\tif (terminated != NULL)\n\t\t\t\t\t\t*terminated = 0;\n\t\t\t\t\tgoto string_done;\n\t\t\t\t}\n\t\t\t\terror(\"Unterminated quoted argument\");\n\t\t\t\treturn NULL;\n\t\t\t}\n string_done:\n\t\t\tif (state == MA_UNQUOTED) {\n\t\t\t\targvs[j++] = '\\0';\n\t\t\t\targc++;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (state == MA_START) {\n\t\t\t\targv[argc] = argvs + j;\n\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t*lastquote = '\\0';\n\t\t\t}\n\t\t\tif ((state == MA_SQUOTE || state == MA_DQUOTE) &&\n\t\t\t    (arg[i] == '?' || arg[i] == '[' || arg[i] == '*')) {\n\t\t\t\t/*\n\t\t\t\t * Special case for sftp: escape quoted\n\t\t\t\t * glob(3) wildcards. NB. string can grow\n\t\t\t\t * here.\n\t\t\t\t */\n\t\t\t\tif (j >= sizeof(argvs) - 3)\n\t\t\t\t\tgoto args_too_longs;\n\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\targvs[j++] = arg[i];\n\t\t\t} else\n\t\t\t\targvs[j++] = arg[i];\n\t\t}\n\t\ti++;\n\t}\n\t*argcp = argc;\n\treturn argv;\n}"
  },
  {
    "function_name": "undo_glob_escape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "1098-1131",
    "snippet": "static void\nundo_glob_escape(char *s)\n{\n\tsize_t i, j;\n\n\tfor (i = j = 0;;) {\n\t\tif (s[i] == '\\0') {\n\t\t\ts[j] = '\\0';\n\t\t\treturn;\n\t\t}\n\t\tif (s[i] != '\\\\') {\n\t\t\ts[j++] = s[i++];\n\t\t\tcontinue;\n\t\t}\n\t\t/* s[i] == '\\\\' */\n\t\t++i;\n\t\tswitch (s[i]) {\n\t\tcase '?':\n\t\tcase '[':\n\t\tcase '*':\n\t\tcase '\\\\':\n\t\t\ts[j++] = s[i++];\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\ts[j++] = '\\\\';\n\t\t\ts[j] = '\\0';\n\t\t\treturn;\n\t\tdefault:\n\t\t\ts[j++] = '\\\\';\n\t\t\ts[j++] = s[i++];\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nundo_glob_escape(char *s)\n{\n\tsize_t i, j;\n\n\tfor (i = j = 0;;) {\n\t\tif (s[i] == '\\0') {\n\t\t\ts[j] = '\\0';\n\t\t\treturn;\n\t\t}\n\t\tif (s[i] != '\\\\') {\n\t\t\ts[j++] = s[i++];\n\t\t\tcontinue;\n\t\t}\n\t\t/* s[i] == '\\\\' */\n\t\t++i;\n\t\tswitch (s[i]) {\n\t\tcase '?':\n\t\tcase '[':\n\t\tcase '*':\n\t\tcase '\\\\':\n\t\t\ts[j++] = s[i++];\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\ts[j++] = '\\\\';\n\t\t\ts[j] = '\\0';\n\t\t\treturn;\n\t\tdefault:\n\t\t\ts[j++] = '\\\\';\n\t\t\ts[j++] = s[i++];\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "do_df",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "1035-1091",
    "snippet": "static int\ndo_df(struct sftp_conn *conn, const char *path, int hflag, int iflag)\n{\n\tstruct sftp_statvfs st;\n\tchar s_used[FMT_SCALED_STRSIZE], s_avail[FMT_SCALED_STRSIZE];\n\tchar s_root[FMT_SCALED_STRSIZE], s_total[FMT_SCALED_STRSIZE];\n\tchar s_icapacity[16], s_dcapacity[16];\n\n\tif (do_statvfs(conn, path, &st, 1) == -1)\n\t\treturn -1;\n\tif (st.f_files == 0)\n\t\tstrlcpy(s_icapacity, \"ERR\", sizeof(s_icapacity));\n\telse {\n\t\tsnprintf(s_icapacity, sizeof(s_icapacity), \"%3llu%%\",\n\t\t    (unsigned long long)(100 * (st.f_files - st.f_ffree) /\n\t\t    st.f_files));\n\t}\n\tif (st.f_blocks == 0)\n\t\tstrlcpy(s_dcapacity, \"ERR\", sizeof(s_dcapacity));\n\telse {\n\t\tsnprintf(s_dcapacity, sizeof(s_dcapacity), \"%3llu%%\",\n\t\t    (unsigned long long)(100 * (st.f_blocks - st.f_bfree) /\n\t\t    st.f_blocks));\n\t}\n\tif (iflag) {\n\t\tprintf(\"     Inodes        Used       Avail      \"\n\t\t    \"(root)    %%Capacity\\n\");\n\t\tprintf(\"%11llu %11llu %11llu %11llu         %s\\n\",\n\t\t    (unsigned long long)st.f_files,\n\t\t    (unsigned long long)(st.f_files - st.f_ffree),\n\t\t    (unsigned long long)st.f_favail,\n\t\t    (unsigned long long)st.f_ffree, s_icapacity);\n\t} else if (hflag) {\n\t\tstrlcpy(s_used, \"error\", sizeof(s_used));\n\t\tstrlcpy(s_avail, \"error\", sizeof(s_avail));\n\t\tstrlcpy(s_root, \"error\", sizeof(s_root));\n\t\tstrlcpy(s_total, \"error\", sizeof(s_total));\n\t\tfmt_scaled((st.f_blocks - st.f_bfree) * st.f_frsize, s_used);\n\t\tfmt_scaled(st.f_bavail * st.f_frsize, s_avail);\n\t\tfmt_scaled(st.f_bfree * st.f_frsize, s_root);\n\t\tfmt_scaled(st.f_blocks * st.f_frsize, s_total);\n\t\tprintf(\"    Size     Used    Avail   (root)    %%Capacity\\n\");\n\t\tprintf(\"%7sB %7sB %7sB %7sB         %s\\n\",\n\t\t    s_total, s_used, s_avail, s_root, s_dcapacity);\n\t} else {\n\t\tprintf(\"        Size         Used        Avail       \"\n\t\t    \"(root)    %%Capacity\\n\");\n\t\tprintf(\"%12llu %12llu %12llu %12llu         %s\\n\",\n\t\t    (unsigned long long)(st.f_frsize * st.f_blocks / 1024),\n\t\t    (unsigned long long)(st.f_frsize *\n\t\t    (st.f_blocks - st.f_bfree) / 1024),\n\t\t    (unsigned long long)(st.f_frsize * st.f_bavail / 1024),\n\t\t    (unsigned long long)(st.f_frsize * st.f_bfree / 1024),\n\t\t    s_dcapacity);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%12llu %12llu %12llu %12llu         %s\\n\"",
            "(unsigned long long)(st.f_frsize * st.f_blocks / 1024)",
            "(unsigned long long)(st.f_frsize *\n\t\t    (st.f_blocks - st.f_bfree) / 1024)",
            "(unsigned long long)(st.f_frsize * st.f_bavail / 1024)",
            "(unsigned long long)(st.f_frsize * st.f_bfree / 1024)",
            "s_dcapacity"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"        Size         Used        Avail       \"\n\t\t    \"(root)    %%Capacity\\n\""
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmt_scaled",
          "args": [
            "st.f_blocks * st.f_frsize",
            "s_total"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_scaled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fmt_scaled.c",
          "lines": "218-276",
          "snippet": "int\nfmt_scaled(long long number, char *result)\n{\n\tlong long abval, fract = 0;\n\tunsigned int i;\n\tunit_type unit = NONE;\n\n\tabval = llabs(number);\n\n\t/* Not every negative long long has a positive representation.\n\t * Also check for numbers that are just too darned big to format\n\t */\n\tif (abval < 0 || abval / 1024 >= scale_factors[SCALE_LENGTH-1]) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\n\t/* scale whole part; get unscaled fraction */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\t\tif (abval/1024 < scale_factors[i]) {\n\t\t\tunit = units[i];\n\t\t\tfract = (i == 0) ? 0 : abval % scale_factors[i];\n\t\t\tnumber /= scale_factors[i];\n\t\t\tif (i > 0)\n\t\t\t\tfract /= scale_factors[i - 1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfract = (10 * fract + 512) / 1024;\n\t/* if the result would be >= 10, round main number */\n\tif (fract >= 10) {\n\t\tif (number >= 0)\n\t\t\tnumber++;\n\t\telse\n\t\t\tnumber--;\n\t\tfract = 0;\n\t} else if (fract < 0) {\n\t\t/* shouldn't happen */\n\t\tfract = 0;\n\t}\n\n\tif (number == 0)\n\t\tstrlcpy(result, \"0B\", FMT_SCALED_STRSIZE);\n\telse if (unit == NONE || number >= 100 || number <= -100) {\n\t\tif (fract >= 5) {\n\t\t\tif (number >= 0)\n\t\t\t\tnumber++;\n\t\t\telse\n\t\t\t\tnumber--;\n\t\t}\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld%c\",\n\t\t\tnumber, scale_chars[unit]);\n\t} else\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld.%1lld%c\",\n\t\t\tnumber, fract, scale_chars[unit]);\n\n\treturn 0;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"includes.h\"\n\n#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))\n\nint\nfmt_scaled(long long number, char *result)\n{\n\tlong long abval, fract = 0;\n\tunsigned int i;\n\tunit_type unit = NONE;\n\n\tabval = llabs(number);\n\n\t/* Not every negative long long has a positive representation.\n\t * Also check for numbers that are just too darned big to format\n\t */\n\tif (abval < 0 || abval / 1024 >= scale_factors[SCALE_LENGTH-1]) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\n\t/* scale whole part; get unscaled fraction */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\t\tif (abval/1024 < scale_factors[i]) {\n\t\t\tunit = units[i];\n\t\t\tfract = (i == 0) ? 0 : abval % scale_factors[i];\n\t\t\tnumber /= scale_factors[i];\n\t\t\tif (i > 0)\n\t\t\t\tfract /= scale_factors[i - 1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfract = (10 * fract + 512) / 1024;\n\t/* if the result would be >= 10, round main number */\n\tif (fract >= 10) {\n\t\tif (number >= 0)\n\t\t\tnumber++;\n\t\telse\n\t\t\tnumber--;\n\t\tfract = 0;\n\t} else if (fract < 0) {\n\t\t/* shouldn't happen */\n\t\tfract = 0;\n\t}\n\n\tif (number == 0)\n\t\tstrlcpy(result, \"0B\", FMT_SCALED_STRSIZE);\n\telse if (unit == NONE || number >= 100 || number <= -100) {\n\t\tif (fract >= 5) {\n\t\t\tif (number >= 0)\n\t\t\t\tnumber++;\n\t\t\telse\n\t\t\t\tnumber--;\n\t\t}\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld%c\",\n\t\t\tnumber, scale_chars[unit]);\n\t} else\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld.%1lld%c\",\n\t\t\tnumber, fract, scale_chars[unit]);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "s_total",
            "\"error\"",
            "sizeof(s_total)"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "s_dcapacity",
            "sizeof(s_dcapacity)",
            "\"%3llu%%\"",
            "(unsigned long long)(100 * (st.f_blocks - st.f_bfree) /\n\t\t    st.f_blocks)"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_statvfs",
          "args": [
            "conn",
            "path",
            "&st",
            "1"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "do_statvfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1082-1109",
          "snippet": "int\ndo_statvfs(struct sftp_conn *conn, const char *path, struct sftp_statvfs *st,\n    int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\tint r;\n\n\tif ((conn->exts & SFTP_EXT_STATVFS) == 0) {\n\t\terror(\"Server does not support statvfs@openssh.com extension\");\n\t\treturn -1;\n\t}\n\n\tid = conn->msg_id++;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsshbuf_reset(msg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"statvfs@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, path)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n\n\treturn get_decode_statvfs(conn, st, id, quiet);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SFTP_EXT_STATVFS\t0x00000002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SFTP_EXT_STATVFS\t0x00000002\n\nint\ndo_statvfs(struct sftp_conn *conn, const char *path, struct sftp_statvfs *st,\n    int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\tint r;\n\n\tif ((conn->exts & SFTP_EXT_STATVFS) == 0) {\n\t\terror(\"Server does not support statvfs@openssh.com extension\");\n\t\treturn -1;\n\t}\n\n\tid = conn->msg_id++;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsshbuf_reset(msg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"statvfs@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, path)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n\n\treturn get_decode_statvfs(conn, st, id, quiet);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndo_df(struct sftp_conn *conn, const char *path, int hflag, int iflag)\n{\n\tstruct sftp_statvfs st;\n\tchar s_used[FMT_SCALED_STRSIZE], s_avail[FMT_SCALED_STRSIZE];\n\tchar s_root[FMT_SCALED_STRSIZE], s_total[FMT_SCALED_STRSIZE];\n\tchar s_icapacity[16], s_dcapacity[16];\n\n\tif (do_statvfs(conn, path, &st, 1) == -1)\n\t\treturn -1;\n\tif (st.f_files == 0)\n\t\tstrlcpy(s_icapacity, \"ERR\", sizeof(s_icapacity));\n\telse {\n\t\tsnprintf(s_icapacity, sizeof(s_icapacity), \"%3llu%%\",\n\t\t    (unsigned long long)(100 * (st.f_files - st.f_ffree) /\n\t\t    st.f_files));\n\t}\n\tif (st.f_blocks == 0)\n\t\tstrlcpy(s_dcapacity, \"ERR\", sizeof(s_dcapacity));\n\telse {\n\t\tsnprintf(s_dcapacity, sizeof(s_dcapacity), \"%3llu%%\",\n\t\t    (unsigned long long)(100 * (st.f_blocks - st.f_bfree) /\n\t\t    st.f_blocks));\n\t}\n\tif (iflag) {\n\t\tprintf(\"     Inodes        Used       Avail      \"\n\t\t    \"(root)    %%Capacity\\n\");\n\t\tprintf(\"%11llu %11llu %11llu %11llu         %s\\n\",\n\t\t    (unsigned long long)st.f_files,\n\t\t    (unsigned long long)(st.f_files - st.f_ffree),\n\t\t    (unsigned long long)st.f_favail,\n\t\t    (unsigned long long)st.f_ffree, s_icapacity);\n\t} else if (hflag) {\n\t\tstrlcpy(s_used, \"error\", sizeof(s_used));\n\t\tstrlcpy(s_avail, \"error\", sizeof(s_avail));\n\t\tstrlcpy(s_root, \"error\", sizeof(s_root));\n\t\tstrlcpy(s_total, \"error\", sizeof(s_total));\n\t\tfmt_scaled((st.f_blocks - st.f_bfree) * st.f_frsize, s_used);\n\t\tfmt_scaled(st.f_bavail * st.f_frsize, s_avail);\n\t\tfmt_scaled(st.f_bfree * st.f_frsize, s_root);\n\t\tfmt_scaled(st.f_blocks * st.f_frsize, s_total);\n\t\tprintf(\"    Size     Used    Avail   (root)    %%Capacity\\n\");\n\t\tprintf(\"%7sB %7sB %7sB %7sB         %s\\n\",\n\t\t    s_total, s_used, s_avail, s_root, s_dcapacity);\n\t} else {\n\t\tprintf(\"        Size         Used        Avail       \"\n\t\t    \"(root)    %%Capacity\\n\");\n\t\tprintf(\"%12llu %12llu %12llu %12llu         %s\\n\",\n\t\t    (unsigned long long)(st.f_frsize * st.f_blocks / 1024),\n\t\t    (unsigned long long)(st.f_frsize *\n\t\t    (st.f_blocks - st.f_bfree) / 1024),\n\t\t    (unsigned long long)(st.f_frsize * st.f_bavail / 1024),\n\t\t    (unsigned long long)(st.f_frsize * st.f_bfree / 1024),\n\t\t    s_dcapacity);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "do_globbed_ls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "929-1033",
    "snippet": "static int\ndo_globbed_ls(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tchar *fname, *lname;\n\tglob_t g;\n\tint err, r;\n\tstruct winsize ws;\n\tu_int i, j, nentries, *indices = NULL, c = 1;\n\tu_int colspace = 0, columns = 1, m = 0, width = 80;\n\n\tmemset(&g, 0, sizeof(g));\n\n\tif ((r = remote_glob(conn, path,\n\t    GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE|GLOB_KEEPSTAT|GLOB_NOSORT,\n\t    NULL, &g)) != 0 ||\n\t    (g.gl_pathc && !g.gl_matchc)) {\n\t\tif (g.gl_pathc)\n\t\t\tglobfree(&g);\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Can't ls: Too many matches for \\\"%s\\\"\", path);\n\t\t} else {\n\t\t\terror(\"Can't ls: \\\"%s\\\" not found\", path);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (interrupted)\n\t\tgoto out;\n\n\t/*\n\t * If the glob returns a single match and it is a directory,\n\t * then just list its contents.\n\t */\n\tif (g.gl_matchc == 1 && g.gl_statv[0] != NULL &&\n\t    S_ISDIR(g.gl_statv[0]->st_mode)) {\n\t\terr = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);\n\t\tglobfree(&g);\n\t\treturn err;\n\t}\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (i = 0; g.gl_pathv[i]; i++)\n\t\t\tm = MAXIMUM(m, strlen(g.gl_pathv[i]));\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t}\n\n\t/*\n\t * Sorting: rather than mess with the contents of glob_t, prepare\n\t * an array of indices into it and sort that. For the usual\n\t * unsorted case, the indices are just the identity 1=1, 2=2, etc.\n\t */\n\tfor (nentries = 0; g.gl_pathv[nentries] != NULL; nentries++)\n\t\t;\t/* count entries */\n\tindices = calloc(nentries, sizeof(*indices));\n\tfor (i = 0; i < nentries; i++)\n\t\tindices[i] = i;\n\n\tif (lflag & SORT_FLAGS) {\n\t\tsort_glob = &g;\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(indices, nentries, sizeof(*indices), sglob_comp);\n\t\tsort_glob = NULL;\n\t}\n\n\tfor (j = 0; j < nentries && !interrupted; j++) {\n\t\ti = indices[j];\n\t\tfname = path_strip(g.gl_pathv[i], strip_path);\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (g.gl_statv[i] == NULL) {\n\t\t\t\terror(\"no stat information for %s\", fname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlname = ls_file(fname, g.gl_statv[i], 1,\n\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\tfree(lname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n out:\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(indices);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)",
      "#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */",
      "#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */",
      "#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */",
      "#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */"
    ],
    "globals_used": [
      "volatile sig_atomic_t interrupted = 0;",
      "int sort_flag;",
      "glob_t *sort_glob;",
      "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "indices"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "globfree",
          "args": [
            "&g"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "globfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "959-981",
          "snippet": "void\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nvoid\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_file",
          "args": [
            "fname",
            "g.gl_statv[i]",
            "1",
            "(lflag & LS_SI_UNITS)"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "ls_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "213-258",
          "snippet": "char *\nls_file(const char *name, const struct stat *st, int remote, int si_units)\n{\n\tint ulen, glen, sz = 0;\n\tstruct tm *ltime = localtime(&st->st_mtime);\n\tconst char *user, *group;\n\tchar buf[1024], lc[8], mode[11+1], tbuf[12+1], ubuf[11+1], gbuf[11+1];\n\tchar sbuf[FMT_SCALED_STRSIZE];\n\ttime_t now;\n\n\tstrmode(st->st_mode, mode);\n\tif (remote) {\n\t\tsnprintf(ubuf, sizeof ubuf, \"%u\", (u_int)st->st_uid);\n\t\tuser = ubuf;\n\t\tsnprintf(gbuf, sizeof gbuf, \"%u\", (u_int)st->st_gid);\n\t\tgroup = gbuf;\n\t\tstrlcpy(lc, \"?\", sizeof(lc));\n\t} else {\n\t\tuser = user_from_uid(st->st_uid, 0);\n\t\tgroup = group_from_gid(st->st_gid, 0);\n\t\tsnprintf(lc, sizeof(lc), \"%u\", (u_int)st->st_nlink);\n\t}\n\tif (ltime != NULL) {\n\t\tnow = time(NULL);\n\t\tif (now - (365*24*60*60)/2 < st->st_mtime &&\n\t\t    now >= st->st_mtime)\n\t\t\tsz = strftime(tbuf, sizeof tbuf, \"%b %e %H:%M\", ltime);\n\t\telse\n\t\t\tsz = strftime(tbuf, sizeof tbuf, \"%b %e  %Y\", ltime);\n\t}\n\tif (sz == 0)\n\t\ttbuf[0] = '\\0';\n\tulen = MAXIMUM(strlen(user), 8);\n\tglen = MAXIMUM(strlen(group), 8);\n\tif (si_units) {\n\t\tfmt_scaled((long long)st->st_size, sbuf);\n\t\tsnprintf(buf, sizeof buf, \"%s %3s %-*s %-*s %8s %s %s\",\n\t\t    mode, lc, ulen, user, glen, group,\n\t\t    sbuf, tbuf, name);\n\t} else {\n\t\tsnprintf(buf, sizeof buf, \"%s %3s %-*s %-*s %8llu %s %s\",\n\t\t    mode, lc, ulen, user, glen, group,\n\t\t    (unsigned long long)st->st_size, tbuf, name);\n\t}\n\treturn xstrdup(buf);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nls_file(const char *name, const struct stat *st, int remote, int si_units)\n{\n\tint ulen, glen, sz = 0;\n\tstruct tm *ltime = localtime(&st->st_mtime);\n\tconst char *user, *group;\n\tchar buf[1024], lc[8], mode[11+1], tbuf[12+1], ubuf[11+1], gbuf[11+1];\n\tchar sbuf[FMT_SCALED_STRSIZE];\n\ttime_t now;\n\n\tstrmode(st->st_mode, mode);\n\tif (remote) {\n\t\tsnprintf(ubuf, sizeof ubuf, \"%u\", (u_int)st->st_uid);\n\t\tuser = ubuf;\n\t\tsnprintf(gbuf, sizeof gbuf, \"%u\", (u_int)st->st_gid);\n\t\tgroup = gbuf;\n\t\tstrlcpy(lc, \"?\", sizeof(lc));\n\t} else {\n\t\tuser = user_from_uid(st->st_uid, 0);\n\t\tgroup = group_from_gid(st->st_gid, 0);\n\t\tsnprintf(lc, sizeof(lc), \"%u\", (u_int)st->st_nlink);\n\t}\n\tif (ltime != NULL) {\n\t\tnow = time(NULL);\n\t\tif (now - (365*24*60*60)/2 < st->st_mtime &&\n\t\t    now >= st->st_mtime)\n\t\t\tsz = strftime(tbuf, sizeof tbuf, \"%b %e %H:%M\", ltime);\n\t\telse\n\t\t\tsz = strftime(tbuf, sizeof tbuf, \"%b %e  %Y\", ltime);\n\t}\n\tif (sz == 0)\n\t\ttbuf[0] = '\\0';\n\tulen = MAXIMUM(strlen(user), 8);\n\tglen = MAXIMUM(strlen(group), 8);\n\tif (si_units) {\n\t\tfmt_scaled((long long)st->st_size, sbuf);\n\t\tsnprintf(buf, sizeof buf, \"%s %3s %-*s %-*s %8s %s %s\",\n\t\t    mode, lc, ulen, user, glen, group,\n\t\t    sbuf, tbuf, name);\n\t} else {\n\t\tsnprintf(buf, sizeof buf, \"%s %3s %-*s %-*s %8llu %s %s\",\n\t\t    mode, lc, ulen, user, glen, group,\n\t\t    (unsigned long long)st->st_size, tbuf, name);\n\t}\n\treturn xstrdup(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"no stat information for %s\"",
            "fname"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_strip",
          "args": [
            "g.gl_pathv[i]",
            "strip_path"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "path_strip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "368-384",
          "snippet": "static char *\npath_strip(const char *path, const char *strip)\n{\n\tsize_t len;\n\n\tif (strip == NULL)\n\t\treturn (xstrdup(path));\n\n\tlen = strlen(strip);\n\tif (strncmp(path, strip, len) == 0) {\n\t\tif (strip[len - 1] != '/' && path[len] == '/')\n\t\t\tlen++;\n\t\treturn (xstrdup(path + len));\n\t}\n\n\treturn (xstrdup(path));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\npath_strip(const char *path, const char *strip)\n{\n\tsize_t len;\n\n\tif (strip == NULL)\n\t\treturn (xstrdup(path));\n\n\tlen = strlen(strip);\n\tif (strncmp(path, strip, len) == 0) {\n\t\tif (strip[len - 1] != '/' && path[len] == '/')\n\t\t\tlen++;\n\t\treturn (xstrdup(path + len));\n\t}\n\n\treturn (xstrdup(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "indices",
            "nentries",
            "sizeof(*indices)",
            "sglob_comp"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "nentries",
            "sizeof(*indices)"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "columns",
            "1"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "m",
            "strlen(g.gl_pathv[i])"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "g.gl_pathv[i]"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fileno(stdin)",
            "TIOCGWINSZ",
            "&ws"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_ls_dir",
          "args": [
            "conn",
            "g.gl_pathv[0]",
            "strip_path",
            "lflag"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "do_ls_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "815-898",
          "snippet": "static int\ndo_ls_dir(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tint n;\n\tu_int c = 1, colspace = 0, columns = 1;\n\tSFTP_DIRENT **d;\n\n\tif ((n = do_readdir(conn, path, &d)) != 0)\n\t\treturn (n);\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\tu_int m = 0, width = 80;\n\t\tstruct winsize ws;\n\t\tchar *tmp;\n\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (n = 0; d[n] != NULL; n++) {\n\t\t\tif (d[n]->filename[0] != '.' || (lflag & LS_SHOW_ALL))\n\t\t\t\tm = MAXIMUM(m, strlen(d[n]->filename));\n\t\t}\n\n\t\t/* Add any subpath that also needs to be counted */\n\t\ttmp = path_strip(path, strip_path);\n\t\tm += strlen(tmp);\n\t\tfree(tmp);\n\n\t\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\t\twidth = ws.ws_col;\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t\tcolspace = MINIMUM(colspace, width);\n\t}\n\n\tif (lflag & SORT_FLAGS) {\n\t\tfor (n = 0; d[n] != NULL; n++)\n\t\t\t;\t/* count entries */\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(d, n, sizeof(*d), sdirent_comp);\n\t}\n\n\tfor (n = 0; d[n] != NULL && !interrupted; n++) {\n\t\tchar *tmp, *fname;\n\n\t\tif (d[n]->filename[0] == '.' && !(lflag & LS_SHOW_ALL))\n\t\t\tcontinue;\n\n\t\ttmp = path_append(path, d[n]->filename);\n\t\tfname = path_strip(tmp, strip_path);\n\t\tfree(tmp);\n\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (lflag & (LS_NUMERIC_VIEW|LS_SI_UNITS)) {\n\t\t\t\tchar *lname;\n\t\t\t\tstruct stat sb;\n\n\t\t\t\tmemset(&sb, 0, sizeof(sb));\n\t\t\t\tattrib_to_stat(&d[n]->a, &sb);\n\t\t\t\tlname = ls_file(fname, &sb, 1,\n\t\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\t\tfree(lname);\n\t\t\t} else\n\t\t\t\tmprintf(\"%s\\n\", d[n]->longname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n\tfree_sftp_dirents(d);\n\treturn (0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)",
            "#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */",
            "#define LS_SHOW_ALL\t0x0080\t/* Don't skip filenames starting with '.' */",
            "#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */",
            "#define LS_NUMERIC_VIEW\t0x0004\t/* Long view with numeric uid/gid */",
            "#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */",
            "#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */"
          ],
          "globals_used": [
            "volatile sig_atomic_t interrupted = 0;",
            "int sort_flag;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)\n#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */\n#define LS_SHOW_ALL\t0x0080\t/* Don't skip filenames starting with '.' */\n#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */\n#define LS_NUMERIC_VIEW\t0x0004\t/* Long view with numeric uid/gid */\n#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */\n#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */\n\nvolatile sig_atomic_t interrupted = 0;\nint sort_flag;\n\nstatic int\ndo_ls_dir(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tint n;\n\tu_int c = 1, colspace = 0, columns = 1;\n\tSFTP_DIRENT **d;\n\n\tif ((n = do_readdir(conn, path, &d)) != 0)\n\t\treturn (n);\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\tu_int m = 0, width = 80;\n\t\tstruct winsize ws;\n\t\tchar *tmp;\n\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (n = 0; d[n] != NULL; n++) {\n\t\t\tif (d[n]->filename[0] != '.' || (lflag & LS_SHOW_ALL))\n\t\t\t\tm = MAXIMUM(m, strlen(d[n]->filename));\n\t\t}\n\n\t\t/* Add any subpath that also needs to be counted */\n\t\ttmp = path_strip(path, strip_path);\n\t\tm += strlen(tmp);\n\t\tfree(tmp);\n\n\t\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\t\twidth = ws.ws_col;\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t\tcolspace = MINIMUM(colspace, width);\n\t}\n\n\tif (lflag & SORT_FLAGS) {\n\t\tfor (n = 0; d[n] != NULL; n++)\n\t\t\t;\t/* count entries */\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(d, n, sizeof(*d), sdirent_comp);\n\t}\n\n\tfor (n = 0; d[n] != NULL && !interrupted; n++) {\n\t\tchar *tmp, *fname;\n\n\t\tif (d[n]->filename[0] == '.' && !(lflag & LS_SHOW_ALL))\n\t\t\tcontinue;\n\n\t\ttmp = path_append(path, d[n]->filename);\n\t\tfname = path_strip(tmp, strip_path);\n\t\tfree(tmp);\n\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (lflag & (LS_NUMERIC_VIEW|LS_SI_UNITS)) {\n\t\t\t\tchar *lname;\n\t\t\t\tstruct stat sb;\n\n\t\t\t\tmemset(&sb, 0, sizeof(sb));\n\t\t\t\tattrib_to_stat(&d[n]->a, &sb);\n\t\t\t\tlname = ls_file(fname, &sb, 1,\n\t\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\t\tfree(lname);\n\t\t\t} else\n\t\t\t\tmprintf(\"%s\\n\", d[n]->longname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n\tfree_sftp_dirents(d);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "g.gl_statv[0]->st_mode"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remote_glob",
          "args": [
            "conn",
            "path",
            "GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE|GLOB_KEEPSTAT|GLOB_NOSORT",
            "NULL",
            "&g"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "remote_glob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-glob.c",
          "lines": "136-150",
          "snippet": "int\nremote_glob(struct sftp_conn *conn, const char *pattern, int flags,\n    int (*errfunc)(const char *, int), glob_t *pglob)\n{\n\tpglob->gl_opendir = fudge_opendir;\n\tpglob->gl_readdir = (struct dirent *(*)(void *))fudge_readdir;\n\tpglob->gl_closedir = (void (*)(void *))fudge_closedir;\n\tpglob->gl_lstat = fudge_lstat;\n\tpglob->gl_stat = fudge_stat;\n\n\tmemset(&cur, 0, sizeof(cur));\n\tcur.conn = conn;\n\n\treturn(glob(pattern, flags | GLOB_ALTDIRFUNC, errfunc, pglob));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <dirent.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);",
            "static struct {\n\tstruct sftp_conn *conn;\n} cur;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <dirent.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\nstatic struct {\n\tstruct sftp_conn *conn;\n} cur;\n\nint\nremote_glob(struct sftp_conn *conn, const char *pattern, int flags,\n    int (*errfunc)(const char *, int), glob_t *pglob)\n{\n\tpglob->gl_opendir = fudge_opendir;\n\tpglob->gl_readdir = (struct dirent *(*)(void *))fudge_readdir;\n\tpglob->gl_closedir = (void (*)(void *))fudge_closedir;\n\tpglob->gl_lstat = fudge_lstat;\n\tpglob->gl_stat = fudge_stat;\n\n\tmemset(&cur, 0, sizeof(cur));\n\tcur.conn = conn;\n\n\treturn(glob(pattern, flags | GLOB_ALTDIRFUNC, errfunc, pglob));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&g",
            "0",
            "sizeof(g)"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)\n#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */\n#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */\n#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */\n#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */\n\nvolatile sig_atomic_t interrupted = 0;\nint sort_flag;\nglob_t *sort_glob;\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\n\nstatic int\ndo_globbed_ls(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tchar *fname, *lname;\n\tglob_t g;\n\tint err, r;\n\tstruct winsize ws;\n\tu_int i, j, nentries, *indices = NULL, c = 1;\n\tu_int colspace = 0, columns = 1, m = 0, width = 80;\n\n\tmemset(&g, 0, sizeof(g));\n\n\tif ((r = remote_glob(conn, path,\n\t    GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE|GLOB_KEEPSTAT|GLOB_NOSORT,\n\t    NULL, &g)) != 0 ||\n\t    (g.gl_pathc && !g.gl_matchc)) {\n\t\tif (g.gl_pathc)\n\t\t\tglobfree(&g);\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Can't ls: Too many matches for \\\"%s\\\"\", path);\n\t\t} else {\n\t\t\terror(\"Can't ls: \\\"%s\\\" not found\", path);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (interrupted)\n\t\tgoto out;\n\n\t/*\n\t * If the glob returns a single match and it is a directory,\n\t * then just list its contents.\n\t */\n\tif (g.gl_matchc == 1 && g.gl_statv[0] != NULL &&\n\t    S_ISDIR(g.gl_statv[0]->st_mode)) {\n\t\terr = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);\n\t\tglobfree(&g);\n\t\treturn err;\n\t}\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (i = 0; g.gl_pathv[i]; i++)\n\t\t\tm = MAXIMUM(m, strlen(g.gl_pathv[i]));\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t}\n\n\t/*\n\t * Sorting: rather than mess with the contents of glob_t, prepare\n\t * an array of indices into it and sort that. For the usual\n\t * unsorted case, the indices are just the identity 1=1, 2=2, etc.\n\t */\n\tfor (nentries = 0; g.gl_pathv[nentries] != NULL; nentries++)\n\t\t;\t/* count entries */\n\tindices = calloc(nentries, sizeof(*indices));\n\tfor (i = 0; i < nentries; i++)\n\t\tindices[i] = i;\n\n\tif (lflag & SORT_FLAGS) {\n\t\tsort_glob = &g;\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(indices, nentries, sizeof(*indices), sglob_comp);\n\t\tsort_glob = NULL;\n\t}\n\n\tfor (j = 0; j < nentries && !interrupted; j++) {\n\t\ti = indices[j];\n\t\tfname = path_strip(g.gl_pathv[i], strip_path);\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (g.gl_statv[i] == NULL) {\n\t\t\t\terror(\"no stat information for %s\", fname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlname = ls_file(fname, g.gl_statv[i], 1,\n\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\tfree(lname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n out:\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(indices);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sglob_comp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "900-926",
    "snippet": "static int\nsglob_comp(const void *aa, const void *bb)\n{\n\tu_int a = *(const u_int *)aa;\n\tu_int b = *(const u_int *)bb;\n\tconst char *ap = sort_glob->gl_pathv[a];\n\tconst char *bp = sort_glob->gl_pathv[b];\n\tconst struct stat *as = sort_glob->gl_statv[a];\n\tconst struct stat *bs = sort_glob->gl_statv[b];\n\tint rmul = sort_flag & LS_REVERSE_SORT ? -1 : 1;\n\n#define NCMP(a,b) (a == b ? 0 : (a < b ? 1 : -1))\n\tif (sort_flag & LS_NAME_SORT)\n\t\treturn (rmul * strcmp(ap, bp));\n\telse if (sort_flag & LS_TIME_SORT) {\n#if defined(HAVE_STRUCT_STAT_ST_MTIM)\n\t\treturn (rmul * timespeccmp(&as->st_mtim, &bs->st_mtim, <));\n#elif defined(HAVE_STRUCT_STAT_ST_MTIME)\n\t\treturn (rmul * NCMP(as->st_mtime, bs->st_mtime));\n#else\n\treturn rmul * 1;\n#endif\n\t} else if (sort_flag & LS_SIZE_SORT)\n\t\treturn (rmul * NCMP(as->st_size, bs->st_size));\n\n\tfatal(\"Unknown ls sort type\");\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */",
      "#define LS_SIZE_SORT\t0x0020\t/* Sort by file size */",
      "#define LS_TIME_SORT\t0x0010\t/* Sort by mtime */",
      "#define LS_NAME_SORT\t0x0008\t/* Sort by name (default) */"
    ],
    "globals_used": [
      "int sort_flag;",
      "glob_t *sort_glob;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Unknown ls sort type\""
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCMP",
          "args": [
            "as->st_size",
            "bs->st_size"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCMP",
          "args": [
            "as->st_mtime",
            "bs->st_mtime"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespeccmp",
          "args": [
            "&as->st_mtim",
            "&bs->st_mtim, <"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ap",
            "bp"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */\n#define LS_SIZE_SORT\t0x0020\t/* Sort by file size */\n#define LS_TIME_SORT\t0x0010\t/* Sort by mtime */\n#define LS_NAME_SORT\t0x0008\t/* Sort by name (default) */\n\nint sort_flag;\nglob_t *sort_glob;\n\nstatic int\nsglob_comp(const void *aa, const void *bb)\n{\n\tu_int a = *(const u_int *)aa;\n\tu_int b = *(const u_int *)bb;\n\tconst char *ap = sort_glob->gl_pathv[a];\n\tconst char *bp = sort_glob->gl_pathv[b];\n\tconst struct stat *as = sort_glob->gl_statv[a];\n\tconst struct stat *bs = sort_glob->gl_statv[b];\n\tint rmul = sort_flag & LS_REVERSE_SORT ? -1 : 1;\n\n#define NCMP(a,b) (a == b ? 0 : (a < b ? 1 : -1))\n\tif (sort_flag & LS_NAME_SORT)\n\t\treturn (rmul * strcmp(ap, bp));\n\telse if (sort_flag & LS_TIME_SORT) {\n#if defined(HAVE_STRUCT_STAT_ST_MTIM)\n\t\treturn (rmul * timespeccmp(&as->st_mtim, &bs->st_mtim, <));\n#elif defined(HAVE_STRUCT_STAT_ST_MTIME)\n\t\treturn (rmul * NCMP(as->st_mtime, bs->st_mtime));\n#else\n\treturn rmul * 1;\n#endif\n\t} else if (sort_flag & LS_SIZE_SORT)\n\t\treturn (rmul * NCMP(as->st_size, bs->st_size));\n\n\tfatal(\"Unknown ls sort type\");\n}"
  },
  {
    "function_name": "do_ls_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "815-898",
    "snippet": "static int\ndo_ls_dir(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tint n;\n\tu_int c = 1, colspace = 0, columns = 1;\n\tSFTP_DIRENT **d;\n\n\tif ((n = do_readdir(conn, path, &d)) != 0)\n\t\treturn (n);\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\tu_int m = 0, width = 80;\n\t\tstruct winsize ws;\n\t\tchar *tmp;\n\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (n = 0; d[n] != NULL; n++) {\n\t\t\tif (d[n]->filename[0] != '.' || (lflag & LS_SHOW_ALL))\n\t\t\t\tm = MAXIMUM(m, strlen(d[n]->filename));\n\t\t}\n\n\t\t/* Add any subpath that also needs to be counted */\n\t\ttmp = path_strip(path, strip_path);\n\t\tm += strlen(tmp);\n\t\tfree(tmp);\n\n\t\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\t\twidth = ws.ws_col;\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t\tcolspace = MINIMUM(colspace, width);\n\t}\n\n\tif (lflag & SORT_FLAGS) {\n\t\tfor (n = 0; d[n] != NULL; n++)\n\t\t\t;\t/* count entries */\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(d, n, sizeof(*d), sdirent_comp);\n\t}\n\n\tfor (n = 0; d[n] != NULL && !interrupted; n++) {\n\t\tchar *tmp, *fname;\n\n\t\tif (d[n]->filename[0] == '.' && !(lflag & LS_SHOW_ALL))\n\t\t\tcontinue;\n\n\t\ttmp = path_append(path, d[n]->filename);\n\t\tfname = path_strip(tmp, strip_path);\n\t\tfree(tmp);\n\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (lflag & (LS_NUMERIC_VIEW|LS_SI_UNITS)) {\n\t\t\t\tchar *lname;\n\t\t\t\tstruct stat sb;\n\n\t\t\t\tmemset(&sb, 0, sizeof(sb));\n\t\t\t\tattrib_to_stat(&d[n]->a, &sb);\n\t\t\t\tlname = ls_file(fname, &sb, 1,\n\t\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\t\tfree(lname);\n\t\t\t} else\n\t\t\t\tmprintf(\"%s\\n\", d[n]->longname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n\tfree_sftp_dirents(d);\n\treturn (0);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)",
      "#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */",
      "#define LS_SHOW_ALL\t0x0080\t/* Don't skip filenames starting with '.' */",
      "#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */",
      "#define LS_NUMERIC_VIEW\t0x0004\t/* Long view with numeric uid/gid */",
      "#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */",
      "#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */"
    ],
    "globals_used": [
      "volatile sig_atomic_t interrupted = 0;",
      "int sort_flag;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_sftp_dirents",
          "args": [
            "d"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "free_sftp_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "681-693",
          "snippet": "void free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_file",
          "args": [
            "fname",
            "&sb",
            "1",
            "(lflag & LS_SI_UNITS)"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "ls_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "213-258",
          "snippet": "char *\nls_file(const char *name, const struct stat *st, int remote, int si_units)\n{\n\tint ulen, glen, sz = 0;\n\tstruct tm *ltime = localtime(&st->st_mtime);\n\tconst char *user, *group;\n\tchar buf[1024], lc[8], mode[11+1], tbuf[12+1], ubuf[11+1], gbuf[11+1];\n\tchar sbuf[FMT_SCALED_STRSIZE];\n\ttime_t now;\n\n\tstrmode(st->st_mode, mode);\n\tif (remote) {\n\t\tsnprintf(ubuf, sizeof ubuf, \"%u\", (u_int)st->st_uid);\n\t\tuser = ubuf;\n\t\tsnprintf(gbuf, sizeof gbuf, \"%u\", (u_int)st->st_gid);\n\t\tgroup = gbuf;\n\t\tstrlcpy(lc, \"?\", sizeof(lc));\n\t} else {\n\t\tuser = user_from_uid(st->st_uid, 0);\n\t\tgroup = group_from_gid(st->st_gid, 0);\n\t\tsnprintf(lc, sizeof(lc), \"%u\", (u_int)st->st_nlink);\n\t}\n\tif (ltime != NULL) {\n\t\tnow = time(NULL);\n\t\tif (now - (365*24*60*60)/2 < st->st_mtime &&\n\t\t    now >= st->st_mtime)\n\t\t\tsz = strftime(tbuf, sizeof tbuf, \"%b %e %H:%M\", ltime);\n\t\telse\n\t\t\tsz = strftime(tbuf, sizeof tbuf, \"%b %e  %Y\", ltime);\n\t}\n\tif (sz == 0)\n\t\ttbuf[0] = '\\0';\n\tulen = MAXIMUM(strlen(user), 8);\n\tglen = MAXIMUM(strlen(group), 8);\n\tif (si_units) {\n\t\tfmt_scaled((long long)st->st_size, sbuf);\n\t\tsnprintf(buf, sizeof buf, \"%s %3s %-*s %-*s %8s %s %s\",\n\t\t    mode, lc, ulen, user, glen, group,\n\t\t    sbuf, tbuf, name);\n\t} else {\n\t\tsnprintf(buf, sizeof buf, \"%s %3s %-*s %-*s %8llu %s %s\",\n\t\t    mode, lc, ulen, user, glen, group,\n\t\t    (unsigned long long)st->st_size, tbuf, name);\n\t}\n\treturn xstrdup(buf);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nls_file(const char *name, const struct stat *st, int remote, int si_units)\n{\n\tint ulen, glen, sz = 0;\n\tstruct tm *ltime = localtime(&st->st_mtime);\n\tconst char *user, *group;\n\tchar buf[1024], lc[8], mode[11+1], tbuf[12+1], ubuf[11+1], gbuf[11+1];\n\tchar sbuf[FMT_SCALED_STRSIZE];\n\ttime_t now;\n\n\tstrmode(st->st_mode, mode);\n\tif (remote) {\n\t\tsnprintf(ubuf, sizeof ubuf, \"%u\", (u_int)st->st_uid);\n\t\tuser = ubuf;\n\t\tsnprintf(gbuf, sizeof gbuf, \"%u\", (u_int)st->st_gid);\n\t\tgroup = gbuf;\n\t\tstrlcpy(lc, \"?\", sizeof(lc));\n\t} else {\n\t\tuser = user_from_uid(st->st_uid, 0);\n\t\tgroup = group_from_gid(st->st_gid, 0);\n\t\tsnprintf(lc, sizeof(lc), \"%u\", (u_int)st->st_nlink);\n\t}\n\tif (ltime != NULL) {\n\t\tnow = time(NULL);\n\t\tif (now - (365*24*60*60)/2 < st->st_mtime &&\n\t\t    now >= st->st_mtime)\n\t\t\tsz = strftime(tbuf, sizeof tbuf, \"%b %e %H:%M\", ltime);\n\t\telse\n\t\t\tsz = strftime(tbuf, sizeof tbuf, \"%b %e  %Y\", ltime);\n\t}\n\tif (sz == 0)\n\t\ttbuf[0] = '\\0';\n\tulen = MAXIMUM(strlen(user), 8);\n\tglen = MAXIMUM(strlen(group), 8);\n\tif (si_units) {\n\t\tfmt_scaled((long long)st->st_size, sbuf);\n\t\tsnprintf(buf, sizeof buf, \"%s %3s %-*s %-*s %8s %s %s\",\n\t\t    mode, lc, ulen, user, glen, group,\n\t\t    sbuf, tbuf, name);\n\t} else {\n\t\tsnprintf(buf, sizeof buf, \"%s %3s %-*s %-*s %8llu %s %s\",\n\t\t    mode, lc, ulen, user, glen, group,\n\t\t    (unsigned long long)st->st_size, tbuf, name);\n\t}\n\treturn xstrdup(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "attrib_to_stat",
          "args": [
            "&d[n]->a",
            "&sb"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "attrib_to_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "84-101",
          "snippet": "void\nattrib_to_stat(const Attrib *a, struct stat *st)\n{\n\tmemset(st, 0, sizeof(*st));\n\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE)\n\t\tst->st_size = a->size;\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tst->st_uid = a->uid;\n\t\tst->st_gid = a->gid;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)\n\t\tst->st_mode = a->perm;\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tst->st_atime = a->atime;\n\t\tst->st_mtime = a->mtime;\n\t}\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nattrib_to_stat(const Attrib *a, struct stat *st)\n{\n\tmemset(st, 0, sizeof(*st));\n\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE)\n\t\tst->st_size = a->size;\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tst->st_uid = a->uid;\n\t\tst->st_gid = a->gid;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)\n\t\tst->st_mode = a->perm;\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tst->st_atime = a->atime;\n\t\tst->st_mtime = a->mtime;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sb",
            "0",
            "sizeof(sb)"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_strip",
          "args": [
            "tmp",
            "strip_path"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "path_strip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "368-384",
          "snippet": "static char *\npath_strip(const char *path, const char *strip)\n{\n\tsize_t len;\n\n\tif (strip == NULL)\n\t\treturn (xstrdup(path));\n\n\tlen = strlen(strip);\n\tif (strncmp(path, strip, len) == 0) {\n\t\tif (strip[len - 1] != '/' && path[len] == '/')\n\t\t\tlen++;\n\t\treturn (xstrdup(path + len));\n\t}\n\n\treturn (xstrdup(path));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\npath_strip(const char *path, const char *strip)\n{\n\tsize_t len;\n\n\tif (strip == NULL)\n\t\treturn (xstrdup(path));\n\n\tlen = strlen(strip);\n\tif (strncmp(path, strip, len) == 0) {\n\t\tif (strip[len - 1] != '/' && path[len] == '/')\n\t\t\tlen++;\n\t\treturn (xstrdup(path + len));\n\t}\n\n\treturn (xstrdup(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_append",
          "args": [
            "path",
            "d[n]->filename"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "path_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1906-1919",
          "snippet": "char *\npath_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\npath_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "d",
            "n",
            "sizeof(*d)",
            "sdirent_comp"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "colspace",
            "width"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "columns",
            "1"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fileno(stdin)",
            "TIOCGWINSZ",
            "&ws"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "m",
            "strlen(d[n]->filename)"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "d[n]->filename"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_readdir",
          "args": [
            "conn",
            "path",
            "&d"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "do_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "675-679",
          "snippet": "int\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)\n#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */\n#define LS_SHOW_ALL\t0x0080\t/* Don't skip filenames starting with '.' */\n#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */\n#define LS_NUMERIC_VIEW\t0x0004\t/* Long view with numeric uid/gid */\n#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */\n#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */\n\nvolatile sig_atomic_t interrupted = 0;\nint sort_flag;\n\nstatic int\ndo_ls_dir(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tint n;\n\tu_int c = 1, colspace = 0, columns = 1;\n\tSFTP_DIRENT **d;\n\n\tif ((n = do_readdir(conn, path, &d)) != 0)\n\t\treturn (n);\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\tu_int m = 0, width = 80;\n\t\tstruct winsize ws;\n\t\tchar *tmp;\n\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (n = 0; d[n] != NULL; n++) {\n\t\t\tif (d[n]->filename[0] != '.' || (lflag & LS_SHOW_ALL))\n\t\t\t\tm = MAXIMUM(m, strlen(d[n]->filename));\n\t\t}\n\n\t\t/* Add any subpath that also needs to be counted */\n\t\ttmp = path_strip(path, strip_path);\n\t\tm += strlen(tmp);\n\t\tfree(tmp);\n\n\t\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\t\twidth = ws.ws_col;\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t\tcolspace = MINIMUM(colspace, width);\n\t}\n\n\tif (lflag & SORT_FLAGS) {\n\t\tfor (n = 0; d[n] != NULL; n++)\n\t\t\t;\t/* count entries */\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(d, n, sizeof(*d), sdirent_comp);\n\t}\n\n\tfor (n = 0; d[n] != NULL && !interrupted; n++) {\n\t\tchar *tmp, *fname;\n\n\t\tif (d[n]->filename[0] == '.' && !(lflag & LS_SHOW_ALL))\n\t\t\tcontinue;\n\n\t\ttmp = path_append(path, d[n]->filename);\n\t\tfname = path_strip(tmp, strip_path);\n\t\tfree(tmp);\n\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (lflag & (LS_NUMERIC_VIEW|LS_SI_UNITS)) {\n\t\t\t\tchar *lname;\n\t\t\t\tstruct stat sb;\n\n\t\t\t\tmemset(&sb, 0, sizeof(sb));\n\t\t\t\tattrib_to_stat(&d[n]->a, &sb);\n\t\t\t\tlname = ls_file(fname, &sb, 1,\n\t\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\t\tfree(lname);\n\t\t\t} else\n\t\t\t\tmprintf(\"%s\\n\", d[n]->longname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n\tfree_sftp_dirents(d);\n\treturn (0);\n}"
  },
  {
    "function_name": "sdirent_comp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "796-812",
    "snippet": "static int\nsdirent_comp(const void *aa, const void *bb)\n{\n\tSFTP_DIRENT *a = *(SFTP_DIRENT **)aa;\n\tSFTP_DIRENT *b = *(SFTP_DIRENT **)bb;\n\tint rmul = sort_flag & LS_REVERSE_SORT ? -1 : 1;\n\n#define NCMP(a,b) (a == b ? 0 : (a < b ? 1 : -1))\n\tif (sort_flag & LS_NAME_SORT)\n\t\treturn (rmul * strcmp(a->filename, b->filename));\n\telse if (sort_flag & LS_TIME_SORT)\n\t\treturn (rmul * NCMP(a->a.mtime, b->a.mtime));\n\telse if (sort_flag & LS_SIZE_SORT)\n\t\treturn (rmul * NCMP(a->a.size, b->a.size));\n\n\tfatal(\"Unknown ls sort type\");\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */",
      "#define LS_SIZE_SORT\t0x0020\t/* Sort by file size */",
      "#define LS_TIME_SORT\t0x0010\t/* Sort by mtime */",
      "#define LS_NAME_SORT\t0x0008\t/* Sort by name (default) */"
    ],
    "globals_used": [
      "int sort_flag;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Unknown ls sort type\""
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCMP",
          "args": [
            "a->a.size",
            "b->a.size"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCMP",
          "args": [
            "a->a.mtime",
            "b->a.mtime"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->filename",
            "b->filename"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */\n#define LS_SIZE_SORT\t0x0020\t/* Sort by file size */\n#define LS_TIME_SORT\t0x0010\t/* Sort by mtime */\n#define LS_NAME_SORT\t0x0008\t/* Sort by name (default) */\n\nint sort_flag;\n\nstatic int\nsdirent_comp(const void *aa, const void *bb)\n{\n\tSFTP_DIRENT *a = *(SFTP_DIRENT **)aa;\n\tSFTP_DIRENT *b = *(SFTP_DIRENT **)bb;\n\tint rmul = sort_flag & LS_REVERSE_SORT ? -1 : 1;\n\n#define NCMP(a,b) (a == b ? 0 : (a < b ? 1 : -1))\n\tif (sort_flag & LS_NAME_SORT)\n\t\treturn (rmul * strcmp(a->filename, b->filename));\n\telse if (sort_flag & LS_TIME_SORT)\n\t\treturn (rmul * NCMP(a->a.mtime, b->a.mtime));\n\telse if (sort_flag & LS_SIZE_SORT)\n\t\treturn (rmul * NCMP(a->a.size, b->a.size));\n\n\tfatal(\"Unknown ls sort type\");\n}"
  },
  {
    "function_name": "process_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "704-794",
    "snippet": "static int\nprocess_put(struct sftp_conn *conn, const char *src, const char *dst,\n    const char *pwd, int pflag, int rflag, int resume, int fflag)\n{\n\tchar *tmp_dst = NULL;\n\tchar *abs_dst = NULL;\n\tchar *tmp = NULL, *filename = NULL;\n\tglob_t g;\n\tint err = 0;\n\tint i, dst_is_dir = 1;\n\tstruct stat sb;\n\n\tif (dst) {\n\t\ttmp_dst = xstrdup(dst);\n\t\ttmp_dst = make_absolute(tmp_dst, pwd);\n\t}\n\n\tmemset(&g, 0, sizeof(g));\n\tdebug3(\"Looking up %s\", src);\n\tif (glob(src, GLOB_NOCHECK | GLOB_MARK, NULL, &g)) {\n\t\terror(\"File \\\"%s\\\" not found.\", src);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\t/* If we aren't fetching to pwd then stash this status for later */\n\tif (tmp_dst != NULL)\n\t\tdst_is_dir = remote_is_dir(conn, tmp_dst);\n\n\t/* If multiple matches, dst may be directory or unspecified */\n\tif (g.gl_matchc > 1 && tmp_dst && !dst_is_dir) {\n\t\terror(\"Multiple paths match, but destination \"\n\t\t    \"\\\"%s\\\" is not a directory\", tmp_dst);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\tif (stat(g.gl_pathv[i], &sb) == -1) {\n\t\t\terr = -1;\n\t\t\terror(\"stat %s: %s\", g.gl_pathv[i], strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp = xstrdup(g.gl_pathv[i]);\n\t\tif ((filename = basename(tmp)) == NULL) {\n\t\t\terror(\"basename %s: %s\", tmp, strerror(errno));\n\t\t\tfree(tmp);\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (g.gl_matchc == 1 && tmp_dst) {\n\t\t\t/* If directory specified, append filename */\n\t\t\tif (dst_is_dir)\n\t\t\t\tabs_dst = path_append(tmp_dst, filename);\n\t\t\telse\n\t\t\t\tabs_dst = xstrdup(tmp_dst);\n\t\t} else if (tmp_dst) {\n\t\t\tabs_dst = path_append(tmp_dst, filename);\n\t\t} else {\n\t\t\tabs_dst = make_absolute(xstrdup(filename), pwd);\n\t\t}\n\t\tfree(tmp);\n\n                resume |= global_aflag;\n\t\tif (!quiet && resume)\n\t\t\tmprintf(\"Resuming upload of %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\telse if (!quiet && !resume)\n\t\t\tmprintf(\"Uploading %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\tif (pathname_is_dir(g.gl_pathv[i]) && (rflag || global_rflag)) {\n\t\t\tif (upload_dir(conn, g.gl_pathv[i], abs_dst,\n\t\t\t    pflag || global_pflag, 1, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t} else {\n\t\t\tif (do_upload(conn, g.gl_pathv[i], abs_dst,\n\t\t\t    pflag || global_pflag, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t}\n\t}\n\nout:\n\tfree(abs_dst);\n\tfree(tmp_dst);\n\tglobfree(&g);\n\treturn(err);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int quiet = 0;",
      "int global_rflag = 0;",
      "int global_aflag = 0;",
      "int global_pflag = 0;",
      "int global_fflag = 0;",
      "volatile sig_atomic_t interrupted = 0;",
      "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "globfree",
          "args": [
            "&g"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "globfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "959-981",
          "snippet": "void\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nvoid\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp_dst"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_upload",
          "args": [
            "conn",
            "g.gl_pathv[i]",
            "abs_dst",
            "pflag || global_pflag",
            "resume",
            "fflag || global_fflag"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "do_upload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1570-1789",
          "snippet": "int\ndo_upload(struct sftp_conn *conn, const char *local_path,\n    const char *remote_path, int preserve_flag, int resume, int fsync_flag)\n{\n\tint r, local_fd;\n\tu_int status = SSH2_FX_OK;\n\tu_int id;\n\tu_char type;\n\toff_t offset, progress_counter;\n\tu_char *handle, *data;\n\tstruct sshbuf *msg;\n\tstruct stat sb;\n\tAttrib a, *c = NULL;\n\tu_int32_t startid;\n\tu_int32_t ackid;\n\tstruct outstanding_ack {\n\t\tu_int id;\n\t\tu_int len;\n\t\toff_t offset;\n\t\tTAILQ_ENTRY(outstanding_ack) tq;\n\t};\n\tTAILQ_HEAD(ackhead, outstanding_ack) acks;\n\tstruct outstanding_ack *ack = NULL;\n\tsize_t handle_len;\n\n\tTAILQ_INIT(&acks);\n\n\tif ((local_fd = open(local_path, O_RDONLY, 0)) == -1) {\n\t\terror(\"Couldn't open local file \\\"%s\\\" for reading: %s\",\n\t\t    local_path, strerror(errno));\n\t\treturn(-1);\n\t}\n\tif (fstat(local_fd, &sb) == -1) {\n\t\terror(\"Couldn't fstat local file \\\"%s\\\": %s\",\n\t\t    local_path, strerror(errno));\n\t\tclose(local_fd);\n\t\treturn(-1);\n\t}\n\tif (!S_ISREG(sb.st_mode)) {\n\t\terror(\"%s is not a regular file\", local_path);\n\t\tclose(local_fd);\n\t\treturn(-1);\n\t}\n\tstat_to_attrib(&sb, &a);\n\n\ta.flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\ta.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\ta.perm &= 0777;\n\tif (!preserve_flag)\n\t\ta.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n\n\tif (resume) {\n\t\t/* Get remote file size if it exists */\n\t\tif ((c = do_stat(conn, remote_path, 0)) == NULL) {\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((off_t)c->size >= sb.st_size) {\n\t\t\terror(\"destination file bigger or same size as \"\n\t\t\t      \"source file\");\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lseek(local_fd, (off_t)c->size, SEEK_SET) == -1) {\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\t/* Send open request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FXF_WRITE|SSH2_FXF_CREAT|\n\t    (resume ? SSH2_FXF_APPEND : SSH2_FXF_TRUNC))) != 0 ||\n\t    (r = encode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, remote_path);\n\n\tsshbuf_reset(msg);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote open(\\\"%s\\\")\", remote_path);\n\tif (handle == NULL) {\n\t\tclose(local_fd);\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t}\n\n\tstartid = ackid = id + 1;\n\tdata = xmalloc(conn->transfer_buflen);\n\n\t/* Read from local and write to remote */\n\toffset = progress_counter = (resume ? c->size : 0);\n\tif (showprogress)\n\t\tstart_progress_meter(local_path, sb.st_size,\n\t\t    &progress_counter);\n\n\tfor (;;) {\n\t\tint len;\n\n\t\t/*\n\t\t * Can't use atomicio here because it returns 0 on EOF,\n\t\t * thus losing the last block of the file.\n\t\t * Simulate an EOF on interrupt, allowing ACKs from the\n\t\t * server to drain.\n\t\t */\n\t\tif (interrupted || status != SSH2_FX_OK)\n\t\t\tlen = 0;\n\t\telse do\n\t\t\tlen = read(local_fd, data, conn->transfer_buflen);\n\t\twhile ((len == -1) &&\n\t\t    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK));\n\n\t\tif (len == -1)\n\t\t\tfatal(\"Couldn't read from \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\n\t\tif (len != 0) {\n\t\t\tack = xcalloc(1, sizeof(*ack));\n\t\t\tack->id = ++id;\n\t\t\tack->offset = offset;\n\t\t\tack->len = len;\n\t\t\tTAILQ_INSERT_TAIL(&acks, ack, tq);\n\n\t\t\tsshbuf_reset(msg);\n\t\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_WRITE)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(msg, ack->id)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, handle,\n\t\t\t    handle_len)) != 0 ||\n\t\t\t    (r = sshbuf_put_u64(msg, offset)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, data, len)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tsend_msg(conn, msg);\n\t\t\tdebug3(\"Sent message SSH2_FXP_WRITE I:%u O:%llu S:%u\",\n\t\t\t    id, (unsigned long long)offset, len);\n\t\t} else if (TAILQ_FIRST(&acks) == NULL)\n\t\t\tbreak;\n\n\t\tif (ack == NULL)\n\t\t\tfatal(\"Unexpected ACK %u\", id);\n\n\t\tif (id == startid || len == 0 ||\n\t\t    id - ackid >= conn->num_requests) {\n\t\t\tu_int rid;\n\n\t\t\tsshbuf_reset(msg);\n\t\t\tget_msg(conn, msg);\n\t\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t\t    (r = sshbuf_get_u32(msg, &rid)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\n\t\t\tif (type != SSH2_FXP_STATUS)\n\t\t\t\tfatal(\"Expected SSH2_FXP_STATUS(%d) packet, \"\n\t\t\t\t    \"got %d\", SSH2_FXP_STATUS, type);\n\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\t\t\t/* Find the request in our queue */\n\t\t\tfor (ack = TAILQ_FIRST(&acks);\n\t\t\t    ack != NULL && ack->id != rid;\n\t\t\t    ack = TAILQ_NEXT(ack, tq))\n\t\t\t\t;\n\t\t\tif (ack == NULL)\n\t\t\t\tfatal(\"Can't find request for ID %u\", rid);\n\t\t\tTAILQ_REMOVE(&acks, ack, tq);\n\t\t\tdebug3(\"In write loop, ack for %u %u bytes at %lld\",\n\t\t\t    ack->id, ack->len, (long long)ack->offset);\n\t\t\t++ackid;\n\t\t\tprogress_counter += ack->len;\n\t\t\tfree(ack);\n\t\t}\n\t\toffset += len;\n\t\tif (offset < 0)\n\t\t\tfatal(\"%s: offset < 0\", __func__);\n\t}\n\tsshbuf_free(msg);\n\n\tif (showprogress)\n\t\tstop_progress_meter();\n\tfree(data);\n\n\tif (status != SSH2_FX_OK) {\n\t\terror(\"Couldn't write to remote file \\\"%s\\\": %s\",\n\t\t    remote_path, fx2txt(status));\n\t\tstatus = SSH2_FX_FAILURE;\n\t}\n\n\tif (close(local_fd) == -1) {\n\t\terror(\"Couldn't close local file \\\"%s\\\": %s\", local_path,\n\t\t    strerror(errno));\n\t\tstatus = SSH2_FX_FAILURE;\n\t}\n\n\t/* Override umask and utimes if asked */\n\tif (preserve_flag)\n\t\tdo_fsetstat(conn, handle, handle_len, &a);\n\n\tif (fsync_flag)\n\t\t(void)do_fsync(conn, handle, handle_len);\n\n\tif (do_close(conn, handle, handle_len) != 0)\n\t\tstatus = SSH2_FX_FAILURE;\n\n\tfree(handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern volatile sig_atomic_t interrupted;",
            "extern int showprogress;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern volatile sig_atomic_t interrupted;\nextern int showprogress;\n\nint\ndo_upload(struct sftp_conn *conn, const char *local_path,\n    const char *remote_path, int preserve_flag, int resume, int fsync_flag)\n{\n\tint r, local_fd;\n\tu_int status = SSH2_FX_OK;\n\tu_int id;\n\tu_char type;\n\toff_t offset, progress_counter;\n\tu_char *handle, *data;\n\tstruct sshbuf *msg;\n\tstruct stat sb;\n\tAttrib a, *c = NULL;\n\tu_int32_t startid;\n\tu_int32_t ackid;\n\tstruct outstanding_ack {\n\t\tu_int id;\n\t\tu_int len;\n\t\toff_t offset;\n\t\tTAILQ_ENTRY(outstanding_ack) tq;\n\t};\n\tTAILQ_HEAD(ackhead, outstanding_ack) acks;\n\tstruct outstanding_ack *ack = NULL;\n\tsize_t handle_len;\n\n\tTAILQ_INIT(&acks);\n\n\tif ((local_fd = open(local_path, O_RDONLY, 0)) == -1) {\n\t\terror(\"Couldn't open local file \\\"%s\\\" for reading: %s\",\n\t\t    local_path, strerror(errno));\n\t\treturn(-1);\n\t}\n\tif (fstat(local_fd, &sb) == -1) {\n\t\terror(\"Couldn't fstat local file \\\"%s\\\": %s\",\n\t\t    local_path, strerror(errno));\n\t\tclose(local_fd);\n\t\treturn(-1);\n\t}\n\tif (!S_ISREG(sb.st_mode)) {\n\t\terror(\"%s is not a regular file\", local_path);\n\t\tclose(local_fd);\n\t\treturn(-1);\n\t}\n\tstat_to_attrib(&sb, &a);\n\n\ta.flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\ta.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\ta.perm &= 0777;\n\tif (!preserve_flag)\n\t\ta.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n\n\tif (resume) {\n\t\t/* Get remote file size if it exists */\n\t\tif ((c = do_stat(conn, remote_path, 0)) == NULL) {\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((off_t)c->size >= sb.st_size) {\n\t\t\terror(\"destination file bigger or same size as \"\n\t\t\t      \"source file\");\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lseek(local_fd, (off_t)c->size, SEEK_SET) == -1) {\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\t/* Send open request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FXF_WRITE|SSH2_FXF_CREAT|\n\t    (resume ? SSH2_FXF_APPEND : SSH2_FXF_TRUNC))) != 0 ||\n\t    (r = encode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, remote_path);\n\n\tsshbuf_reset(msg);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote open(\\\"%s\\\")\", remote_path);\n\tif (handle == NULL) {\n\t\tclose(local_fd);\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t}\n\n\tstartid = ackid = id + 1;\n\tdata = xmalloc(conn->transfer_buflen);\n\n\t/* Read from local and write to remote */\n\toffset = progress_counter = (resume ? c->size : 0);\n\tif (showprogress)\n\t\tstart_progress_meter(local_path, sb.st_size,\n\t\t    &progress_counter);\n\n\tfor (;;) {\n\t\tint len;\n\n\t\t/*\n\t\t * Can't use atomicio here because it returns 0 on EOF,\n\t\t * thus losing the last block of the file.\n\t\t * Simulate an EOF on interrupt, allowing ACKs from the\n\t\t * server to drain.\n\t\t */\n\t\tif (interrupted || status != SSH2_FX_OK)\n\t\t\tlen = 0;\n\t\telse do\n\t\t\tlen = read(local_fd, data, conn->transfer_buflen);\n\t\twhile ((len == -1) &&\n\t\t    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK));\n\n\t\tif (len == -1)\n\t\t\tfatal(\"Couldn't read from \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\n\t\tif (len != 0) {\n\t\t\tack = xcalloc(1, sizeof(*ack));\n\t\t\tack->id = ++id;\n\t\t\tack->offset = offset;\n\t\t\tack->len = len;\n\t\t\tTAILQ_INSERT_TAIL(&acks, ack, tq);\n\n\t\t\tsshbuf_reset(msg);\n\t\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_WRITE)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(msg, ack->id)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, handle,\n\t\t\t    handle_len)) != 0 ||\n\t\t\t    (r = sshbuf_put_u64(msg, offset)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, data, len)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tsend_msg(conn, msg);\n\t\t\tdebug3(\"Sent message SSH2_FXP_WRITE I:%u O:%llu S:%u\",\n\t\t\t    id, (unsigned long long)offset, len);\n\t\t} else if (TAILQ_FIRST(&acks) == NULL)\n\t\t\tbreak;\n\n\t\tif (ack == NULL)\n\t\t\tfatal(\"Unexpected ACK %u\", id);\n\n\t\tif (id == startid || len == 0 ||\n\t\t    id - ackid >= conn->num_requests) {\n\t\t\tu_int rid;\n\n\t\t\tsshbuf_reset(msg);\n\t\t\tget_msg(conn, msg);\n\t\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t\t    (r = sshbuf_get_u32(msg, &rid)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\n\t\t\tif (type != SSH2_FXP_STATUS)\n\t\t\t\tfatal(\"Expected SSH2_FXP_STATUS(%d) packet, \"\n\t\t\t\t    \"got %d\", SSH2_FXP_STATUS, type);\n\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\t\t\t/* Find the request in our queue */\n\t\t\tfor (ack = TAILQ_FIRST(&acks);\n\t\t\t    ack != NULL && ack->id != rid;\n\t\t\t    ack = TAILQ_NEXT(ack, tq))\n\t\t\t\t;\n\t\t\tif (ack == NULL)\n\t\t\t\tfatal(\"Can't find request for ID %u\", rid);\n\t\t\tTAILQ_REMOVE(&acks, ack, tq);\n\t\t\tdebug3(\"In write loop, ack for %u %u bytes at %lld\",\n\t\t\t    ack->id, ack->len, (long long)ack->offset);\n\t\t\t++ackid;\n\t\t\tprogress_counter += ack->len;\n\t\t\tfree(ack);\n\t\t}\n\t\toffset += len;\n\t\tif (offset < 0)\n\t\t\tfatal(\"%s: offset < 0\", __func__);\n\t}\n\tsshbuf_free(msg);\n\n\tif (showprogress)\n\t\tstop_progress_meter();\n\tfree(data);\n\n\tif (status != SSH2_FX_OK) {\n\t\terror(\"Couldn't write to remote file \\\"%s\\\": %s\",\n\t\t    remote_path, fx2txt(status));\n\t\tstatus = SSH2_FX_FAILURE;\n\t}\n\n\tif (close(local_fd) == -1) {\n\t\terror(\"Couldn't close local file \\\"%s\\\": %s\", local_path,\n\t\t    strerror(errno));\n\t\tstatus = SSH2_FX_FAILURE;\n\t}\n\n\t/* Override umask and utimes if asked */\n\tif (preserve_flag)\n\t\tdo_fsetstat(conn, handle, handle_len, &a);\n\n\tif (fsync_flag)\n\t\t(void)do_fsync(conn, handle, handle_len);\n\n\tif (do_close(conn, handle, handle_len) != 0)\n\t\tstatus = SSH2_FX_FAILURE;\n\n\tfree(handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "upload_dir",
          "args": [
            "conn",
            "g.gl_pathv[i]",
            "abs_dst",
            "pflag || global_pflag",
            "1",
            "resume",
            "fflag || global_fflag"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "upload_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1887-1904",
          "snippet": "int\nupload_dir(struct sftp_conn *conn, const char *src, const char *dst,\n    int preserve_flag, int print_flag, int resume, int fsync_flag)\n{\n\tchar *dst_canon;\n\tint ret;\n\n\tif ((dst_canon = do_realpath(conn, dst)) == NULL) {\n\t\terror(\"Unable to canonicalize path \\\"%s\\\"\", dst);\n\t\treturn -1;\n\t}\n\n\tret = upload_dir_internal(conn, src, dst_canon, 0, preserve_flag,\n\t    print_flag, resume, fsync_flag);\n\n\tfree(dst_canon);\n\treturn ret;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nupload_dir(struct sftp_conn *conn, const char *src, const char *dst,\n    int preserve_flag, int print_flag, int resume, int fsync_flag)\n{\n\tchar *dst_canon;\n\tint ret;\n\n\tif ((dst_canon = do_realpath(conn, dst)) == NULL) {\n\t\terror(\"Unable to canonicalize path \\\"%s\\\"\", dst);\n\t\treturn -1;\n\t}\n\n\tret = upload_dir_internal(conn, src, dst_canon, 0, preserve_flag,\n\t    print_flag, resume, fsync_flag);\n\n\tfree(dst_canon);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathname_is_dir",
          "args": [
            "g.gl_pathv[i]"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "pathname_is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "610-616",
          "snippet": "static int\npathname_is_dir(const char *pathname)\n{\n\tsize_t l = strlen(pathname);\n\n\treturn l > 0 && pathname[l - 1] == '/';\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\npathname_is_dir(const char *pathname)\n{\n\tsize_t l = strlen(pathname);\n\n\treturn l > 0 && pathname[l - 1] == '/';\n}"
        }
      },
      {
        "call_info": {
          "callee": "mprintf",
          "args": [
            "\"Uploading %s to %s\\n\"",
            "g.gl_pathv[i]",
            "abs_dst"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_absolute",
          "args": [
            "xstrdup(filename)",
            "pwd"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "make_absolute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "386-398",
          "snippet": "static char *\nmake_absolute(char *p, const char *pwd)\n{\n\tchar *abs_str;\n\n\t/* Derelativise */\n\tif (p && p[0] != '/') {\n\t\tabs_str = path_append(pwd, p);\n\t\tfree(p);\n\t\treturn(abs_str);\n\t} else\n\t\treturn(p);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nmake_absolute(char *p, const char *pwd)\n{\n\tchar *abs_str;\n\n\t/* Derelativise */\n\tif (p && p[0] != '/') {\n\t\tabs_str = path_append(pwd, p);\n\t\tfree(p);\n\t\treturn(abs_str);\n\t} else\n\t\treturn(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "filename"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_append",
          "args": [
            "tmp_dst",
            "filename"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "path_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1906-1919",
          "snippet": "char *\npath_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\npath_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"basename %s: %s\"",
            "tmp",
            "strerror(errno)"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "basename",
          "args": [
            "tmp"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "basename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/basename.c",
          "lines": "26-65",
          "snippet": "char *\nbasename(const char *path)\n{\n\tstatic char bname[MAXPATHLEN];\n\tsize_t len;\n\tconst char *endp, *startp;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tbname[0] = '.';\n\t\tbname[1] = '\\0';\n\t\treturn (bname);\n\t}\n\n\t/* Strip any trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* All slashes becomes \"/\" */\n\tif (endp == path && *endp == '/') {\n\t\tbname[0] = '/';\n\t\tbname[1] = '\\0';\n\t\treturn (bname);\n\t}\n\n\t/* Find the start of the base */\n\tstartp = endp;\n\twhile (startp > path && *(startp - 1) != '/')\n\t\tstartp--;\n\n\tlen = endp - startp + 1;\n\tif (len >= sizeof(bname)) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn (NULL);\n\t}\n\tmemcpy(bname, startp, len);\n\tbname[len] = '\\0';\n\treturn (bname);\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"includes.h\"\n\nchar *\nbasename(const char *path)\n{\n\tstatic char bname[MAXPATHLEN];\n\tsize_t len;\n\tconst char *endp, *startp;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tbname[0] = '.';\n\t\tbname[1] = '\\0';\n\t\treturn (bname);\n\t}\n\n\t/* Strip any trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* All slashes becomes \"/\" */\n\tif (endp == path && *endp == '/') {\n\t\tbname[0] = '/';\n\t\tbname[1] = '\\0';\n\t\treturn (bname);\n\t}\n\n\t/* Find the start of the base */\n\tstartp = endp;\n\twhile (startp > path && *(startp - 1) != '/')\n\t\tstartp--;\n\n\tlen = endp - startp + 1;\n\tif (len >= sizeof(bname)) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn (NULL);\n\t}\n\tmemcpy(bname, startp, len);\n\tbname[len] = '\\0';\n\treturn (bname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "g.gl_pathv[i]",
            "&sb"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "remote_is_dir",
          "args": [
            "conn",
            "tmp_dst"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "remote_is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "596-607",
          "snippet": "static int\nremote_is_dir(struct sftp_conn *conn, const char *path)\n{\n\tAttrib *a;\n\n\t/* XXX: report errors? */\n\tif ((a = do_stat(conn, path, 1)) == NULL)\n\t\treturn(0);\n\tif (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))\n\t\treturn(0);\n\treturn(S_ISDIR(a->perm));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nremote_is_dir(struct sftp_conn *conn, const char *path)\n{\n\tAttrib *a;\n\n\t/* XXX: report errors? */\n\tif ((a = do_stat(conn, path, 1)) == NULL)\n\t\treturn(0);\n\tif (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))\n\t\treturn(0);\n\treturn(S_ISDIR(a->perm));\n}"
        }
      },
      {
        "call_info": {
          "callee": "glob",
          "args": [
            "src",
            "GLOB_NOCHECK | GLOB_MARK",
            "NULL",
            "&g"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "do_globbed_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "929-1033",
          "snippet": "static int\ndo_globbed_ls(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tchar *fname, *lname;\n\tglob_t g;\n\tint err, r;\n\tstruct winsize ws;\n\tu_int i, j, nentries, *indices = NULL, c = 1;\n\tu_int colspace = 0, columns = 1, m = 0, width = 80;\n\n\tmemset(&g, 0, sizeof(g));\n\n\tif ((r = remote_glob(conn, path,\n\t    GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE|GLOB_KEEPSTAT|GLOB_NOSORT,\n\t    NULL, &g)) != 0 ||\n\t    (g.gl_pathc && !g.gl_matchc)) {\n\t\tif (g.gl_pathc)\n\t\t\tglobfree(&g);\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Can't ls: Too many matches for \\\"%s\\\"\", path);\n\t\t} else {\n\t\t\terror(\"Can't ls: \\\"%s\\\" not found\", path);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (interrupted)\n\t\tgoto out;\n\n\t/*\n\t * If the glob returns a single match and it is a directory,\n\t * then just list its contents.\n\t */\n\tif (g.gl_matchc == 1 && g.gl_statv[0] != NULL &&\n\t    S_ISDIR(g.gl_statv[0]->st_mode)) {\n\t\terr = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);\n\t\tglobfree(&g);\n\t\treturn err;\n\t}\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (i = 0; g.gl_pathv[i]; i++)\n\t\t\tm = MAXIMUM(m, strlen(g.gl_pathv[i]));\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t}\n\n\t/*\n\t * Sorting: rather than mess with the contents of glob_t, prepare\n\t * an array of indices into it and sort that. For the usual\n\t * unsorted case, the indices are just the identity 1=1, 2=2, etc.\n\t */\n\tfor (nentries = 0; g.gl_pathv[nentries] != NULL; nentries++)\n\t\t;\t/* count entries */\n\tindices = calloc(nentries, sizeof(*indices));\n\tfor (i = 0; i < nentries; i++)\n\t\tindices[i] = i;\n\n\tif (lflag & SORT_FLAGS) {\n\t\tsort_glob = &g;\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(indices, nentries, sizeof(*indices), sglob_comp);\n\t\tsort_glob = NULL;\n\t}\n\n\tfor (j = 0; j < nentries && !interrupted; j++) {\n\t\ti = indices[j];\n\t\tfname = path_strip(g.gl_pathv[i], strip_path);\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (g.gl_statv[i] == NULL) {\n\t\t\t\terror(\"no stat information for %s\", fname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlname = ls_file(fname, g.gl_statv[i], 1,\n\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\tfree(lname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n out:\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(indices);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)",
            "#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */",
            "#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */",
            "#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */",
            "#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */"
          ],
          "globals_used": [
            "volatile sig_atomic_t interrupted = 0;",
            "int sort_flag;",
            "glob_t *sort_glob;",
            "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)\n#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */\n#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */\n#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */\n#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */\n\nvolatile sig_atomic_t interrupted = 0;\nint sort_flag;\nglob_t *sort_glob;\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\n\nstatic int\ndo_globbed_ls(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tchar *fname, *lname;\n\tglob_t g;\n\tint err, r;\n\tstruct winsize ws;\n\tu_int i, j, nentries, *indices = NULL, c = 1;\n\tu_int colspace = 0, columns = 1, m = 0, width = 80;\n\n\tmemset(&g, 0, sizeof(g));\n\n\tif ((r = remote_glob(conn, path,\n\t    GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE|GLOB_KEEPSTAT|GLOB_NOSORT,\n\t    NULL, &g)) != 0 ||\n\t    (g.gl_pathc && !g.gl_matchc)) {\n\t\tif (g.gl_pathc)\n\t\t\tglobfree(&g);\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Can't ls: Too many matches for \\\"%s\\\"\", path);\n\t\t} else {\n\t\t\terror(\"Can't ls: \\\"%s\\\" not found\", path);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (interrupted)\n\t\tgoto out;\n\n\t/*\n\t * If the glob returns a single match and it is a directory,\n\t * then just list its contents.\n\t */\n\tif (g.gl_matchc == 1 && g.gl_statv[0] != NULL &&\n\t    S_ISDIR(g.gl_statv[0]->st_mode)) {\n\t\terr = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);\n\t\tglobfree(&g);\n\t\treturn err;\n\t}\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (i = 0; g.gl_pathv[i]; i++)\n\t\t\tm = MAXIMUM(m, strlen(g.gl_pathv[i]));\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t}\n\n\t/*\n\t * Sorting: rather than mess with the contents of glob_t, prepare\n\t * an array of indices into it and sort that. For the usual\n\t * unsorted case, the indices are just the identity 1=1, 2=2, etc.\n\t */\n\tfor (nentries = 0; g.gl_pathv[nentries] != NULL; nentries++)\n\t\t;\t/* count entries */\n\tindices = calloc(nentries, sizeof(*indices));\n\tfor (i = 0; i < nentries; i++)\n\t\tindices[i] = i;\n\n\tif (lflag & SORT_FLAGS) {\n\t\tsort_glob = &g;\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(indices, nentries, sizeof(*indices), sglob_comp);\n\t\tsort_glob = NULL;\n\t}\n\n\tfor (j = 0; j < nentries && !interrupted; j++) {\n\t\ti = indices[j];\n\t\tfname = path_strip(g.gl_pathv[i], strip_path);\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (g.gl_statv[i] == NULL) {\n\t\t\t\terror(\"no stat information for %s\", fname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlname = ls_file(fname, g.gl_statv[i], 1,\n\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\tfree(lname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n out:\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(indices);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Looking up %s\"",
            "src"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&g",
            "0",
            "sizeof(g)"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint quiet = 0;\nint global_rflag = 0;\nint global_aflag = 0;\nint global_pflag = 0;\nint global_fflag = 0;\nvolatile sig_atomic_t interrupted = 0;\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\n\nstatic int\nprocess_put(struct sftp_conn *conn, const char *src, const char *dst,\n    const char *pwd, int pflag, int rflag, int resume, int fflag)\n{\n\tchar *tmp_dst = NULL;\n\tchar *abs_dst = NULL;\n\tchar *tmp = NULL, *filename = NULL;\n\tglob_t g;\n\tint err = 0;\n\tint i, dst_is_dir = 1;\n\tstruct stat sb;\n\n\tif (dst) {\n\t\ttmp_dst = xstrdup(dst);\n\t\ttmp_dst = make_absolute(tmp_dst, pwd);\n\t}\n\n\tmemset(&g, 0, sizeof(g));\n\tdebug3(\"Looking up %s\", src);\n\tif (glob(src, GLOB_NOCHECK | GLOB_MARK, NULL, &g)) {\n\t\terror(\"File \\\"%s\\\" not found.\", src);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\t/* If we aren't fetching to pwd then stash this status for later */\n\tif (tmp_dst != NULL)\n\t\tdst_is_dir = remote_is_dir(conn, tmp_dst);\n\n\t/* If multiple matches, dst may be directory or unspecified */\n\tif (g.gl_matchc > 1 && tmp_dst && !dst_is_dir) {\n\t\terror(\"Multiple paths match, but destination \"\n\t\t    \"\\\"%s\\\" is not a directory\", tmp_dst);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\tif (stat(g.gl_pathv[i], &sb) == -1) {\n\t\t\terr = -1;\n\t\t\terror(\"stat %s: %s\", g.gl_pathv[i], strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp = xstrdup(g.gl_pathv[i]);\n\t\tif ((filename = basename(tmp)) == NULL) {\n\t\t\terror(\"basename %s: %s\", tmp, strerror(errno));\n\t\t\tfree(tmp);\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (g.gl_matchc == 1 && tmp_dst) {\n\t\t\t/* If directory specified, append filename */\n\t\t\tif (dst_is_dir)\n\t\t\t\tabs_dst = path_append(tmp_dst, filename);\n\t\t\telse\n\t\t\t\tabs_dst = xstrdup(tmp_dst);\n\t\t} else if (tmp_dst) {\n\t\t\tabs_dst = path_append(tmp_dst, filename);\n\t\t} else {\n\t\t\tabs_dst = make_absolute(xstrdup(filename), pwd);\n\t\t}\n\t\tfree(tmp);\n\n                resume |= global_aflag;\n\t\tif (!quiet && resume)\n\t\t\tmprintf(\"Resuming upload of %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\telse if (!quiet && !resume)\n\t\t\tmprintf(\"Uploading %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\tif (pathname_is_dir(g.gl_pathv[i]) && (rflag || global_rflag)) {\n\t\t\tif (upload_dir(conn, g.gl_pathv[i], abs_dst,\n\t\t\t    pflag || global_pflag, 1, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t} else {\n\t\t\tif (do_upload(conn, g.gl_pathv[i], abs_dst,\n\t\t\t    pflag || global_pflag, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t}\n\t}\n\nout:\n\tfree(abs_dst);\n\tfree(tmp_dst);\n\tglobfree(&g);\n\treturn(err);\n}"
  },
  {
    "function_name": "process_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "618-702",
    "snippet": "static int\nprocess_get(struct sftp_conn *conn, const char *src, const char *dst,\n    const char *pwd, int pflag, int rflag, int resume, int fflag)\n{\n\tchar *abs_src = NULL;\n\tchar *abs_dst = NULL;\n\tglob_t g;\n\tchar *filename, *tmp=NULL;\n\tint i, r, err = 0;\n\n\tabs_src = xstrdup(src);\n\tabs_src = make_absolute(abs_src, pwd);\n\tmemset(&g, 0, sizeof(g));\n\n\tdebug3(\"Looking up %s\", abs_src);\n\tif ((r = remote_glob(conn, abs_src, GLOB_MARK, NULL, &g)) != 0) {\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Too many matches for \\\"%s\\\".\", abs_src);\n\t\t} else {\n\t\t\terror(\"File \\\"%s\\\" not found.\", abs_src);\n\t\t}\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If multiple matches then dst must be a directory or\n\t * unspecified.\n\t */\n\tif (g.gl_matchc > 1 && dst != NULL && !is_dir(dst)) {\n\t\terror(\"Multiple source paths, but destination \"\n\t\t    \"\\\"%s\\\" is not a directory\", dst);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\ttmp = xstrdup(g.gl_pathv[i]);\n\t\tif ((filename = basename(tmp)) == NULL) {\n\t\t\terror(\"basename %s: %s\", tmp, strerror(errno));\n\t\t\tfree(tmp);\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (g.gl_matchc == 1 && dst) {\n\t\t\tif (is_dir(dst)) {\n\t\t\t\tabs_dst = path_append(dst, filename);\n\t\t\t} else {\n\t\t\t\tabs_dst = xstrdup(dst);\n\t\t\t}\n\t\t} else if (dst) {\n\t\t\tabs_dst = path_append(dst, filename);\n\t\t} else {\n\t\t\tabs_dst = xstrdup(filename);\n\t\t}\n\t\tfree(tmp);\n\n\t\tresume |= global_aflag;\n\t\tif (!quiet && resume)\n\t\t\tmprintf(\"Resuming %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\telse if (!quiet && !resume)\n\t\t\tmprintf(\"Fetching %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\tif (pathname_is_dir(g.gl_pathv[i]) && (rflag || global_rflag)) {\n\t\t\tif (download_dir(conn, g.gl_pathv[i], abs_dst, NULL,\n\t\t\t    pflag || global_pflag, 1, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t} else {\n\t\t\tif (do_download(conn, g.gl_pathv[i], abs_dst, NULL,\n\t\t\t    pflag || global_pflag, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t}\n\t\tfree(abs_dst);\n\t\tabs_dst = NULL;\n\t}\n\nout:\n\tfree(abs_src);\n\tglobfree(&g);\n\treturn(err);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int quiet = 0;",
      "int global_rflag = 0;",
      "int global_aflag = 0;",
      "int global_pflag = 0;",
      "int global_fflag = 0;",
      "volatile sig_atomic_t interrupted = 0;",
      "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "globfree",
          "args": [
            "&g"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "globfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "959-981",
          "snippet": "void\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nvoid\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "abs_src"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_download",
          "args": [
            "conn",
            "g.gl_pathv[i]",
            "abs_dst",
            "NULL",
            "pflag || global_pflag",
            "resume",
            "fflag || global_fflag"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "do_download",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1161-1455",
          "snippet": "int\ndo_download(struct sftp_conn *conn, const char *remote_path,\n    const char *local_path, Attrib *a, int preserve_flag, int resume_flag,\n    int fsync_flag)\n{\n\tAttrib junk;\n\tstruct sshbuf *msg;\n\tu_char *handle;\n\tint local_fd = -1, write_error;\n\tint read_error, write_errno, reordered = 0, r;\n\tu_int64_t offset = 0, size, highwater;\n\tu_int mode, id, buflen, num_req, max_req, status = SSH2_FX_OK;\n\toff_t progress_counter;\n\tsize_t handle_len;\n\tstruct stat st;\n\tstruct request {\n\t\tu_int id;\n\t\tsize_t len;\n\t\tu_int64_t offset;\n\t\tTAILQ_ENTRY(request) tq;\n\t};\n\tTAILQ_HEAD(reqhead, request) requests;\n\tstruct request *req;\n\tu_char type;\n\n\tTAILQ_INIT(&requests);\n\n\tif (a == NULL && (a = do_stat(conn, remote_path, 0)) == NULL)\n\t\treturn -1;\n\n\t/* Do not preserve set[ug]id here, as we do not preserve ownership */\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)\n\t\tmode = a->perm & 0777;\n\telse\n\t\tmode = 0666;\n\n\tif ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&\n\t    (!S_ISREG(a->perm))) {\n\t\terror(\"Cannot download non-regular file: %s\", remote_path);\n\t\treturn(-1);\n\t}\n\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE)\n\t\tsize = a->size;\n\telse\n\t\tsize = 0;\n\n\tbuflen = conn->transfer_buflen;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tattrib_clear(&junk); /* Send empty attributes */\n\n\t/* Send open request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FXF_READ)) != 0 ||\n\t    (r = encode_attrib(msg, &junk)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, remote_path);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote open(\\\"%s\\\")\", remote_path);\n\tif (handle == NULL) {\n\t\tsshbuf_free(msg);\n\t\treturn(-1);\n\t}\n\n\tlocal_fd = open(local_path,\n\t    O_WRONLY | O_CREAT | (resume_flag ? 0 : O_TRUNC), mode | S_IWUSR);\n\tif (local_fd == -1) {\n\t\terror(\"Couldn't open local file \\\"%s\\\" for writing: %s\",\n\t\t    local_path, strerror(errno));\n\t\tgoto fail;\n\t}\n\toffset = highwater = 0;\n\tif (resume_flag) {\n\t\tif (fstat(local_fd, &st) == -1) {\n\t\t\terror(\"Unable to stat local file \\\"%s\\\": %s\",\n\t\t\t    local_path, strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (st.st_size < 0) {\n\t\t\terror(\"\\\"%s\\\" has negative size\", local_path);\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((u_int64_t)st.st_size > size) {\n\t\t\terror(\"Unable to resume download of \\\"%s\\\": \"\n\t\t\t    \"local file is larger than remote\", local_path);\n fail:\n\t\t\tdo_close(conn, handle, handle_len);\n\t\t\tsshbuf_free(msg);\n\t\t\tfree(handle);\n\t\t\tif (local_fd != -1)\n\t\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = highwater = st.st_size;\n\t}\n\n\t/* Read from remote and write to local */\n\twrite_error = read_error = write_errno = num_req = 0;\n\tmax_req = 1;\n\tprogress_counter = offset;\n\n\tif (showprogress && size != 0)\n\t\tstart_progress_meter(remote_path, size, &progress_counter);\n\n\twhile (num_req > 0 || max_req > 0) {\n\t\tu_char *data;\n\t\tsize_t len;\n\n\t\t/*\n\t\t * Simulate EOF on interrupt: stop sending new requests and\n\t\t * allow outstanding requests to drain gracefully\n\t\t */\n\t\tif (interrupted) {\n\t\t\tif (num_req == 0) /* If we haven't started yet... */\n\t\t\t\tbreak;\n\t\t\tmax_req = 0;\n\t\t}\n\n\t\t/* Send some more requests */\n\t\twhile (num_req < max_req) {\n\t\t\tdebug3(\"Request range %llu -> %llu (%d/%d)\",\n\t\t\t    (unsigned long long)offset,\n\t\t\t    (unsigned long long)offset + buflen - 1,\n\t\t\t    num_req, max_req);\n\t\t\treq = xcalloc(1, sizeof(*req));\n\t\t\treq->id = conn->msg_id++;\n\t\t\treq->len = buflen;\n\t\t\treq->offset = offset;\n\t\t\toffset += buflen;\n\t\t\tnum_req++;\n\t\t\tTAILQ_INSERT_TAIL(&requests, req, tq);\n\t\t\tsend_read_request(conn, req->id, req->offset,\n\t\t\t    req->len, handle, handle_len);\n\t\t}\n\n\t\tsshbuf_reset(msg);\n\t\tget_msg(conn, msg);\n\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tdebug3(\"Received reply T:%u I:%u R:%d\", type, id, max_req);\n\n\t\t/* Find the request in our queue */\n\t\tfor (req = TAILQ_FIRST(&requests);\n\t\t    req != NULL && req->id != id;\n\t\t    req = TAILQ_NEXT(req, tq))\n\t\t\t;\n\t\tif (req == NULL)\n\t\t\tfatal(\"Unexpected reply %u\", id);\n\n\t\tswitch (type) {\n\t\tcase SSH2_FXP_STATUS:\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (status != SSH2_FX_EOF)\n\t\t\t\tread_error = 1;\n\t\t\tmax_req = 0;\n\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\tfree(req);\n\t\t\tnum_req--;\n\t\t\tbreak;\n\t\tcase SSH2_FXP_DATA:\n\t\t\tif ((r = sshbuf_get_string(msg, &data, &len)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"Received data %llu -> %llu\",\n\t\t\t    (unsigned long long)req->offset,\n\t\t\t    (unsigned long long)req->offset + len - 1);\n\t\t\tif (len > req->len)\n\t\t\t\tfatal(\"Received more data than asked for \"\n\t\t\t\t    \"%zu > %zu\", len, req->len);\n\t\t\tif ((lseek(local_fd, req->offset, SEEK_SET) == -1 ||\n\t\t\t    atomicio(vwrite, local_fd, data, len) != len) &&\n\t\t\t    !write_error) {\n\t\t\t\twrite_errno = errno;\n\t\t\t\twrite_error = 1;\n\t\t\t\tmax_req = 0;\n\t\t\t}\n\t\t\telse if (!reordered && req->offset <= highwater)\n\t\t\t\thighwater = req->offset + len;\n\t\t\telse if (!reordered && req->offset > highwater)\n\t\t\t\treordered = 1;\n\t\t\tprogress_counter += len;\n\t\t\tfree(data);\n\n\t\t\tif (len == req->len) {\n\t\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\t\tfree(req);\n\t\t\t\tnum_req--;\n\t\t\t} else {\n\t\t\t\t/* Resend the request for the missing data */\n\t\t\t\tdebug3(\"Short data block, re-requesting \"\n\t\t\t\t    \"%llu -> %llu (%2d)\",\n\t\t\t\t    (unsigned long long)req->offset + len,\n\t\t\t\t    (unsigned long long)req->offset +\n\t\t\t\t    req->len - 1, num_req);\n\t\t\t\treq->id = conn->msg_id++;\n\t\t\t\treq->len -= len;\n\t\t\t\treq->offset += len;\n\t\t\t\tsend_read_request(conn, req->id,\n\t\t\t\t    req->offset, req->len, handle, handle_len);\n\t\t\t\t/* Reduce the request size */\n\t\t\t\tif (len < buflen)\n\t\t\t\t\tbuflen = MAXIMUM(MIN_READ_SIZE, len);\n\t\t\t}\n\t\t\tif (max_req > 0) { /* max_req = 0 iff EOF received */\n\t\t\t\tif (size > 0 && offset > size) {\n\t\t\t\t\t/* Only one request at a time\n\t\t\t\t\t * after the expected EOF */\n\t\t\t\t\tdebug3(\"Finish at %llu (%2d)\",\n\t\t\t\t\t    (unsigned long long)offset,\n\t\t\t\t\t    num_req);\n\t\t\t\t\tmax_req = 1;\n\t\t\t\t} else if (max_req <= conn->num_requests) {\n\t\t\t\t\t++max_req;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Expected SSH2_FXP_DATA(%u) packet, got %u\",\n\t\t\t    SSH2_FXP_DATA, type);\n\t\t}\n\t}\n\n\tif (showprogress && size)\n\t\tstop_progress_meter();\n\n\t/* Sanity check */\n\tif (TAILQ_FIRST(&requests) != NULL)\n\t\tfatal(\"Transfer complete, but requests still in queue\");\n\t/* Truncate at highest contiguous point to avoid holes on interrupt */\n\tif (read_error || write_error || interrupted) {\n\t\tif (reordered && resume_flag) {\n\t\t\terror(\"Unable to resume download of \\\"%s\\\": \"\n\t\t\t    \"server reordered requests\", local_path);\n\t\t}\n\t\tdebug(\"truncating at %llu\", (unsigned long long)highwater);\n\t\tif (ftruncate(local_fd, highwater) == -1)\n\t\t\terror(\"ftruncate \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\t}\n\tif (read_error) {\n\t\terror(\"Couldn't read from remote file \\\"%s\\\" : %s\",\n\t\t    remote_path, fx2txt(status));\n\t\tstatus = -1;\n\t\tdo_close(conn, handle, handle_len);\n\t} else if (write_error) {\n\t\terror(\"Couldn't write to \\\"%s\\\": %s\", local_path,\n\t\t    strerror(write_errno));\n\t\tstatus = SSH2_FX_FAILURE;\n\t\tdo_close(conn, handle, handle_len);\n\t} else {\n\t\tif (do_close(conn, handle, handle_len) != 0 || interrupted)\n\t\t\tstatus = SSH2_FX_FAILURE;\n\t\telse\n\t\t\tstatus = SSH2_FX_OK;\n\t\t/* Override umask and utimes if asked */\n#ifdef HAVE_FCHMOD\n\t\tif (preserve_flag && fchmod(local_fd, mode) == -1)\n#else\n\t\tif (preserve_flag && chmod(local_path, mode) == -1)\n#endif /* HAVE_FCHMOD */\n\t\t\terror(\"Couldn't set mode on \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\t\tif (preserve_flag &&\n\t\t    (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME)) {\n\t\t\tstruct timeval tv[2];\n\t\t\ttv[0].tv_sec = a->atime;\n\t\t\ttv[1].tv_sec = a->mtime;\n\t\t\ttv[0].tv_usec = tv[1].tv_usec = 0;\n\t\t\tif (utimes(local_path, tv) == -1)\n\t\t\t\terror(\"Can't set times on \\\"%s\\\": %s\",\n\t\t\t\t    local_path, strerror(errno));\n\t\t}\n\t\tif (fsync_flag) {\n\t\t\tdebug(\"syncing \\\"%s\\\"\", local_path);\n\t\t\tif (fsync(local_fd) == -1)\n\t\t\t\terror(\"Couldn't sync file \\\"%s\\\": %s\",\n\t\t\t\t    local_path, strerror(errno));\n\t\t}\n\t}\n\tclose(local_fd);\n\tsshbuf_free(msg);\n\tfree(handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MIN_READ_SIZE\t512"
          ],
          "globals_used": [
            "extern volatile sig_atomic_t interrupted;",
            "extern int showprogress;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MIN_READ_SIZE\t512\n\nextern volatile sig_atomic_t interrupted;\nextern int showprogress;\n\nint\ndo_download(struct sftp_conn *conn, const char *remote_path,\n    const char *local_path, Attrib *a, int preserve_flag, int resume_flag,\n    int fsync_flag)\n{\n\tAttrib junk;\n\tstruct sshbuf *msg;\n\tu_char *handle;\n\tint local_fd = -1, write_error;\n\tint read_error, write_errno, reordered = 0, r;\n\tu_int64_t offset = 0, size, highwater;\n\tu_int mode, id, buflen, num_req, max_req, status = SSH2_FX_OK;\n\toff_t progress_counter;\n\tsize_t handle_len;\n\tstruct stat st;\n\tstruct request {\n\t\tu_int id;\n\t\tsize_t len;\n\t\tu_int64_t offset;\n\t\tTAILQ_ENTRY(request) tq;\n\t};\n\tTAILQ_HEAD(reqhead, request) requests;\n\tstruct request *req;\n\tu_char type;\n\n\tTAILQ_INIT(&requests);\n\n\tif (a == NULL && (a = do_stat(conn, remote_path, 0)) == NULL)\n\t\treturn -1;\n\n\t/* Do not preserve set[ug]id here, as we do not preserve ownership */\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)\n\t\tmode = a->perm & 0777;\n\telse\n\t\tmode = 0666;\n\n\tif ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&\n\t    (!S_ISREG(a->perm))) {\n\t\terror(\"Cannot download non-regular file: %s\", remote_path);\n\t\treturn(-1);\n\t}\n\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE)\n\t\tsize = a->size;\n\telse\n\t\tsize = 0;\n\n\tbuflen = conn->transfer_buflen;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tattrib_clear(&junk); /* Send empty attributes */\n\n\t/* Send open request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FXF_READ)) != 0 ||\n\t    (r = encode_attrib(msg, &junk)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, remote_path);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote open(\\\"%s\\\")\", remote_path);\n\tif (handle == NULL) {\n\t\tsshbuf_free(msg);\n\t\treturn(-1);\n\t}\n\n\tlocal_fd = open(local_path,\n\t    O_WRONLY | O_CREAT | (resume_flag ? 0 : O_TRUNC), mode | S_IWUSR);\n\tif (local_fd == -1) {\n\t\terror(\"Couldn't open local file \\\"%s\\\" for writing: %s\",\n\t\t    local_path, strerror(errno));\n\t\tgoto fail;\n\t}\n\toffset = highwater = 0;\n\tif (resume_flag) {\n\t\tif (fstat(local_fd, &st) == -1) {\n\t\t\terror(\"Unable to stat local file \\\"%s\\\": %s\",\n\t\t\t    local_path, strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (st.st_size < 0) {\n\t\t\terror(\"\\\"%s\\\" has negative size\", local_path);\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((u_int64_t)st.st_size > size) {\n\t\t\terror(\"Unable to resume download of \\\"%s\\\": \"\n\t\t\t    \"local file is larger than remote\", local_path);\n fail:\n\t\t\tdo_close(conn, handle, handle_len);\n\t\t\tsshbuf_free(msg);\n\t\t\tfree(handle);\n\t\t\tif (local_fd != -1)\n\t\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = highwater = st.st_size;\n\t}\n\n\t/* Read from remote and write to local */\n\twrite_error = read_error = write_errno = num_req = 0;\n\tmax_req = 1;\n\tprogress_counter = offset;\n\n\tif (showprogress && size != 0)\n\t\tstart_progress_meter(remote_path, size, &progress_counter);\n\n\twhile (num_req > 0 || max_req > 0) {\n\t\tu_char *data;\n\t\tsize_t len;\n\n\t\t/*\n\t\t * Simulate EOF on interrupt: stop sending new requests and\n\t\t * allow outstanding requests to drain gracefully\n\t\t */\n\t\tif (interrupted) {\n\t\t\tif (num_req == 0) /* If we haven't started yet... */\n\t\t\t\tbreak;\n\t\t\tmax_req = 0;\n\t\t}\n\n\t\t/* Send some more requests */\n\t\twhile (num_req < max_req) {\n\t\t\tdebug3(\"Request range %llu -> %llu (%d/%d)\",\n\t\t\t    (unsigned long long)offset,\n\t\t\t    (unsigned long long)offset + buflen - 1,\n\t\t\t    num_req, max_req);\n\t\t\treq = xcalloc(1, sizeof(*req));\n\t\t\treq->id = conn->msg_id++;\n\t\t\treq->len = buflen;\n\t\t\treq->offset = offset;\n\t\t\toffset += buflen;\n\t\t\tnum_req++;\n\t\t\tTAILQ_INSERT_TAIL(&requests, req, tq);\n\t\t\tsend_read_request(conn, req->id, req->offset,\n\t\t\t    req->len, handle, handle_len);\n\t\t}\n\n\t\tsshbuf_reset(msg);\n\t\tget_msg(conn, msg);\n\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tdebug3(\"Received reply T:%u I:%u R:%d\", type, id, max_req);\n\n\t\t/* Find the request in our queue */\n\t\tfor (req = TAILQ_FIRST(&requests);\n\t\t    req != NULL && req->id != id;\n\t\t    req = TAILQ_NEXT(req, tq))\n\t\t\t;\n\t\tif (req == NULL)\n\t\t\tfatal(\"Unexpected reply %u\", id);\n\n\t\tswitch (type) {\n\t\tcase SSH2_FXP_STATUS:\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (status != SSH2_FX_EOF)\n\t\t\t\tread_error = 1;\n\t\t\tmax_req = 0;\n\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\tfree(req);\n\t\t\tnum_req--;\n\t\t\tbreak;\n\t\tcase SSH2_FXP_DATA:\n\t\t\tif ((r = sshbuf_get_string(msg, &data, &len)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"Received data %llu -> %llu\",\n\t\t\t    (unsigned long long)req->offset,\n\t\t\t    (unsigned long long)req->offset + len - 1);\n\t\t\tif (len > req->len)\n\t\t\t\tfatal(\"Received more data than asked for \"\n\t\t\t\t    \"%zu > %zu\", len, req->len);\n\t\t\tif ((lseek(local_fd, req->offset, SEEK_SET) == -1 ||\n\t\t\t    atomicio(vwrite, local_fd, data, len) != len) &&\n\t\t\t    !write_error) {\n\t\t\t\twrite_errno = errno;\n\t\t\t\twrite_error = 1;\n\t\t\t\tmax_req = 0;\n\t\t\t}\n\t\t\telse if (!reordered && req->offset <= highwater)\n\t\t\t\thighwater = req->offset + len;\n\t\t\telse if (!reordered && req->offset > highwater)\n\t\t\t\treordered = 1;\n\t\t\tprogress_counter += len;\n\t\t\tfree(data);\n\n\t\t\tif (len == req->len) {\n\t\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\t\tfree(req);\n\t\t\t\tnum_req--;\n\t\t\t} else {\n\t\t\t\t/* Resend the request for the missing data */\n\t\t\t\tdebug3(\"Short data block, re-requesting \"\n\t\t\t\t    \"%llu -> %llu (%2d)\",\n\t\t\t\t    (unsigned long long)req->offset + len,\n\t\t\t\t    (unsigned long long)req->offset +\n\t\t\t\t    req->len - 1, num_req);\n\t\t\t\treq->id = conn->msg_id++;\n\t\t\t\treq->len -= len;\n\t\t\t\treq->offset += len;\n\t\t\t\tsend_read_request(conn, req->id,\n\t\t\t\t    req->offset, req->len, handle, handle_len);\n\t\t\t\t/* Reduce the request size */\n\t\t\t\tif (len < buflen)\n\t\t\t\t\tbuflen = MAXIMUM(MIN_READ_SIZE, len);\n\t\t\t}\n\t\t\tif (max_req > 0) { /* max_req = 0 iff EOF received */\n\t\t\t\tif (size > 0 && offset > size) {\n\t\t\t\t\t/* Only one request at a time\n\t\t\t\t\t * after the expected EOF */\n\t\t\t\t\tdebug3(\"Finish at %llu (%2d)\",\n\t\t\t\t\t    (unsigned long long)offset,\n\t\t\t\t\t    num_req);\n\t\t\t\t\tmax_req = 1;\n\t\t\t\t} else if (max_req <= conn->num_requests) {\n\t\t\t\t\t++max_req;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Expected SSH2_FXP_DATA(%u) packet, got %u\",\n\t\t\t    SSH2_FXP_DATA, type);\n\t\t}\n\t}\n\n\tif (showprogress && size)\n\t\tstop_progress_meter();\n\n\t/* Sanity check */\n\tif (TAILQ_FIRST(&requests) != NULL)\n\t\tfatal(\"Transfer complete, but requests still in queue\");\n\t/* Truncate at highest contiguous point to avoid holes on interrupt */\n\tif (read_error || write_error || interrupted) {\n\t\tif (reordered && resume_flag) {\n\t\t\terror(\"Unable to resume download of \\\"%s\\\": \"\n\t\t\t    \"server reordered requests\", local_path);\n\t\t}\n\t\tdebug(\"truncating at %llu\", (unsigned long long)highwater);\n\t\tif (ftruncate(local_fd, highwater) == -1)\n\t\t\terror(\"ftruncate \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\t}\n\tif (read_error) {\n\t\terror(\"Couldn't read from remote file \\\"%s\\\" : %s\",\n\t\t    remote_path, fx2txt(status));\n\t\tstatus = -1;\n\t\tdo_close(conn, handle, handle_len);\n\t} else if (write_error) {\n\t\terror(\"Couldn't write to \\\"%s\\\": %s\", local_path,\n\t\t    strerror(write_errno));\n\t\tstatus = SSH2_FX_FAILURE;\n\t\tdo_close(conn, handle, handle_len);\n\t} else {\n\t\tif (do_close(conn, handle, handle_len) != 0 || interrupted)\n\t\t\tstatus = SSH2_FX_FAILURE;\n\t\telse\n\t\t\tstatus = SSH2_FX_OK;\n\t\t/* Override umask and utimes if asked */\n#ifdef HAVE_FCHMOD\n\t\tif (preserve_flag && fchmod(local_fd, mode) == -1)\n#else\n\t\tif (preserve_flag && chmod(local_path, mode) == -1)\n#endif /* HAVE_FCHMOD */\n\t\t\terror(\"Couldn't set mode on \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\t\tif (preserve_flag &&\n\t\t    (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME)) {\n\t\t\tstruct timeval tv[2];\n\t\t\ttv[0].tv_sec = a->atime;\n\t\t\ttv[1].tv_sec = a->mtime;\n\t\t\ttv[0].tv_usec = tv[1].tv_usec = 0;\n\t\t\tif (utimes(local_path, tv) == -1)\n\t\t\t\terror(\"Can't set times on \\\"%s\\\": %s\",\n\t\t\t\t    local_path, strerror(errno));\n\t\t}\n\t\tif (fsync_flag) {\n\t\t\tdebug(\"syncing \\\"%s\\\"\", local_path);\n\t\t\tif (fsync(local_fd) == -1)\n\t\t\t\terror(\"Couldn't sync file \\\"%s\\\": %s\",\n\t\t\t\t    local_path, strerror(errno));\n\t\t}\n\t}\n\tclose(local_fd);\n\tsshbuf_free(msg);\n\tfree(handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "download_dir",
          "args": [
            "conn",
            "g.gl_pathv[i]",
            "abs_dst",
            "NULL",
            "pflag || global_pflag",
            "1",
            "resume",
            "fflag || global_fflag"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "download_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1551-1568",
          "snippet": "int\ndownload_dir(struct sftp_conn *conn, const char *src, const char *dst,\n    Attrib *dirattrib, int preserve_flag, int print_flag, int resume_flag,\n    int fsync_flag)\n{\n\tchar *src_canon;\n\tint ret;\n\n\tif ((src_canon = do_realpath(conn, src)) == NULL) {\n\t\terror(\"Unable to canonicalize path \\\"%s\\\"\", src);\n\t\treturn -1;\n\t}\n\n\tret = download_dir_internal(conn, src_canon, dst, 0,\n\t    dirattrib, preserve_flag, print_flag, resume_flag, fsync_flag);\n\tfree(src_canon);\n\treturn ret;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndownload_dir(struct sftp_conn *conn, const char *src, const char *dst,\n    Attrib *dirattrib, int preserve_flag, int print_flag, int resume_flag,\n    int fsync_flag)\n{\n\tchar *src_canon;\n\tint ret;\n\n\tif ((src_canon = do_realpath(conn, src)) == NULL) {\n\t\terror(\"Unable to canonicalize path \\\"%s\\\"\", src);\n\t\treturn -1;\n\t}\n\n\tret = download_dir_internal(conn, src_canon, dst, 0,\n\t    dirattrib, preserve_flag, print_flag, resume_flag, fsync_flag);\n\tfree(src_canon);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathname_is_dir",
          "args": [
            "g.gl_pathv[i]"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "pathname_is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "610-616",
          "snippet": "static int\npathname_is_dir(const char *pathname)\n{\n\tsize_t l = strlen(pathname);\n\n\treturn l > 0 && pathname[l - 1] == '/';\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\npathname_is_dir(const char *pathname)\n{\n\tsize_t l = strlen(pathname);\n\n\treturn l > 0 && pathname[l - 1] == '/';\n}"
        }
      },
      {
        "call_info": {
          "callee": "mprintf",
          "args": [
            "\"Fetching %s to %s\\n\"",
            "g.gl_pathv[i]",
            "abs_dst"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "filename"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_append",
          "args": [
            "dst",
            "filename"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "path_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1906-1919",
          "snippet": "char *\npath_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\npath_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"basename %s: %s\"",
            "tmp",
            "strerror(errno)"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "basename",
          "args": [
            "tmp"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "basename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/basename.c",
          "lines": "26-65",
          "snippet": "char *\nbasename(const char *path)\n{\n\tstatic char bname[MAXPATHLEN];\n\tsize_t len;\n\tconst char *endp, *startp;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tbname[0] = '.';\n\t\tbname[1] = '\\0';\n\t\treturn (bname);\n\t}\n\n\t/* Strip any trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* All slashes becomes \"/\" */\n\tif (endp == path && *endp == '/') {\n\t\tbname[0] = '/';\n\t\tbname[1] = '\\0';\n\t\treturn (bname);\n\t}\n\n\t/* Find the start of the base */\n\tstartp = endp;\n\twhile (startp > path && *(startp - 1) != '/')\n\t\tstartp--;\n\n\tlen = endp - startp + 1;\n\tif (len >= sizeof(bname)) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn (NULL);\n\t}\n\tmemcpy(bname, startp, len);\n\tbname[len] = '\\0';\n\treturn (bname);\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"includes.h\"\n\nchar *\nbasename(const char *path)\n{\n\tstatic char bname[MAXPATHLEN];\n\tsize_t len;\n\tconst char *endp, *startp;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tbname[0] = '.';\n\t\tbname[1] = '\\0';\n\t\treturn (bname);\n\t}\n\n\t/* Strip any trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* All slashes becomes \"/\" */\n\tif (endp == path && *endp == '/') {\n\t\tbname[0] = '/';\n\t\tbname[1] = '\\0';\n\t\treturn (bname);\n\t}\n\n\t/* Find the start of the base */\n\tstartp = endp;\n\twhile (startp > path && *(startp - 1) != '/')\n\t\tstartp--;\n\n\tlen = endp - startp + 1;\n\tif (len >= sizeof(bname)) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn (NULL);\n\t}\n\tmemcpy(bname, startp, len);\n\tbname[len] = '\\0';\n\treturn (bname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remote_glob",
          "args": [
            "conn",
            "abs_src",
            "GLOB_MARK",
            "NULL",
            "&g"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "remote_glob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-glob.c",
          "lines": "136-150",
          "snippet": "int\nremote_glob(struct sftp_conn *conn, const char *pattern, int flags,\n    int (*errfunc)(const char *, int), glob_t *pglob)\n{\n\tpglob->gl_opendir = fudge_opendir;\n\tpglob->gl_readdir = (struct dirent *(*)(void *))fudge_readdir;\n\tpglob->gl_closedir = (void (*)(void *))fudge_closedir;\n\tpglob->gl_lstat = fudge_lstat;\n\tpglob->gl_stat = fudge_stat;\n\n\tmemset(&cur, 0, sizeof(cur));\n\tcur.conn = conn;\n\n\treturn(glob(pattern, flags | GLOB_ALTDIRFUNC, errfunc, pglob));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <dirent.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);",
            "static struct {\n\tstruct sftp_conn *conn;\n} cur;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <dirent.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\nstatic struct {\n\tstruct sftp_conn *conn;\n} cur;\n\nint\nremote_glob(struct sftp_conn *conn, const char *pattern, int flags,\n    int (*errfunc)(const char *, int), glob_t *pglob)\n{\n\tpglob->gl_opendir = fudge_opendir;\n\tpglob->gl_readdir = (struct dirent *(*)(void *))fudge_readdir;\n\tpglob->gl_closedir = (void (*)(void *))fudge_closedir;\n\tpglob->gl_lstat = fudge_lstat;\n\tpglob->gl_stat = fudge_stat;\n\n\tmemset(&cur, 0, sizeof(cur));\n\tcur.conn = conn;\n\n\treturn(glob(pattern, flags | GLOB_ALTDIRFUNC, errfunc, pglob));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Looking up %s\"",
            "abs_src"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&g",
            "0",
            "sizeof(g)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_absolute",
          "args": [
            "abs_src",
            "pwd"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "make_absolute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "386-398",
          "snippet": "static char *\nmake_absolute(char *p, const char *pwd)\n{\n\tchar *abs_str;\n\n\t/* Derelativise */\n\tif (p && p[0] != '/') {\n\t\tabs_str = path_append(pwd, p);\n\t\tfree(p);\n\t\treturn(abs_str);\n\t} else\n\t\treturn(p);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nmake_absolute(char *p, const char *pwd)\n{\n\tchar *abs_str;\n\n\t/* Derelativise */\n\tif (p && p[0] != '/') {\n\t\tabs_str = path_append(pwd, p);\n\t\tfree(p);\n\t\treturn(abs_str);\n\t} else\n\t\treturn(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint quiet = 0;\nint global_rflag = 0;\nint global_aflag = 0;\nint global_pflag = 0;\nint global_fflag = 0;\nvolatile sig_atomic_t interrupted = 0;\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\n\nstatic int\nprocess_get(struct sftp_conn *conn, const char *src, const char *dst,\n    const char *pwd, int pflag, int rflag, int resume, int fflag)\n{\n\tchar *abs_src = NULL;\n\tchar *abs_dst = NULL;\n\tglob_t g;\n\tchar *filename, *tmp=NULL;\n\tint i, r, err = 0;\n\n\tabs_src = xstrdup(src);\n\tabs_src = make_absolute(abs_src, pwd);\n\tmemset(&g, 0, sizeof(g));\n\n\tdebug3(\"Looking up %s\", abs_src);\n\tif ((r = remote_glob(conn, abs_src, GLOB_MARK, NULL, &g)) != 0) {\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Too many matches for \\\"%s\\\".\", abs_src);\n\t\t} else {\n\t\t\terror(\"File \\\"%s\\\" not found.\", abs_src);\n\t\t}\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If multiple matches then dst must be a directory or\n\t * unspecified.\n\t */\n\tif (g.gl_matchc > 1 && dst != NULL && !is_dir(dst)) {\n\t\terror(\"Multiple source paths, but destination \"\n\t\t    \"\\\"%s\\\" is not a directory\", dst);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\ttmp = xstrdup(g.gl_pathv[i]);\n\t\tif ((filename = basename(tmp)) == NULL) {\n\t\t\terror(\"basename %s: %s\", tmp, strerror(errno));\n\t\t\tfree(tmp);\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (g.gl_matchc == 1 && dst) {\n\t\t\tif (is_dir(dst)) {\n\t\t\t\tabs_dst = path_append(dst, filename);\n\t\t\t} else {\n\t\t\t\tabs_dst = xstrdup(dst);\n\t\t\t}\n\t\t} else if (dst) {\n\t\t\tabs_dst = path_append(dst, filename);\n\t\t} else {\n\t\t\tabs_dst = xstrdup(filename);\n\t\t}\n\t\tfree(tmp);\n\n\t\tresume |= global_aflag;\n\t\tif (!quiet && resume)\n\t\t\tmprintf(\"Resuming %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\telse if (!quiet && !resume)\n\t\t\tmprintf(\"Fetching %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\tif (pathname_is_dir(g.gl_pathv[i]) && (rflag || global_rflag)) {\n\t\t\tif (download_dir(conn, g.gl_pathv[i], abs_dst, NULL,\n\t\t\t    pflag || global_pflag, 1, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t} else {\n\t\t\tif (do_download(conn, g.gl_pathv[i], abs_dst, NULL,\n\t\t\t    pflag || global_pflag, resume,\n\t\t\t    fflag || global_fflag) == -1)\n\t\t\t\terr = -1;\n\t\t}\n\t\tfree(abs_dst);\n\t\tabs_dst = NULL;\n\t}\n\nout:\n\tfree(abs_src);\n\tglobfree(&g);\n\treturn(err);\n}"
  },
  {
    "function_name": "pathname_is_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "610-616",
    "snippet": "static int\npathname_is_dir(const char *pathname)\n{\n\tsize_t l = strlen(pathname);\n\n\treturn l > 0 && pathname[l - 1] == '/';\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pathname"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\npathname_is_dir(const char *pathname)\n{\n\tsize_t l = strlen(pathname);\n\n\treturn l > 0 && pathname[l - 1] == '/';\n}"
  },
  {
    "function_name": "remote_is_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "596-607",
    "snippet": "static int\nremote_is_dir(struct sftp_conn *conn, const char *path)\n{\n\tAttrib *a;\n\n\t/* XXX: report errors? */\n\tif ((a = do_stat(conn, path, 1)) == NULL)\n\t\treturn(0);\n\tif (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))\n\t\treturn(0);\n\treturn(S_ISDIR(a->perm));\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "a->perm"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_stat",
          "args": [
            "conn",
            "path",
            "1"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "do_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "742-754",
          "snippet": "Attrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nAttrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nremote_is_dir(struct sftp_conn *conn, const char *path)\n{\n\tAttrib *a;\n\n\t/* XXX: report errors? */\n\tif ((a = do_stat(conn, path, 1)) == NULL)\n\t\treturn(0);\n\tif (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))\n\t\treturn(0);\n\treturn(S_ISDIR(a->perm));\n}"
  },
  {
    "function_name": "is_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "584-594",
    "snippet": "static int\nis_dir(const char *path)\n{\n\tstruct stat sb;\n\n\t/* XXX: report errors? */\n\tif (stat(path, &sb) == -1)\n\t\treturn(0);\n\n\treturn(S_ISDIR(sb.st_mode));\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb.st_mode"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&sb"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_dir(const char *path)\n{\n\tstruct stat sb;\n\n\t/* XXX: report errors? */\n\tif (stat(path, &sb) == -1)\n\t\treturn(0);\n\n\treturn(S_ISDIR(sb.st_mode));\n}"
  },
  {
    "function_name": "parse_no_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "564-582",
    "snippet": "static int\nparse_no_flags(const char *cmd, char **argv, int argc)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\twhile ((ch = getopt(argc, argv, \"\")) != -1) {\n\t\tswitch (ch) {\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Invalid flag -%c\"",
            "cmd",
            "optopt"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"\""
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_no_flags(const char *cmd, char **argv, int argc)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\twhile ((ch = getopt(argc, argv, \"\")) != -1) {\n\t\tswitch (ch) {\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}"
  },
  {
    "function_name": "parse_df_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "537-562",
    "snippet": "static int\nparse_df_flags(const char *cmd, char **argv, int argc, int *hflag, int *iflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*hflag = *iflag = 0;\n\twhile ((ch = getopt(argc, argv, \"hi\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'h':\n\t\t\t*hflag = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\t*iflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Invalid flag -%c\"",
            "cmd",
            "optopt"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"hi\""
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_df_flags(const char *cmd, char **argv, int argc, int *hflag, int *iflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*hflag = *iflag = 0;\n\twhile ((ch = getopt(argc, argv, \"hi\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'h':\n\t\t\t*hflag = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\t*iflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}"
  },
  {
    "function_name": "parse_ls_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "484-535",
    "snippet": "static int\nparse_ls_flags(char **argv, int argc, int *lflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*lflag = LS_NAME_SORT;\n\twhile ((ch = getopt(argc, argv, \"1Safhlnrt\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase '1':\n\t\t\t*lflag &= ~VIEW_FLAGS;\n\t\t\t*lflag |= LS_SHORT_VIEW;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\t*lflag |= LS_SIZE_SORT;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t*lflag |= LS_SHOW_ALL;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\t*lflag |= LS_SI_UNITS;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t*lflag &= ~LS_SHORT_VIEW;\n\t\t\t*lflag |= LS_LONG_VIEW;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t*lflag &= ~LS_SHORT_VIEW;\n\t\t\t*lflag |= LS_NUMERIC_VIEW|LS_LONG_VIEW;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\t*lflag |= LS_REVERSE_SORT;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\t*lflag |= LS_TIME_SORT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"ls: Invalid flag -%c\", optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)",
      "#define VIEW_FLAGS\t(LS_LONG_VIEW|LS_SHORT_VIEW|LS_NUMERIC_VIEW|LS_SI_UNITS)",
      "#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */",
      "#define LS_SHOW_ALL\t0x0080\t/* Don't skip filenames starting with '.' */",
      "#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */",
      "#define LS_SIZE_SORT\t0x0020\t/* Sort by file size */",
      "#define LS_TIME_SORT\t0x0010\t/* Sort by mtime */",
      "#define LS_NAME_SORT\t0x0008\t/* Sort by name (default) */",
      "#define LS_NUMERIC_VIEW\t0x0004\t/* Long view with numeric uid/gid */",
      "#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */",
      "#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ls: Invalid flag -%c\"",
            "optopt"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"1Safhlnrt\""
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)\n#define VIEW_FLAGS\t(LS_LONG_VIEW|LS_SHORT_VIEW|LS_NUMERIC_VIEW|LS_SI_UNITS)\n#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */\n#define LS_SHOW_ALL\t0x0080\t/* Don't skip filenames starting with '.' */\n#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */\n#define LS_SIZE_SORT\t0x0020\t/* Sort by file size */\n#define LS_TIME_SORT\t0x0010\t/* Sort by mtime */\n#define LS_NAME_SORT\t0x0008\t/* Sort by name (default) */\n#define LS_NUMERIC_VIEW\t0x0004\t/* Long view with numeric uid/gid */\n#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */\n#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */\n\nstatic int\nparse_ls_flags(char **argv, int argc, int *lflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*lflag = LS_NAME_SORT;\n\twhile ((ch = getopt(argc, argv, \"1Safhlnrt\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase '1':\n\t\t\t*lflag &= ~VIEW_FLAGS;\n\t\t\t*lflag |= LS_SHORT_VIEW;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\t*lflag |= LS_SIZE_SORT;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t*lflag |= LS_SHOW_ALL;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\t*lflag |= LS_SI_UNITS;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t*lflag &= ~LS_SHORT_VIEW;\n\t\t\t*lflag |= LS_LONG_VIEW;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t*lflag &= ~LS_SHORT_VIEW;\n\t\t\t*lflag |= LS_NUMERIC_VIEW|LS_LONG_VIEW;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\t*lflag |= LS_REVERSE_SORT;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\t*lflag |= LS_TIME_SORT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"ls: Invalid flag -%c\", optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}"
  },
  {
    "function_name": "parse_rename_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "460-482",
    "snippet": "static int\nparse_rename_flags(const char *cmd, char **argv, int argc, int *lflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*lflag = 0;\n\twhile ((ch = getopt(argc, argv, \"l\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'l':\n\t\t\t*lflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Invalid flag -%c\"",
            "cmd",
            "optopt"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"l\""
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_rename_flags(const char *cmd, char **argv, int argc, int *lflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*lflag = 0;\n\twhile ((ch = getopt(argc, argv, \"l\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'l':\n\t\t\t*lflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}"
  },
  {
    "function_name": "parse_link_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "436-458",
    "snippet": "static int\nparse_link_flags(const char *cmd, char **argv, int argc, int *sflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*sflag = 0;\n\twhile ((ch = getopt(argc, argv, \"s\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 's':\n\t\t\t*sflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Invalid flag -%c\"",
            "cmd",
            "optopt"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"s\""
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_link_flags(const char *cmd, char **argv, int argc, int *sflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*sflag = 0;\n\twhile ((ch = getopt(argc, argv, \"s\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 's':\n\t\t\t*sflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}"
  },
  {
    "function_name": "parse_getput_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "400-434",
    "snippet": "static int\nparse_getput_flags(const char *cmd, char **argv, int argc,\n    int *aflag, int *fflag, int *pflag, int *rflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*aflag = *fflag = *rflag = *pflag = 0;\n\twhile ((ch = getopt(argc, argv, \"afPpRr\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\t*aflag = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t*fflag = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\t*pflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\tcase 'R':\n\t\t\t*rflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Invalid flag -%c\"",
            "cmd",
            "optopt"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"afPpRr\""
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_getput_flags(const char *cmd, char **argv, int argc,\n    int *aflag, int *fflag, int *pflag, int *rflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*aflag = *fflag = *rflag = *pflag = 0;\n\twhile ((ch = getopt(argc, argv, \"afPpRr\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\t*aflag = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t*fflag = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\t*pflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\tcase 'R':\n\t\t\t*rflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}"
  },
  {
    "function_name": "make_absolute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "386-398",
    "snippet": "static char *\nmake_absolute(char *p, const char *pwd)\n{\n\tchar *abs_str;\n\n\t/* Derelativise */\n\tif (p && p[0] != '/') {\n\t\tabs_str = path_append(pwd, p);\n\t\tfree(p);\n\t\treturn(abs_str);\n\t} else\n\t\treturn(p);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_append",
          "args": [
            "pwd",
            "p"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "path_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1906-1919",
          "snippet": "char *\npath_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\npath_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nmake_absolute(char *p, const char *pwd)\n{\n\tchar *abs_str;\n\n\t/* Derelativise */\n\tif (p && p[0] != '/') {\n\t\tabs_str = path_append(pwd, p);\n\t\tfree(p);\n\t\treturn(abs_str);\n\t} else\n\t\treturn(p);\n}"
  },
  {
    "function_name": "path_strip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "368-384",
    "snippet": "static char *\npath_strip(const char *path, const char *strip)\n{\n\tsize_t len;\n\n\tif (strip == NULL)\n\t\treturn (xstrdup(path));\n\n\tlen = strlen(strip);\n\tif (strncmp(path, strip, len) == 0) {\n\t\tif (strip[len - 1] != '/' && path[len] == '/')\n\t\t\tlen++;\n\t\treturn (xstrdup(path + len));\n\t}\n\n\treturn (xstrdup(path));\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "path"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "strip",
            "len"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "strip"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\npath_strip(const char *path, const char *strip)\n{\n\tsize_t len;\n\n\tif (strip == NULL)\n\t\treturn (xstrdup(path));\n\n\tlen = strlen(strip);\n\tif (strncmp(path, strip, len) == 0) {\n\t\tif (strip[len - 1] != '/' && path[len] == '/')\n\t\t\tlen++;\n\t\treturn (xstrdup(path + len));\n\t}\n\n\treturn (xstrdup(path));\n}"
  },
  {
    "function_name": "local_do_ls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "351-365",
    "snippet": "static void\nlocal_do_ls(const char *args)\n{\n\tif (!args || !*args)\n\t\tlocal_do_shell(_PATH_LS);\n\telse {\n\t\tint len = strlen(_PATH_LS \" \") + strlen(args) + 1;\n\t\tchar *buf = xmalloc(len);\n\n\t\t/* XXX: quoting - rip quoting code from ftp? */\n\t\tsnprintf(buf, len, _PATH_LS \" %s\", args);\n\t\tlocal_do_shell(buf);\n\t\tfree(buf);\n\t}\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_do_shell",
          "args": [
            "buf"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "local_do_shell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "313-349",
          "snippet": "static void\nlocal_do_shell(const char *args)\n{\n\tint status;\n\tchar *shell;\n\tpid_t pid;\n\n\tif (!*args)\n\t\targs = NULL;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"Couldn't fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\t/* XXX: child has pipe fds to ssh subproc open - issue? */\n\t\tif (args) {\n\t\t\tdebug3(\"Executing %s -c \\\"%s\\\"\", shell, args);\n\t\t\texecl(shell, shell, \"-c\", args, (char *)NULL);\n\t\t} else {\n\t\t\tdebug3(\"Executing %s\", shell);\n\t\t\texecl(shell, shell, (char *)NULL);\n\t\t}\n\t\tfprintf(stderr, \"Couldn't execute \\\"%s\\\": %s\\n\", shell,\n\t\t    strerror(errno));\n\t\t_exit(1);\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\tif (!WIFEXITED(status))\n\t\terror(\"Shell exited abnormally\");\n\telse if (WEXITSTATUS(status))\n\t\terror(\"Shell exited with status %d\", WEXITSTATUS(status));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nlocal_do_shell(const char *args)\n{\n\tint status;\n\tchar *shell;\n\tpid_t pid;\n\n\tif (!*args)\n\t\targs = NULL;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"Couldn't fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\t/* XXX: child has pipe fds to ssh subproc open - issue? */\n\t\tif (args) {\n\t\t\tdebug3(\"Executing %s -c \\\"%s\\\"\", shell, args);\n\t\t\texecl(shell, shell, \"-c\", args, (char *)NULL);\n\t\t} else {\n\t\t\tdebug3(\"Executing %s\", shell);\n\t\t\texecl(shell, shell, (char *)NULL);\n\t\t}\n\t\tfprintf(stderr, \"Couldn't execute \\\"%s\\\": %s\\n\", shell,\n\t\t    strerror(errno));\n\t\t_exit(1);\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\tif (!WIFEXITED(status))\n\t\terror(\"Shell exited abnormally\");\n\telse if (WEXITSTATUS(status))\n\t\terror(\"Shell exited with status %d\", WEXITSTATUS(status));\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "len",
            "_PATH_LS \" %s\"",
            "args"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "len"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "args"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "_PATH_LS \" \""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nlocal_do_ls(const char *args)\n{\n\tif (!args || !*args)\n\t\tlocal_do_shell(_PATH_LS);\n\telse {\n\t\tint len = strlen(_PATH_LS \" \") + strlen(args) + 1;\n\t\tchar *buf = xmalloc(len);\n\n\t\t/* XXX: quoting - rip quoting code from ftp? */\n\t\tsnprintf(buf, len, _PATH_LS \" %s\", args);\n\t\tlocal_do_shell(buf);\n\t\tfree(buf);\n\t}\n}"
  },
  {
    "function_name": "local_do_shell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "313-349",
    "snippet": "static void\nlocal_do_shell(const char *args)\n{\n\tint status;\n\tchar *shell;\n\tpid_t pid;\n\n\tif (!*args)\n\t\targs = NULL;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"Couldn't fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\t/* XXX: child has pipe fds to ssh subproc open - issue? */\n\t\tif (args) {\n\t\t\tdebug3(\"Executing %s -c \\\"%s\\\"\", shell, args);\n\t\t\texecl(shell, shell, \"-c\", args, (char *)NULL);\n\t\t} else {\n\t\t\tdebug3(\"Executing %s\", shell);\n\t\t\texecl(shell, shell, (char *)NULL);\n\t\t}\n\t\tfprintf(stderr, \"Couldn't execute \\\"%s\\\": %s\\n\", shell,\n\t\t    strerror(errno));\n\t\t_exit(1);\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\tif (!WIFEXITED(status))\n\t\terror(\"Shell exited abnormally\");\n\telse if (WEXITSTATUS(status))\n\t\terror(\"Shell exited with status %d\", WEXITSTATUS(status));\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Shell exited with status %d\"",
            "WEXITSTATUS(status)"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Couldn't wait for child: %s\"",
            "strerror(errno)"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Couldn't execute \\\"%s\\\": %s\\n\"",
            "shell",
            "strerror(errno)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execl",
          "args": [
            "shell",
            "shell",
            "(char *)NULL"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Executing %s\"",
            "shell"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execl",
          "args": [
            "shell",
            "shell",
            "\"-c\"",
            "args",
            "(char *)NULL"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SHELL\""
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nlocal_do_shell(const char *args)\n{\n\tint status;\n\tchar *shell;\n\tpid_t pid;\n\n\tif (!*args)\n\t\targs = NULL;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"Couldn't fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\t/* XXX: child has pipe fds to ssh subproc open - issue? */\n\t\tif (args) {\n\t\t\tdebug3(\"Executing %s -c \\\"%s\\\"\", shell, args);\n\t\t\texecl(shell, shell, \"-c\", args, (char *)NULL);\n\t\t} else {\n\t\t\tdebug3(\"Executing %s\", shell);\n\t\t\texecl(shell, shell, (char *)NULL);\n\t\t}\n\t\tfprintf(stderr, \"Couldn't execute \\\"%s\\\": %s\\n\", shell,\n\t\t    strerror(errno));\n\t\t_exit(1);\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\tif (!WIFEXITED(status))\n\t\terror(\"Shell exited abnormally\");\n\telse if (WEXITSTATUS(status))\n\t\terror(\"Shell exited with status %d\", WEXITSTATUS(status));\n}"
  },
  {
    "function_name": "help",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "275-311",
    "snippet": "static void\nhelp(void)\n{\n\tprintf(\"Available commands:\\n\"\n\t    \"bye                                Quit sftp\\n\"\n\t    \"cd path                            Change remote directory to 'path'\\n\"\n\t    \"chgrp grp path                     Change group of file 'path' to 'grp'\\n\"\n\t    \"chmod mode path                    Change permissions of file 'path' to 'mode'\\n\"\n\t    \"chown own path                     Change owner of file 'path' to 'own'\\n\"\n\t    \"df [-hi] [path]                    Display statistics for current directory or\\n\"\n\t    \"                                   filesystem containing 'path'\\n\"\n\t    \"exit                               Quit sftp\\n\"\n\t    \"get [-afPpRr] remote [local]       Download file\\n\"\n\t    \"reget [-fPpRr] remote [local]      Resume download file\\n\"\n\t    \"reput [-fPpRr] [local] remote      Resume upload file\\n\"\n\t    \"help                               Display this help text\\n\"\n\t    \"lcd path                           Change local directory to 'path'\\n\"\n\t    \"lls [ls-options [path]]            Display local directory listing\\n\"\n\t    \"lmkdir path                        Create local directory\\n\"\n\t    \"ln [-s] oldpath newpath            Link remote file (-s for symlink)\\n\"\n\t    \"lpwd                               Print local working directory\\n\"\n\t    \"ls [-1afhlnrSt] [path]             Display remote directory listing\\n\"\n\t    \"lumask umask                       Set local umask to 'umask'\\n\"\n\t    \"mkdir path                         Create remote directory\\n\"\n\t    \"progress                           Toggle display of progress meter\\n\"\n\t    \"put [-afPpRr] local [remote]       Upload file\\n\"\n\t    \"pwd                                Display remote working directory\\n\"\n\t    \"quit                               Quit sftp\\n\"\n\t    \"rename oldpath newpath             Rename remote file\\n\"\n\t    \"rm path                            Delete remote file\\n\"\n\t    \"rmdir path                         Remove remote directory\\n\"\n\t    \"symlink oldpath newpath            Symlink remote file\\n\"\n\t    \"version                            Show SFTP version\\n\"\n\t    \"!command                           Execute 'command' in local shell\\n\"\n\t    \"!                                  Escape to local shell\\n\"\n\t    \"?                                  Synonym for help\\n\");\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Available commands:\\n\"\n\t    \"bye                                Quit sftp\\n\"\n\t    \"cd path                            Change remote directory to 'path'\\n\"\n\t    \"chgrp grp path                     Change group of file 'path' to 'grp'\\n\"\n\t    \"chmod mode path                    Change permissions of file 'path' to 'mode'\\n\"\n\t    \"chown own path                     Change owner of file 'path' to 'own'\\n\"\n\t    \"df [-hi] [path]                    Display statistics for current directory or\\n\"\n\t    \"                                   filesystem containing 'path'\\n\"\n\t    \"exit                               Quit sftp\\n\"\n\t    \"get [-afPpRr] remote [local]       Download file\\n\"\n\t    \"reget [-fPpRr] remote [local]      Resume download file\\n\"\n\t    \"reput [-fPpRr] [local] remote      Resume upload file\\n\"\n\t    \"help                               Display this help text\\n\"\n\t    \"lcd path                           Change local directory to 'path'\\n\"\n\t    \"lls [ls-options [path]]            Display local directory listing\\n\"\n\t    \"lmkdir path                        Create local directory\\n\"\n\t    \"ln [-s] oldpath newpath            Link remote file (-s for symlink)\\n\"\n\t    \"lpwd                               Print local working directory\\n\"\n\t    \"ls [-1afhlnrSt] [path]             Display remote directory listing\\n\"\n\t    \"lumask umask                       Set local umask to 'umask'\\n\"\n\t    \"mkdir path                         Create remote directory\\n\"\n\t    \"progress                           Toggle display of progress meter\\n\"\n\t    \"put [-afPpRr] local [remote]       Upload file\\n\"\n\t    \"pwd                                Display remote working directory\\n\"\n\t    \"quit                               Quit sftp\\n\"\n\t    \"rename oldpath newpath             Rename remote file\\n\"\n\t    \"rm path                            Delete remote file\\n\"\n\t    \"rmdir path                         Remove remote directory\\n\"\n\t    \"symlink oldpath newpath            Symlink remote file\\n\"\n\t    \"version                            Show SFTP version\\n\"\n\t    \"!command                           Execute 'command' in local shell\\n\"\n\t    \"!                                  Escape to local shell\\n\"\n\t    \"?                                  Synonym for help\\n\""
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhelp(void)\n{\n\tprintf(\"Available commands:\\n\"\n\t    \"bye                                Quit sftp\\n\"\n\t    \"cd path                            Change remote directory to 'path'\\n\"\n\t    \"chgrp grp path                     Change group of file 'path' to 'grp'\\n\"\n\t    \"chmod mode path                    Change permissions of file 'path' to 'mode'\\n\"\n\t    \"chown own path                     Change owner of file 'path' to 'own'\\n\"\n\t    \"df [-hi] [path]                    Display statistics for current directory or\\n\"\n\t    \"                                   filesystem containing 'path'\\n\"\n\t    \"exit                               Quit sftp\\n\"\n\t    \"get [-afPpRr] remote [local]       Download file\\n\"\n\t    \"reget [-fPpRr] remote [local]      Resume download file\\n\"\n\t    \"reput [-fPpRr] [local] remote      Resume upload file\\n\"\n\t    \"help                               Display this help text\\n\"\n\t    \"lcd path                           Change local directory to 'path'\\n\"\n\t    \"lls [ls-options [path]]            Display local directory listing\\n\"\n\t    \"lmkdir path                        Create local directory\\n\"\n\t    \"ln [-s] oldpath newpath            Link remote file (-s for symlink)\\n\"\n\t    \"lpwd                               Print local working directory\\n\"\n\t    \"ls [-1afhlnrSt] [path]             Display remote directory listing\\n\"\n\t    \"lumask umask                       Set local umask to 'umask'\\n\"\n\t    \"mkdir path                         Create remote directory\\n\"\n\t    \"progress                           Toggle display of progress meter\\n\"\n\t    \"put [-afPpRr] local [remote]       Upload file\\n\"\n\t    \"pwd                                Display remote working directory\\n\"\n\t    \"quit                               Quit sftp\\n\"\n\t    \"rename oldpath newpath             Rename remote file\\n\"\n\t    \"rm path                            Delete remote file\\n\"\n\t    \"rmdir path                         Remove remote directory\\n\"\n\t    \"symlink oldpath newpath            Symlink remote file\\n\"\n\t    \"version                            Show SFTP version\\n\"\n\t    \"!command                           Execute 'command' in local shell\\n\"\n\t    \"!                                  Escape to local shell\\n\"\n\t    \"?                                  Synonym for help\\n\");\n}"
  },
  {
    "function_name": "sigchld_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "257-273",
    "snippet": "static void\nsigchld_handler(int sig)\n{\n\tint save_errno = errno;\n\tpid_t pid;\n\tconst char msg[] = \"\\rConnection closed.  \\n\";\n\n\t/* Report if ssh transport process dies. */\n\twhile ((pid = waitpid(sshpid, NULL, WNOHANG)) == -1 && errno == EINTR)\n\t\tcontinue;\n\tif (pid == sshpid) {\n\t\t(void)write(STDERR_FILENO, msg, sizeof(msg) - 1);\n\t\tsshpid = -1;\n\t}\n\n\terrno = save_errno;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile pid_t sshpid = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "STDERR_FILENO",
            "msg",
            "sizeof(msg) - 1"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "sshpid",
            "NULL",
            "WNOHANG"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile pid_t sshpid = -1;\n\nstatic void\nsigchld_handler(int sig)\n{\n\tint save_errno = errno;\n\tpid_t pid;\n\tconst char msg[] = \"\\rConnection closed.  \\n\";\n\n\t/* Report if ssh transport process dies. */\n\twhile ((pid = waitpid(sshpid, NULL, WNOHANG)) == -1 && errno == EINTR)\n\t\tcontinue;\n\tif (pid == sshpid) {\n\t\t(void)write(STDERR_FILENO, msg, sizeof(msg) - 1);\n\t\tsshpid = -1;\n\t}\n\n\terrno = save_errno;\n}"
  },
  {
    "function_name": "cmd_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "245-254",
    "snippet": "static void\ncmd_interrupt(int signo)\n{\n\tconst char msg[] = \"\\rInterrupt  \\n\";\n\tint olderrno = errno;\n\n\t(void)write(STDERR_FILENO, msg, sizeof(msg) - 1);\n\tinterrupted = 1;\n\terrno = olderrno;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "volatile sig_atomic_t interrupted = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "STDERR_FILENO",
            "msg",
            "sizeof(msg) - 1"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvolatile sig_atomic_t interrupted = 0;\n\nstatic void\ncmd_interrupt(int signo)\n{\n\tconst char msg[] = \"\\rInterrupt  \\n\";\n\tint olderrno = errno;\n\n\t(void)write(STDERR_FILENO, msg, sizeof(msg) - 1);\n\tinterrupted = 1;\n\terrno = olderrno;\n}"
  },
  {
    "function_name": "suspchild",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "233-242",
    "snippet": "static void\nsuspchild(int signo)\n{\n\tif (sshpid > 1) {\n\t\tkill(sshpid, signo);\n\t\twhile (waitpid(sshpid, NULL, WUNTRACED) == -1 && errno == EINTR)\n\t\t\tcontinue;\n\t}\n\tkill(getpid(), SIGSTOP);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile pid_t sshpid = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "getpid()",
            "SIGSTOP"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "sshpid",
            "NULL",
            "WUNTRACED"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "sshpid",
            "signo"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile pid_t sshpid = -1;\n\nstatic void\nsuspchild(int signo)\n{\n\tif (sshpid > 1) {\n\t\tkill(sshpid, signo);\n\t\twhile (waitpid(sshpid, NULL, WUNTRACED) == -1 && errno == EINTR)\n\t\t\tcontinue;\n\t}\n\tkill(getpid(), SIGSTOP);\n}"
  },
  {
    "function_name": "killchild",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
    "lines": "221-230",
    "snippet": "static void\nkillchild(int signo)\n{\n\tif (sshpid > 1) {\n\t\tkill(sshpid, SIGTERM);\n\t\twaitpid(sshpid, NULL, 0);\n\t}\n\n\t_exit(1);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <limits.h>",
      "#include <histedit.h>",
      "# include <locale.h>",
      "#include <libgen.h>",
      "# include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile pid_t sshpid = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "sshpid",
            "NULL",
            "0"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "sshpid",
            "SIGTERM"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile pid_t sshpid = -1;\n\nstatic void\nkillchild(int signo)\n{\n\tif (sshpid > 1) {\n\t\tkill(sshpid, SIGTERM);\n\t\twaitpid(sshpid, NULL, 0);\n\t}\n\n\t_exit(1);\n}"
  }
]