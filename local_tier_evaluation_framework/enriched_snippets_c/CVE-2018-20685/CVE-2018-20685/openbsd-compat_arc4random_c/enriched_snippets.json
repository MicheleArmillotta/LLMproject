[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
    "lines": "322-337",
    "snippet": "int\nmain(int argc, char **argv)\n{\n\tconst int iter = 1000000;\n\tint     i;\n\tpctrval v;\n\n\tv = rdtsc();\n\tfor (i = 0; i < iter; i++)\n\t\tarc4random();\n\tv = rdtsc() - v;\n\tv /= iter;\n\n\tprintf(\"%qd cycles\\n\", v);\n\texit(0);\n}",
    "includes": [
      "#include <machine/pctr.h>",
      "#include <stdio.h>",
      "#include \"chacha_private.h\"",
      "#include \"log.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/rand.h>",
      "# include <sys/random.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%qd cycles\\n\"",
            "v"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-asprintf.c",
          "lines": "86-97",
          "snippet": "int asprintf(char **str, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\t*str = NULL;\n\tva_start(ap, fmt);\n\tret = vasprintf(str, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint asprintf(char **str, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\t*str = NULL;\n\tva_start(ap, fmt);\n\tret = vasprintf(str, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arc4random",
          "args": [],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "235-244",
          "snippet": "u_int32_t\narc4random(void)\n{\n\tu_int32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\narc4random(void)\n{\n\tu_int32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmain(int argc, char **argv)\n{\n\tconst int iter = 1000000;\n\tint     i;\n\tpctrval v;\n\n\tv = rdtsc();\n\tfor (i = 0; i < iter; i++)\n\t\tarc4random();\n\tv = rdtsc() - v;\n\tv /= iter;\n\n\tprintf(\"%qd cycles\\n\", v);\n\texit(0);\n}"
  },
  {
    "function_name": "arc4random_uniform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
    "lines": "291-315",
    "snippet": "u_int32_t\narc4random_uniform(u_int32_t upper_bound)\n{\n\tu_int32_t r, min;\n\n\tif (upper_bound < 2)\n\t\treturn 0;\n\n\t/* 2**32 % x == (2**32 - x) % x */\n\tmin = -upper_bound % upper_bound;\n\n\t/*\n\t * This could theoretically loop forever but each retry has\n\t * p > 0.5 (worst case, usually far better) of selecting a\n\t * number inside the range we need, so it should rarely need\n\t * to re-roll.\n\t */\n\tfor (;;) {\n\t\tr = arc4random();\n\t\tif (r >= min)\n\t\t\tbreak;\n\t}\n\n\treturn r % upper_bound;\n}",
    "includes": [
      "#include <machine/pctr.h>",
      "#include <stdio.h>",
      "#include \"chacha_private.h\"",
      "#include \"log.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/rand.h>",
      "# include <sys/random.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arc4random",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "235-244",
          "snippet": "u_int32_t\narc4random(void)\n{\n\tu_int32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\narc4random(void)\n{\n\tu_int32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\narc4random_uniform(u_int32_t upper_bound)\n{\n\tu_int32_t r, min;\n\n\tif (upper_bound < 2)\n\t\treturn 0;\n\n\t/* 2**32 % x == (2**32 - x) % x */\n\tmin = -upper_bound % upper_bound;\n\n\t/*\n\t * This could theoretically loop forever but each retry has\n\t * p > 0.5 (worst case, usually far better) of selecting a\n\t * number inside the range we need, so it should rarely need\n\t * to re-roll.\n\t */\n\tfor (;;) {\n\t\tr = arc4random();\n\t\tif (r >= min)\n\t\t\tbreak;\n\t}\n\n\treturn r % upper_bound;\n}"
  },
  {
    "function_name": "arc4random_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
    "lines": "263-277",
    "snippet": "void\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}",
    "includes": [
      "#include <machine/pctr.h>",
      "#include <stdio.h>",
      "#include \"chacha_private.h\"",
      "#include \"log.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/rand.h>",
      "# include <sys/random.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "&r",
            "sizeof(r)"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4random",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "235-244",
          "snippet": "u_int32_t\narc4random(void)\n{\n\tu_int32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\narc4random(void)\n{\n\tu_int32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}"
  },
  {
    "function_name": "arc4random_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
    "lines": "251-257",
    "snippet": "void\narc4random_buf(void *buf, size_t n)\n{\n\t_ARC4_LOCK();\n\t_rs_random_buf(buf, n);\n\t_ARC4_UNLOCK();\n}",
    "includes": [
      "#include <machine/pctr.h>",
      "#include <stdio.h>",
      "#include \"chacha_private.h\"",
      "#include \"log.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/rand.h>",
      "# include <sys/random.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ARC4_UNLOCK",
          "args": [],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_rs_random_buf",
          "args": [
            "buf",
            "n"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "_rs_random_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "177-196",
          "snippet": "static inline void\n_rs_random_buf(void *_buf, size_t n)\n{\n\tu_char *buf = (u_char *)_buf;\n\tsize_t m;\n\n\t_rs_stir_if_needed(n);\n\twhile (n > 0) {\n\t\tif (rs_have > 0) {\n\t\t\tm = MIN(n, rs_have);\n\t\t\tmemcpy(buf, rs_buf + RSBUFSZ - rs_have, m);\n\t\t\tmemset(rs_buf + RSBUFSZ - rs_have, 0, m);\n\t\t\tbuf += m;\n\t\t\tn -= m;\n\t\t\trs_have -= m;\n\t\t}\n\t\tif (rs_have == 0)\n\t\t\t_rs_rekey(NULL, 0);\n\t}\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define RSBUFSZ\t(16*BLOCKSZ)",
            "#define inline",
            "#define inline __inline"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RSBUFSZ\t(16*BLOCKSZ)\n#define inline\n#define inline __inline\n\nstatic inline void\n_rs_random_buf(void *_buf, size_t n)\n{\n\tu_char *buf = (u_char *)_buf;\n\tsize_t m;\n\n\t_rs_stir_if_needed(n);\n\twhile (n > 0) {\n\t\tif (rs_have > 0) {\n\t\t\tm = MIN(n, rs_have);\n\t\t\tmemcpy(buf, rs_buf + RSBUFSZ - rs_have, m);\n\t\t\tmemset(rs_buf + RSBUFSZ - rs_have, 0, m);\n\t\t\tbuf += m;\n\t\t\tn -= m;\n\t\t\trs_have -= m;\n\t\t}\n\t\tif (rs_have == 0)\n\t\t\t_rs_rekey(NULL, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ARC4_LOCK",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_buf(void *buf, size_t n)\n{\n\t_ARC4_LOCK();\n\t_rs_random_buf(buf, n);\n\t_ARC4_UNLOCK();\n}"
  },
  {
    "function_name": "arc4random",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
    "lines": "235-244",
    "snippet": "u_int32_t\narc4random(void)\n{\n\tu_int32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}",
    "includes": [
      "#include <machine/pctr.h>",
      "#include <stdio.h>",
      "#include \"chacha_private.h\"",
      "#include \"log.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/rand.h>",
      "# include <sys/random.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ARC4_UNLOCK",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_rs_random_u32",
          "args": [
            "&val"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "_rs_random_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "198-208",
          "snippet": "static inline void\n_rs_random_u32(u_int32_t *val)\n{\n\t_rs_stir_if_needed(sizeof(*val));\n\tif (rs_have < sizeof(*val))\n\t\t_rs_rekey(NULL, 0);\n\tmemcpy(val, rs_buf + RSBUFSZ - rs_have, sizeof(*val));\n\tmemset(rs_buf + RSBUFSZ - rs_have, 0, sizeof(*val));\n\trs_have -= sizeof(*val);\n\treturn;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define RSBUFSZ\t(16*BLOCKSZ)",
            "#define inline",
            "#define inline __inline"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RSBUFSZ\t(16*BLOCKSZ)\n#define inline\n#define inline __inline\n\nstatic inline void\n_rs_random_u32(u_int32_t *val)\n{\n\t_rs_stir_if_needed(sizeof(*val));\n\tif (rs_have < sizeof(*val))\n\t\t_rs_rekey(NULL, 0);\n\tmemcpy(val, rs_buf + RSBUFSZ - rs_have, sizeof(*val));\n\tmemset(rs_buf + RSBUFSZ - rs_have, 0, sizeof(*val));\n\trs_have -= sizeof(*val);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ARC4_LOCK",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\narc4random(void)\n{\n\tu_int32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}"
  },
  {
    "function_name": "arc4random_addrandom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
    "lines": "218-233",
    "snippet": "void\narc4random_addrandom(u_char *dat, int datlen)\n{\n\tint m;\n\n\t_ARC4_LOCK();\n\tif (!rs_initialized)\n\t\t_rs_stir();\n\twhile (datlen > 0) {\n\t\tm = MIN(datlen, KEYSZ + IVSZ);\n\t\t_rs_rekey(dat, m);\n\t\tdat += m;\n\t\tdatlen -= m;\n\t}\n\t_ARC4_UNLOCK();\n}",
    "includes": [
      "#include <machine/pctr.h>",
      "#include <stdio.h>",
      "#include \"chacha_private.h\"",
      "#include \"log.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/rand.h>",
      "# include <sys/random.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define IVSZ\t8",
      "#define KEYSZ\t32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ARC4_UNLOCK",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_rs_rekey",
          "args": [
            "dat",
            "m"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "_rs_rekey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "155-175",
          "snippet": "static inline void\n_rs_rekey(u_char *dat, size_t datlen)\n{\n#ifndef KEYSTREAM_ONLY\n\tmemset(rs_buf, 0,RSBUFSZ);\n#endif\n\t/* fill rs_buf with the keystream */\n\tchacha_encrypt_bytes(&rs, rs_buf, rs_buf, RSBUFSZ);\n\t/* mix in optional user provided data */\n\tif (dat) {\n\t\tsize_t i, m;\n\n\t\tm = MIN(datlen, KEYSZ + IVSZ);\n\t\tfor (i = 0; i < m; i++)\n\t\t\trs_buf[i] ^= dat[i];\n\t}\n\t/* immediately reinit for backtracking resistance */\n\t_rs_init(rs_buf, KEYSZ + IVSZ);\n\tmemset(rs_buf, 0, KEYSZ + IVSZ);\n\trs_have = RSBUFSZ - KEYSZ - IVSZ;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define RSBUFSZ\t(16*BLOCKSZ)",
            "#define IVSZ\t8",
            "#define KEYSZ\t32",
            "#define inline",
            "#define inline __inline",
            "#define KEYSTREAM_ONLY"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RSBUFSZ\t(16*BLOCKSZ)\n#define IVSZ\t8\n#define KEYSZ\t32\n#define inline\n#define inline __inline\n#define KEYSTREAM_ONLY\n\nstatic inline void\n_rs_rekey(u_char *dat, size_t datlen)\n{\n#ifndef KEYSTREAM_ONLY\n\tmemset(rs_buf, 0,RSBUFSZ);\n#endif\n\t/* fill rs_buf with the keystream */\n\tchacha_encrypt_bytes(&rs, rs_buf, rs_buf, RSBUFSZ);\n\t/* mix in optional user provided data */\n\tif (dat) {\n\t\tsize_t i, m;\n\n\t\tm = MIN(datlen, KEYSZ + IVSZ);\n\t\tfor (i = 0; i < m; i++)\n\t\t\trs_buf[i] ^= dat[i];\n\t}\n\t/* immediately reinit for backtracking resistance */\n\t_rs_init(rs_buf, KEYSZ + IVSZ);\n\tmemset(rs_buf, 0, KEYSZ + IVSZ);\n\trs_have = RSBUFSZ - KEYSZ - IVSZ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "datlen",
            "KEYSZ + IVSZ"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "_SPLAY_MINMAX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sys-tree.h",
          "lines": "247-278",
          "snippet": "void name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}",
          "includes": [
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n\nvoid name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}"
        }
      },
      {
        "call_info": {
          "callee": "_rs_stir",
          "args": [],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "_rs_stir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "116-141",
          "snippet": "static void\n_rs_stir(void)\n{\n\tu_char rnd[KEYSZ + IVSZ];\n\n#ifdef WITH_OPENSSL\n\tif (RAND_bytes(rnd, sizeof(rnd)) <= 0)\n\t\tfatal(\"Couldn't obtain random bytes (error 0x%lx)\",\n\t\t    (unsigned long)ERR_get_error());\n#else\n\tgetrnd(rnd, sizeof(rnd));\n#endif\n\n\tif (!rs_initialized) {\n\t\trs_initialized = 1;\n\t\t_rs_init(rnd, sizeof(rnd));\n\t} else\n\t\t_rs_rekey(rnd, sizeof(rnd));\n\texplicit_bzero(rnd, sizeof(rnd));\n\n\t/* invalidate rs_buf */\n\trs_have = 0;\n\tmemset(rs_buf, 0, RSBUFSZ);\n\n\trs_count = 1600000;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define RSBUFSZ\t(16*BLOCKSZ)",
            "#define IVSZ\t8",
            "#define KEYSZ\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RSBUFSZ\t(16*BLOCKSZ)\n#define IVSZ\t8\n#define KEYSZ\t32\n\nstatic void\n_rs_stir(void)\n{\n\tu_char rnd[KEYSZ + IVSZ];\n\n#ifdef WITH_OPENSSL\n\tif (RAND_bytes(rnd, sizeof(rnd)) <= 0)\n\t\tfatal(\"Couldn't obtain random bytes (error 0x%lx)\",\n\t\t    (unsigned long)ERR_get_error());\n#else\n\tgetrnd(rnd, sizeof(rnd));\n#endif\n\n\tif (!rs_initialized) {\n\t\trs_initialized = 1;\n\t\t_rs_init(rnd, sizeof(rnd));\n\t} else\n\t\t_rs_rekey(rnd, sizeof(rnd));\n\texplicit_bzero(rnd, sizeof(rnd));\n\n\t/* invalidate rs_buf */\n\trs_have = 0;\n\tmemset(rs_buf, 0, RSBUFSZ);\n\n\trs_count = 1600000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ARC4_LOCK",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define IVSZ\t8\n#define KEYSZ\t32\n\nvoid\narc4random_addrandom(u_char *dat, int datlen)\n{\n\tint m;\n\n\t_ARC4_LOCK();\n\tif (!rs_initialized)\n\t\t_rs_stir();\n\twhile (datlen > 0) {\n\t\tm = MIN(datlen, KEYSZ + IVSZ);\n\t\t_rs_rekey(dat, m);\n\t\tdat += m;\n\t\tdatlen -= m;\n\t}\n\t_ARC4_UNLOCK();\n}"
  },
  {
    "function_name": "arc4random_stir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
    "lines": "210-216",
    "snippet": "void\narc4random_stir(void)\n{\n\t_ARC4_LOCK();\n\t_rs_stir();\n\t_ARC4_UNLOCK();\n}",
    "includes": [
      "#include <machine/pctr.h>",
      "#include <stdio.h>",
      "#include \"chacha_private.h\"",
      "#include \"log.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/rand.h>",
      "# include <sys/random.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ARC4_UNLOCK",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_rs_stir",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "_rs_stir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "116-141",
          "snippet": "static void\n_rs_stir(void)\n{\n\tu_char rnd[KEYSZ + IVSZ];\n\n#ifdef WITH_OPENSSL\n\tif (RAND_bytes(rnd, sizeof(rnd)) <= 0)\n\t\tfatal(\"Couldn't obtain random bytes (error 0x%lx)\",\n\t\t    (unsigned long)ERR_get_error());\n#else\n\tgetrnd(rnd, sizeof(rnd));\n#endif\n\n\tif (!rs_initialized) {\n\t\trs_initialized = 1;\n\t\t_rs_init(rnd, sizeof(rnd));\n\t} else\n\t\t_rs_rekey(rnd, sizeof(rnd));\n\texplicit_bzero(rnd, sizeof(rnd));\n\n\t/* invalidate rs_buf */\n\trs_have = 0;\n\tmemset(rs_buf, 0, RSBUFSZ);\n\n\trs_count = 1600000;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define RSBUFSZ\t(16*BLOCKSZ)",
            "#define IVSZ\t8",
            "#define KEYSZ\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RSBUFSZ\t(16*BLOCKSZ)\n#define IVSZ\t8\n#define KEYSZ\t32\n\nstatic void\n_rs_stir(void)\n{\n\tu_char rnd[KEYSZ + IVSZ];\n\n#ifdef WITH_OPENSSL\n\tif (RAND_bytes(rnd, sizeof(rnd)) <= 0)\n\t\tfatal(\"Couldn't obtain random bytes (error 0x%lx)\",\n\t\t    (unsigned long)ERR_get_error());\n#else\n\tgetrnd(rnd, sizeof(rnd));\n#endif\n\n\tif (!rs_initialized) {\n\t\trs_initialized = 1;\n\t\t_rs_init(rnd, sizeof(rnd));\n\t} else\n\t\t_rs_rekey(rnd, sizeof(rnd));\n\texplicit_bzero(rnd, sizeof(rnd));\n\n\t/* invalidate rs_buf */\n\trs_have = 0;\n\tmemset(rs_buf, 0, RSBUFSZ);\n\n\trs_count = 1600000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ARC4_LOCK",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_stir(void)\n{\n\t_ARC4_LOCK();\n\t_rs_stir();\n\t_ARC4_UNLOCK();\n}"
  },
  {
    "function_name": "_rs_random_u32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
    "lines": "198-208",
    "snippet": "static inline void\n_rs_random_u32(u_int32_t *val)\n{\n\t_rs_stir_if_needed(sizeof(*val));\n\tif (rs_have < sizeof(*val))\n\t\t_rs_rekey(NULL, 0);\n\tmemcpy(val, rs_buf + RSBUFSZ - rs_have, sizeof(*val));\n\tmemset(rs_buf + RSBUFSZ - rs_have, 0, sizeof(*val));\n\trs_have -= sizeof(*val);\n\treturn;\n}",
    "includes": [
      "#include <machine/pctr.h>",
      "#include <stdio.h>",
      "#include \"chacha_private.h\"",
      "#include \"log.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/rand.h>",
      "# include <sys/random.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define RSBUFSZ\t(16*BLOCKSZ)",
      "#define inline",
      "#define inline __inline"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rs_buf + RSBUFSZ - rs_have",
            "0",
            "sizeof(*val)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "rs_buf + RSBUFSZ - rs_have",
            "sizeof(*val)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_rs_rekey",
          "args": [
            "NULL",
            "0"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "_rs_rekey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "155-175",
          "snippet": "static inline void\n_rs_rekey(u_char *dat, size_t datlen)\n{\n#ifndef KEYSTREAM_ONLY\n\tmemset(rs_buf, 0,RSBUFSZ);\n#endif\n\t/* fill rs_buf with the keystream */\n\tchacha_encrypt_bytes(&rs, rs_buf, rs_buf, RSBUFSZ);\n\t/* mix in optional user provided data */\n\tif (dat) {\n\t\tsize_t i, m;\n\n\t\tm = MIN(datlen, KEYSZ + IVSZ);\n\t\tfor (i = 0; i < m; i++)\n\t\t\trs_buf[i] ^= dat[i];\n\t}\n\t/* immediately reinit for backtracking resistance */\n\t_rs_init(rs_buf, KEYSZ + IVSZ);\n\tmemset(rs_buf, 0, KEYSZ + IVSZ);\n\trs_have = RSBUFSZ - KEYSZ - IVSZ;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define RSBUFSZ\t(16*BLOCKSZ)",
            "#define IVSZ\t8",
            "#define KEYSZ\t32",
            "#define inline",
            "#define inline __inline",
            "#define KEYSTREAM_ONLY"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RSBUFSZ\t(16*BLOCKSZ)\n#define IVSZ\t8\n#define KEYSZ\t32\n#define inline\n#define inline __inline\n#define KEYSTREAM_ONLY\n\nstatic inline void\n_rs_rekey(u_char *dat, size_t datlen)\n{\n#ifndef KEYSTREAM_ONLY\n\tmemset(rs_buf, 0,RSBUFSZ);\n#endif\n\t/* fill rs_buf with the keystream */\n\tchacha_encrypt_bytes(&rs, rs_buf, rs_buf, RSBUFSZ);\n\t/* mix in optional user provided data */\n\tif (dat) {\n\t\tsize_t i, m;\n\n\t\tm = MIN(datlen, KEYSZ + IVSZ);\n\t\tfor (i = 0; i < m; i++)\n\t\t\trs_buf[i] ^= dat[i];\n\t}\n\t/* immediately reinit for backtracking resistance */\n\t_rs_init(rs_buf, KEYSZ + IVSZ);\n\tmemset(rs_buf, 0, KEYSZ + IVSZ);\n\trs_have = RSBUFSZ - KEYSZ - IVSZ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_rs_stir_if_needed",
          "args": [
            "sizeof(*val)"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "_rs_stir_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "143-153",
          "snippet": "static inline void\n_rs_stir_if_needed(size_t len)\n{\n\tpid_t pid = getpid();\n\n\tif (rs_count <= len || !rs_initialized || rs_stir_pid != pid) {\n\t\trs_stir_pid = pid;\n\t\t_rs_stir();\n\t} else\n\t\trs_count -= len;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define inline",
            "#define inline __inline"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define inline\n#define inline __inline\n\nstatic inline void\n_rs_stir_if_needed(size_t len)\n{\n\tpid_t pid = getpid();\n\n\tif (rs_count <= len || !rs_initialized || rs_stir_pid != pid) {\n\t\trs_stir_pid = pid;\n\t\t_rs_stir();\n\t} else\n\t\trs_count -= len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RSBUFSZ\t(16*BLOCKSZ)\n#define inline\n#define inline __inline\n\nstatic inline void\n_rs_random_u32(u_int32_t *val)\n{\n\t_rs_stir_if_needed(sizeof(*val));\n\tif (rs_have < sizeof(*val))\n\t\t_rs_rekey(NULL, 0);\n\tmemcpy(val, rs_buf + RSBUFSZ - rs_have, sizeof(*val));\n\tmemset(rs_buf + RSBUFSZ - rs_have, 0, sizeof(*val));\n\trs_have -= sizeof(*val);\n\treturn;\n}"
  },
  {
    "function_name": "_rs_random_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
    "lines": "177-196",
    "snippet": "static inline void\n_rs_random_buf(void *_buf, size_t n)\n{\n\tu_char *buf = (u_char *)_buf;\n\tsize_t m;\n\n\t_rs_stir_if_needed(n);\n\twhile (n > 0) {\n\t\tif (rs_have > 0) {\n\t\t\tm = MIN(n, rs_have);\n\t\t\tmemcpy(buf, rs_buf + RSBUFSZ - rs_have, m);\n\t\t\tmemset(rs_buf + RSBUFSZ - rs_have, 0, m);\n\t\t\tbuf += m;\n\t\t\tn -= m;\n\t\t\trs_have -= m;\n\t\t}\n\t\tif (rs_have == 0)\n\t\t\t_rs_rekey(NULL, 0);\n\t}\n}",
    "includes": [
      "#include <machine/pctr.h>",
      "#include <stdio.h>",
      "#include \"chacha_private.h\"",
      "#include \"log.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/rand.h>",
      "# include <sys/random.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define RSBUFSZ\t(16*BLOCKSZ)",
      "#define inline",
      "#define inline __inline"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_rs_rekey",
          "args": [
            "NULL",
            "0"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "_rs_rekey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "155-175",
          "snippet": "static inline void\n_rs_rekey(u_char *dat, size_t datlen)\n{\n#ifndef KEYSTREAM_ONLY\n\tmemset(rs_buf, 0,RSBUFSZ);\n#endif\n\t/* fill rs_buf with the keystream */\n\tchacha_encrypt_bytes(&rs, rs_buf, rs_buf, RSBUFSZ);\n\t/* mix in optional user provided data */\n\tif (dat) {\n\t\tsize_t i, m;\n\n\t\tm = MIN(datlen, KEYSZ + IVSZ);\n\t\tfor (i = 0; i < m; i++)\n\t\t\trs_buf[i] ^= dat[i];\n\t}\n\t/* immediately reinit for backtracking resistance */\n\t_rs_init(rs_buf, KEYSZ + IVSZ);\n\tmemset(rs_buf, 0, KEYSZ + IVSZ);\n\trs_have = RSBUFSZ - KEYSZ - IVSZ;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define RSBUFSZ\t(16*BLOCKSZ)",
            "#define IVSZ\t8",
            "#define KEYSZ\t32",
            "#define inline",
            "#define inline __inline",
            "#define KEYSTREAM_ONLY"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RSBUFSZ\t(16*BLOCKSZ)\n#define IVSZ\t8\n#define KEYSZ\t32\n#define inline\n#define inline __inline\n#define KEYSTREAM_ONLY\n\nstatic inline void\n_rs_rekey(u_char *dat, size_t datlen)\n{\n#ifndef KEYSTREAM_ONLY\n\tmemset(rs_buf, 0,RSBUFSZ);\n#endif\n\t/* fill rs_buf with the keystream */\n\tchacha_encrypt_bytes(&rs, rs_buf, rs_buf, RSBUFSZ);\n\t/* mix in optional user provided data */\n\tif (dat) {\n\t\tsize_t i, m;\n\n\t\tm = MIN(datlen, KEYSZ + IVSZ);\n\t\tfor (i = 0; i < m; i++)\n\t\t\trs_buf[i] ^= dat[i];\n\t}\n\t/* immediately reinit for backtracking resistance */\n\t_rs_init(rs_buf, KEYSZ + IVSZ);\n\tmemset(rs_buf, 0, KEYSZ + IVSZ);\n\trs_have = RSBUFSZ - KEYSZ - IVSZ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rs_buf + RSBUFSZ - rs_have",
            "0",
            "m"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "rs_buf + RSBUFSZ - rs_have",
            "m"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "n",
            "rs_have"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "_SPLAY_MINMAX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sys-tree.h",
          "lines": "247-278",
          "snippet": "void name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}",
          "includes": [
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n\nvoid name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}"
        }
      },
      {
        "call_info": {
          "callee": "_rs_stir_if_needed",
          "args": [
            "n"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "_rs_stir_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "143-153",
          "snippet": "static inline void\n_rs_stir_if_needed(size_t len)\n{\n\tpid_t pid = getpid();\n\n\tif (rs_count <= len || !rs_initialized || rs_stir_pid != pid) {\n\t\trs_stir_pid = pid;\n\t\t_rs_stir();\n\t} else\n\t\trs_count -= len;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define inline",
            "#define inline __inline"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define inline\n#define inline __inline\n\nstatic inline void\n_rs_stir_if_needed(size_t len)\n{\n\tpid_t pid = getpid();\n\n\tif (rs_count <= len || !rs_initialized || rs_stir_pid != pid) {\n\t\trs_stir_pid = pid;\n\t\t_rs_stir();\n\t} else\n\t\trs_count -= len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RSBUFSZ\t(16*BLOCKSZ)\n#define inline\n#define inline __inline\n\nstatic inline void\n_rs_random_buf(void *_buf, size_t n)\n{\n\tu_char *buf = (u_char *)_buf;\n\tsize_t m;\n\n\t_rs_stir_if_needed(n);\n\twhile (n > 0) {\n\t\tif (rs_have > 0) {\n\t\t\tm = MIN(n, rs_have);\n\t\t\tmemcpy(buf, rs_buf + RSBUFSZ - rs_have, m);\n\t\t\tmemset(rs_buf + RSBUFSZ - rs_have, 0, m);\n\t\t\tbuf += m;\n\t\t\tn -= m;\n\t\t\trs_have -= m;\n\t\t}\n\t\tif (rs_have == 0)\n\t\t\t_rs_rekey(NULL, 0);\n\t}\n}"
  },
  {
    "function_name": "_rs_rekey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
    "lines": "155-175",
    "snippet": "static inline void\n_rs_rekey(u_char *dat, size_t datlen)\n{\n#ifndef KEYSTREAM_ONLY\n\tmemset(rs_buf, 0,RSBUFSZ);\n#endif\n\t/* fill rs_buf with the keystream */\n\tchacha_encrypt_bytes(&rs, rs_buf, rs_buf, RSBUFSZ);\n\t/* mix in optional user provided data */\n\tif (dat) {\n\t\tsize_t i, m;\n\n\t\tm = MIN(datlen, KEYSZ + IVSZ);\n\t\tfor (i = 0; i < m; i++)\n\t\t\trs_buf[i] ^= dat[i];\n\t}\n\t/* immediately reinit for backtracking resistance */\n\t_rs_init(rs_buf, KEYSZ + IVSZ);\n\tmemset(rs_buf, 0, KEYSZ + IVSZ);\n\trs_have = RSBUFSZ - KEYSZ - IVSZ;\n}",
    "includes": [
      "#include <machine/pctr.h>",
      "#include <stdio.h>",
      "#include \"chacha_private.h\"",
      "#include \"log.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/rand.h>",
      "# include <sys/random.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define RSBUFSZ\t(16*BLOCKSZ)",
      "#define IVSZ\t8",
      "#define KEYSZ\t32",
      "#define inline",
      "#define inline __inline",
      "#define KEYSTREAM_ONLY"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rs_buf",
            "0",
            "KEYSZ + IVSZ"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_rs_init",
          "args": [
            "rs_buf",
            "KEYSZ + IVSZ"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "_rs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "75-82",
          "snippet": "static inline void\n_rs_init(u_char *buf, size_t n)\n{\n\tif (n < KEYSZ + IVSZ)\n\t\treturn;\n\tchacha_keysetup(&rs, buf, KEYSZ * 8, 0);\n\tchacha_ivsetup(&rs, buf + KEYSZ);\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define IVSZ\t8",
            "#define KEYSZ\t32",
            "#define inline",
            "#define inline __inline"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define IVSZ\t8\n#define KEYSZ\t32\n#define inline\n#define inline __inline\n\nstatic inline void\n_rs_init(u_char *buf, size_t n)\n{\n\tif (n < KEYSZ + IVSZ)\n\t\treturn;\n\tchacha_keysetup(&rs, buf, KEYSZ * 8, 0);\n\tchacha_ivsetup(&rs, buf + KEYSZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "datlen",
            "KEYSZ + IVSZ"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "_SPLAY_MINMAX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sys-tree.h",
          "lines": "247-278",
          "snippet": "void name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}",
          "includes": [
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n\nvoid name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}"
        }
      },
      {
        "call_info": {
          "callee": "chacha_encrypt_bytes",
          "args": [
            "&rs",
            "rs_buf",
            "rs_buf",
            "RSBUFSZ"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "chacha_encrypt_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/chacha_private.h",
          "lines": "88-222",
          "snippet": "static void\nchacha_encrypt_bytes(chacha_ctx *x,const u8 *m,u8 *c,u32 bytes)\n{\n  u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n  u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n  u8 *ctarget = NULL;\n  u8 tmp[64];\n  u_int i;\n\n  if (!bytes) return;\n\n  j0 = x->input[0];\n  j1 = x->input[1];\n  j2 = x->input[2];\n  j3 = x->input[3];\n  j4 = x->input[4];\n  j5 = x->input[5];\n  j6 = x->input[6];\n  j7 = x->input[7];\n  j8 = x->input[8];\n  j9 = x->input[9];\n  j10 = x->input[10];\n  j11 = x->input[11];\n  j12 = x->input[12];\n  j13 = x->input[13];\n  j14 = x->input[14];\n  j15 = x->input[15];\n\n  for (;;) {\n    if (bytes < 64) {\n      for (i = 0;i < bytes;++i) tmp[i] = m[i];\n      m = tmp;\n      ctarget = c;\n      c = tmp;\n    }\n    x0 = j0;\n    x1 = j1;\n    x2 = j2;\n    x3 = j3;\n    x4 = j4;\n    x5 = j5;\n    x6 = j6;\n    x7 = j7;\n    x8 = j8;\n    x9 = j9;\n    x10 = j10;\n    x11 = j11;\n    x12 = j12;\n    x13 = j13;\n    x14 = j14;\n    x15 = j15;\n    for (i = 20;i > 0;i -= 2) {\n      QUARTERROUND( x0, x4, x8,x12)\n      QUARTERROUND( x1, x5, x9,x13)\n      QUARTERROUND( x2, x6,x10,x14)\n      QUARTERROUND( x3, x7,x11,x15)\n      QUARTERROUND( x0, x5,x10,x15)\n      QUARTERROUND( x1, x6,x11,x12)\n      QUARTERROUND( x2, x7, x8,x13)\n      QUARTERROUND( x3, x4, x9,x14)\n    }\n    x0 = PLUS(x0,j0);\n    x1 = PLUS(x1,j1);\n    x2 = PLUS(x2,j2);\n    x3 = PLUS(x3,j3);\n    x4 = PLUS(x4,j4);\n    x5 = PLUS(x5,j5);\n    x6 = PLUS(x6,j6);\n    x7 = PLUS(x7,j7);\n    x8 = PLUS(x8,j8);\n    x9 = PLUS(x9,j9);\n    x10 = PLUS(x10,j10);\n    x11 = PLUS(x11,j11);\n    x12 = PLUS(x12,j12);\n    x13 = PLUS(x13,j13);\n    x14 = PLUS(x14,j14);\n    x15 = PLUS(x15,j15);\n\n#ifndef KEYSTREAM_ONLY\n    x0 = XOR(x0,U8TO32_LITTLE(m + 0));\n    x1 = XOR(x1,U8TO32_LITTLE(m + 4));\n    x2 = XOR(x2,U8TO32_LITTLE(m + 8));\n    x3 = XOR(x3,U8TO32_LITTLE(m + 12));\n    x4 = XOR(x4,U8TO32_LITTLE(m + 16));\n    x5 = XOR(x5,U8TO32_LITTLE(m + 20));\n    x6 = XOR(x6,U8TO32_LITTLE(m + 24));\n    x7 = XOR(x7,U8TO32_LITTLE(m + 28));\n    x8 = XOR(x8,U8TO32_LITTLE(m + 32));\n    x9 = XOR(x9,U8TO32_LITTLE(m + 36));\n    x10 = XOR(x10,U8TO32_LITTLE(m + 40));\n    x11 = XOR(x11,U8TO32_LITTLE(m + 44));\n    x12 = XOR(x12,U8TO32_LITTLE(m + 48));\n    x13 = XOR(x13,U8TO32_LITTLE(m + 52));\n    x14 = XOR(x14,U8TO32_LITTLE(m + 56));\n    x15 = XOR(x15,U8TO32_LITTLE(m + 60));\n#endif\n\n    j12 = PLUSONE(j12);\n    if (!j12) {\n      j13 = PLUSONE(j13);\n      /* stopping at 2^70 bytes per nonce is user's responsibility */\n    }\n\n    U32TO8_LITTLE(c + 0,x0);\n    U32TO8_LITTLE(c + 4,x1);\n    U32TO8_LITTLE(c + 8,x2);\n    U32TO8_LITTLE(c + 12,x3);\n    U32TO8_LITTLE(c + 16,x4);\n    U32TO8_LITTLE(c + 20,x5);\n    U32TO8_LITTLE(c + 24,x6);\n    U32TO8_LITTLE(c + 28,x7);\n    U32TO8_LITTLE(c + 32,x8);\n    U32TO8_LITTLE(c + 36,x9);\n    U32TO8_LITTLE(c + 40,x10);\n    U32TO8_LITTLE(c + 44,x11);\n    U32TO8_LITTLE(c + 48,x12);\n    U32TO8_LITTLE(c + 52,x13);\n    U32TO8_LITTLE(c + 56,x14);\n    U32TO8_LITTLE(c + 60,x15);\n\n    if (bytes <= 64) {\n      if (bytes < 64) {\n        for (i = 0;i < bytes;++i) ctarget[i] = c[i];\n      }\n      x->input[12] = j12;\n      x->input[13] = j13;\n      return;\n    }\n    bytes -= 64;\n    c += 64;\n#ifndef KEYSTREAM_ONLY\n    m += 64;\n#endif\n  }\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void\nchacha_encrypt_bytes(chacha_ctx *x,const u8 *m,u8 *c,u32 bytes)\n{\n  u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n  u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n  u8 *ctarget = NULL;\n  u8 tmp[64];\n  u_int i;\n\n  if (!bytes) return;\n\n  j0 = x->input[0];\n  j1 = x->input[1];\n  j2 = x->input[2];\n  j3 = x->input[3];\n  j4 = x->input[4];\n  j5 = x->input[5];\n  j6 = x->input[6];\n  j7 = x->input[7];\n  j8 = x->input[8];\n  j9 = x->input[9];\n  j10 = x->input[10];\n  j11 = x->input[11];\n  j12 = x->input[12];\n  j13 = x->input[13];\n  j14 = x->input[14];\n  j15 = x->input[15];\n\n  for (;;) {\n    if (bytes < 64) {\n      for (i = 0;i < bytes;++i) tmp[i] = m[i];\n      m = tmp;\n      ctarget = c;\n      c = tmp;\n    }\n    x0 = j0;\n    x1 = j1;\n    x2 = j2;\n    x3 = j3;\n    x4 = j4;\n    x5 = j5;\n    x6 = j6;\n    x7 = j7;\n    x8 = j8;\n    x9 = j9;\n    x10 = j10;\n    x11 = j11;\n    x12 = j12;\n    x13 = j13;\n    x14 = j14;\n    x15 = j15;\n    for (i = 20;i > 0;i -= 2) {\n      QUARTERROUND( x0, x4, x8,x12)\n      QUARTERROUND( x1, x5, x9,x13)\n      QUARTERROUND( x2, x6,x10,x14)\n      QUARTERROUND( x3, x7,x11,x15)\n      QUARTERROUND( x0, x5,x10,x15)\n      QUARTERROUND( x1, x6,x11,x12)\n      QUARTERROUND( x2, x7, x8,x13)\n      QUARTERROUND( x3, x4, x9,x14)\n    }\n    x0 = PLUS(x0,j0);\n    x1 = PLUS(x1,j1);\n    x2 = PLUS(x2,j2);\n    x3 = PLUS(x3,j3);\n    x4 = PLUS(x4,j4);\n    x5 = PLUS(x5,j5);\n    x6 = PLUS(x6,j6);\n    x7 = PLUS(x7,j7);\n    x8 = PLUS(x8,j8);\n    x9 = PLUS(x9,j9);\n    x10 = PLUS(x10,j10);\n    x11 = PLUS(x11,j11);\n    x12 = PLUS(x12,j12);\n    x13 = PLUS(x13,j13);\n    x14 = PLUS(x14,j14);\n    x15 = PLUS(x15,j15);\n\n#ifndef KEYSTREAM_ONLY\n    x0 = XOR(x0,U8TO32_LITTLE(m + 0));\n    x1 = XOR(x1,U8TO32_LITTLE(m + 4));\n    x2 = XOR(x2,U8TO32_LITTLE(m + 8));\n    x3 = XOR(x3,U8TO32_LITTLE(m + 12));\n    x4 = XOR(x4,U8TO32_LITTLE(m + 16));\n    x5 = XOR(x5,U8TO32_LITTLE(m + 20));\n    x6 = XOR(x6,U8TO32_LITTLE(m + 24));\n    x7 = XOR(x7,U8TO32_LITTLE(m + 28));\n    x8 = XOR(x8,U8TO32_LITTLE(m + 32));\n    x9 = XOR(x9,U8TO32_LITTLE(m + 36));\n    x10 = XOR(x10,U8TO32_LITTLE(m + 40));\n    x11 = XOR(x11,U8TO32_LITTLE(m + 44));\n    x12 = XOR(x12,U8TO32_LITTLE(m + 48));\n    x13 = XOR(x13,U8TO32_LITTLE(m + 52));\n    x14 = XOR(x14,U8TO32_LITTLE(m + 56));\n    x15 = XOR(x15,U8TO32_LITTLE(m + 60));\n#endif\n\n    j12 = PLUSONE(j12);\n    if (!j12) {\n      j13 = PLUSONE(j13);\n      /* stopping at 2^70 bytes per nonce is user's responsibility */\n    }\n\n    U32TO8_LITTLE(c + 0,x0);\n    U32TO8_LITTLE(c + 4,x1);\n    U32TO8_LITTLE(c + 8,x2);\n    U32TO8_LITTLE(c + 12,x3);\n    U32TO8_LITTLE(c + 16,x4);\n    U32TO8_LITTLE(c + 20,x5);\n    U32TO8_LITTLE(c + 24,x6);\n    U32TO8_LITTLE(c + 28,x7);\n    U32TO8_LITTLE(c + 32,x8);\n    U32TO8_LITTLE(c + 36,x9);\n    U32TO8_LITTLE(c + 40,x10);\n    U32TO8_LITTLE(c + 44,x11);\n    U32TO8_LITTLE(c + 48,x12);\n    U32TO8_LITTLE(c + 52,x13);\n    U32TO8_LITTLE(c + 56,x14);\n    U32TO8_LITTLE(c + 60,x15);\n\n    if (bytes <= 64) {\n      if (bytes < 64) {\n        for (i = 0;i < bytes;++i) ctarget[i] = c[i];\n      }\n      x->input[12] = j12;\n      x->input[13] = j13;\n      return;\n    }\n    bytes -= 64;\n    c += 64;\n#ifndef KEYSTREAM_ONLY\n    m += 64;\n#endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rs_buf",
            "0",
            "RSBUFSZ"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RSBUFSZ\t(16*BLOCKSZ)\n#define IVSZ\t8\n#define KEYSZ\t32\n#define inline\n#define inline __inline\n#define KEYSTREAM_ONLY\n\nstatic inline void\n_rs_rekey(u_char *dat, size_t datlen)\n{\n#ifndef KEYSTREAM_ONLY\n\tmemset(rs_buf, 0,RSBUFSZ);\n#endif\n\t/* fill rs_buf with the keystream */\n\tchacha_encrypt_bytes(&rs, rs_buf, rs_buf, RSBUFSZ);\n\t/* mix in optional user provided data */\n\tif (dat) {\n\t\tsize_t i, m;\n\n\t\tm = MIN(datlen, KEYSZ + IVSZ);\n\t\tfor (i = 0; i < m; i++)\n\t\t\trs_buf[i] ^= dat[i];\n\t}\n\t/* immediately reinit for backtracking resistance */\n\t_rs_init(rs_buf, KEYSZ + IVSZ);\n\tmemset(rs_buf, 0, KEYSZ + IVSZ);\n\trs_have = RSBUFSZ - KEYSZ - IVSZ;\n}"
  },
  {
    "function_name": "_rs_stir_if_needed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
    "lines": "143-153",
    "snippet": "static inline void\n_rs_stir_if_needed(size_t len)\n{\n\tpid_t pid = getpid();\n\n\tif (rs_count <= len || !rs_initialized || rs_stir_pid != pid) {\n\t\trs_stir_pid = pid;\n\t\t_rs_stir();\n\t} else\n\t\trs_count -= len;\n}",
    "includes": [
      "#include <machine/pctr.h>",
      "#include <stdio.h>",
      "#include \"chacha_private.h\"",
      "#include \"log.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/rand.h>",
      "# include <sys/random.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define inline",
      "#define inline __inline"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_rs_stir",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "_rs_stir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "116-141",
          "snippet": "static void\n_rs_stir(void)\n{\n\tu_char rnd[KEYSZ + IVSZ];\n\n#ifdef WITH_OPENSSL\n\tif (RAND_bytes(rnd, sizeof(rnd)) <= 0)\n\t\tfatal(\"Couldn't obtain random bytes (error 0x%lx)\",\n\t\t    (unsigned long)ERR_get_error());\n#else\n\tgetrnd(rnd, sizeof(rnd));\n#endif\n\n\tif (!rs_initialized) {\n\t\trs_initialized = 1;\n\t\t_rs_init(rnd, sizeof(rnd));\n\t} else\n\t\t_rs_rekey(rnd, sizeof(rnd));\n\texplicit_bzero(rnd, sizeof(rnd));\n\n\t/* invalidate rs_buf */\n\trs_have = 0;\n\tmemset(rs_buf, 0, RSBUFSZ);\n\n\trs_count = 1600000;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define RSBUFSZ\t(16*BLOCKSZ)",
            "#define IVSZ\t8",
            "#define KEYSZ\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RSBUFSZ\t(16*BLOCKSZ)\n#define IVSZ\t8\n#define KEYSZ\t32\n\nstatic void\n_rs_stir(void)\n{\n\tu_char rnd[KEYSZ + IVSZ];\n\n#ifdef WITH_OPENSSL\n\tif (RAND_bytes(rnd, sizeof(rnd)) <= 0)\n\t\tfatal(\"Couldn't obtain random bytes (error 0x%lx)\",\n\t\t    (unsigned long)ERR_get_error());\n#else\n\tgetrnd(rnd, sizeof(rnd));\n#endif\n\n\tif (!rs_initialized) {\n\t\trs_initialized = 1;\n\t\t_rs_init(rnd, sizeof(rnd));\n\t} else\n\t\t_rs_rekey(rnd, sizeof(rnd));\n\texplicit_bzero(rnd, sizeof(rnd));\n\n\t/* invalidate rs_buf */\n\trs_have = 0;\n\tmemset(rs_buf, 0, RSBUFSZ);\n\n\trs_count = 1600000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define inline\n#define inline __inline\n\nstatic inline void\n_rs_stir_if_needed(size_t len)\n{\n\tpid_t pid = getpid();\n\n\tif (rs_count <= len || !rs_initialized || rs_stir_pid != pid) {\n\t\trs_stir_pid = pid;\n\t\t_rs_stir();\n\t} else\n\t\trs_count -= len;\n}"
  },
  {
    "function_name": "_rs_stir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
    "lines": "116-141",
    "snippet": "static void\n_rs_stir(void)\n{\n\tu_char rnd[KEYSZ + IVSZ];\n\n#ifdef WITH_OPENSSL\n\tif (RAND_bytes(rnd, sizeof(rnd)) <= 0)\n\t\tfatal(\"Couldn't obtain random bytes (error 0x%lx)\",\n\t\t    (unsigned long)ERR_get_error());\n#else\n\tgetrnd(rnd, sizeof(rnd));\n#endif\n\n\tif (!rs_initialized) {\n\t\trs_initialized = 1;\n\t\t_rs_init(rnd, sizeof(rnd));\n\t} else\n\t\t_rs_rekey(rnd, sizeof(rnd));\n\texplicit_bzero(rnd, sizeof(rnd));\n\n\t/* invalidate rs_buf */\n\trs_have = 0;\n\tmemset(rs_buf, 0, RSBUFSZ);\n\n\trs_count = 1600000;\n}",
    "includes": [
      "#include <machine/pctr.h>",
      "#include <stdio.h>",
      "#include \"chacha_private.h\"",
      "#include \"log.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/rand.h>",
      "# include <sys/random.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define RSBUFSZ\t(16*BLOCKSZ)",
      "#define IVSZ\t8",
      "#define KEYSZ\t32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rs_buf",
            "0",
            "RSBUFSZ"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "rnd",
            "sizeof(rnd)"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_rs_rekey",
          "args": [
            "rnd",
            "sizeof(rnd)"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "_rs_rekey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "155-175",
          "snippet": "static inline void\n_rs_rekey(u_char *dat, size_t datlen)\n{\n#ifndef KEYSTREAM_ONLY\n\tmemset(rs_buf, 0,RSBUFSZ);\n#endif\n\t/* fill rs_buf with the keystream */\n\tchacha_encrypt_bytes(&rs, rs_buf, rs_buf, RSBUFSZ);\n\t/* mix in optional user provided data */\n\tif (dat) {\n\t\tsize_t i, m;\n\n\t\tm = MIN(datlen, KEYSZ + IVSZ);\n\t\tfor (i = 0; i < m; i++)\n\t\t\trs_buf[i] ^= dat[i];\n\t}\n\t/* immediately reinit for backtracking resistance */\n\t_rs_init(rs_buf, KEYSZ + IVSZ);\n\tmemset(rs_buf, 0, KEYSZ + IVSZ);\n\trs_have = RSBUFSZ - KEYSZ - IVSZ;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define RSBUFSZ\t(16*BLOCKSZ)",
            "#define IVSZ\t8",
            "#define KEYSZ\t32",
            "#define inline",
            "#define inline __inline",
            "#define KEYSTREAM_ONLY"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RSBUFSZ\t(16*BLOCKSZ)\n#define IVSZ\t8\n#define KEYSZ\t32\n#define inline\n#define inline __inline\n#define KEYSTREAM_ONLY\n\nstatic inline void\n_rs_rekey(u_char *dat, size_t datlen)\n{\n#ifndef KEYSTREAM_ONLY\n\tmemset(rs_buf, 0,RSBUFSZ);\n#endif\n\t/* fill rs_buf with the keystream */\n\tchacha_encrypt_bytes(&rs, rs_buf, rs_buf, RSBUFSZ);\n\t/* mix in optional user provided data */\n\tif (dat) {\n\t\tsize_t i, m;\n\n\t\tm = MIN(datlen, KEYSZ + IVSZ);\n\t\tfor (i = 0; i < m; i++)\n\t\t\trs_buf[i] ^= dat[i];\n\t}\n\t/* immediately reinit for backtracking resistance */\n\t_rs_init(rs_buf, KEYSZ + IVSZ);\n\tmemset(rs_buf, 0, KEYSZ + IVSZ);\n\trs_have = RSBUFSZ - KEYSZ - IVSZ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_rs_init",
          "args": [
            "rnd",
            "sizeof(rnd)"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "_rs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "75-82",
          "snippet": "static inline void\n_rs_init(u_char *buf, size_t n)\n{\n\tif (n < KEYSZ + IVSZ)\n\t\treturn;\n\tchacha_keysetup(&rs, buf, KEYSZ * 8, 0);\n\tchacha_ivsetup(&rs, buf + KEYSZ);\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define IVSZ\t8",
            "#define KEYSZ\t32",
            "#define inline",
            "#define inline __inline"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define IVSZ\t8\n#define KEYSZ\t32\n#define inline\n#define inline __inline\n\nstatic inline void\n_rs_init(u_char *buf, size_t n)\n{\n\tif (n < KEYSZ + IVSZ)\n\t\treturn;\n\tchacha_keysetup(&rs, buf, KEYSZ * 8, 0);\n\tchacha_ivsetup(&rs, buf + KEYSZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrnd",
          "args": [
            "rnd",
            "sizeof(rnd)"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "getrnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "88-113",
          "snippet": "static void\ngetrnd(u_char *s, size_t len)\n{\n\tint fd;\n\tssize_t r;\n\tsize_t o = 0;\n\n#ifdef HAVE_GETRANDOM\n\tif ((r = getrandom(s, len, 0)) > 0 && (size_t)r == len)\n\t\treturn;\n#endif /* HAVE_GETRANDOM */\n\n\tif ((fd = open(SSH_RANDOM_DEV, O_RDONLY)) == -1)\n\t\tfatal(\"Couldn't open %s: %s\", SSH_RANDOM_DEV, strerror(errno));\n\twhile (o < len) {\n\t\tr = read(fd, s + o, len - o);\n\t\tif (r < 0) {\n\t\t\tif (errno == EAGAIN || errno == EINTR ||\n\t\t\t    errno == EWOULDBLOCK)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"read %s: %s\", SSH_RANDOM_DEV, strerror(errno));\n\t\t}\n\t\to += r;\n\t}\n\tclose(fd);\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ngetrnd(u_char *s, size_t len)\n{\n\tint fd;\n\tssize_t r;\n\tsize_t o = 0;\n\n#ifdef HAVE_GETRANDOM\n\tif ((r = getrandom(s, len, 0)) > 0 && (size_t)r == len)\n\t\treturn;\n#endif /* HAVE_GETRANDOM */\n\n\tif ((fd = open(SSH_RANDOM_DEV, O_RDONLY)) == -1)\n\t\tfatal(\"Couldn't open %s: %s\", SSH_RANDOM_DEV, strerror(errno));\n\twhile (o < len) {\n\t\tr = read(fd, s + o, len - o);\n\t\tif (r < 0) {\n\t\t\tif (errno == EAGAIN || errno == EINTR ||\n\t\t\t    errno == EWOULDBLOCK)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"read %s: %s\", SSH_RANDOM_DEV, strerror(errno));\n\t\t}\n\t\to += r;\n\t}\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Couldn't obtain random bytes (error 0x%lx)\"",
            "(unsigned long)ERR_get_error()"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_get_error",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_bytes",
          "args": [
            "rnd",
            "sizeof(rnd)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RSBUFSZ\t(16*BLOCKSZ)\n#define IVSZ\t8\n#define KEYSZ\t32\n\nstatic void\n_rs_stir(void)\n{\n\tu_char rnd[KEYSZ + IVSZ];\n\n#ifdef WITH_OPENSSL\n\tif (RAND_bytes(rnd, sizeof(rnd)) <= 0)\n\t\tfatal(\"Couldn't obtain random bytes (error 0x%lx)\",\n\t\t    (unsigned long)ERR_get_error());\n#else\n\tgetrnd(rnd, sizeof(rnd));\n#endif\n\n\tif (!rs_initialized) {\n\t\trs_initialized = 1;\n\t\t_rs_init(rnd, sizeof(rnd));\n\t} else\n\t\t_rs_rekey(rnd, sizeof(rnd));\n\texplicit_bzero(rnd, sizeof(rnd));\n\n\t/* invalidate rs_buf */\n\trs_have = 0;\n\tmemset(rs_buf, 0, RSBUFSZ);\n\n\trs_count = 1600000;\n}"
  },
  {
    "function_name": "getrnd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
    "lines": "88-113",
    "snippet": "static void\ngetrnd(u_char *s, size_t len)\n{\n\tint fd;\n\tssize_t r;\n\tsize_t o = 0;\n\n#ifdef HAVE_GETRANDOM\n\tif ((r = getrandom(s, len, 0)) > 0 && (size_t)r == len)\n\t\treturn;\n#endif /* HAVE_GETRANDOM */\n\n\tif ((fd = open(SSH_RANDOM_DEV, O_RDONLY)) == -1)\n\t\tfatal(\"Couldn't open %s: %s\", SSH_RANDOM_DEV, strerror(errno));\n\twhile (o < len) {\n\t\tr = read(fd, s + o, len - o);\n\t\tif (r < 0) {\n\t\t\tif (errno == EAGAIN || errno == EINTR ||\n\t\t\t    errno == EWOULDBLOCK)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"read %s: %s\", SSH_RANDOM_DEV, strerror(errno));\n\t\t}\n\t\to += r;\n\t}\n\tclose(fd);\n}",
    "includes": [
      "#include <machine/pctr.h>",
      "#include <stdio.h>",
      "#include \"chacha_private.h\"",
      "#include \"log.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/rand.h>",
      "# include <sys/random.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"read %s: %s\"",
            "SSH_RANDOM_DEV",
            "strerror(errno)"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "s + o",
            "len - o"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "do_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "675-679",
          "snippet": "int\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "SSH_RANDOM_DEV",
            "O_RDONLY"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "binary_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-cygwin_util.c",
          "lines": "43-53",
          "snippet": "int\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrandom",
          "args": [
            "s",
            "len",
            "0"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ngetrnd(u_char *s, size_t len)\n{\n\tint fd;\n\tssize_t r;\n\tsize_t o = 0;\n\n#ifdef HAVE_GETRANDOM\n\tif ((r = getrandom(s, len, 0)) > 0 && (size_t)r == len)\n\t\treturn;\n#endif /* HAVE_GETRANDOM */\n\n\tif ((fd = open(SSH_RANDOM_DEV, O_RDONLY)) == -1)\n\t\tfatal(\"Couldn't open %s: %s\", SSH_RANDOM_DEV, strerror(errno));\n\twhile (o < len) {\n\t\tr = read(fd, s + o, len - o);\n\t\tif (r < 0) {\n\t\t\tif (errno == EAGAIN || errno == EINTR ||\n\t\t\t    errno == EWOULDBLOCK)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"read %s: %s\", SSH_RANDOM_DEV, strerror(errno));\n\t\t}\n\t\to += r;\n\t}\n\tclose(fd);\n}"
  },
  {
    "function_name": "_rs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
    "lines": "75-82",
    "snippet": "static inline void\n_rs_init(u_char *buf, size_t n)\n{\n\tif (n < KEYSZ + IVSZ)\n\t\treturn;\n\tchacha_keysetup(&rs, buf, KEYSZ * 8, 0);\n\tchacha_ivsetup(&rs, buf + KEYSZ);\n}",
    "includes": [
      "#include <machine/pctr.h>",
      "#include <stdio.h>",
      "#include \"chacha_private.h\"",
      "#include \"log.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/rand.h>",
      "# include <sys/random.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define IVSZ\t8",
      "#define KEYSZ\t32",
      "#define inline",
      "#define inline __inline"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chacha_ivsetup",
          "args": [
            "&rs",
            "buf + KEYSZ"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "chacha_ivsetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/chacha_private.h",
          "lines": "79-86",
          "snippet": "static void\nchacha_ivsetup(chacha_ctx *x,const u8 *iv)\n{\n  x->input[12] = 0;\n  x->input[13] = 0;\n  x->input[14] = U8TO32_LITTLE(iv + 0);\n  x->input[15] = U8TO32_LITTLE(iv + 4);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void\nchacha_ivsetup(chacha_ctx *x,const u8 *iv)\n{\n  x->input[12] = 0;\n  x->input[13] = 0;\n  x->input[14] = U8TO32_LITTLE(iv + 0);\n  x->input[15] = U8TO32_LITTLE(iv + 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chacha_keysetup",
          "args": [
            "&rs",
            "buf",
            "KEYSZ * 8",
            "0"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "chacha_keysetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/chacha_private.h",
          "lines": "54-77",
          "snippet": "static void\nchacha_keysetup(chacha_ctx *x,const u8 *k,u32 kbits,u32 ivbits)\n{\n  const char *constants;\n\n  x->input[4] = U8TO32_LITTLE(k + 0);\n  x->input[5] = U8TO32_LITTLE(k + 4);\n  x->input[6] = U8TO32_LITTLE(k + 8);\n  x->input[7] = U8TO32_LITTLE(k + 12);\n  if (kbits == 256) { /* recommended */\n    k += 16;\n    constants = sigma;\n  } else { /* kbits == 128 */\n    constants = tau;\n  }\n  x->input[8] = U8TO32_LITTLE(k + 0);\n  x->input[9] = U8TO32_LITTLE(k + 4);\n  x->input[10] = U8TO32_LITTLE(k + 8);\n  x->input[11] = U8TO32_LITTLE(k + 12);\n  x->input[0] = U8TO32_LITTLE(constants + 0);\n  x->input[1] = U8TO32_LITTLE(constants + 4);\n  x->input[2] = U8TO32_LITTLE(constants + 8);\n  x->input[3] = U8TO32_LITTLE(constants + 12);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const char sigma[16] = \"expand 32-byte k\";",
            "static const char tau[16] = \"expand 16-byte k\";"
          ],
          "called_functions": [],
          "contextual_snippet": "static const char sigma[16] = \"expand 32-byte k\";\nstatic const char tau[16] = \"expand 16-byte k\";\n\nstatic void\nchacha_keysetup(chacha_ctx *x,const u8 *k,u32 kbits,u32 ivbits)\n{\n  const char *constants;\n\n  x->input[4] = U8TO32_LITTLE(k + 0);\n  x->input[5] = U8TO32_LITTLE(k + 4);\n  x->input[6] = U8TO32_LITTLE(k + 8);\n  x->input[7] = U8TO32_LITTLE(k + 12);\n  if (kbits == 256) { /* recommended */\n    k += 16;\n    constants = sigma;\n  } else { /* kbits == 128 */\n    constants = tau;\n  }\n  x->input[8] = U8TO32_LITTLE(k + 0);\n  x->input[9] = U8TO32_LITTLE(k + 4);\n  x->input[10] = U8TO32_LITTLE(k + 8);\n  x->input[11] = U8TO32_LITTLE(k + 12);\n  x->input[0] = U8TO32_LITTLE(constants + 0);\n  x->input[1] = U8TO32_LITTLE(constants + 4);\n  x->input[2] = U8TO32_LITTLE(constants + 8);\n  x->input[3] = U8TO32_LITTLE(constants + 12);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define IVSZ\t8\n#define KEYSZ\t32\n#define inline\n#define inline __inline\n\nstatic inline void\n_rs_init(u_char *buf, size_t n)\n{\n\tif (n < KEYSZ + IVSZ)\n\t\treturn;\n\tchacha_keysetup(&rs, buf, KEYSZ * 8, 0);\n\tchacha_ivsetup(&rs, buf + KEYSZ);\n}"
  }
]