[
  {
    "function_name": "ssh_krl_file_contains_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "1333-1366",
    "snippet": "int\nssh_krl_file_contains_key(const char *path, const struct sshkey *key)\n{\n\tstruct sshbuf *krlbuf = NULL;\n\tstruct ssh_krl *krl = NULL;\n\tint oerrno = 0, r, fd;\n\n\tif (path == NULL)\n\t\treturn 0;\n\n\tif ((krlbuf = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((fd = open(path, O_RDONLY)) == -1) {\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\toerrno = errno;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, krlbuf)) != 0) {\n\t\toerrno = errno;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_krl_from_blob(krlbuf, &krl, NULL, 0)) != 0)\n\t\tgoto out;\n\tdebug2(\"%s: checking KRL %s\", __func__, path);\n\tr = ssh_krl_check_key(krl, key);\n out:\n\tif (fd != -1)\n\t\tclose(fd);\n\tsshbuf_free(krlbuf);\n\tssh_krl_free(krl);\n\tif (r != 0)\n\t\terrno = oerrno;\n\treturn r;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_krl_free",
          "args": [
            "krl"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "krlbuf"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_check_key",
          "args": [
            "krl",
            "key"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_check_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "1316-1331",
          "snippet": "int\nssh_krl_check_key(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tint r;\n\n\tKRL_DBG((\"%s: checking key\", __func__));\n\tif ((r = is_key_revoked(krl, key)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(key)) {\n\t\tdebug2(\"%s: checking CA key\", __func__);\n\t\tif ((r = is_key_revoked(krl, key->cert->signature_key)) != 0)\n\t\t\treturn r;\n\t}\n\tKRL_DBG((\"%s: key okay\", __func__));\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_check_key(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tint r;\n\n\tKRL_DBG((\"%s: checking key\", __func__));\n\tif ((r = is_key_revoked(krl, key)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(key)) {\n\t\tdebug2(\"%s: checking CA key\", __func__);\n\t\tif ((r = is_key_revoked(krl, key->cert->signature_key)) != 0)\n\t\t\treturn r;\n\t}\n\tKRL_DBG((\"%s: key okay\", __func__));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: checking KRL %s\"",
            "__func__",
            "path"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_from_blob",
          "args": [
            "krlbuf",
            "&krl",
            "NULL",
            "0"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "983-1216",
          "snippet": "int\nssh_krl_from_blob(struct sshbuf *buf, struct ssh_krl **krlp,\n    const struct sshkey **sign_ca_keys, size_t nsign_ca_keys)\n{\n\tstruct sshbuf *copy = NULL, *sect = NULL;\n\tstruct ssh_krl *krl = NULL;\n\tchar timestamp[64];\n\tint r = SSH_ERR_INTERNAL_ERROR, sig_seen;\n\tstruct sshkey *key = NULL, **ca_used = NULL, **tmp_ca_used;\n\tu_char type;\n\tconst u_char *blob;\n\tsize_t i, j, sig_off, sects_off, blen, nca_used;\n\tu_int format_version;\n\n\tnca_used = 0;\n\t*krlp = NULL;\n\tif (sshbuf_len(buf) < sizeof(KRL_MAGIC) - 1 ||\n\t    memcmp(sshbuf_ptr(buf), KRL_MAGIC, sizeof(KRL_MAGIC) - 1) != 0) {\n\t\tdebug3(\"%s: not a KRL\", __func__);\n\t\treturn SSH_ERR_KRL_BAD_MAGIC;\n\t}\n\n\t/* Take a copy of the KRL buffer so we can verify its signature later */\n\tif ((copy = sshbuf_fromb(buf)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(copy, sizeof(KRL_MAGIC) - 1)) != 0)\n\t\tgoto out;\n\n\tif ((krl = ssh_krl_init()) == NULL) {\n\t\terror(\"%s: alloc failed\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(copy, &format_version)) != 0)\n\t\tgoto out;\n\tif (format_version != KRL_FORMAT_VERSION) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u64(copy, &krl->krl_version)) != 0 ||\n\t    (r = sshbuf_get_u64(copy, &krl->generated_date)) != 0 ||\n\t    (r = sshbuf_get_u64(copy, &krl->flags)) != 0 ||\n\t    (r = sshbuf_skip_string(copy)) != 0 ||\n\t    (r = sshbuf_get_cstring(copy, &krl->comment, NULL)) != 0)\n\t\tgoto out;\n\n\tformat_timestamp(krl->generated_date, timestamp, sizeof(timestamp));\n\tdebug(\"KRL version %llu generated at %s%s%s\",\n\t    (long long unsigned)krl->krl_version, timestamp,\n\t    *krl->comment ? \": \" : \"\", krl->comment);\n\n\t/*\n\t * 1st pass: verify signatures, if any. This is done to avoid\n\t * detailed parsing of data whose provenance is unverified.\n\t */\n\tsig_seen = 0;\n\tif (sshbuf_len(buf) < sshbuf_len(copy)) {\n\t\t/* Shouldn't happen */\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tsects_off = sshbuf_len(buf) - sshbuf_len(copy);\n\twhile (sshbuf_len(copy) > 0) {\n\t\tif ((r = sshbuf_get_u8(copy, &type)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(copy, &blob, &blen)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: first pass, section 0x%02x\", __func__, type));\n\t\tif (type != KRL_SECTION_SIGNATURE) {\n\t\t\tif (sig_seen) {\n\t\t\t\terror(\"KRL contains non-signature section \"\n\t\t\t\t    \"after signature\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* Not interested for now. */\n\t\t\tcontinue;\n\t\t}\n\t\tsig_seen = 1;\n\t\t/* First string component is the signing key */\n\t\tif ((r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_len(buf) < sshbuf_len(copy)) {\n\t\t\t/* Shouldn't happen */\n\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tsig_off = sshbuf_len(buf) - sshbuf_len(copy);\n\t\t/* Second string component is the signature itself */\n\t\tif ((r = sshbuf_get_string_direct(copy, &blob, &blen)) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Check signature over entire KRL up to this point */\n\t\tif ((r = sshkey_verify(key, blob, blen,\n\t\t    sshbuf_ptr(buf), sig_off, NULL, 0)) != 0)\n\t\t\tgoto out;\n\t\t/* Check if this key has already signed this KRL */\n\t\tfor (i = 0; i < nca_used; i++) {\n\t\t\tif (sshkey_equal(ca_used[i], key)) {\n\t\t\t\terror(\"KRL signed more than once with \"\n\t\t\t\t    \"the same key\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* Record keys used to sign the KRL */\n\t\ttmp_ca_used = recallocarray(ca_used, nca_used, nca_used + 1,\n\t\t    sizeof(*ca_used));\n\t\tif (tmp_ca_used == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tca_used = tmp_ca_used;\n\t\tca_used[nca_used++] = key;\n\t\tkey = NULL;\n\t}\n\n\tif (sshbuf_len(copy) != 0) {\n\t\t/* Shouldn't happen */\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 2nd pass: parse and load the KRL, skipping the header to the point\n\t * where the section start.\n\t */\n\tsshbuf_free(copy);\n\tif ((copy = sshbuf_fromb(buf)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(copy, sects_off)) != 0)\n\t\tgoto out;\n\twhile (sshbuf_len(copy) > 0) {\n\t\tsshbuf_free(sect);\n\t\tsect = NULL;\n\t\tif ((r = sshbuf_get_u8(copy, &type)) != 0 ||\n\t\t    (r = sshbuf_froms(copy, &sect)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: second pass, section 0x%02x\", __func__, type));\n\n\t\tswitch (type) {\n\t\tcase KRL_SECTION_CERTIFICATES:\n\t\t\tif ((r = parse_revoked_certs(sect, krl)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_EXPLICIT_KEY:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_keys, 0)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_FINGERPRINT_SHA1:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_sha1s, 20)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_FINGERPRINT_SHA256:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_sha256s, 32)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_SIGNATURE:\n\t\t\t/* Handled above, but still need to stay in synch */\n\t\t\tsshbuf_free(sect);\n\t\t\tsect = NULL;\n\t\t\tif ((r = sshbuf_skip_string(copy)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"Unsupported KRL section %u\", type);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sect != NULL && sshbuf_len(sect) > 0) {\n\t\t\terror(\"KRL section contains unparsed data\");\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Check that the key(s) used to sign the KRL weren't revoked */\n\tsig_seen = 0;\n\tfor (i = 0; i < nca_used; i++) {\n\t\tif (ssh_krl_check_key(krl, ca_used[i]) == 0)\n\t\t\tsig_seen = 1;\n\t\telse {\n\t\t\tsshkey_free(ca_used[i]);\n\t\t\tca_used[i] = NULL;\n\t\t}\n\t}\n\tif (nca_used && !sig_seen) {\n\t\terror(\"All keys used to sign KRL were revoked\");\n\t\tr = SSH_ERR_KEY_REVOKED;\n\t\tgoto out;\n\t}\n\n\t/* If we have CA keys, then verify that one was used to sign the KRL */\n\tif (sig_seen && nsign_ca_keys != 0) {\n\t\tsig_seen = 0;\n\t\tfor (i = 0; !sig_seen && i < nsign_ca_keys; i++) {\n\t\t\tfor (j = 0; j < nca_used; j++) {\n\t\t\t\tif (ca_used[j] == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (sshkey_equal(ca_used[j], sign_ca_keys[i])) {\n\t\t\t\t\tsig_seen = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!sig_seen) {\n\t\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\t\terror(\"KRL not signed with any trusted key\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*krlp = krl;\n\tr = 0;\n out:\n\tif (r != 0)\n\t\tssh_krl_free(krl);\n\tfor (i = 0; i < nca_used; i++)\n\t\tsshkey_free(ca_used[i]);\n\tfree(ca_used);\n\tsshkey_free(key);\n\tsshbuf_free(copy);\n\tsshbuf_free(sect);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_from_blob(struct sshbuf *buf, struct ssh_krl **krlp,\n    const struct sshkey **sign_ca_keys, size_t nsign_ca_keys)\n{\n\tstruct sshbuf *copy = NULL, *sect = NULL;\n\tstruct ssh_krl *krl = NULL;\n\tchar timestamp[64];\n\tint r = SSH_ERR_INTERNAL_ERROR, sig_seen;\n\tstruct sshkey *key = NULL, **ca_used = NULL, **tmp_ca_used;\n\tu_char type;\n\tconst u_char *blob;\n\tsize_t i, j, sig_off, sects_off, blen, nca_used;\n\tu_int format_version;\n\n\tnca_used = 0;\n\t*krlp = NULL;\n\tif (sshbuf_len(buf) < sizeof(KRL_MAGIC) - 1 ||\n\t    memcmp(sshbuf_ptr(buf), KRL_MAGIC, sizeof(KRL_MAGIC) - 1) != 0) {\n\t\tdebug3(\"%s: not a KRL\", __func__);\n\t\treturn SSH_ERR_KRL_BAD_MAGIC;\n\t}\n\n\t/* Take a copy of the KRL buffer so we can verify its signature later */\n\tif ((copy = sshbuf_fromb(buf)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(copy, sizeof(KRL_MAGIC) - 1)) != 0)\n\t\tgoto out;\n\n\tif ((krl = ssh_krl_init()) == NULL) {\n\t\terror(\"%s: alloc failed\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(copy, &format_version)) != 0)\n\t\tgoto out;\n\tif (format_version != KRL_FORMAT_VERSION) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u64(copy, &krl->krl_version)) != 0 ||\n\t    (r = sshbuf_get_u64(copy, &krl->generated_date)) != 0 ||\n\t    (r = sshbuf_get_u64(copy, &krl->flags)) != 0 ||\n\t    (r = sshbuf_skip_string(copy)) != 0 ||\n\t    (r = sshbuf_get_cstring(copy, &krl->comment, NULL)) != 0)\n\t\tgoto out;\n\n\tformat_timestamp(krl->generated_date, timestamp, sizeof(timestamp));\n\tdebug(\"KRL version %llu generated at %s%s%s\",\n\t    (long long unsigned)krl->krl_version, timestamp,\n\t    *krl->comment ? \": \" : \"\", krl->comment);\n\n\t/*\n\t * 1st pass: verify signatures, if any. This is done to avoid\n\t * detailed parsing of data whose provenance is unverified.\n\t */\n\tsig_seen = 0;\n\tif (sshbuf_len(buf) < sshbuf_len(copy)) {\n\t\t/* Shouldn't happen */\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tsects_off = sshbuf_len(buf) - sshbuf_len(copy);\n\twhile (sshbuf_len(copy) > 0) {\n\t\tif ((r = sshbuf_get_u8(copy, &type)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(copy, &blob, &blen)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: first pass, section 0x%02x\", __func__, type));\n\t\tif (type != KRL_SECTION_SIGNATURE) {\n\t\t\tif (sig_seen) {\n\t\t\t\terror(\"KRL contains non-signature section \"\n\t\t\t\t    \"after signature\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* Not interested for now. */\n\t\t\tcontinue;\n\t\t}\n\t\tsig_seen = 1;\n\t\t/* First string component is the signing key */\n\t\tif ((r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_len(buf) < sshbuf_len(copy)) {\n\t\t\t/* Shouldn't happen */\n\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tsig_off = sshbuf_len(buf) - sshbuf_len(copy);\n\t\t/* Second string component is the signature itself */\n\t\tif ((r = sshbuf_get_string_direct(copy, &blob, &blen)) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Check signature over entire KRL up to this point */\n\t\tif ((r = sshkey_verify(key, blob, blen,\n\t\t    sshbuf_ptr(buf), sig_off, NULL, 0)) != 0)\n\t\t\tgoto out;\n\t\t/* Check if this key has already signed this KRL */\n\t\tfor (i = 0; i < nca_used; i++) {\n\t\t\tif (sshkey_equal(ca_used[i], key)) {\n\t\t\t\terror(\"KRL signed more than once with \"\n\t\t\t\t    \"the same key\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* Record keys used to sign the KRL */\n\t\ttmp_ca_used = recallocarray(ca_used, nca_used, nca_used + 1,\n\t\t    sizeof(*ca_used));\n\t\tif (tmp_ca_used == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tca_used = tmp_ca_used;\n\t\tca_used[nca_used++] = key;\n\t\tkey = NULL;\n\t}\n\n\tif (sshbuf_len(copy) != 0) {\n\t\t/* Shouldn't happen */\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 2nd pass: parse and load the KRL, skipping the header to the point\n\t * where the section start.\n\t */\n\tsshbuf_free(copy);\n\tif ((copy = sshbuf_fromb(buf)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(copy, sects_off)) != 0)\n\t\tgoto out;\n\twhile (sshbuf_len(copy) > 0) {\n\t\tsshbuf_free(sect);\n\t\tsect = NULL;\n\t\tif ((r = sshbuf_get_u8(copy, &type)) != 0 ||\n\t\t    (r = sshbuf_froms(copy, &sect)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: second pass, section 0x%02x\", __func__, type));\n\n\t\tswitch (type) {\n\t\tcase KRL_SECTION_CERTIFICATES:\n\t\t\tif ((r = parse_revoked_certs(sect, krl)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_EXPLICIT_KEY:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_keys, 0)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_FINGERPRINT_SHA1:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_sha1s, 20)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_FINGERPRINT_SHA256:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_sha256s, 32)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_SIGNATURE:\n\t\t\t/* Handled above, but still need to stay in synch */\n\t\t\tsshbuf_free(sect);\n\t\t\tsect = NULL;\n\t\t\tif ((r = sshbuf_skip_string(copy)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"Unsupported KRL section %u\", type);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sect != NULL && sshbuf_len(sect) > 0) {\n\t\t\terror(\"KRL section contains unparsed data\");\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Check that the key(s) used to sign the KRL weren't revoked */\n\tsig_seen = 0;\n\tfor (i = 0; i < nca_used; i++) {\n\t\tif (ssh_krl_check_key(krl, ca_used[i]) == 0)\n\t\t\tsig_seen = 1;\n\t\telse {\n\t\t\tsshkey_free(ca_used[i]);\n\t\t\tca_used[i] = NULL;\n\t\t}\n\t}\n\tif (nca_used && !sig_seen) {\n\t\terror(\"All keys used to sign KRL were revoked\");\n\t\tr = SSH_ERR_KEY_REVOKED;\n\t\tgoto out;\n\t}\n\n\t/* If we have CA keys, then verify that one was used to sign the KRL */\n\tif (sig_seen && nsign_ca_keys != 0) {\n\t\tsig_seen = 0;\n\t\tfor (i = 0; !sig_seen && i < nsign_ca_keys; i++) {\n\t\t\tfor (j = 0; j < nca_used; j++) {\n\t\t\t\tif (ca_used[j] == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (sshkey_equal(ca_used[j], sign_ca_keys[i])) {\n\t\t\t\t\tsig_seen = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!sig_seen) {\n\t\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\t\terror(\"KRL not signed with any trusted key\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*krlp = krl;\n\tr = 0;\n out:\n\tif (r != 0)\n\t\tssh_krl_free(krl);\n\tfor (i = 0; i < nca_used; i++)\n\t\tsshkey_free(ca_used[i]);\n\tfree(ca_used);\n\tsshkey_free(key);\n\tsshbuf_free(copy);\n\tsshbuf_free(sect);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_file",
          "args": [
            "fd",
            "krlbuf"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "96-135",
          "snippet": "int\nsshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_KEY_FILE_SIZE\t(1024 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_KEY_FILE_SIZE\t(1024 * 1024)\n\nint\nsshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_file_contains_key(const char *path, const struct sshkey *key)\n{\n\tstruct sshbuf *krlbuf = NULL;\n\tstruct ssh_krl *krl = NULL;\n\tint oerrno = 0, r, fd;\n\n\tif (path == NULL)\n\t\treturn 0;\n\n\tif ((krlbuf = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((fd = open(path, O_RDONLY)) == -1) {\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\toerrno = errno;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, krlbuf)) != 0) {\n\t\toerrno = errno;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_krl_from_blob(krlbuf, &krl, NULL, 0)) != 0)\n\t\tgoto out;\n\tdebug2(\"%s: checking KRL %s\", __func__, path);\n\tr = ssh_krl_check_key(krl, key);\n out:\n\tif (fd != -1)\n\t\tclose(fd);\n\tsshbuf_free(krlbuf);\n\tssh_krl_free(krl);\n\tif (r != 0)\n\t\terrno = oerrno;\n\treturn r;\n}"
  },
  {
    "function_name": "ssh_krl_check_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "1316-1331",
    "snippet": "int\nssh_krl_check_key(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tint r;\n\n\tKRL_DBG((\"%s: checking key\", __func__));\n\tif ((r = is_key_revoked(krl, key)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(key)) {\n\t\tdebug2(\"%s: checking CA key\", __func__);\n\t\tif ((r = is_key_revoked(krl, key->cert->signature_key)) != 0)\n\t\t\treturn r;\n\t}\n\tKRL_DBG((\"%s: key okay\", __func__));\n\treturn 0;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: key okay\", __func__)"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_key_revoked",
          "args": [
            "krl",
            "key->cert->signature_key"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "is_key_revoked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "1253-1314",
          "snippet": "static int\nis_key_revoked(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tstruct revoked_blob rb, *erb;\n\tstruct revoked_certs *rc;\n\tint r;\n\n\t/* Check explicitly revoked hashes first */\n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = sshkey_fingerprint_raw(key, SSH_DIGEST_SHA1,\n\t    &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_sha1s, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"%s: revoked by key SHA1\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = sshkey_fingerprint_raw(key, SSH_DIGEST_SHA256,\n\t    &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_sha256s, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"%s: revoked by key SHA256\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\t/* Next, explicit keys */\n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = plain_key_blob(key, &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_keys, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"%s: revoked by explicit key\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\tif (!sshkey_is_cert(key))\n\t\treturn 0;\n\n\t/* Check cert revocation for the specified CA */\n\tif ((r = revoked_certs_for_ca_key(krl, key->cert->signature_key,\n\t    &rc, 0)) != 0)\n\t\treturn r;\n\tif (rc != NULL) {\n\t\tif ((r = is_cert_revoked(key, rc)) != 0)\n\t\t\treturn r;\n\t}\n\t/* Check cert revocation for the wildcard CA */\n\tif ((r = revoked_certs_for_ca_key(krl, NULL, &rc, 0)) != 0)\n\t\treturn r;\n\tif (rc != NULL) {\n\t\tif ((r = is_cert_revoked(key, rc)) != 0)\n\t\t\treturn r;\n\t}\n\n\tKRL_DBG((\"%s: %llu no match\", __func__, key->cert->serial));\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_key_revoked(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tstruct revoked_blob rb, *erb;\n\tstruct revoked_certs *rc;\n\tint r;\n\n\t/* Check explicitly revoked hashes first */\n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = sshkey_fingerprint_raw(key, SSH_DIGEST_SHA1,\n\t    &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_sha1s, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"%s: revoked by key SHA1\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = sshkey_fingerprint_raw(key, SSH_DIGEST_SHA256,\n\t    &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_sha256s, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"%s: revoked by key SHA256\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\t/* Next, explicit keys */\n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = plain_key_blob(key, &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_keys, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"%s: revoked by explicit key\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\tif (!sshkey_is_cert(key))\n\t\treturn 0;\n\n\t/* Check cert revocation for the specified CA */\n\tif ((r = revoked_certs_for_ca_key(krl, key->cert->signature_key,\n\t    &rc, 0)) != 0)\n\t\treturn r;\n\tif (rc != NULL) {\n\t\tif ((r = is_cert_revoked(key, rc)) != 0)\n\t\t\treturn r;\n\t}\n\t/* Check cert revocation for the wildcard CA */\n\tif ((r = revoked_certs_for_ca_key(krl, NULL, &rc, 0)) != 0)\n\t\treturn r;\n\tif (rc != NULL) {\n\t\tif ((r = is_cert_revoked(key, rc)) != 0)\n\t\t\treturn r;\n\t}\n\n\tKRL_DBG((\"%s: %llu no match\", __func__, key->cert->serial));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: checking CA key\"",
            "__func__"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: checking key\", __func__)"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_check_key(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tint r;\n\n\tKRL_DBG((\"%s: checking key\", __func__));\n\tif ((r = is_key_revoked(krl, key)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(key)) {\n\t\tdebug2(\"%s: checking CA key\", __func__);\n\t\tif ((r = is_key_revoked(krl, key->cert->signature_key)) != 0)\n\t\t\treturn r;\n\t}\n\tKRL_DBG((\"%s: key okay\", __func__));\n\treturn 0;\n}"
  },
  {
    "function_name": "is_key_revoked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "1253-1314",
    "snippet": "static int\nis_key_revoked(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tstruct revoked_blob rb, *erb;\n\tstruct revoked_certs *rc;\n\tint r;\n\n\t/* Check explicitly revoked hashes first */\n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = sshkey_fingerprint_raw(key, SSH_DIGEST_SHA1,\n\t    &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_sha1s, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"%s: revoked by key SHA1\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = sshkey_fingerprint_raw(key, SSH_DIGEST_SHA256,\n\t    &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_sha256s, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"%s: revoked by key SHA256\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\t/* Next, explicit keys */\n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = plain_key_blob(key, &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_keys, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"%s: revoked by explicit key\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\tif (!sshkey_is_cert(key))\n\t\treturn 0;\n\n\t/* Check cert revocation for the specified CA */\n\tif ((r = revoked_certs_for_ca_key(krl, key->cert->signature_key,\n\t    &rc, 0)) != 0)\n\t\treturn r;\n\tif (rc != NULL) {\n\t\tif ((r = is_cert_revoked(key, rc)) != 0)\n\t\t\treturn r;\n\t}\n\t/* Check cert revocation for the wildcard CA */\n\tif ((r = revoked_certs_for_ca_key(krl, NULL, &rc, 0)) != 0)\n\t\treturn r;\n\tif (rc != NULL) {\n\t\tif ((r = is_cert_revoked(key, rc)) != 0)\n\t\t\treturn r;\n\t}\n\n\tKRL_DBG((\"%s: %llu no match\", __func__, key->cert->serial));\n\treturn 0;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: %llu no match\", __func__, key->cert->serial)"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cert_revoked",
          "args": [
            "key",
            "rc"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "is_cert_revoked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "1219-1250",
          "snippet": "static int\nis_cert_revoked(const struct sshkey *key, struct revoked_certs *rc)\n{\n\tstruct revoked_serial rs, *ers;\n\tstruct revoked_key_id rki, *erki;\n\n\t/* Check revocation by cert key ID */\n\tmemset(&rki, 0, sizeof(rki));\n\trki.key_id = key->cert->key_id;\n\terki = RB_FIND(revoked_key_id_tree, &rc->revoked_key_ids, &rki);\n\tif (erki != NULL) {\n\t\tKRL_DBG((\"%s: revoked by key ID\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\t/*\n\t * Zero serials numbers are ignored (it's the default when the\n\t * CA doesn't specify one).\n\t */\n\tif (key->cert->serial == 0)\n\t\treturn 0;\n\n\tmemset(&rs, 0, sizeof(rs));\n\trs.lo = rs.hi = key->cert->serial;\n\ters = RB_FIND(revoked_serial_tree, &rc->revoked_serials, &rs);\n\tif (ers != NULL) {\n\t\tKRL_DBG((\"%s: revoked serial %llu matched %llu:%llu\", __func__,\n\t\t    key->cert->serial, ers->lo, ers->hi));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_cert_revoked(const struct sshkey *key, struct revoked_certs *rc)\n{\n\tstruct revoked_serial rs, *ers;\n\tstruct revoked_key_id rki, *erki;\n\n\t/* Check revocation by cert key ID */\n\tmemset(&rki, 0, sizeof(rki));\n\trki.key_id = key->cert->key_id;\n\terki = RB_FIND(revoked_key_id_tree, &rc->revoked_key_ids, &rki);\n\tif (erki != NULL) {\n\t\tKRL_DBG((\"%s: revoked by key ID\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\t/*\n\t * Zero serials numbers are ignored (it's the default when the\n\t * CA doesn't specify one).\n\t */\n\tif (key->cert->serial == 0)\n\t\treturn 0;\n\n\tmemset(&rs, 0, sizeof(rs));\n\trs.lo = rs.hi = key->cert->serial;\n\ters = RB_FIND(revoked_serial_tree, &rc->revoked_serials, &rs);\n\tif (ers != NULL) {\n\t\tKRL_DBG((\"%s: revoked serial %llu matched %llu:%llu\", __func__,\n\t\t    key->cert->serial, ers->lo, ers->hi));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "revoked_certs_for_ca_key",
          "args": [
            "krl",
            "NULL",
            "&rc",
            "0"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "revoked_certs_for_ca_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "213-246",
          "snippet": "static int\nrevoked_certs_for_ca_key(struct ssh_krl *krl, const struct sshkey *ca_key,\n    struct revoked_certs **rcp, int allow_create)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\t*rcp = NULL;\n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tif ((ca_key == NULL && rc->ca_key == NULL) ||\n\t\t    sshkey_equal(rc->ca_key, ca_key)) {\n\t\t\t*rcp = rc;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!allow_create)\n\t\treturn 0;\n\t/* If this CA doesn't exist in the list then add it now */\n\tif ((rc = calloc(1, sizeof(*rc))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (ca_key == NULL)\n\t\trc->ca_key = NULL;\n\telse if ((r = sshkey_from_private(ca_key, &rc->ca_key)) != 0) {\n\t\tfree(rc);\n\t\treturn r;\n\t}\n\tRB_INIT(&rc->revoked_serials);\n\tRB_INIT(&rc->revoked_key_ids);\n\tTAILQ_INSERT_TAIL(&krl->revoked_certs, rc, entry);\n\tKRL_DBG((\"%s: new CA %s\", __func__,\n\t    ca_key == NULL ? \"*\" : sshkey_type(ca_key)));\n\t*rcp = rc;\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrevoked_certs_for_ca_key(struct ssh_krl *krl, const struct sshkey *ca_key,\n    struct revoked_certs **rcp, int allow_create)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\t*rcp = NULL;\n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tif ((ca_key == NULL && rc->ca_key == NULL) ||\n\t\t    sshkey_equal(rc->ca_key, ca_key)) {\n\t\t\t*rcp = rc;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!allow_create)\n\t\treturn 0;\n\t/* If this CA doesn't exist in the list then add it now */\n\tif ((rc = calloc(1, sizeof(*rc))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (ca_key == NULL)\n\t\trc->ca_key = NULL;\n\telse if ((r = sshkey_from_private(ca_key, &rc->ca_key)) != 0) {\n\t\tfree(rc);\n\t\treturn r;\n\t}\n\tRB_INIT(&rc->revoked_serials);\n\tRB_INIT(&rc->revoked_key_ids);\n\tTAILQ_INSERT_TAIL(&krl->revoked_certs, rc, entry);\n\tKRL_DBG((\"%s: new CA %s\", __func__,\n\t    ca_key == NULL ? \"*\" : sshkey_type(ca_key)));\n\t*rcp = rc;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: revoked by explicit key\", __func__)"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rb.blob"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_FIND",
          "args": [
            "revoked_blob_tree",
            "&krl->revoked_keys",
            "&rb"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plain_key_blob",
          "args": [
            "key",
            "&rb.blob",
            "&rb.len"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "plain_key_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "368-385",
          "snippet": "static int\nplain_key_blob(const struct sshkey *key, u_char **blob, size_t *blen)\n{\n\tstruct sshkey *kcopy;\n\tint r;\n\n\tif ((r = sshkey_from_private(key, &kcopy)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(kcopy)) {\n\t\tif ((r = sshkey_drop_cert(kcopy)) != 0) {\n\t\t\tsshkey_free(kcopy);\n\t\t\treturn r;\n\t\t}\n\t}\n\tr = sshkey_to_blob(kcopy, blob, blen);\n\tsshkey_free(kcopy);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nplain_key_blob(const struct sshkey *key, u_char **blob, size_t *blen)\n{\n\tstruct sshkey *kcopy;\n\tint r;\n\n\tif ((r = sshkey_from_private(key, &kcopy)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(kcopy)) {\n\t\tif ((r = sshkey_drop_cert(kcopy)) != 0) {\n\t\t\tsshkey_free(kcopy);\n\t\t\treturn r;\n\t\t}\n\t}\n\tr = sshkey_to_blob(kcopy, blob, blen);\n\tsshkey_free(kcopy);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rb",
            "0",
            "sizeof(rb)"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: revoked by key SHA256\", __func__)"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_FIND",
          "args": [
            "revoked_blob_tree",
            "&krl->revoked_sha256s",
            "&rb"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint_raw",
          "args": [
            "key",
            "SSH_DIGEST_SHA256",
            "&rb.blob",
            "&rb.len"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "892-933",
          "snippet": "int\nsshkey_fingerprint_raw(const struct sshkey *k, int dgst_alg,\n    u_char **retp, size_t *lenp)\n{\n\tu_char *blob = NULL, *ret = NULL;\n\tsize_t blob_len = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (ssh_digest_bytes(dgst_alg) == 0) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((r = to_blob(k, &blob, &blob_len, 1, SSHKEY_SERIALIZE_DEFAULT))\n\t    != 0)\n\t\tgoto out;\n\tif ((ret = calloc(1, SSH_DIGEST_MAX_LENGTH)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_digest_memory(dgst_alg, blob, blob_len,\n\t    ret, SSH_DIGEST_MAX_LENGTH)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (retp != NULL) {\n\t\t*retp = ret;\n\t\tret = NULL;\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = ssh_digest_bytes(dgst_alg);\n\tr = 0;\n out:\n\tfree(ret);\n\tif (blob != NULL) {\n\t\texplicit_bzero(blob, blob_len);\n\t\tfree(blob);\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_fingerprint_raw(const struct sshkey *k, int dgst_alg,\n    u_char **retp, size_t *lenp)\n{\n\tu_char *blob = NULL, *ret = NULL;\n\tsize_t blob_len = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (ssh_digest_bytes(dgst_alg) == 0) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((r = to_blob(k, &blob, &blob_len, 1, SSHKEY_SERIALIZE_DEFAULT))\n\t    != 0)\n\t\tgoto out;\n\tif ((ret = calloc(1, SSH_DIGEST_MAX_LENGTH)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_digest_memory(dgst_alg, blob, blob_len,\n\t    ret, SSH_DIGEST_MAX_LENGTH)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (retp != NULL) {\n\t\t*retp = ret;\n\t\tret = NULL;\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = ssh_digest_bytes(dgst_alg);\n\tr = 0;\n out:\n\tfree(ret);\n\tif (blob != NULL) {\n\t\texplicit_bzero(blob, blob_len);\n\t\tfree(blob);\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rb",
            "0",
            "sizeof(rb)"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: revoked by key SHA1\", __func__)"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_FIND",
          "args": [
            "revoked_blob_tree",
            "&krl->revoked_sha1s",
            "&rb"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rb",
            "0",
            "sizeof(rb)"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_key_revoked(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tstruct revoked_blob rb, *erb;\n\tstruct revoked_certs *rc;\n\tint r;\n\n\t/* Check explicitly revoked hashes first */\n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = sshkey_fingerprint_raw(key, SSH_DIGEST_SHA1,\n\t    &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_sha1s, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"%s: revoked by key SHA1\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = sshkey_fingerprint_raw(key, SSH_DIGEST_SHA256,\n\t    &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_sha256s, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"%s: revoked by key SHA256\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\t/* Next, explicit keys */\n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = plain_key_blob(key, &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_keys, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"%s: revoked by explicit key\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\tif (!sshkey_is_cert(key))\n\t\treturn 0;\n\n\t/* Check cert revocation for the specified CA */\n\tif ((r = revoked_certs_for_ca_key(krl, key->cert->signature_key,\n\t    &rc, 0)) != 0)\n\t\treturn r;\n\tif (rc != NULL) {\n\t\tif ((r = is_cert_revoked(key, rc)) != 0)\n\t\t\treturn r;\n\t}\n\t/* Check cert revocation for the wildcard CA */\n\tif ((r = revoked_certs_for_ca_key(krl, NULL, &rc, 0)) != 0)\n\t\treturn r;\n\tif (rc != NULL) {\n\t\tif ((r = is_cert_revoked(key, rc)) != 0)\n\t\t\treturn r;\n\t}\n\n\tKRL_DBG((\"%s: %llu no match\", __func__, key->cert->serial));\n\treturn 0;\n}"
  },
  {
    "function_name": "is_cert_revoked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "1219-1250",
    "snippet": "static int\nis_cert_revoked(const struct sshkey *key, struct revoked_certs *rc)\n{\n\tstruct revoked_serial rs, *ers;\n\tstruct revoked_key_id rki, *erki;\n\n\t/* Check revocation by cert key ID */\n\tmemset(&rki, 0, sizeof(rki));\n\trki.key_id = key->cert->key_id;\n\terki = RB_FIND(revoked_key_id_tree, &rc->revoked_key_ids, &rki);\n\tif (erki != NULL) {\n\t\tKRL_DBG((\"%s: revoked by key ID\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\t/*\n\t * Zero serials numbers are ignored (it's the default when the\n\t * CA doesn't specify one).\n\t */\n\tif (key->cert->serial == 0)\n\t\treturn 0;\n\n\tmemset(&rs, 0, sizeof(rs));\n\trs.lo = rs.hi = key->cert->serial;\n\ters = RB_FIND(revoked_serial_tree, &rc->revoked_serials, &rs);\n\tif (ers != NULL) {\n\t\tKRL_DBG((\"%s: revoked serial %llu matched %llu:%llu\", __func__,\n\t\t    key->cert->serial, ers->lo, ers->hi));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: revoked serial %llu matched %llu:%llu\", __func__,\n\t\t    key->cert->serial, ers->lo, ers->hi)"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_FIND",
          "args": [
            "revoked_serial_tree",
            "&rc->revoked_serials",
            "&rs"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rs",
            "0",
            "sizeof(rs)"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: revoked by key ID\", __func__)"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_FIND",
          "args": [
            "revoked_key_id_tree",
            "&rc->revoked_key_ids",
            "&rki"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rki",
            "0",
            "sizeof(rki)"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_cert_revoked(const struct sshkey *key, struct revoked_certs *rc)\n{\n\tstruct revoked_serial rs, *ers;\n\tstruct revoked_key_id rki, *erki;\n\n\t/* Check revocation by cert key ID */\n\tmemset(&rki, 0, sizeof(rki));\n\trki.key_id = key->cert->key_id;\n\terki = RB_FIND(revoked_key_id_tree, &rc->revoked_key_ids, &rki);\n\tif (erki != NULL) {\n\t\tKRL_DBG((\"%s: revoked by key ID\", __func__));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\t/*\n\t * Zero serials numbers are ignored (it's the default when the\n\t * CA doesn't specify one).\n\t */\n\tif (key->cert->serial == 0)\n\t\treturn 0;\n\n\tmemset(&rs, 0, sizeof(rs));\n\trs.lo = rs.hi = key->cert->serial;\n\ters = RB_FIND(revoked_serial_tree, &rc->revoked_serials, &rs);\n\tif (ers != NULL) {\n\t\tKRL_DBG((\"%s: revoked serial %llu matched %llu:%llu\", __func__,\n\t\t    key->cert->serial, ers->lo, ers->hi));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_krl_from_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "983-1216",
    "snippet": "int\nssh_krl_from_blob(struct sshbuf *buf, struct ssh_krl **krlp,\n    const struct sshkey **sign_ca_keys, size_t nsign_ca_keys)\n{\n\tstruct sshbuf *copy = NULL, *sect = NULL;\n\tstruct ssh_krl *krl = NULL;\n\tchar timestamp[64];\n\tint r = SSH_ERR_INTERNAL_ERROR, sig_seen;\n\tstruct sshkey *key = NULL, **ca_used = NULL, **tmp_ca_used;\n\tu_char type;\n\tconst u_char *blob;\n\tsize_t i, j, sig_off, sects_off, blen, nca_used;\n\tu_int format_version;\n\n\tnca_used = 0;\n\t*krlp = NULL;\n\tif (sshbuf_len(buf) < sizeof(KRL_MAGIC) - 1 ||\n\t    memcmp(sshbuf_ptr(buf), KRL_MAGIC, sizeof(KRL_MAGIC) - 1) != 0) {\n\t\tdebug3(\"%s: not a KRL\", __func__);\n\t\treturn SSH_ERR_KRL_BAD_MAGIC;\n\t}\n\n\t/* Take a copy of the KRL buffer so we can verify its signature later */\n\tif ((copy = sshbuf_fromb(buf)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(copy, sizeof(KRL_MAGIC) - 1)) != 0)\n\t\tgoto out;\n\n\tif ((krl = ssh_krl_init()) == NULL) {\n\t\terror(\"%s: alloc failed\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(copy, &format_version)) != 0)\n\t\tgoto out;\n\tif (format_version != KRL_FORMAT_VERSION) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u64(copy, &krl->krl_version)) != 0 ||\n\t    (r = sshbuf_get_u64(copy, &krl->generated_date)) != 0 ||\n\t    (r = sshbuf_get_u64(copy, &krl->flags)) != 0 ||\n\t    (r = sshbuf_skip_string(copy)) != 0 ||\n\t    (r = sshbuf_get_cstring(copy, &krl->comment, NULL)) != 0)\n\t\tgoto out;\n\n\tformat_timestamp(krl->generated_date, timestamp, sizeof(timestamp));\n\tdebug(\"KRL version %llu generated at %s%s%s\",\n\t    (long long unsigned)krl->krl_version, timestamp,\n\t    *krl->comment ? \": \" : \"\", krl->comment);\n\n\t/*\n\t * 1st pass: verify signatures, if any. This is done to avoid\n\t * detailed parsing of data whose provenance is unverified.\n\t */\n\tsig_seen = 0;\n\tif (sshbuf_len(buf) < sshbuf_len(copy)) {\n\t\t/* Shouldn't happen */\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tsects_off = sshbuf_len(buf) - sshbuf_len(copy);\n\twhile (sshbuf_len(copy) > 0) {\n\t\tif ((r = sshbuf_get_u8(copy, &type)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(copy, &blob, &blen)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: first pass, section 0x%02x\", __func__, type));\n\t\tif (type != KRL_SECTION_SIGNATURE) {\n\t\t\tif (sig_seen) {\n\t\t\t\terror(\"KRL contains non-signature section \"\n\t\t\t\t    \"after signature\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* Not interested for now. */\n\t\t\tcontinue;\n\t\t}\n\t\tsig_seen = 1;\n\t\t/* First string component is the signing key */\n\t\tif ((r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_len(buf) < sshbuf_len(copy)) {\n\t\t\t/* Shouldn't happen */\n\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tsig_off = sshbuf_len(buf) - sshbuf_len(copy);\n\t\t/* Second string component is the signature itself */\n\t\tif ((r = sshbuf_get_string_direct(copy, &blob, &blen)) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Check signature over entire KRL up to this point */\n\t\tif ((r = sshkey_verify(key, blob, blen,\n\t\t    sshbuf_ptr(buf), sig_off, NULL, 0)) != 0)\n\t\t\tgoto out;\n\t\t/* Check if this key has already signed this KRL */\n\t\tfor (i = 0; i < nca_used; i++) {\n\t\t\tif (sshkey_equal(ca_used[i], key)) {\n\t\t\t\terror(\"KRL signed more than once with \"\n\t\t\t\t    \"the same key\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* Record keys used to sign the KRL */\n\t\ttmp_ca_used = recallocarray(ca_used, nca_used, nca_used + 1,\n\t\t    sizeof(*ca_used));\n\t\tif (tmp_ca_used == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tca_used = tmp_ca_used;\n\t\tca_used[nca_used++] = key;\n\t\tkey = NULL;\n\t}\n\n\tif (sshbuf_len(copy) != 0) {\n\t\t/* Shouldn't happen */\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 2nd pass: parse and load the KRL, skipping the header to the point\n\t * where the section start.\n\t */\n\tsshbuf_free(copy);\n\tif ((copy = sshbuf_fromb(buf)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(copy, sects_off)) != 0)\n\t\tgoto out;\n\twhile (sshbuf_len(copy) > 0) {\n\t\tsshbuf_free(sect);\n\t\tsect = NULL;\n\t\tif ((r = sshbuf_get_u8(copy, &type)) != 0 ||\n\t\t    (r = sshbuf_froms(copy, &sect)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: second pass, section 0x%02x\", __func__, type));\n\n\t\tswitch (type) {\n\t\tcase KRL_SECTION_CERTIFICATES:\n\t\t\tif ((r = parse_revoked_certs(sect, krl)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_EXPLICIT_KEY:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_keys, 0)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_FINGERPRINT_SHA1:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_sha1s, 20)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_FINGERPRINT_SHA256:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_sha256s, 32)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_SIGNATURE:\n\t\t\t/* Handled above, but still need to stay in synch */\n\t\t\tsshbuf_free(sect);\n\t\t\tsect = NULL;\n\t\t\tif ((r = sshbuf_skip_string(copy)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"Unsupported KRL section %u\", type);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sect != NULL && sshbuf_len(sect) > 0) {\n\t\t\terror(\"KRL section contains unparsed data\");\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Check that the key(s) used to sign the KRL weren't revoked */\n\tsig_seen = 0;\n\tfor (i = 0; i < nca_used; i++) {\n\t\tif (ssh_krl_check_key(krl, ca_used[i]) == 0)\n\t\t\tsig_seen = 1;\n\t\telse {\n\t\t\tsshkey_free(ca_used[i]);\n\t\t\tca_used[i] = NULL;\n\t\t}\n\t}\n\tif (nca_used && !sig_seen) {\n\t\terror(\"All keys used to sign KRL were revoked\");\n\t\tr = SSH_ERR_KEY_REVOKED;\n\t\tgoto out;\n\t}\n\n\t/* If we have CA keys, then verify that one was used to sign the KRL */\n\tif (sig_seen && nsign_ca_keys != 0) {\n\t\tsig_seen = 0;\n\t\tfor (i = 0; !sig_seen && i < nsign_ca_keys; i++) {\n\t\t\tfor (j = 0; j < nca_used; j++) {\n\t\t\t\tif (ca_used[j] == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (sshkey_equal(ca_used[j], sign_ca_keys[i])) {\n\t\t\t\t\tsig_seen = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!sig_seen) {\n\t\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\t\terror(\"KRL not signed with any trusted key\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*krlp = krl;\n\tr = 0;\n out:\n\tif (r != 0)\n\t\tssh_krl_free(krl);\n\tfor (i = 0; i < nca_used; i++)\n\t\tsshkey_free(ca_used[i]);\n\tfree(ca_used);\n\tsshkey_free(key);\n\tsshbuf_free(copy);\n\tsshbuf_free(sect);\n\treturn r;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "sect"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ca_used"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"KRL not signed with any trusted key\""
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "ca_used[j]",
            "sign_ca_keys[i]"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_check_key",
          "args": [
            "krl",
            "ca_used[i]"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_check_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "1316-1331",
          "snippet": "int\nssh_krl_check_key(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tint r;\n\n\tKRL_DBG((\"%s: checking key\", __func__));\n\tif ((r = is_key_revoked(krl, key)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(key)) {\n\t\tdebug2(\"%s: checking CA key\", __func__);\n\t\tif ((r = is_key_revoked(krl, key->cert->signature_key)) != 0)\n\t\t\treturn r;\n\t}\n\tKRL_DBG((\"%s: key okay\", __func__));\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_check_key(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tint r;\n\n\tKRL_DBG((\"%s: checking key\", __func__));\n\tif ((r = is_key_revoked(krl, key)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(key)) {\n\t\tdebug2(\"%s: checking CA key\", __func__);\n\t\tif ((r = is_key_revoked(krl, key->cert->signature_key)) != 0)\n\t\t\treturn r;\n\t}\n\tKRL_DBG((\"%s: key okay\", __func__));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "sect"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "copy"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blob_section",
          "args": [
            "sect",
            "&krl->revoked_sha256s",
            "32"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "blob_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "958-980",
          "snippet": "static int\nblob_section(struct sshbuf *sect, struct revoked_blob_tree *target_tree,\n    size_t expected_len)\n{\n\tu_char *rdata = NULL;\n\tsize_t rlen = 0;\n\tint r;\n\n\twhile (sshbuf_len(sect) > 0) {\n\t\tif ((r = sshbuf_get_string(sect, &rdata, &rlen)) != 0)\n\t\t\treturn r;\n\t\tif (expected_len != 0 && rlen != expected_len) {\n\t\t\terror(\"%s: bad length\", __func__);\n\t\t\tfree(rdata);\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t}\n\t\tif ((r = revoke_blob(target_tree, rdata, rlen)) != 0) {\n\t\t\tfree(rdata);\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nblob_section(struct sshbuf *sect, struct revoked_blob_tree *target_tree,\n    size_t expected_len)\n{\n\tu_char *rdata = NULL;\n\tsize_t rlen = 0;\n\tint r;\n\n\twhile (sshbuf_len(sect) > 0) {\n\t\tif ((r = sshbuf_get_string(sect, &rdata, &rlen)) != 0)\n\t\t\treturn r;\n\t\tif (expected_len != 0 && rlen != expected_len) {\n\t\t\terror(\"%s: bad length\", __func__);\n\t\t\tfree(rdata);\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t}\n\t\tif ((r = revoke_blob(target_tree, rdata, rlen)) != 0) {\n\t\t\tfree(rdata);\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_revoked_certs",
          "args": [
            "sect",
            "krl"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "parse_revoked_certs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "845-956",
          "snippet": "static int\nparse_revoked_certs(struct sshbuf *buf, struct ssh_krl *krl)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tu_char type;\n\tconst u_char *blob;\n\tsize_t blen, nbits;\n\tstruct sshbuf *subsect = NULL;\n\tu_int64_t serial, serial_lo, serial_hi;\n\tstruct bitmap *bitmap = NULL;\n\tchar *key_id = NULL;\n\tstruct sshkey *ca_key = NULL;\n\n\tif ((subsect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* Header: key, reserved */\n\tif ((r = sshbuf_get_string_direct(buf, &blob, &blen)) != 0 ||\n\t    (r = sshbuf_skip_string(buf)) != 0)\n\t\tgoto out;\n\tif (blen != 0 && (r = sshkey_from_blob(blob, blen, &ca_key)) != 0)\n\t\tgoto out;\n\n\twhile (sshbuf_len(buf) > 0) {\n\t\tsshbuf_free(subsect);\n\t\tsubsect = NULL;\n\t\tif ((r = sshbuf_get_u8(buf, &type)) != 0 ||\n\t\t    (r = sshbuf_froms(buf, &subsect)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: subsection type 0x%02x\", __func__, type));\n\t\t/* sshbuf_dump(subsect, stderr); */\n\n\t\tswitch (type) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\twhile (sshbuf_len(subsect) > 0) {\n\t\t\t\tif ((r = sshbuf_get_u64(subsect, &serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_serial(krl,\n\t\t\t\t    ca_key, serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tif ((r = sshbuf_get_u64(subsect, &serial_lo)) != 0 ||\n\t\t\t    (r = sshbuf_get_u64(subsect, &serial_hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((r = ssh_krl_revoke_cert_by_serial_range(krl,\n\t\t\t    ca_key, serial_lo, serial_hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif ((bitmap = bitmap_new()) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u64(subsect, &serial_lo)) != 0 ||\n\t\t\t    (r = sshbuf_get_bignum2_bytes_direct(subsect,\n\t\t\t    &blob, &blen)) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (bitmap_from_string(bitmap, blob, blen) != 0) {\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnbits = bitmap_nbits(bitmap);\n\t\t\tfor (serial = 0; serial < (u_int64_t)nbits; serial++) {\n\t\t\t\tif (serial > 0 && serial_lo + serial == 0) {\n\t\t\t\t\terror(\"%s: bitmap wraps u64\", __func__);\n\t\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (!bitmap_test_bit(bitmap, serial))\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_serial(krl,\n\t\t\t\t    ca_key, serial_lo + serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbitmap_free(bitmap);\n\t\t\tbitmap = NULL;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_KEY_ID:\n\t\t\twhile (sshbuf_len(subsect) > 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(subsect,\n\t\t\t\t    &key_id, NULL)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_key_id(krl,\n\t\t\t\t    ca_key, key_id)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tfree(key_id);\n\t\t\t\tkey_id = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"Unsupported KRL certificate section %u\", type);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_len(subsect) > 0) {\n\t\t\terror(\"KRL certificate section contains unparsed data\");\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tr = 0;\n out:\n\tif (bitmap != NULL)\n\t\tbitmap_free(bitmap);\n\tfree(key_id);\n\tsshkey_free(ca_key);\n\tsshbuf_free(subsect);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_revoked_certs(struct sshbuf *buf, struct ssh_krl *krl)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tu_char type;\n\tconst u_char *blob;\n\tsize_t blen, nbits;\n\tstruct sshbuf *subsect = NULL;\n\tu_int64_t serial, serial_lo, serial_hi;\n\tstruct bitmap *bitmap = NULL;\n\tchar *key_id = NULL;\n\tstruct sshkey *ca_key = NULL;\n\n\tif ((subsect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* Header: key, reserved */\n\tif ((r = sshbuf_get_string_direct(buf, &blob, &blen)) != 0 ||\n\t    (r = sshbuf_skip_string(buf)) != 0)\n\t\tgoto out;\n\tif (blen != 0 && (r = sshkey_from_blob(blob, blen, &ca_key)) != 0)\n\t\tgoto out;\n\n\twhile (sshbuf_len(buf) > 0) {\n\t\tsshbuf_free(subsect);\n\t\tsubsect = NULL;\n\t\tif ((r = sshbuf_get_u8(buf, &type)) != 0 ||\n\t\t    (r = sshbuf_froms(buf, &subsect)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: subsection type 0x%02x\", __func__, type));\n\t\t/* sshbuf_dump(subsect, stderr); */\n\n\t\tswitch (type) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\twhile (sshbuf_len(subsect) > 0) {\n\t\t\t\tif ((r = sshbuf_get_u64(subsect, &serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_serial(krl,\n\t\t\t\t    ca_key, serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tif ((r = sshbuf_get_u64(subsect, &serial_lo)) != 0 ||\n\t\t\t    (r = sshbuf_get_u64(subsect, &serial_hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((r = ssh_krl_revoke_cert_by_serial_range(krl,\n\t\t\t    ca_key, serial_lo, serial_hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif ((bitmap = bitmap_new()) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u64(subsect, &serial_lo)) != 0 ||\n\t\t\t    (r = sshbuf_get_bignum2_bytes_direct(subsect,\n\t\t\t    &blob, &blen)) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (bitmap_from_string(bitmap, blob, blen) != 0) {\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnbits = bitmap_nbits(bitmap);\n\t\t\tfor (serial = 0; serial < (u_int64_t)nbits; serial++) {\n\t\t\t\tif (serial > 0 && serial_lo + serial == 0) {\n\t\t\t\t\terror(\"%s: bitmap wraps u64\", __func__);\n\t\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (!bitmap_test_bit(bitmap, serial))\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_serial(krl,\n\t\t\t\t    ca_key, serial_lo + serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbitmap_free(bitmap);\n\t\t\tbitmap = NULL;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_KEY_ID:\n\t\t\twhile (sshbuf_len(subsect) > 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(subsect,\n\t\t\t\t    &key_id, NULL)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_key_id(krl,\n\t\t\t\t    ca_key, key_id)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tfree(key_id);\n\t\t\t\tkey_id = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"Unsupported KRL certificate section %u\", type);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_len(subsect) > 0) {\n\t\t\terror(\"KRL certificate section contains unparsed data\");\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tr = 0;\n out:\n\tif (bitmap != NULL)\n\t\tbitmap_free(bitmap);\n\tfree(key_id);\n\tsshkey_free(ca_key);\n\tsshbuf_free(subsect);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: second pass, section 0x%02x\", __func__, type)"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_froms",
          "args": [
            "copy",
            "&sect"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_froms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "377-399",
          "snippet": "int\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "copy",
            "&type"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "copy",
            "sects_off"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_fromb",
          "args": [
            "buf"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_fromb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "117-131",
          "snippet": "struct sshbuf *\nsshbuf_fromb(struct sshbuf *buf)\n{\n\tstruct sshbuf *ret;\n\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\tif ((ret = sshbuf_from(sshbuf_ptr(buf), sshbuf_len(buf))) == NULL)\n\t\treturn NULL;\n\tif (sshbuf_set_parent(ret, buf) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_fromb(struct sshbuf *buf)\n{\n\tstruct sshbuf *ret;\n\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\tif ((ret = sshbuf_from(sshbuf_ptr(buf), sshbuf_len(buf))) == NULL)\n\t\treturn NULL;\n\tif (sshbuf_set_parent(ret, buf) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recallocarray",
          "args": [
            "ca_used",
            "nca_used",
            "nca_used + 1",
            "sizeof(*ca_used)"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_verify",
          "args": [
            "key",
            "blob",
            "blen",
            "sshbuf_ptr(buf)",
            "sig_off",
            "NULL",
            "0"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2427-2459",
          "snippet": "int\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "buf"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string_direct",
          "args": [
            "copy",
            "&blob",
            "&blen"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob",
          "args": [
            "blob",
            "blen",
            "&key"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2263-2274",
          "snippet": "int\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: first pass, section 0x%02x\", __func__, type)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"KRL version %llu generated at %s%s%s\"",
            "(long long unsigned)krl->krl_version",
            "timestamp",
            "*krl->comment ? \": \" : \"\"",
            "krl->comment"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_timestamp",
          "args": [
            "krl->generated_date",
            "timestamp",
            "sizeof(timestamp)"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "format_timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "829-843",
          "snippet": "static void\nformat_timestamp(u_int64_t timestamp, char *ts, size_t nts)\n{\n\ttime_t t;\n\tstruct tm *tm;\n\n\tt = timestamp;\n\ttm = localtime(&t);\n\tif (tm == NULL)\n\t\tstrlcpy(ts, \"<INVALID>\", nts);\n\telse {\n\t\t*ts = '\\0';\n\t\tstrftime(ts, nts, \"%Y%m%dT%H%M%S\", tm);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nformat_timestamp(u_int64_t timestamp, char *ts, size_t nts)\n{\n\ttime_t t;\n\tstruct tm *tm;\n\n\tt = timestamp;\n\ttm = localtime(&t);\n\tif (tm == NULL)\n\t\tstrlcpy(ts, \"<INVALID>\", nts);\n\telse {\n\t\t*ts = '\\0';\n\t\tstrftime(ts, nts, \"%Y%m%dT%H%M%S\", tm);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "copy",
            "&krl->comment",
            "NULL"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "copy"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u64",
          "args": [
            "copy",
            "&krl->flags"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "44-55",
          "snippet": "int\nsshbuf_get_u64(struct sshbuf *buf, u_int64_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 8)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U64(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u64(struct sshbuf *buf, u_int64_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 8)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U64(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "copy",
            "&format_version"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_init",
          "args": [],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "131-143",
          "snippet": "struct ssh_krl *\nssh_krl_init(void)\n{\n\tstruct ssh_krl *krl;\n\n\tif ((krl = calloc(1, sizeof(*krl))) == NULL)\n\t\treturn NULL;\n\tRB_INIT(&krl->revoked_keys);\n\tRB_INIT(&krl->revoked_sha1s);\n\tRB_INIT(&krl->revoked_sha256s);\n\tTAILQ_INIT(&krl->revoked_certs);\n\treturn krl;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct ssh_krl *\nssh_krl_init(void)\n{\n\tstruct ssh_krl *krl;\n\n\tif ((krl = calloc(1, sizeof(*krl))) == NULL)\n\t\treturn NULL;\n\tRB_INIT(&krl->revoked_keys);\n\tRB_INIT(&krl->revoked_sha1s);\n\tRB_INIT(&krl->revoked_sha256s);\n\tTAILQ_INIT(&krl->revoked_certs);\n\treturn krl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sshbuf_ptr(buf)",
            "KRL_MAGIC",
            "sizeof(KRL_MAGIC) - 1"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_from_blob(struct sshbuf *buf, struct ssh_krl **krlp,\n    const struct sshkey **sign_ca_keys, size_t nsign_ca_keys)\n{\n\tstruct sshbuf *copy = NULL, *sect = NULL;\n\tstruct ssh_krl *krl = NULL;\n\tchar timestamp[64];\n\tint r = SSH_ERR_INTERNAL_ERROR, sig_seen;\n\tstruct sshkey *key = NULL, **ca_used = NULL, **tmp_ca_used;\n\tu_char type;\n\tconst u_char *blob;\n\tsize_t i, j, sig_off, sects_off, blen, nca_used;\n\tu_int format_version;\n\n\tnca_used = 0;\n\t*krlp = NULL;\n\tif (sshbuf_len(buf) < sizeof(KRL_MAGIC) - 1 ||\n\t    memcmp(sshbuf_ptr(buf), KRL_MAGIC, sizeof(KRL_MAGIC) - 1) != 0) {\n\t\tdebug3(\"%s: not a KRL\", __func__);\n\t\treturn SSH_ERR_KRL_BAD_MAGIC;\n\t}\n\n\t/* Take a copy of the KRL buffer so we can verify its signature later */\n\tif ((copy = sshbuf_fromb(buf)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(copy, sizeof(KRL_MAGIC) - 1)) != 0)\n\t\tgoto out;\n\n\tif ((krl = ssh_krl_init()) == NULL) {\n\t\terror(\"%s: alloc failed\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(copy, &format_version)) != 0)\n\t\tgoto out;\n\tif (format_version != KRL_FORMAT_VERSION) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u64(copy, &krl->krl_version)) != 0 ||\n\t    (r = sshbuf_get_u64(copy, &krl->generated_date)) != 0 ||\n\t    (r = sshbuf_get_u64(copy, &krl->flags)) != 0 ||\n\t    (r = sshbuf_skip_string(copy)) != 0 ||\n\t    (r = sshbuf_get_cstring(copy, &krl->comment, NULL)) != 0)\n\t\tgoto out;\n\n\tformat_timestamp(krl->generated_date, timestamp, sizeof(timestamp));\n\tdebug(\"KRL version %llu generated at %s%s%s\",\n\t    (long long unsigned)krl->krl_version, timestamp,\n\t    *krl->comment ? \": \" : \"\", krl->comment);\n\n\t/*\n\t * 1st pass: verify signatures, if any. This is done to avoid\n\t * detailed parsing of data whose provenance is unverified.\n\t */\n\tsig_seen = 0;\n\tif (sshbuf_len(buf) < sshbuf_len(copy)) {\n\t\t/* Shouldn't happen */\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tsects_off = sshbuf_len(buf) - sshbuf_len(copy);\n\twhile (sshbuf_len(copy) > 0) {\n\t\tif ((r = sshbuf_get_u8(copy, &type)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(copy, &blob, &blen)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: first pass, section 0x%02x\", __func__, type));\n\t\tif (type != KRL_SECTION_SIGNATURE) {\n\t\t\tif (sig_seen) {\n\t\t\t\terror(\"KRL contains non-signature section \"\n\t\t\t\t    \"after signature\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* Not interested for now. */\n\t\t\tcontinue;\n\t\t}\n\t\tsig_seen = 1;\n\t\t/* First string component is the signing key */\n\t\tif ((r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_len(buf) < sshbuf_len(copy)) {\n\t\t\t/* Shouldn't happen */\n\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tsig_off = sshbuf_len(buf) - sshbuf_len(copy);\n\t\t/* Second string component is the signature itself */\n\t\tif ((r = sshbuf_get_string_direct(copy, &blob, &blen)) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Check signature over entire KRL up to this point */\n\t\tif ((r = sshkey_verify(key, blob, blen,\n\t\t    sshbuf_ptr(buf), sig_off, NULL, 0)) != 0)\n\t\t\tgoto out;\n\t\t/* Check if this key has already signed this KRL */\n\t\tfor (i = 0; i < nca_used; i++) {\n\t\t\tif (sshkey_equal(ca_used[i], key)) {\n\t\t\t\terror(\"KRL signed more than once with \"\n\t\t\t\t    \"the same key\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* Record keys used to sign the KRL */\n\t\ttmp_ca_used = recallocarray(ca_used, nca_used, nca_used + 1,\n\t\t    sizeof(*ca_used));\n\t\tif (tmp_ca_used == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tca_used = tmp_ca_used;\n\t\tca_used[nca_used++] = key;\n\t\tkey = NULL;\n\t}\n\n\tif (sshbuf_len(copy) != 0) {\n\t\t/* Shouldn't happen */\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 2nd pass: parse and load the KRL, skipping the header to the point\n\t * where the section start.\n\t */\n\tsshbuf_free(copy);\n\tif ((copy = sshbuf_fromb(buf)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(copy, sects_off)) != 0)\n\t\tgoto out;\n\twhile (sshbuf_len(copy) > 0) {\n\t\tsshbuf_free(sect);\n\t\tsect = NULL;\n\t\tif ((r = sshbuf_get_u8(copy, &type)) != 0 ||\n\t\t    (r = sshbuf_froms(copy, &sect)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: second pass, section 0x%02x\", __func__, type));\n\n\t\tswitch (type) {\n\t\tcase KRL_SECTION_CERTIFICATES:\n\t\t\tif ((r = parse_revoked_certs(sect, krl)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_EXPLICIT_KEY:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_keys, 0)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_FINGERPRINT_SHA1:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_sha1s, 20)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_FINGERPRINT_SHA256:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_sha256s, 32)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_SIGNATURE:\n\t\t\t/* Handled above, but still need to stay in synch */\n\t\t\tsshbuf_free(sect);\n\t\t\tsect = NULL;\n\t\t\tif ((r = sshbuf_skip_string(copy)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"Unsupported KRL section %u\", type);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sect != NULL && sshbuf_len(sect) > 0) {\n\t\t\terror(\"KRL section contains unparsed data\");\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Check that the key(s) used to sign the KRL weren't revoked */\n\tsig_seen = 0;\n\tfor (i = 0; i < nca_used; i++) {\n\t\tif (ssh_krl_check_key(krl, ca_used[i]) == 0)\n\t\t\tsig_seen = 1;\n\t\telse {\n\t\t\tsshkey_free(ca_used[i]);\n\t\t\tca_used[i] = NULL;\n\t\t}\n\t}\n\tif (nca_used && !sig_seen) {\n\t\terror(\"All keys used to sign KRL were revoked\");\n\t\tr = SSH_ERR_KEY_REVOKED;\n\t\tgoto out;\n\t}\n\n\t/* If we have CA keys, then verify that one was used to sign the KRL */\n\tif (sig_seen && nsign_ca_keys != 0) {\n\t\tsig_seen = 0;\n\t\tfor (i = 0; !sig_seen && i < nsign_ca_keys; i++) {\n\t\t\tfor (j = 0; j < nca_used; j++) {\n\t\t\t\tif (ca_used[j] == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (sshkey_equal(ca_used[j], sign_ca_keys[i])) {\n\t\t\t\t\tsig_seen = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!sig_seen) {\n\t\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\t\terror(\"KRL not signed with any trusted key\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*krlp = krl;\n\tr = 0;\n out:\n\tif (r != 0)\n\t\tssh_krl_free(krl);\n\tfor (i = 0; i < nca_used; i++)\n\t\tsshkey_free(ca_used[i]);\n\tfree(ca_used);\n\tsshkey_free(key);\n\tsshbuf_free(copy);\n\tsshbuf_free(sect);\n\treturn r;\n}"
  },
  {
    "function_name": "blob_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "958-980",
    "snippet": "static int\nblob_section(struct sshbuf *sect, struct revoked_blob_tree *target_tree,\n    size_t expected_len)\n{\n\tu_char *rdata = NULL;\n\tsize_t rlen = 0;\n\tint r;\n\n\twhile (sshbuf_len(sect) > 0) {\n\t\tif ((r = sshbuf_get_string(sect, &rdata, &rlen)) != 0)\n\t\t\treturn r;\n\t\tif (expected_len != 0 && rlen != expected_len) {\n\t\t\terror(\"%s: bad length\", __func__);\n\t\t\tfree(rdata);\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t}\n\t\tif ((r = revoke_blob(target_tree, rdata, rlen)) != 0) {\n\t\t\tfree(rdata);\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rdata"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "revoke_blob",
          "args": [
            "target_tree",
            "rdata",
            "rlen"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "revoke_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "388-403",
          "snippet": "static int\nrevoke_blob(struct revoked_blob_tree *rbt, u_char *blob, size_t len)\n{\n\tstruct revoked_blob *rb, *erb;\n\n\tif ((rb = calloc(1, sizeof(*rb))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\trb->blob = blob;\n\trb->len = len;\n\terb = RB_INSERT(revoked_blob_tree, rbt, rb);\n\tif (erb != NULL) {\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrevoke_blob(struct revoked_blob_tree *rbt, u_char *blob, size_t len)\n{\n\tstruct revoked_blob *rb, *erb;\n\n\tif ((rb = calloc(1, sizeof(*rb))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\trb->blob = blob;\n\trb->len = len;\n\terb = RB_INSERT(revoked_blob_tree, rbt, rb);\n\tif (erb != NULL) {\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: bad length\"",
            "__func__"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "sect",
            "&rdata",
            "&rlen"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "sect"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nblob_section(struct sshbuf *sect, struct revoked_blob_tree *target_tree,\n    size_t expected_len)\n{\n\tu_char *rdata = NULL;\n\tsize_t rlen = 0;\n\tint r;\n\n\twhile (sshbuf_len(sect) > 0) {\n\t\tif ((r = sshbuf_get_string(sect, &rdata, &rlen)) != 0)\n\t\t\treturn r;\n\t\tif (expected_len != 0 && rlen != expected_len) {\n\t\t\terror(\"%s: bad length\", __func__);\n\t\t\tfree(rdata);\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t}\n\t\tif ((r = revoke_blob(target_tree, rdata, rlen)) != 0) {\n\t\t\tfree(rdata);\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_revoked_certs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "845-956",
    "snippet": "static int\nparse_revoked_certs(struct sshbuf *buf, struct ssh_krl *krl)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tu_char type;\n\tconst u_char *blob;\n\tsize_t blen, nbits;\n\tstruct sshbuf *subsect = NULL;\n\tu_int64_t serial, serial_lo, serial_hi;\n\tstruct bitmap *bitmap = NULL;\n\tchar *key_id = NULL;\n\tstruct sshkey *ca_key = NULL;\n\n\tif ((subsect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* Header: key, reserved */\n\tif ((r = sshbuf_get_string_direct(buf, &blob, &blen)) != 0 ||\n\t    (r = sshbuf_skip_string(buf)) != 0)\n\t\tgoto out;\n\tif (blen != 0 && (r = sshkey_from_blob(blob, blen, &ca_key)) != 0)\n\t\tgoto out;\n\n\twhile (sshbuf_len(buf) > 0) {\n\t\tsshbuf_free(subsect);\n\t\tsubsect = NULL;\n\t\tif ((r = sshbuf_get_u8(buf, &type)) != 0 ||\n\t\t    (r = sshbuf_froms(buf, &subsect)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: subsection type 0x%02x\", __func__, type));\n\t\t/* sshbuf_dump(subsect, stderr); */\n\n\t\tswitch (type) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\twhile (sshbuf_len(subsect) > 0) {\n\t\t\t\tif ((r = sshbuf_get_u64(subsect, &serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_serial(krl,\n\t\t\t\t    ca_key, serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tif ((r = sshbuf_get_u64(subsect, &serial_lo)) != 0 ||\n\t\t\t    (r = sshbuf_get_u64(subsect, &serial_hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((r = ssh_krl_revoke_cert_by_serial_range(krl,\n\t\t\t    ca_key, serial_lo, serial_hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif ((bitmap = bitmap_new()) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u64(subsect, &serial_lo)) != 0 ||\n\t\t\t    (r = sshbuf_get_bignum2_bytes_direct(subsect,\n\t\t\t    &blob, &blen)) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (bitmap_from_string(bitmap, blob, blen) != 0) {\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnbits = bitmap_nbits(bitmap);\n\t\t\tfor (serial = 0; serial < (u_int64_t)nbits; serial++) {\n\t\t\t\tif (serial > 0 && serial_lo + serial == 0) {\n\t\t\t\t\terror(\"%s: bitmap wraps u64\", __func__);\n\t\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (!bitmap_test_bit(bitmap, serial))\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_serial(krl,\n\t\t\t\t    ca_key, serial_lo + serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbitmap_free(bitmap);\n\t\t\tbitmap = NULL;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_KEY_ID:\n\t\t\twhile (sshbuf_len(subsect) > 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(subsect,\n\t\t\t\t    &key_id, NULL)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_key_id(krl,\n\t\t\t\t    ca_key, key_id)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tfree(key_id);\n\t\t\t\tkey_id = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"Unsupported KRL certificate section %u\", type);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_len(subsect) > 0) {\n\t\t\terror(\"KRL certificate section contains unparsed data\");\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tr = 0;\n out:\n\tif (bitmap != NULL)\n\t\tbitmap_free(bitmap);\n\tfree(key_id);\n\tsshkey_free(ca_key);\n\tsshbuf_free(subsect);\n\treturn r;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "subsect"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "ca_key"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "key_id"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_free",
          "args": [
            "bitmap"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/bitmap.c",
          "lines": "53-62",
          "snippet": "void\nbitmap_free(struct bitmap *b)\n{\n\tif (b != NULL && b->d != NULL) {\n\t\tbitmap_zero(b);\n\t\tfree(b->d);\n\t\tb->d = NULL;\n\t}\n\tfree(b);\n}",
          "includes": [
            "#include \"bitmap.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitmap.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nbitmap_free(struct bitmap *b)\n{\n\tif (b != NULL && b->d != NULL) {\n\t\tbitmap_zero(b);\n\t\tfree(b->d);\n\t\tb->d = NULL;\n\t}\n\tfree(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"KRL certificate section contains unparsed data\""
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "subsect"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_revoke_cert_by_key_id",
          "args": [
            "krl",
            "ca_key",
            "key_id"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_revoke_cert_by_key_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "342-365",
          "snippet": "int\nssh_krl_revoke_cert_by_key_id(struct ssh_krl *krl, const struct sshkey *ca_key,\n    const char *key_id)\n{\n\tstruct revoked_key_id *rki, *erki;\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\n\tKRL_DBG((\"%s: revoke %s\", __func__, key_id));\n\tif ((rki = calloc(1, sizeof(*rki))) == NULL ||\n\t    (rki->key_id = strdup(key_id)) == NULL) {\n\t\tfree(rki);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\terki = RB_INSERT(revoked_key_id_tree, &rc->revoked_key_ids, rki);\n\tif (erki != NULL) {\n\t\tfree(rki->key_id);\n\t\tfree(rki);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_cert_by_key_id(struct ssh_krl *krl, const struct sshkey *ca_key,\n    const char *key_id)\n{\n\tstruct revoked_key_id *rki, *erki;\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\n\tKRL_DBG((\"%s: revoke %s\", __func__, key_id));\n\tif ((rki = calloc(1, sizeof(*rki))) == NULL ||\n\t    (rki->key_id = strdup(key_id)) == NULL) {\n\t\tfree(rki);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\terki = RB_INSERT(revoked_key_id_tree, &rc->revoked_key_ids, rki);\n\tif (erki != NULL) {\n\t\tfree(rki->key_id);\n\t\tfree(rki);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "subsect",
            "&key_id",
            "NULL"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_revoke_cert_by_serial",
          "args": [
            "krl",
            "ca_key",
            "serial_lo + serial"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_revoke_cert_by_serial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "321-326",
          "snippet": "int\nssh_krl_revoke_cert_by_serial(struct ssh_krl *krl, const struct sshkey *ca_key,\n    u_int64_t serial)\n{\n\treturn ssh_krl_revoke_cert_by_serial_range(krl, ca_key, serial, serial);\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_cert_by_serial(struct ssh_krl *krl, const struct sshkey *ca_key,\n    u_int64_t serial)\n{\n\treturn ssh_krl_revoke_cert_by_serial_range(krl, ca_key, serial, serial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_test_bit",
          "args": [
            "bitmap",
            "serial"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/bitmap.c",
          "lines": "71-79",
          "snippet": "int\nbitmap_test_bit(struct bitmap *b, u_int n)\n{\n\tif (b->top >= b->len)\n\t\treturn 0; /* invalid */\n\tif (b->len == 0 || (n / BITMAP_BITS) > b->top)\n\t\treturn 0;\n\treturn (b->d[n / BITMAP_BITS] >> (n & BITMAP_WMASK)) & 1;\n}",
          "includes": [
            "#include \"bitmap.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define BITMAP_WMASK\t((BITMAP_WTYPE)BITMAP_BITS - 1)",
            "#define BITMAP_BITS\t(sizeof(BITMAP_WTYPE) * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitmap.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BITMAP_WMASK\t((BITMAP_WTYPE)BITMAP_BITS - 1)\n#define BITMAP_BITS\t(sizeof(BITMAP_WTYPE) * 8)\n\nint\nbitmap_test_bit(struct bitmap *b, u_int n)\n{\n\tif (b->top >= b->len)\n\t\treturn 0; /* invalid */\n\tif (b->len == 0 || (n / BITMAP_BITS) > b->top)\n\t\treturn 0;\n\treturn (b->d[n / BITMAP_BITS] >> (n & BITMAP_WMASK)) & 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_nbits",
          "args": [
            "bitmap"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_nbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/bitmap.c",
          "lines": "140-159",
          "snippet": "size_t\nbitmap_nbits(struct bitmap *b)\n{\n\tsize_t bits;\n\tBITMAP_WTYPE w;\n\n\tretop(b);\n\tif (b->top >= b->len)\n\t\treturn 0; /* invalid */\n\tif (b->len == 0 || (b->top == 0 && b->d[0] == 0))\n\t\treturn 0;\n\t/* Find MSB set */\n\tw = b->d[b->top];\n\tbits = (b->top + 1) * BITMAP_BITS;\n\twhile (!(w & ((BITMAP_WTYPE)1 << (BITMAP_BITS - 1)))) {\n\t\tw <<= 1;\n\t\tbits--;\n\t}\n\treturn bits;\n}",
          "includes": [
            "#include \"bitmap.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define BITMAP_BITS\t(sizeof(BITMAP_WTYPE) * 8)",
            "#define BITMAP_WTYPE\tu_int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitmap.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BITMAP_BITS\t(sizeof(BITMAP_WTYPE) * 8)\n#define BITMAP_WTYPE\tu_int\n\nsize_t\nbitmap_nbits(struct bitmap *b)\n{\n\tsize_t bits;\n\tBITMAP_WTYPE w;\n\n\tretop(b);\n\tif (b->top >= b->len)\n\t\treturn 0; /* invalid */\n\tif (b->len == 0 || (b->top == 0 && b->d[0] == 0))\n\t\treturn 0;\n\t/* Find MSB set */\n\tw = b->d[b->top];\n\tbits = (b->top + 1) * BITMAP_BITS;\n\twhile (!(w & ((BITMAP_WTYPE)1 << (BITMAP_BITS - 1)))) {\n\t\tw <<= 1;\n\t\tbits--;\n\t}\n\treturn bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_from_string",
          "args": [
            "bitmap",
            "blob",
            "blen"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_from_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/bitmap.c",
          "lines": "188-214",
          "snippet": "int\nbitmap_from_string(struct bitmap *b, const void *p, size_t l)\n{\n\tint r;\n\tsize_t i, offset, shift;\n\tconst u_char *s = (const u_char *)p;\n\n\tif (l > BITMAP_MAX / 8)\n\t\treturn -1;\n\tif ((r = reserve(b, l * 8)) != 0)\n\t\treturn r;\n\tbitmap_zero(b);\n\tif (l == 0)\n\t\treturn 0;\n\tb->top = offset = ((l + (BITMAP_BYTES - 1)) / BITMAP_BYTES) - 1;\n\tshift = ((l + (BITMAP_BYTES - 1)) % BITMAP_BYTES) * 8;\n\tfor (i = 0; i < l; i++) {\n\t\tb->d[offset] |= (BITMAP_WTYPE)s[i] << shift;\n\t\tif (shift == 0) {\n\t\t\toffset--;\n\t\t\tshift = BITMAP_BITS - 8;\n\t\t} else\n\t\t\tshift -= 8;\n\t}\n\tretop(b);\n\treturn 0;\n}",
          "includes": [
            "#include \"bitmap.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define BITMAP_BITS\t(sizeof(BITMAP_WTYPE) * 8)",
            "#define BITMAP_BYTES\t(sizeof(BITMAP_WTYPE))",
            "#define BITMAP_MAX\t(1<<24)",
            "#define BITMAP_WTYPE\tu_int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitmap.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BITMAP_BITS\t(sizeof(BITMAP_WTYPE) * 8)\n#define BITMAP_BYTES\t(sizeof(BITMAP_WTYPE))\n#define BITMAP_MAX\t(1<<24)\n#define BITMAP_WTYPE\tu_int\n\nint\nbitmap_from_string(struct bitmap *b, const void *p, size_t l)\n{\n\tint r;\n\tsize_t i, offset, shift;\n\tconst u_char *s = (const u_char *)p;\n\n\tif (l > BITMAP_MAX / 8)\n\t\treturn -1;\n\tif ((r = reserve(b, l * 8)) != 0)\n\t\treturn r;\n\tbitmap_zero(b);\n\tif (l == 0)\n\t\treturn 0;\n\tb->top = offset = ((l + (BITMAP_BYTES - 1)) / BITMAP_BYTES) - 1;\n\tshift = ((l + (BITMAP_BYTES - 1)) % BITMAP_BYTES) * 8;\n\tfor (i = 0; i < l; i++) {\n\t\tb->d[offset] |= (BITMAP_WTYPE)s[i] << shift;\n\t\tif (shift == 0) {\n\t\t\toffset--;\n\t\t\tshift = BITMAP_BITS - 8;\n\t\t} else\n\t\t\tshift -= 8;\n\t}\n\tretop(b);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_bignum2_bytes_direct",
          "args": [
            "subsect",
            "&blob",
            "&blen"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_bignum2_bytes_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "430-464",
          "snippet": "int\nsshbuf_get_bignum2_bytes_direct(struct sshbuf *buf,\n    const u_char **valp, size_t *lenp)\n{\n\tconst u_char *d;\n\tsize_t len, olen;\n\tint r;\n\n\tif ((r = sshbuf_peek_string_direct(buf, &d, &olen)) < 0)\n\t\treturn r;\n\tlen = olen;\n\t/* Refuse negative (MSB set) bignums */\n\tif ((len != 0 && (*d & 0x80) != 0))\n\t\treturn SSH_ERR_BIGNUM_IS_NEGATIVE;\n\t/* Refuse overlong bignums, allow prepended \\0 to avoid MSB set */\n\tif (len > SSHBUF_MAX_BIGNUM + 1 ||\n\t    (len == SSHBUF_MAX_BIGNUM + 1 && *d != 0))\n\t\treturn SSH_ERR_BIGNUM_TOO_LARGE;\n\t/* Trim leading zeros */\n\twhile (len > 0 && *d == 0x00) {\n\t\td++;\n\t\tlen--;\n\t}\n\tif (valp != NULL)\n\t\t*valp = d;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, olen + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_bignum2_bytes_direct(struct sshbuf *buf,\n    const u_char **valp, size_t *lenp)\n{\n\tconst u_char *d;\n\tsize_t len, olen;\n\tint r;\n\n\tif ((r = sshbuf_peek_string_direct(buf, &d, &olen)) < 0)\n\t\treturn r;\n\tlen = olen;\n\t/* Refuse negative (MSB set) bignums */\n\tif ((len != 0 && (*d & 0x80) != 0))\n\t\treturn SSH_ERR_BIGNUM_IS_NEGATIVE;\n\t/* Refuse overlong bignums, allow prepended \\0 to avoid MSB set */\n\tif (len > SSHBUF_MAX_BIGNUM + 1 ||\n\t    (len == SSHBUF_MAX_BIGNUM + 1 && *d != 0))\n\t\treturn SSH_ERR_BIGNUM_TOO_LARGE;\n\t/* Trim leading zeros */\n\twhile (len > 0 && *d == 0x00) {\n\t\td++;\n\t\tlen--;\n\t}\n\tif (valp != NULL)\n\t\t*valp = d;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, olen + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u64",
          "args": [
            "subsect",
            "&serial_lo"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "44-55",
          "snippet": "int\nsshbuf_get_u64(struct sshbuf *buf, u_int64_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 8)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U64(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u64(struct sshbuf *buf, u_int64_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 8)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U64(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_new",
          "args": [],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/bitmap.c",
          "lines": "37-51",
          "snippet": "struct bitmap *\nbitmap_new(void)\n{\n\tstruct bitmap *ret;\n\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL)\n\t\treturn NULL;\n\tif ((ret->d = calloc(1, BITMAP_BYTES)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret->len = 1;\n\tret->top = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"bitmap.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define BITMAP_BYTES\t(sizeof(BITMAP_WTYPE))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitmap.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BITMAP_BYTES\t(sizeof(BITMAP_WTYPE))\n\nstruct bitmap *\nbitmap_new(void)\n{\n\tstruct bitmap *ret;\n\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL)\n\t\treturn NULL;\n\tif ((ret->d = calloc(1, BITMAP_BYTES)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret->len = 1;\n\tret->top = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_revoke_cert_by_serial_range",
          "args": [
            "krl",
            "ca_key",
            "serial_lo",
            "serial_hi"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_revoke_cert_by_serial_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "328-340",
          "snippet": "int\nssh_krl_revoke_cert_by_serial_range(struct ssh_krl *krl,\n    const struct sshkey *ca_key, u_int64_t lo, u_int64_t hi)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif (lo > hi || lo == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\treturn insert_serial_range(&rc->revoked_serials, lo, hi);\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_cert_by_serial_range(struct ssh_krl *krl,\n    const struct sshkey *ca_key, u_int64_t lo, u_int64_t hi)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif (lo > hi || lo == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\treturn insert_serial_range(&rc->revoked_serials, lo, hi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: subsection type 0x%02x\", __func__, type)"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_froms",
          "args": [
            "buf",
            "&subsect"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_froms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "377-399",
          "snippet": "int\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "buf",
            "&type"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob",
          "args": [
            "blob",
            "blen",
            "&ca_key"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2263-2274",
          "snippet": "int\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "buf"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string_direct",
          "args": [
            "buf",
            "&blob",
            "&blen"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_revoked_certs(struct sshbuf *buf, struct ssh_krl *krl)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tu_char type;\n\tconst u_char *blob;\n\tsize_t blen, nbits;\n\tstruct sshbuf *subsect = NULL;\n\tu_int64_t serial, serial_lo, serial_hi;\n\tstruct bitmap *bitmap = NULL;\n\tchar *key_id = NULL;\n\tstruct sshkey *ca_key = NULL;\n\n\tif ((subsect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* Header: key, reserved */\n\tif ((r = sshbuf_get_string_direct(buf, &blob, &blen)) != 0 ||\n\t    (r = sshbuf_skip_string(buf)) != 0)\n\t\tgoto out;\n\tif (blen != 0 && (r = sshkey_from_blob(blob, blen, &ca_key)) != 0)\n\t\tgoto out;\n\n\twhile (sshbuf_len(buf) > 0) {\n\t\tsshbuf_free(subsect);\n\t\tsubsect = NULL;\n\t\tif ((r = sshbuf_get_u8(buf, &type)) != 0 ||\n\t\t    (r = sshbuf_froms(buf, &subsect)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: subsection type 0x%02x\", __func__, type));\n\t\t/* sshbuf_dump(subsect, stderr); */\n\n\t\tswitch (type) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\twhile (sshbuf_len(subsect) > 0) {\n\t\t\t\tif ((r = sshbuf_get_u64(subsect, &serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_serial(krl,\n\t\t\t\t    ca_key, serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tif ((r = sshbuf_get_u64(subsect, &serial_lo)) != 0 ||\n\t\t\t    (r = sshbuf_get_u64(subsect, &serial_hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((r = ssh_krl_revoke_cert_by_serial_range(krl,\n\t\t\t    ca_key, serial_lo, serial_hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif ((bitmap = bitmap_new()) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u64(subsect, &serial_lo)) != 0 ||\n\t\t\t    (r = sshbuf_get_bignum2_bytes_direct(subsect,\n\t\t\t    &blob, &blen)) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (bitmap_from_string(bitmap, blob, blen) != 0) {\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnbits = bitmap_nbits(bitmap);\n\t\t\tfor (serial = 0; serial < (u_int64_t)nbits; serial++) {\n\t\t\t\tif (serial > 0 && serial_lo + serial == 0) {\n\t\t\t\t\terror(\"%s: bitmap wraps u64\", __func__);\n\t\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (!bitmap_test_bit(bitmap, serial))\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_serial(krl,\n\t\t\t\t    ca_key, serial_lo + serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbitmap_free(bitmap);\n\t\t\tbitmap = NULL;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_KEY_ID:\n\t\t\twhile (sshbuf_len(subsect) > 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(subsect,\n\t\t\t\t    &key_id, NULL)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_key_id(krl,\n\t\t\t\t    ca_key, key_id)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tfree(key_id);\n\t\t\t\tkey_id = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"Unsupported KRL certificate section %u\", type);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_len(subsect) > 0) {\n\t\t\terror(\"KRL certificate section contains unparsed data\");\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tr = 0;\n out:\n\tif (bitmap != NULL)\n\t\tbitmap_free(bitmap);\n\tfree(key_id);\n\tsshkey_free(ca_key);\n\tsshbuf_free(subsect);\n\treturn r;\n}"
  },
  {
    "function_name": "format_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "829-843",
    "snippet": "static void\nformat_timestamp(u_int64_t timestamp, char *ts, size_t nts)\n{\n\ttime_t t;\n\tstruct tm *tm;\n\n\tt = timestamp;\n\ttm = localtime(&t);\n\tif (tm == NULL)\n\t\tstrlcpy(ts, \"<INVALID>\", nts);\n\telse {\n\t\t*ts = '\\0';\n\t\tstrftime(ts, nts, \"%Y%m%dT%H%M%S\", tm);\n\t}\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strftime",
          "args": [
            "ts",
            "nts",
            "\"%Y%m%dT%H%M%S\"",
            "tm"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ts",
            "\"<INVALID>\"",
            "nts"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "localtime",
          "args": [
            "&t"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nformat_timestamp(u_int64_t timestamp, char *ts, size_t nts)\n{\n\ttime_t t;\n\tstruct tm *tm;\n\n\tt = timestamp;\n\ttm = localtime(&t);\n\tif (tm == NULL)\n\t\tstrlcpy(ts, \"<INVALID>\", nts);\n\telse {\n\t\t*ts = '\\0';\n\t\tstrftime(ts, nts, \"%Y%m%dT%H%M%S\", tm);\n\t}\n}"
  },
  {
    "function_name": "ssh_krl_to_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "733-827",
    "snippet": "int\nssh_krl_to_blob(struct ssh_krl *krl, struct sshbuf *buf,\n    const struct sshkey **sign_keys, u_int nsign_keys)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct revoked_certs *rc;\n\tstruct revoked_blob *rb;\n\tstruct sshbuf *sect;\n\tu_char *sblob = NULL;\n\tsize_t slen, i;\n\n\tif (krl->generated_date == 0)\n\t\tkrl->generated_date = time(NULL);\n\n\tif ((sect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* Store the header */\n\tif ((r = sshbuf_put(buf, KRL_MAGIC, sizeof(KRL_MAGIC) - 1)) != 0 ||\n\t    (r = sshbuf_put_u32(buf, KRL_FORMAT_VERSION)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->krl_version)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->generated_date)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->flags)) != 0 ||\n\t    (r = sshbuf_put_string(buf, NULL, 0)) != 0 ||\n\t    (r = sshbuf_put_cstring(buf, krl->comment)) != 0)\n\t\tgoto out;\n\n\t/* Store sections for revoked certificates */\n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tsshbuf_reset(sect);\n\t\tif ((r = revoked_certs_generate(rc, sect)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_CERTIFICATES)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Finally, output sections for revocations by public key/hash */\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_keys) {\n\t\tKRL_DBG((\"%s: key len %zu \", __func__, rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_EXPLICIT_KEY)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_sha1s) {\n\t\tKRL_DBG((\"%s: hash len %zu \", __func__, rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf,\n\t\t    KRL_SECTION_FINGERPRINT_SHA1)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_sha256s) {\n\t\tKRL_DBG((\"%s: hash len %zu \", __func__, rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf,\n\t\t    KRL_SECTION_FINGERPRINT_SHA256)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < nsign_keys; i++) {\n\t\tKRL_DBG((\"%s: signature key %s\", __func__,\n\t\t    sshkey_ssh_name(sign_keys[i])));\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_SIGNATURE)) != 0 ||\n\t\t    (r = sshkey_puts(sign_keys[i], buf)) != 0)\n\t\t\tgoto out;\n\n\t\tif ((r = sshkey_sign(sign_keys[i], &sblob, &slen,\n\t\t    sshbuf_ptr(buf), sshbuf_len(buf), NULL, 0)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: signature sig len %zu\", __func__, slen));\n\t\tif ((r = sshbuf_put_string(buf, sblob, slen)) != 0)\n\t\t\tgoto out;\n\t}\n\n\tr = 0;\n out:\n\tfree(sblob);\n\tsshbuf_free(sect);\n\treturn r;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "sect"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sblob"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "buf",
            "sblob",
            "slen"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: signature sig len %zu\", __func__, slen)"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_sign",
          "args": [
            "sign_keys[i]",
            "&sblob",
            "&slen",
            "sshbuf_ptr(buf)",
            "sshbuf_len(buf)",
            "NULL",
            "0"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2385-2421",
          "snippet": "int\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "buf"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "buf"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_puts",
          "args": [
            "sign_keys[i]",
            "buf"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "836-840",
          "snippet": "int\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "buf",
            "KRL_SECTION_SIGNATURE"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: signature key %s\", __func__,\n\t\t    sshkey_ssh_name(sign_keys[i]))"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "sign_keys[i]"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "buf",
            "sect"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: hash len %zu \", __func__, rb->len)"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_FOREACH",
          "args": [
            "rb",
            "revoked_blob_tree",
            "&krl->revoked_sha256s"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "sect"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: hash len %zu \", __func__, rb->len)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_FOREACH",
          "args": [
            "rb",
            "revoked_blob_tree",
            "&krl->revoked_sha1s"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: key len %zu \", __func__, rb->len)"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_FOREACH",
          "args": [
            "rb",
            "revoked_blob_tree",
            "&krl->revoked_keys"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revoked_certs_generate",
          "args": [
            "rc",
            "sect"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "revoked_certs_generate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "574-731",
          "snippet": "static int\nrevoked_certs_generate(struct revoked_certs *rc, struct sshbuf *buf)\n{\n\tint final, force_new_sect, r = SSH_ERR_INTERNAL_ERROR;\n\tu_int64_t i, contig, gap, last = 0, bitmap_start = 0;\n\tstruct revoked_serial *rs, *nrs;\n\tstruct revoked_key_id *rki;\n\tint next_state, state = 0;\n\tstruct sshbuf *sect;\n\tstruct bitmap *bitmap = NULL;\n\n\tif ((sect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* Store the header: optional CA scope key, reserved */\n\tif (rc->ca_key == NULL) {\n\t\tif ((r = sshbuf_put_string(buf, NULL, 0)) != 0)\n\t\t\tgoto out;\n\t} else {\n\t\tif ((r = sshkey_puts(rc->ca_key, buf)) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_string(buf, NULL, 0)) != 0)\n\t\tgoto out;\n\n\t/* Store the revoked serials.  */\n\tfor (rs = RB_MIN(revoked_serial_tree, &rc->revoked_serials);\n\t     rs != NULL;\n\t     rs = RB_NEXT(revoked_serial_tree, &rc->revoked_serials, rs)) {\n\t\tKRL_DBG((\"%s: serial %llu:%llu state 0x%02x\", __func__,\n\t\t    (long long unsigned)rs->lo, (long long unsigned)rs->hi,\n\t\t    state));\n\n\t\t/* Check contiguous length and gap to next section (if any) */\n\t\tnrs = RB_NEXT(revoked_serial_tree, &rc->revoked_serials, rs);\n\t\tfinal = nrs == NULL;\n\t\tgap = nrs == NULL ? 0 : nrs->lo - rs->hi;\n\t\tcontig = 1 + (rs->hi - rs->lo);\n\n\t\t/* Choose next state based on these */\n\t\tnext_state = choose_next_state(state, contig, final,\n\t\t    state == 0 ? 0 : rs->lo - last, gap, &force_new_sect);\n\n\t\t/*\n\t\t * If the current section is a range section or has a different\n\t\t * type to the next section, then finish it off now.\n\t\t */\n\t\tif (state != 0 && (force_new_sect || next_state != state ||\n\t\t    state == KRL_SECTION_CERT_SERIAL_RANGE)) {\n\t\t\tKRL_DBG((\"%s: finish state 0x%02x\", __func__, state));\n\t\t\tswitch (state) {\n\t\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\t\tbreak;\n\t\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\t\tif ((r = put_bitmap(sect, bitmap)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbitmap_free(bitmap);\n\t\t\t\tbitmap = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((r = sshbuf_put_u8(buf, state)) != 0 ||\n\t\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\t\tgoto out;\n\t\t\tsshbuf_reset(sect);\n\t\t}\n\n\t\t/* If we are starting a new section then prepare it now */\n\t\tif (next_state != state || force_new_sect) {\n\t\t\tKRL_DBG((\"%s: start state 0x%02x\", __func__,\n\t\t\t    next_state));\n\t\t\tstate = next_state;\n\t\t\tsshbuf_reset(sect);\n\t\t\tswitch (state) {\n\t\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\t\tbreak;\n\t\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\t\tif ((bitmap = bitmap_new()) == NULL) {\n\t\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbitmap_start = rs->lo;\n\t\t\t\tif ((r = sshbuf_put_u64(sect,\n\t\t\t\t    bitmap_start)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Perform section-specific processing */\n\t\tswitch (state) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tfor (i = 0; i < contig; i++) {\n\t\t\t\tif ((r = sshbuf_put_u64(sect, rs->lo + i)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tif ((r = sshbuf_put_u64(sect, rs->lo)) != 0 ||\n\t\t\t    (r = sshbuf_put_u64(sect, rs->hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif (rs->lo - bitmap_start > INT_MAX) {\n\t\t\t\terror(\"%s: insane bitmap gap\", __func__);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfor (i = 0; i < contig; i++) {\n\t\t\t\tif (bitmap_set_bit(bitmap,\n\t\t\t\t    rs->lo + i - bitmap_start) != 0) {\n\t\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tlast = rs->hi;\n\t}\n\t/* Flush the remaining section, if any */\n\tif (state != 0) {\n\t\tKRL_DBG((\"%s: serial final flush for state 0x%02x\",\n\t\t    __func__, state));\n\t\tswitch (state) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif ((r = put_bitmap(sect, bitmap)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbitmap_free(bitmap);\n\t\t\tbitmap = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif ((r = sshbuf_put_u8(buf, state)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tKRL_DBG((\"%s: serial done \", __func__));\n\n\t/* Now output a section for any revocations by key ID */\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rki, revoked_key_id_tree, &rc->revoked_key_ids) {\n\t\tKRL_DBG((\"%s: key ID %s\", __func__, rki->key_id));\n\t\tif ((r = sshbuf_put_cstring(sect, rki->key_id)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_CERT_KEY_ID)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\tbitmap_free(bitmap);\n\tsshbuf_free(sect);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrevoked_certs_generate(struct revoked_certs *rc, struct sshbuf *buf)\n{\n\tint final, force_new_sect, r = SSH_ERR_INTERNAL_ERROR;\n\tu_int64_t i, contig, gap, last = 0, bitmap_start = 0;\n\tstruct revoked_serial *rs, *nrs;\n\tstruct revoked_key_id *rki;\n\tint next_state, state = 0;\n\tstruct sshbuf *sect;\n\tstruct bitmap *bitmap = NULL;\n\n\tif ((sect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* Store the header: optional CA scope key, reserved */\n\tif (rc->ca_key == NULL) {\n\t\tif ((r = sshbuf_put_string(buf, NULL, 0)) != 0)\n\t\t\tgoto out;\n\t} else {\n\t\tif ((r = sshkey_puts(rc->ca_key, buf)) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_string(buf, NULL, 0)) != 0)\n\t\tgoto out;\n\n\t/* Store the revoked serials.  */\n\tfor (rs = RB_MIN(revoked_serial_tree, &rc->revoked_serials);\n\t     rs != NULL;\n\t     rs = RB_NEXT(revoked_serial_tree, &rc->revoked_serials, rs)) {\n\t\tKRL_DBG((\"%s: serial %llu:%llu state 0x%02x\", __func__,\n\t\t    (long long unsigned)rs->lo, (long long unsigned)rs->hi,\n\t\t    state));\n\n\t\t/* Check contiguous length and gap to next section (if any) */\n\t\tnrs = RB_NEXT(revoked_serial_tree, &rc->revoked_serials, rs);\n\t\tfinal = nrs == NULL;\n\t\tgap = nrs == NULL ? 0 : nrs->lo - rs->hi;\n\t\tcontig = 1 + (rs->hi - rs->lo);\n\n\t\t/* Choose next state based on these */\n\t\tnext_state = choose_next_state(state, contig, final,\n\t\t    state == 0 ? 0 : rs->lo - last, gap, &force_new_sect);\n\n\t\t/*\n\t\t * If the current section is a range section or has a different\n\t\t * type to the next section, then finish it off now.\n\t\t */\n\t\tif (state != 0 && (force_new_sect || next_state != state ||\n\t\t    state == KRL_SECTION_CERT_SERIAL_RANGE)) {\n\t\t\tKRL_DBG((\"%s: finish state 0x%02x\", __func__, state));\n\t\t\tswitch (state) {\n\t\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\t\tbreak;\n\t\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\t\tif ((r = put_bitmap(sect, bitmap)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbitmap_free(bitmap);\n\t\t\t\tbitmap = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((r = sshbuf_put_u8(buf, state)) != 0 ||\n\t\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\t\tgoto out;\n\t\t\tsshbuf_reset(sect);\n\t\t}\n\n\t\t/* If we are starting a new section then prepare it now */\n\t\tif (next_state != state || force_new_sect) {\n\t\t\tKRL_DBG((\"%s: start state 0x%02x\", __func__,\n\t\t\t    next_state));\n\t\t\tstate = next_state;\n\t\t\tsshbuf_reset(sect);\n\t\t\tswitch (state) {\n\t\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\t\tbreak;\n\t\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\t\tif ((bitmap = bitmap_new()) == NULL) {\n\t\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbitmap_start = rs->lo;\n\t\t\t\tif ((r = sshbuf_put_u64(sect,\n\t\t\t\t    bitmap_start)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Perform section-specific processing */\n\t\tswitch (state) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tfor (i = 0; i < contig; i++) {\n\t\t\t\tif ((r = sshbuf_put_u64(sect, rs->lo + i)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tif ((r = sshbuf_put_u64(sect, rs->lo)) != 0 ||\n\t\t\t    (r = sshbuf_put_u64(sect, rs->hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif (rs->lo - bitmap_start > INT_MAX) {\n\t\t\t\terror(\"%s: insane bitmap gap\", __func__);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfor (i = 0; i < contig; i++) {\n\t\t\t\tif (bitmap_set_bit(bitmap,\n\t\t\t\t    rs->lo + i - bitmap_start) != 0) {\n\t\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tlast = rs->hi;\n\t}\n\t/* Flush the remaining section, if any */\n\tif (state != 0) {\n\t\tKRL_DBG((\"%s: serial final flush for state 0x%02x\",\n\t\t    __func__, state));\n\t\tswitch (state) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif ((r = put_bitmap(sect, bitmap)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbitmap_free(bitmap);\n\t\t\tbitmap = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif ((r = sshbuf_put_u8(buf, state)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tKRL_DBG((\"%s: serial done \", __func__));\n\n\t/* Now output a section for any revocations by key ID */\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rki, revoked_key_id_tree, &rc->revoked_key_ids) {\n\t\tKRL_DBG((\"%s: key ID %s\", __func__, rki->key_id));\n\t\tif ((r = sshbuf_put_cstring(sect, rki->key_id)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_CERT_KEY_ID)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\tbitmap_free(bitmap);\n\tsshbuf_free(sect);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH",
          "args": [
            "rc",
            "&krl->revoked_certs",
            "entry"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "buf",
            "krl->comment"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u64",
          "args": [
            "buf",
            "krl->flags"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "299-309",
          "snippet": "int\nsshbuf_put_u64(struct sshbuf *buf, u_int64_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 8, &p)) < 0)\n\t\treturn r;\n\tPOKE_U64(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u64(struct sshbuf *buf, u_int64_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 8, &p)) < 0)\n\t\treturn r;\n\tPOKE_U64(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "buf",
            "KRL_FORMAT_VERSION"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "buf",
            "KRL_MAGIC",
            "sizeof(KRL_MAGIC) - 1"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "parse_cert_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1840-1888",
          "snippet": "static void\nparse_cert_times(char *timespec)\n{\n\tchar *from, *to;\n\ttime_t now = time(NULL);\n\tint64_t secs;\n\n\t/* +timespec relative to now */\n\tif (*timespec == '+' && strchr(timespec, ':') == NULL) {\n\t\tif ((secs = convtime(timespec + 1)) == -1)\n\t\t\tfatal(\"Invalid relative certificate life %s\", timespec);\n\t\tcert_valid_to = now + secs;\n\t\t/*\n\t\t * Backdate certificate one minute to avoid problems on hosts\n\t\t * with poorly-synchronised clocks.\n\t\t */\n\t\tcert_valid_from = ((now - 59)/ 60) * 60;\n\t\treturn;\n\t}\n\n\t/*\n\t * from:to, where\n\t * from := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"always\"\n\t *   to := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"forever\"\n\t */\n\tfrom = xstrdup(timespec);\n\tto = strchr(from, ':');\n\tif (to == NULL || from == to || *(to + 1) == '\\0')\n\t\tfatal(\"Invalid certificate life specification %s\", timespec);\n\t*to++ = '\\0';\n\n\tif (*from == '-' || *from == '+')\n\t\tcert_valid_from = parse_relative_time(from, now);\n\telse if (strcmp(from, \"always\") == 0)\n\t\tcert_valid_from = 0;\n\telse if (parse_absolute_time(from, &cert_valid_from) != 0)\n\t\tfatal(\"Invalid from time \\\"%s\\\"\", from);\n\n\tif (*to == '-' || *to == '+')\n\t\tcert_valid_to = parse_relative_time(to, now);\n\telse if (strcmp(to, \"forever\") == 0)\n\t\tcert_valid_to = ~(u_int64_t)0;\n\telse if (parse_absolute_time(to, &cert_valid_to) != 0)\n\t\tfatal(\"Invalid to time \\\"%s\\\"\", to);\n\n\tif (cert_valid_to <= cert_valid_from)\n\t\tfatal(\"Empty certificate validity interval\");\n\tfree(from);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int64_t cert_valid_from = 0;",
            "u_int64_t cert_valid_to = ~0ULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int64_t cert_valid_from = 0;\nu_int64_t cert_valid_to = ~0ULL;\n\nstatic void\nparse_cert_times(char *timespec)\n{\n\tchar *from, *to;\n\ttime_t now = time(NULL);\n\tint64_t secs;\n\n\t/* +timespec relative to now */\n\tif (*timespec == '+' && strchr(timespec, ':') == NULL) {\n\t\tif ((secs = convtime(timespec + 1)) == -1)\n\t\t\tfatal(\"Invalid relative certificate life %s\", timespec);\n\t\tcert_valid_to = now + secs;\n\t\t/*\n\t\t * Backdate certificate one minute to avoid problems on hosts\n\t\t * with poorly-synchronised clocks.\n\t\t */\n\t\tcert_valid_from = ((now - 59)/ 60) * 60;\n\t\treturn;\n\t}\n\n\t/*\n\t * from:to, where\n\t * from := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"always\"\n\t *   to := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"forever\"\n\t */\n\tfrom = xstrdup(timespec);\n\tto = strchr(from, ':');\n\tif (to == NULL || from == to || *(to + 1) == '\\0')\n\t\tfatal(\"Invalid certificate life specification %s\", timespec);\n\t*to++ = '\\0';\n\n\tif (*from == '-' || *from == '+')\n\t\tcert_valid_from = parse_relative_time(from, now);\n\telse if (strcmp(from, \"always\") == 0)\n\t\tcert_valid_from = 0;\n\telse if (parse_absolute_time(from, &cert_valid_from) != 0)\n\t\tfatal(\"Invalid from time \\\"%s\\\"\", from);\n\n\tif (*to == '-' || *to == '+')\n\t\tcert_valid_to = parse_relative_time(to, now);\n\telse if (strcmp(to, \"forever\") == 0)\n\t\tcert_valid_to = ~(u_int64_t)0;\n\telse if (parse_absolute_time(to, &cert_valid_to) != 0)\n\t\tfatal(\"Invalid to time \\\"%s\\\"\", to);\n\n\tif (cert_valid_to <= cert_valid_from)\n\t\tfatal(\"Empty certificate validity interval\");\n\tfree(from);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_to_blob(struct ssh_krl *krl, struct sshbuf *buf,\n    const struct sshkey **sign_keys, u_int nsign_keys)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct revoked_certs *rc;\n\tstruct revoked_blob *rb;\n\tstruct sshbuf *sect;\n\tu_char *sblob = NULL;\n\tsize_t slen, i;\n\n\tif (krl->generated_date == 0)\n\t\tkrl->generated_date = time(NULL);\n\n\tif ((sect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* Store the header */\n\tif ((r = sshbuf_put(buf, KRL_MAGIC, sizeof(KRL_MAGIC) - 1)) != 0 ||\n\t    (r = sshbuf_put_u32(buf, KRL_FORMAT_VERSION)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->krl_version)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->generated_date)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->flags)) != 0 ||\n\t    (r = sshbuf_put_string(buf, NULL, 0)) != 0 ||\n\t    (r = sshbuf_put_cstring(buf, krl->comment)) != 0)\n\t\tgoto out;\n\n\t/* Store sections for revoked certificates */\n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tsshbuf_reset(sect);\n\t\tif ((r = revoked_certs_generate(rc, sect)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_CERTIFICATES)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Finally, output sections for revocations by public key/hash */\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_keys) {\n\t\tKRL_DBG((\"%s: key len %zu \", __func__, rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_EXPLICIT_KEY)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_sha1s) {\n\t\tKRL_DBG((\"%s: hash len %zu \", __func__, rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf,\n\t\t    KRL_SECTION_FINGERPRINT_SHA1)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_sha256s) {\n\t\tKRL_DBG((\"%s: hash len %zu \", __func__, rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf,\n\t\t    KRL_SECTION_FINGERPRINT_SHA256)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < nsign_keys; i++) {\n\t\tKRL_DBG((\"%s: signature key %s\", __func__,\n\t\t    sshkey_ssh_name(sign_keys[i])));\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_SIGNATURE)) != 0 ||\n\t\t    (r = sshkey_puts(sign_keys[i], buf)) != 0)\n\t\t\tgoto out;\n\n\t\tif ((r = sshkey_sign(sign_keys[i], &sblob, &slen,\n\t\t    sshbuf_ptr(buf), sshbuf_len(buf), NULL, 0)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: signature sig len %zu\", __func__, slen));\n\t\tif ((r = sshbuf_put_string(buf, sblob, slen)) != 0)\n\t\t\tgoto out;\n\t}\n\n\tr = 0;\n out:\n\tfree(sblob);\n\tsshbuf_free(sect);\n\treturn r;\n}"
  },
  {
    "function_name": "revoked_certs_generate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "574-731",
    "snippet": "static int\nrevoked_certs_generate(struct revoked_certs *rc, struct sshbuf *buf)\n{\n\tint final, force_new_sect, r = SSH_ERR_INTERNAL_ERROR;\n\tu_int64_t i, contig, gap, last = 0, bitmap_start = 0;\n\tstruct revoked_serial *rs, *nrs;\n\tstruct revoked_key_id *rki;\n\tint next_state, state = 0;\n\tstruct sshbuf *sect;\n\tstruct bitmap *bitmap = NULL;\n\n\tif ((sect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* Store the header: optional CA scope key, reserved */\n\tif (rc->ca_key == NULL) {\n\t\tif ((r = sshbuf_put_string(buf, NULL, 0)) != 0)\n\t\t\tgoto out;\n\t} else {\n\t\tif ((r = sshkey_puts(rc->ca_key, buf)) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_string(buf, NULL, 0)) != 0)\n\t\tgoto out;\n\n\t/* Store the revoked serials.  */\n\tfor (rs = RB_MIN(revoked_serial_tree, &rc->revoked_serials);\n\t     rs != NULL;\n\t     rs = RB_NEXT(revoked_serial_tree, &rc->revoked_serials, rs)) {\n\t\tKRL_DBG((\"%s: serial %llu:%llu state 0x%02x\", __func__,\n\t\t    (long long unsigned)rs->lo, (long long unsigned)rs->hi,\n\t\t    state));\n\n\t\t/* Check contiguous length and gap to next section (if any) */\n\t\tnrs = RB_NEXT(revoked_serial_tree, &rc->revoked_serials, rs);\n\t\tfinal = nrs == NULL;\n\t\tgap = nrs == NULL ? 0 : nrs->lo - rs->hi;\n\t\tcontig = 1 + (rs->hi - rs->lo);\n\n\t\t/* Choose next state based on these */\n\t\tnext_state = choose_next_state(state, contig, final,\n\t\t    state == 0 ? 0 : rs->lo - last, gap, &force_new_sect);\n\n\t\t/*\n\t\t * If the current section is a range section or has a different\n\t\t * type to the next section, then finish it off now.\n\t\t */\n\t\tif (state != 0 && (force_new_sect || next_state != state ||\n\t\t    state == KRL_SECTION_CERT_SERIAL_RANGE)) {\n\t\t\tKRL_DBG((\"%s: finish state 0x%02x\", __func__, state));\n\t\t\tswitch (state) {\n\t\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\t\tbreak;\n\t\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\t\tif ((r = put_bitmap(sect, bitmap)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbitmap_free(bitmap);\n\t\t\t\tbitmap = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((r = sshbuf_put_u8(buf, state)) != 0 ||\n\t\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\t\tgoto out;\n\t\t\tsshbuf_reset(sect);\n\t\t}\n\n\t\t/* If we are starting a new section then prepare it now */\n\t\tif (next_state != state || force_new_sect) {\n\t\t\tKRL_DBG((\"%s: start state 0x%02x\", __func__,\n\t\t\t    next_state));\n\t\t\tstate = next_state;\n\t\t\tsshbuf_reset(sect);\n\t\t\tswitch (state) {\n\t\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\t\tbreak;\n\t\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\t\tif ((bitmap = bitmap_new()) == NULL) {\n\t\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbitmap_start = rs->lo;\n\t\t\t\tif ((r = sshbuf_put_u64(sect,\n\t\t\t\t    bitmap_start)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Perform section-specific processing */\n\t\tswitch (state) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tfor (i = 0; i < contig; i++) {\n\t\t\t\tif ((r = sshbuf_put_u64(sect, rs->lo + i)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tif ((r = sshbuf_put_u64(sect, rs->lo)) != 0 ||\n\t\t\t    (r = sshbuf_put_u64(sect, rs->hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif (rs->lo - bitmap_start > INT_MAX) {\n\t\t\t\terror(\"%s: insane bitmap gap\", __func__);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfor (i = 0; i < contig; i++) {\n\t\t\t\tif (bitmap_set_bit(bitmap,\n\t\t\t\t    rs->lo + i - bitmap_start) != 0) {\n\t\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tlast = rs->hi;\n\t}\n\t/* Flush the remaining section, if any */\n\tif (state != 0) {\n\t\tKRL_DBG((\"%s: serial final flush for state 0x%02x\",\n\t\t    __func__, state));\n\t\tswitch (state) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif ((r = put_bitmap(sect, bitmap)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbitmap_free(bitmap);\n\t\t\tbitmap = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif ((r = sshbuf_put_u8(buf, state)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tKRL_DBG((\"%s: serial done \", __func__));\n\n\t/* Now output a section for any revocations by key ID */\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rki, revoked_key_id_tree, &rc->revoked_key_ids) {\n\t\tKRL_DBG((\"%s: key ID %s\", __func__, rki->key_id));\n\t\tif ((r = sshbuf_put_cstring(sect, rki->key_id)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_CERT_KEY_ID)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\tbitmap_free(bitmap);\n\tsshbuf_free(sect);\n\treturn r;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "sect"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_free",
          "args": [
            "bitmap"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/bitmap.c",
          "lines": "53-62",
          "snippet": "void\nbitmap_free(struct bitmap *b)\n{\n\tif (b != NULL && b->d != NULL) {\n\t\tbitmap_zero(b);\n\t\tfree(b->d);\n\t\tb->d = NULL;\n\t}\n\tfree(b);\n}",
          "includes": [
            "#include \"bitmap.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitmap.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nbitmap_free(struct bitmap *b)\n{\n\tif (b != NULL && b->d != NULL) {\n\t\tbitmap_zero(b);\n\t\tfree(b->d);\n\t\tb->d = NULL;\n\t}\n\tfree(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "buf",
            "sect"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "buf",
            "KRL_SECTION_CERT_KEY_ID"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "sect"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "sect",
            "rki->key_id"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: key ID %s\", __func__, rki->key_id)"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_FOREACH",
          "args": [
            "rki",
            "revoked_key_id_tree",
            "&rc->revoked_key_ids"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "sect"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: serial done \", __func__)"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bitmap",
          "args": [
            "sect",
            "bitmap"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "put_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "554-571",
          "snippet": "static int\nput_bitmap(struct sshbuf *buf, struct bitmap *bitmap)\n{\n\tsize_t len;\n\tu_char *blob;\n\tint r;\n\n\tlen = bitmap_nbytes(bitmap);\n\tif ((blob = malloc(len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (bitmap_to_string(bitmap, blob, len) != 0) {\n\t\tfree(blob);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tr = sshbuf_put_bignum2_bytes(buf, blob, len);\n\tfree(blob);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nput_bitmap(struct sshbuf *buf, struct bitmap *bitmap)\n{\n\tsize_t len;\n\tu_char *blob;\n\tint r;\n\n\tlen = bitmap_nbytes(bitmap);\n\tif ((blob = malloc(len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (bitmap_to_string(bitmap, blob, len) != 0) {\n\t\tfree(blob);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tr = sshbuf_put_bignum2_bytes(buf, blob, len);\n\tfree(blob);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: serial final flush for state 0x%02x\",\n\t\t    __func__, state)"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_set_bit",
          "args": [
            "bitmap",
            "rs->lo + i - bitmap_start"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/bitmap.c",
          "lines": "100-113",
          "snippet": "int\nbitmap_set_bit(struct bitmap *b, u_int n)\n{\n\tint r;\n\tsize_t offset;\n\n\tif ((r = reserve(b, n)) != 0)\n\t\treturn r;\n\toffset = n / BITMAP_BITS;\n\tif (offset > b->top)\n\t\tb->top = offset;\n\tb->d[offset] |= (BITMAP_WTYPE)1 << (n & BITMAP_WMASK);\n\treturn 0;\n}",
          "includes": [
            "#include \"bitmap.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define BITMAP_WMASK\t((BITMAP_WTYPE)BITMAP_BITS - 1)",
            "#define BITMAP_BITS\t(sizeof(BITMAP_WTYPE) * 8)",
            "#define BITMAP_WTYPE\tu_int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitmap.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BITMAP_WMASK\t((BITMAP_WTYPE)BITMAP_BITS - 1)\n#define BITMAP_BITS\t(sizeof(BITMAP_WTYPE) * 8)\n#define BITMAP_WTYPE\tu_int\n\nint\nbitmap_set_bit(struct bitmap *b, u_int n)\n{\n\tint r;\n\tsize_t offset;\n\n\tif ((r = reserve(b, n)) != 0)\n\t\treturn r;\n\toffset = n / BITMAP_BITS;\n\tif (offset > b->top)\n\t\tb->top = offset;\n\tb->d[offset] |= (BITMAP_WTYPE)1 << (n & BITMAP_WMASK);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: insane bitmap gap\"",
            "__func__"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u64",
          "args": [
            "sect",
            "rs->hi"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "299-309",
          "snippet": "int\nsshbuf_put_u64(struct sshbuf *buf, u_int64_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 8, &p)) < 0)\n\t\treturn r;\n\tPOKE_U64(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u64(struct sshbuf *buf, u_int64_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 8, &p)) < 0)\n\t\treturn r;\n\tPOKE_U64(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_new",
          "args": [],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/bitmap.c",
          "lines": "37-51",
          "snippet": "struct bitmap *\nbitmap_new(void)\n{\n\tstruct bitmap *ret;\n\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL)\n\t\treturn NULL;\n\tif ((ret->d = calloc(1, BITMAP_BYTES)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret->len = 1;\n\tret->top = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"bitmap.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define BITMAP_BYTES\t(sizeof(BITMAP_WTYPE))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitmap.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BITMAP_BYTES\t(sizeof(BITMAP_WTYPE))\n\nstruct bitmap *\nbitmap_new(void)\n{\n\tstruct bitmap *ret;\n\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL)\n\t\treturn NULL;\n\tif ((ret->d = calloc(1, BITMAP_BYTES)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret->len = 1;\n\tret->top = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: start state 0x%02x\", __func__,\n\t\t\t    next_state)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: finish state 0x%02x\", __func__, state)"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "choose_next_state",
          "args": [
            "state",
            "contig",
            "final",
            "state == 0 ? 0 : rs->lo - last",
            "gap",
            "&force_new_sect"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "choose_next_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "478-552",
          "snippet": "static int\nchoose_next_state(int current_state, u_int64_t contig, int final,\n    u_int64_t last_gap, u_int64_t next_gap, int *force_new_section)\n{\n\tint new_state;\n\tu_int64_t cost, cost_list, cost_range, cost_bitmap, cost_bitmap_restart;\n\n\t/*\n\t * Avoid unsigned overflows.\n\t * The limits are high enough to avoid confusing the calculations.\n\t */\n\tcontig = MINIMUM(contig, 1ULL<<31);\n\tlast_gap = MINIMUM(last_gap, 1ULL<<31);\n\tnext_gap = MINIMUM(next_gap, 1ULL<<31);\n\n\t/*\n\t * Calculate the cost to switch from the current state to candidates.\n\t * NB. range sections only ever contain a single range, so their\n\t * switching cost is independent of the current_state.\n\t */\n\tcost_list = cost_bitmap = cost_bitmap_restart = 0;\n\tcost_range = 8;\n\tswitch (current_state) {\n\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\tcost_bitmap_restart = cost_bitmap = 8 + 64;\n\t\tbreak;\n\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\tcost_list = 8;\n\t\tcost_bitmap_restart = 8 + 64;\n\t\tbreak;\n\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\tcase 0:\n\t\tcost_bitmap_restart = cost_bitmap = 8 + 64;\n\t\tcost_list = 8;\n\t}\n\n\t/* Estimate base cost in bits of each section type */\n\tcost_list += 64 * contig + (final ? 0 : 8+64);\n\tcost_range += (2 * 64) + (final ? 0 : 8+64);\n\tcost_bitmap += last_gap + contig + (final ? 0 : MINIMUM(next_gap, 8+64));\n\tcost_bitmap_restart += contig + (final ? 0 : MINIMUM(next_gap, 8+64));\n\n\t/* Convert to byte costs for actual comparison */\n\tcost_list = (cost_list + 7) / 8;\n\tcost_bitmap = (cost_bitmap + 7) / 8;\n\tcost_bitmap_restart = (cost_bitmap_restart + 7) / 8;\n\tcost_range = (cost_range + 7) / 8;\n\n\t/* Now pick the best choice */\n\t*force_new_section = 0;\n\tnew_state = KRL_SECTION_CERT_SERIAL_BITMAP;\n\tcost = cost_bitmap;\n\tif (cost_range < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_RANGE;\n\t\tcost = cost_range;\n\t}\n\tif (cost_list < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_LIST;\n\t\tcost = cost_list;\n\t}\n\tif (cost_bitmap_restart < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_BITMAP;\n\t\t*force_new_section = 1;\n\t\tcost = cost_bitmap_restart;\n\t}\n\tKRL_DBG((\"%s: contig %llu last_gap %llu next_gap %llu final %d, costs:\"\n\t    \"list %llu range %llu bitmap %llu new bitmap %llu, \"\n\t    \"selected 0x%02x%s\", __func__, (long long unsigned)contig,\n\t    (long long unsigned)last_gap, (long long unsigned)next_gap, final,\n\t    (long long unsigned)cost_list, (long long unsigned)cost_range,\n\t    (long long unsigned)cost_bitmap,\n\t    (long long unsigned)cost_bitmap_restart, new_state,\n\t    *force_new_section ? \" restart\" : \"\"));\n\treturn new_state;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nchoose_next_state(int current_state, u_int64_t contig, int final,\n    u_int64_t last_gap, u_int64_t next_gap, int *force_new_section)\n{\n\tint new_state;\n\tu_int64_t cost, cost_list, cost_range, cost_bitmap, cost_bitmap_restart;\n\n\t/*\n\t * Avoid unsigned overflows.\n\t * The limits are high enough to avoid confusing the calculations.\n\t */\n\tcontig = MINIMUM(contig, 1ULL<<31);\n\tlast_gap = MINIMUM(last_gap, 1ULL<<31);\n\tnext_gap = MINIMUM(next_gap, 1ULL<<31);\n\n\t/*\n\t * Calculate the cost to switch from the current state to candidates.\n\t * NB. range sections only ever contain a single range, so their\n\t * switching cost is independent of the current_state.\n\t */\n\tcost_list = cost_bitmap = cost_bitmap_restart = 0;\n\tcost_range = 8;\n\tswitch (current_state) {\n\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\tcost_bitmap_restart = cost_bitmap = 8 + 64;\n\t\tbreak;\n\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\tcost_list = 8;\n\t\tcost_bitmap_restart = 8 + 64;\n\t\tbreak;\n\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\tcase 0:\n\t\tcost_bitmap_restart = cost_bitmap = 8 + 64;\n\t\tcost_list = 8;\n\t}\n\n\t/* Estimate base cost in bits of each section type */\n\tcost_list += 64 * contig + (final ? 0 : 8+64);\n\tcost_range += (2 * 64) + (final ? 0 : 8+64);\n\tcost_bitmap += last_gap + contig + (final ? 0 : MINIMUM(next_gap, 8+64));\n\tcost_bitmap_restart += contig + (final ? 0 : MINIMUM(next_gap, 8+64));\n\n\t/* Convert to byte costs for actual comparison */\n\tcost_list = (cost_list + 7) / 8;\n\tcost_bitmap = (cost_bitmap + 7) / 8;\n\tcost_bitmap_restart = (cost_bitmap_restart + 7) / 8;\n\tcost_range = (cost_range + 7) / 8;\n\n\t/* Now pick the best choice */\n\t*force_new_section = 0;\n\tnew_state = KRL_SECTION_CERT_SERIAL_BITMAP;\n\tcost = cost_bitmap;\n\tif (cost_range < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_RANGE;\n\t\tcost = cost_range;\n\t}\n\tif (cost_list < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_LIST;\n\t\tcost = cost_list;\n\t}\n\tif (cost_bitmap_restart < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_BITMAP;\n\t\t*force_new_section = 1;\n\t\tcost = cost_bitmap_restart;\n\t}\n\tKRL_DBG((\"%s: contig %llu last_gap %llu next_gap %llu final %d, costs:\"\n\t    \"list %llu range %llu bitmap %llu new bitmap %llu, \"\n\t    \"selected 0x%02x%s\", __func__, (long long unsigned)contig,\n\t    (long long unsigned)last_gap, (long long unsigned)next_gap, final,\n\t    (long long unsigned)cost_list, (long long unsigned)cost_range,\n\t    (long long unsigned)cost_bitmap,\n\t    (long long unsigned)cost_bitmap_restart, new_state,\n\t    *force_new_section ? \" restart\" : \"\"));\n\treturn new_state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_NEXT",
          "args": [
            "revoked_serial_tree",
            "&rc->revoked_serials",
            "rs"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: serial %llu:%llu state 0x%02x\", __func__,\n\t\t    (long long unsigned)rs->lo, (long long unsigned)rs->hi,\n\t\t    state)"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_NEXT",
          "args": [
            "revoked_serial_tree",
            "&rc->revoked_serials",
            "rs"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_MIN",
          "args": [
            "revoked_serial_tree",
            "&rc->revoked_serials"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "buf",
            "NULL",
            "0"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_puts",
          "args": [
            "rc->ca_key",
            "buf"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "836-840",
          "snippet": "int\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrevoked_certs_generate(struct revoked_certs *rc, struct sshbuf *buf)\n{\n\tint final, force_new_sect, r = SSH_ERR_INTERNAL_ERROR;\n\tu_int64_t i, contig, gap, last = 0, bitmap_start = 0;\n\tstruct revoked_serial *rs, *nrs;\n\tstruct revoked_key_id *rki;\n\tint next_state, state = 0;\n\tstruct sshbuf *sect;\n\tstruct bitmap *bitmap = NULL;\n\n\tif ((sect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* Store the header: optional CA scope key, reserved */\n\tif (rc->ca_key == NULL) {\n\t\tif ((r = sshbuf_put_string(buf, NULL, 0)) != 0)\n\t\t\tgoto out;\n\t} else {\n\t\tif ((r = sshkey_puts(rc->ca_key, buf)) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_string(buf, NULL, 0)) != 0)\n\t\tgoto out;\n\n\t/* Store the revoked serials.  */\n\tfor (rs = RB_MIN(revoked_serial_tree, &rc->revoked_serials);\n\t     rs != NULL;\n\t     rs = RB_NEXT(revoked_serial_tree, &rc->revoked_serials, rs)) {\n\t\tKRL_DBG((\"%s: serial %llu:%llu state 0x%02x\", __func__,\n\t\t    (long long unsigned)rs->lo, (long long unsigned)rs->hi,\n\t\t    state));\n\n\t\t/* Check contiguous length and gap to next section (if any) */\n\t\tnrs = RB_NEXT(revoked_serial_tree, &rc->revoked_serials, rs);\n\t\tfinal = nrs == NULL;\n\t\tgap = nrs == NULL ? 0 : nrs->lo - rs->hi;\n\t\tcontig = 1 + (rs->hi - rs->lo);\n\n\t\t/* Choose next state based on these */\n\t\tnext_state = choose_next_state(state, contig, final,\n\t\t    state == 0 ? 0 : rs->lo - last, gap, &force_new_sect);\n\n\t\t/*\n\t\t * If the current section is a range section or has a different\n\t\t * type to the next section, then finish it off now.\n\t\t */\n\t\tif (state != 0 && (force_new_sect || next_state != state ||\n\t\t    state == KRL_SECTION_CERT_SERIAL_RANGE)) {\n\t\t\tKRL_DBG((\"%s: finish state 0x%02x\", __func__, state));\n\t\t\tswitch (state) {\n\t\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\t\tbreak;\n\t\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\t\tif ((r = put_bitmap(sect, bitmap)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbitmap_free(bitmap);\n\t\t\t\tbitmap = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((r = sshbuf_put_u8(buf, state)) != 0 ||\n\t\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\t\tgoto out;\n\t\t\tsshbuf_reset(sect);\n\t\t}\n\n\t\t/* If we are starting a new section then prepare it now */\n\t\tif (next_state != state || force_new_sect) {\n\t\t\tKRL_DBG((\"%s: start state 0x%02x\", __func__,\n\t\t\t    next_state));\n\t\t\tstate = next_state;\n\t\t\tsshbuf_reset(sect);\n\t\t\tswitch (state) {\n\t\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\t\tbreak;\n\t\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\t\tif ((bitmap = bitmap_new()) == NULL) {\n\t\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbitmap_start = rs->lo;\n\t\t\t\tif ((r = sshbuf_put_u64(sect,\n\t\t\t\t    bitmap_start)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Perform section-specific processing */\n\t\tswitch (state) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tfor (i = 0; i < contig; i++) {\n\t\t\t\tif ((r = sshbuf_put_u64(sect, rs->lo + i)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tif ((r = sshbuf_put_u64(sect, rs->lo)) != 0 ||\n\t\t\t    (r = sshbuf_put_u64(sect, rs->hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif (rs->lo - bitmap_start > INT_MAX) {\n\t\t\t\terror(\"%s: insane bitmap gap\", __func__);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfor (i = 0; i < contig; i++) {\n\t\t\t\tif (bitmap_set_bit(bitmap,\n\t\t\t\t    rs->lo + i - bitmap_start) != 0) {\n\t\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tlast = rs->hi;\n\t}\n\t/* Flush the remaining section, if any */\n\tif (state != 0) {\n\t\tKRL_DBG((\"%s: serial final flush for state 0x%02x\",\n\t\t    __func__, state));\n\t\tswitch (state) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif ((r = put_bitmap(sect, bitmap)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbitmap_free(bitmap);\n\t\t\tbitmap = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif ((r = sshbuf_put_u8(buf, state)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tKRL_DBG((\"%s: serial done \", __func__));\n\n\t/* Now output a section for any revocations by key ID */\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rki, revoked_key_id_tree, &rc->revoked_key_ids) {\n\t\tKRL_DBG((\"%s: key ID %s\", __func__, rki->key_id));\n\t\tif ((r = sshbuf_put_cstring(sect, rki->key_id)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_CERT_KEY_ID)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\tbitmap_free(bitmap);\n\tsshbuf_free(sect);\n\treturn r;\n}"
  },
  {
    "function_name": "put_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "554-571",
    "snippet": "static int\nput_bitmap(struct sshbuf *buf, struct bitmap *bitmap)\n{\n\tsize_t len;\n\tu_char *blob;\n\tint r;\n\n\tlen = bitmap_nbytes(bitmap);\n\tif ((blob = malloc(len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (bitmap_to_string(bitmap, blob, len) != 0) {\n\t\tfree(blob);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tr = sshbuf_put_bignum2_bytes(buf, blob, len);\n\tfree(blob);\n\treturn r;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "blob"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_bignum2_bytes",
          "args": [
            "buf",
            "blob",
            "len"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_bignum2_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "401-428",
          "snippet": "int\nsshbuf_put_bignum2_bytes(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tconst u_char *s = (const u_char *)v;\n\tint r, prepend;\n\n\tif (len > SSHBUF_SIZE_MAX - 5) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\t/* Skip leading zero bytes */\n\tfor (; len > 0 && *s == 0; len--, s++)\n\t\t;\n\t/*\n\t * If most significant bit is set then prepend a zero byte to\n\t * avoid interpretation as a negative number.\n\t */\n\tprepend = len > 0 && (s[0] & 0x80) != 0;\n\tif ((r = sshbuf_reserve(buf, len + 4 + prepend, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len + prepend);\n\tif (prepend)\n\t\td[4] = 0;\n\tif (len != 0)\n\t\tmemcpy(d + 4 + prepend, s, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_bignum2_bytes(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tconst u_char *s = (const u_char *)v;\n\tint r, prepend;\n\n\tif (len > SSHBUF_SIZE_MAX - 5) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\t/* Skip leading zero bytes */\n\tfor (; len > 0 && *s == 0; len--, s++)\n\t\t;\n\t/*\n\t * If most significant bit is set then prepend a zero byte to\n\t * avoid interpretation as a negative number.\n\t */\n\tprepend = len > 0 && (s[0] & 0x80) != 0;\n\tif ((r = sshbuf_reserve(buf, len + 4 + prepend, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len + prepend);\n\tif (prepend)\n\t\td[4] = 0;\n\tif (len != 0)\n\t\tmemcpy(d + 4 + prepend, s, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_to_string",
          "args": [
            "bitmap",
            "blob",
            "len"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/bitmap.c",
          "lines": "167-186",
          "snippet": "int\nbitmap_to_string(struct bitmap *b, void *p, size_t l)\n{\n\tu_char *s = (u_char *)p;\n\tsize_t i, j, k, need = bitmap_nbytes(b);\n\n\tif (l < need || b->top >= b->len)\n\t\treturn -1;\n\tif (l > need)\n\t\tl = need;\n\t/* Put the bytes from LSB backwards */\n\tfor (i = k = 0; i < b->top + 1; i++) {\n\t\tfor (j = 0; j < BITMAP_BYTES; j++) {\n\t\t\tif (k >= l)\n\t\t\t\tbreak;\n\t\t\ts[need - 1 - k++] = (b->d[i] >> (j * 8)) & 0xff;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"bitmap.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define BITMAP_BYTES\t(sizeof(BITMAP_WTYPE))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitmap.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BITMAP_BYTES\t(sizeof(BITMAP_WTYPE))\n\nint\nbitmap_to_string(struct bitmap *b, void *p, size_t l)\n{\n\tu_char *s = (u_char *)p;\n\tsize_t i, j, k, need = bitmap_nbytes(b);\n\n\tif (l < need || b->top >= b->len)\n\t\treturn -1;\n\tif (l > need)\n\t\tl = need;\n\t/* Put the bytes from LSB backwards */\n\tfor (i = k = 0; i < b->top + 1; i++) {\n\t\tfor (j = 0; j < BITMAP_BYTES; j++) {\n\t\t\tif (k >= l)\n\t\t\t\tbreak;\n\t\t\ts[need - 1 - k++] = (b->d[i] >> (j * 8)) & 0xff;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_nbytes",
          "args": [
            "bitmap"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_nbytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/bitmap.c",
          "lines": "161-165",
          "snippet": "size_t\nbitmap_nbytes(struct bitmap *b)\n{\n\treturn (bitmap_nbits(b) + 7) / 8;\n}",
          "includes": [
            "#include \"bitmap.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitmap.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nbitmap_nbytes(struct bitmap *b)\n{\n\treturn (bitmap_nbits(b) + 7) / 8;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nput_bitmap(struct sshbuf *buf, struct bitmap *bitmap)\n{\n\tsize_t len;\n\tu_char *blob;\n\tint r;\n\n\tlen = bitmap_nbytes(bitmap);\n\tif ((blob = malloc(len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (bitmap_to_string(bitmap, blob, len) != 0) {\n\t\tfree(blob);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tr = sshbuf_put_bignum2_bytes(buf, blob, len);\n\tfree(blob);\n\treturn r;\n}"
  },
  {
    "function_name": "choose_next_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "478-552",
    "snippet": "static int\nchoose_next_state(int current_state, u_int64_t contig, int final,\n    u_int64_t last_gap, u_int64_t next_gap, int *force_new_section)\n{\n\tint new_state;\n\tu_int64_t cost, cost_list, cost_range, cost_bitmap, cost_bitmap_restart;\n\n\t/*\n\t * Avoid unsigned overflows.\n\t * The limits are high enough to avoid confusing the calculations.\n\t */\n\tcontig = MINIMUM(contig, 1ULL<<31);\n\tlast_gap = MINIMUM(last_gap, 1ULL<<31);\n\tnext_gap = MINIMUM(next_gap, 1ULL<<31);\n\n\t/*\n\t * Calculate the cost to switch from the current state to candidates.\n\t * NB. range sections only ever contain a single range, so their\n\t * switching cost is independent of the current_state.\n\t */\n\tcost_list = cost_bitmap = cost_bitmap_restart = 0;\n\tcost_range = 8;\n\tswitch (current_state) {\n\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\tcost_bitmap_restart = cost_bitmap = 8 + 64;\n\t\tbreak;\n\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\tcost_list = 8;\n\t\tcost_bitmap_restart = 8 + 64;\n\t\tbreak;\n\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\tcase 0:\n\t\tcost_bitmap_restart = cost_bitmap = 8 + 64;\n\t\tcost_list = 8;\n\t}\n\n\t/* Estimate base cost in bits of each section type */\n\tcost_list += 64 * contig + (final ? 0 : 8+64);\n\tcost_range += (2 * 64) + (final ? 0 : 8+64);\n\tcost_bitmap += last_gap + contig + (final ? 0 : MINIMUM(next_gap, 8+64));\n\tcost_bitmap_restart += contig + (final ? 0 : MINIMUM(next_gap, 8+64));\n\n\t/* Convert to byte costs for actual comparison */\n\tcost_list = (cost_list + 7) / 8;\n\tcost_bitmap = (cost_bitmap + 7) / 8;\n\tcost_bitmap_restart = (cost_bitmap_restart + 7) / 8;\n\tcost_range = (cost_range + 7) / 8;\n\n\t/* Now pick the best choice */\n\t*force_new_section = 0;\n\tnew_state = KRL_SECTION_CERT_SERIAL_BITMAP;\n\tcost = cost_bitmap;\n\tif (cost_range < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_RANGE;\n\t\tcost = cost_range;\n\t}\n\tif (cost_list < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_LIST;\n\t\tcost = cost_list;\n\t}\n\tif (cost_bitmap_restart < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_BITMAP;\n\t\t*force_new_section = 1;\n\t\tcost = cost_bitmap_restart;\n\t}\n\tKRL_DBG((\"%s: contig %llu last_gap %llu next_gap %llu final %d, costs:\"\n\t    \"list %llu range %llu bitmap %llu new bitmap %llu, \"\n\t    \"selected 0x%02x%s\", __func__, (long long unsigned)contig,\n\t    (long long unsigned)last_gap, (long long unsigned)next_gap, final,\n\t    (long long unsigned)cost_list, (long long unsigned)cost_range,\n\t    (long long unsigned)cost_bitmap,\n\t    (long long unsigned)cost_bitmap_restart, new_state,\n\t    *force_new_section ? \" restart\" : \"\"));\n\treturn new_state;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: contig %llu last_gap %llu next_gap %llu final %d, costs:\"\n\t    \"list %llu range %llu bitmap %llu new bitmap %llu, \"\n\t    \"selected 0x%02x%s\", __func__, (long long unsigned)contig,\n\t    (long long unsigned)last_gap, (long long unsigned)next_gap, final,\n\t    (long long unsigned)cost_list, (long long unsigned)cost_range,\n\t    (long long unsigned)cost_bitmap,\n\t    (long long unsigned)cost_bitmap_restart, new_state,\n\t    *force_new_section ? \" restart\" : \"\")"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "next_gap",
            "8+64"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "next_gap",
            "8+64"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "next_gap",
            "1ULL<<31"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "last_gap",
            "1ULL<<31"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "contig",
            "1ULL<<31"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nchoose_next_state(int current_state, u_int64_t contig, int final,\n    u_int64_t last_gap, u_int64_t next_gap, int *force_new_section)\n{\n\tint new_state;\n\tu_int64_t cost, cost_list, cost_range, cost_bitmap, cost_bitmap_restart;\n\n\t/*\n\t * Avoid unsigned overflows.\n\t * The limits are high enough to avoid confusing the calculations.\n\t */\n\tcontig = MINIMUM(contig, 1ULL<<31);\n\tlast_gap = MINIMUM(last_gap, 1ULL<<31);\n\tnext_gap = MINIMUM(next_gap, 1ULL<<31);\n\n\t/*\n\t * Calculate the cost to switch from the current state to candidates.\n\t * NB. range sections only ever contain a single range, so their\n\t * switching cost is independent of the current_state.\n\t */\n\tcost_list = cost_bitmap = cost_bitmap_restart = 0;\n\tcost_range = 8;\n\tswitch (current_state) {\n\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\tcost_bitmap_restart = cost_bitmap = 8 + 64;\n\t\tbreak;\n\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\tcost_list = 8;\n\t\tcost_bitmap_restart = 8 + 64;\n\t\tbreak;\n\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\tcase 0:\n\t\tcost_bitmap_restart = cost_bitmap = 8 + 64;\n\t\tcost_list = 8;\n\t}\n\n\t/* Estimate base cost in bits of each section type */\n\tcost_list += 64 * contig + (final ? 0 : 8+64);\n\tcost_range += (2 * 64) + (final ? 0 : 8+64);\n\tcost_bitmap += last_gap + contig + (final ? 0 : MINIMUM(next_gap, 8+64));\n\tcost_bitmap_restart += contig + (final ? 0 : MINIMUM(next_gap, 8+64));\n\n\t/* Convert to byte costs for actual comparison */\n\tcost_list = (cost_list + 7) / 8;\n\tcost_bitmap = (cost_bitmap + 7) / 8;\n\tcost_bitmap_restart = (cost_bitmap_restart + 7) / 8;\n\tcost_range = (cost_range + 7) / 8;\n\n\t/* Now pick the best choice */\n\t*force_new_section = 0;\n\tnew_state = KRL_SECTION_CERT_SERIAL_BITMAP;\n\tcost = cost_bitmap;\n\tif (cost_range < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_RANGE;\n\t\tcost = cost_range;\n\t}\n\tif (cost_list < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_LIST;\n\t\tcost = cost_list;\n\t}\n\tif (cost_bitmap_restart < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_BITMAP;\n\t\t*force_new_section = 1;\n\t\tcost = cost_bitmap_restart;\n\t}\n\tKRL_DBG((\"%s: contig %llu last_gap %llu next_gap %llu final %d, costs:\"\n\t    \"list %llu range %llu bitmap %llu new bitmap %llu, \"\n\t    \"selected 0x%02x%s\", __func__, (long long unsigned)contig,\n\t    (long long unsigned)last_gap, (long long unsigned)next_gap, final,\n\t    (long long unsigned)cost_list, (long long unsigned)cost_range,\n\t    (long long unsigned)cost_bitmap,\n\t    (long long unsigned)cost_bitmap_restart, new_state,\n\t    *force_new_section ? \" restart\" : \"\"));\n\treturn new_state;\n}"
  },
  {
    "function_name": "ssh_krl_revoke_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "453-469",
    "snippet": "int\nssh_krl_revoke_key(struct ssh_krl *krl, const struct sshkey *key)\n{\n\t/* XXX replace with SHA256? */\n\tif (!sshkey_is_cert(key))\n\t\treturn ssh_krl_revoke_key_explicit(krl, key);\n\n\tif (key->cert->serial == 0) {\n\t\treturn ssh_krl_revoke_cert_by_key_id(krl,\n\t\t    key->cert->signature_key,\n\t\t    key->cert->key_id);\n\t} else {\n\t\treturn ssh_krl_revoke_cert_by_serial(krl,\n\t\t    key->cert->signature_key,\n\t\t    key->cert->serial);\n\t}\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_krl_revoke_cert_by_serial",
          "args": [
            "krl",
            "key->cert->signature_key",
            "key->cert->serial"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_revoke_cert_by_serial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "321-326",
          "snippet": "int\nssh_krl_revoke_cert_by_serial(struct ssh_krl *krl, const struct sshkey *ca_key,\n    u_int64_t serial)\n{\n\treturn ssh_krl_revoke_cert_by_serial_range(krl, ca_key, serial, serial);\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_cert_by_serial(struct ssh_krl *krl, const struct sshkey *ca_key,\n    u_int64_t serial)\n{\n\treturn ssh_krl_revoke_cert_by_serial_range(krl, ca_key, serial, serial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_revoke_cert_by_key_id",
          "args": [
            "krl",
            "key->cert->signature_key",
            "key->cert->key_id"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_revoke_cert_by_key_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "342-365",
          "snippet": "int\nssh_krl_revoke_cert_by_key_id(struct ssh_krl *krl, const struct sshkey *ca_key,\n    const char *key_id)\n{\n\tstruct revoked_key_id *rki, *erki;\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\n\tKRL_DBG((\"%s: revoke %s\", __func__, key_id));\n\tif ((rki = calloc(1, sizeof(*rki))) == NULL ||\n\t    (rki->key_id = strdup(key_id)) == NULL) {\n\t\tfree(rki);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\terki = RB_INSERT(revoked_key_id_tree, &rc->revoked_key_ids, rki);\n\tif (erki != NULL) {\n\t\tfree(rki->key_id);\n\t\tfree(rki);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_cert_by_key_id(struct ssh_krl *krl, const struct sshkey *ca_key,\n    const char *key_id)\n{\n\tstruct revoked_key_id *rki, *erki;\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\n\tKRL_DBG((\"%s: revoke %s\", __func__, key_id));\n\tif ((rki = calloc(1, sizeof(*rki))) == NULL ||\n\t    (rki->key_id = strdup(key_id)) == NULL) {\n\t\tfree(rki);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\terki = RB_INSERT(revoked_key_id_tree, &rc->revoked_key_ids, rki);\n\tif (erki != NULL) {\n\t\tfree(rki->key_id);\n\t\tfree(rki);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_revoke_key_explicit",
          "args": [
            "krl",
            "key"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_revoke_key_explicit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "405-416",
          "snippet": "int\nssh_krl_revoke_key_explicit(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tu_char *blob;\n\tsize_t len;\n\tint r;\n\n\tdebug3(\"%s: revoke type %s\", __func__, sshkey_type(key));\n\tif ((r = plain_key_blob(key, &blob, &len)) != 0)\n\t\treturn r;\n\treturn revoke_blob(&krl->revoked_keys, blob, len);\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_key_explicit(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tu_char *blob;\n\tsize_t len;\n\tint r;\n\n\tdebug3(\"%s: revoke type %s\", __func__, sshkey_type(key));\n\tif ((r = plain_key_blob(key, &blob, &len)) != 0)\n\t\treturn r;\n\treturn revoke_blob(&krl->revoked_keys, blob, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_key(struct ssh_krl *krl, const struct sshkey *key)\n{\n\t/* XXX replace with SHA256? */\n\tif (!sshkey_is_cert(key))\n\t\treturn ssh_krl_revoke_key_explicit(krl, key);\n\n\tif (key->cert->serial == 0) {\n\t\treturn ssh_krl_revoke_cert_by_key_id(krl,\n\t\t    key->cert->signature_key,\n\t\t    key->cert->key_id);\n\t} else {\n\t\treturn ssh_krl_revoke_cert_by_serial(krl,\n\t\t    key->cert->signature_key,\n\t\t    key->cert->serial);\n\t}\n}"
  },
  {
    "function_name": "ssh_krl_revoke_key_sha256",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "444-451",
    "snippet": "int\nssh_krl_revoke_key_sha256(struct ssh_krl *krl, const u_char *p, size_t len)\n{\n\tdebug3(\"%s: revoke by sha256\", __func__);\n\tif (len != 32)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn revoke_by_hash(&krl->revoked_sha256s, p, len);\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "revoke_by_hash",
          "args": [
            "&krl->revoked_sha256s",
            "p",
            "len"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "revoke_by_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "418-433",
          "snippet": "static int\nrevoke_by_hash(struct revoked_blob_tree *target, const u_char *p, size_t len)\n{\n\tu_char *blob;\n\tint r;\n\n\t/* need to copy hash, as revoke_blob steals ownership */\n\tif ((blob = malloc(len)) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tmemcpy(blob, p, len);\n\tif ((r = revoke_blob(target, blob, len)) != 0) {\n\t\tfree(blob);\n\t\treturn r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrevoke_by_hash(struct revoked_blob_tree *target, const u_char *p, size_t len)\n{\n\tu_char *blob;\n\tint r;\n\n\t/* need to copy hash, as revoke_blob steals ownership */\n\tif ((blob = malloc(len)) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tmemcpy(blob, p, len);\n\tif ((r = revoke_blob(target, blob, len)) != 0) {\n\t\tfree(blob);\n\t\treturn r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: revoke by sha256\"",
            "__func__"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_key_sha256(struct ssh_krl *krl, const u_char *p, size_t len)\n{\n\tdebug3(\"%s: revoke by sha256\", __func__);\n\tif (len != 32)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn revoke_by_hash(&krl->revoked_sha256s, p, len);\n}"
  },
  {
    "function_name": "ssh_krl_revoke_key_sha1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "435-442",
    "snippet": "int\nssh_krl_revoke_key_sha1(struct ssh_krl *krl, const u_char *p, size_t len)\n{\n\tdebug3(\"%s: revoke by sha1\", __func__);\n\tif (len != 20)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn revoke_by_hash(&krl->revoked_sha1s, p, len);\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "revoke_by_hash",
          "args": [
            "&krl->revoked_sha1s",
            "p",
            "len"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "revoke_by_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "418-433",
          "snippet": "static int\nrevoke_by_hash(struct revoked_blob_tree *target, const u_char *p, size_t len)\n{\n\tu_char *blob;\n\tint r;\n\n\t/* need to copy hash, as revoke_blob steals ownership */\n\tif ((blob = malloc(len)) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tmemcpy(blob, p, len);\n\tif ((r = revoke_blob(target, blob, len)) != 0) {\n\t\tfree(blob);\n\t\treturn r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrevoke_by_hash(struct revoked_blob_tree *target, const u_char *p, size_t len)\n{\n\tu_char *blob;\n\tint r;\n\n\t/* need to copy hash, as revoke_blob steals ownership */\n\tif ((blob = malloc(len)) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tmemcpy(blob, p, len);\n\tif ((r = revoke_blob(target, blob, len)) != 0) {\n\t\tfree(blob);\n\t\treturn r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: revoke by sha1\"",
            "__func__"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_key_sha1(struct ssh_krl *krl, const u_char *p, size_t len)\n{\n\tdebug3(\"%s: revoke by sha1\", __func__);\n\tif (len != 20)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn revoke_by_hash(&krl->revoked_sha1s, p, len);\n}"
  },
  {
    "function_name": "revoke_by_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "418-433",
    "snippet": "static int\nrevoke_by_hash(struct revoked_blob_tree *target, const u_char *p, size_t len)\n{\n\tu_char *blob;\n\tint r;\n\n\t/* need to copy hash, as revoke_blob steals ownership */\n\tif ((blob = malloc(len)) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tmemcpy(blob, p, len);\n\tif ((r = revoke_blob(target, blob, len)) != 0) {\n\t\tfree(blob);\n\t\treturn r;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "blob"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "revoke_blob",
          "args": [
            "target",
            "blob",
            "len"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "revoke_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "388-403",
          "snippet": "static int\nrevoke_blob(struct revoked_blob_tree *rbt, u_char *blob, size_t len)\n{\n\tstruct revoked_blob *rb, *erb;\n\n\tif ((rb = calloc(1, sizeof(*rb))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\trb->blob = blob;\n\trb->len = len;\n\terb = RB_INSERT(revoked_blob_tree, rbt, rb);\n\tif (erb != NULL) {\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrevoke_blob(struct revoked_blob_tree *rbt, u_char *blob, size_t len)\n{\n\tstruct revoked_blob *rb, *erb;\n\n\tif ((rb = calloc(1, sizeof(*rb))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\trb->blob = blob;\n\trb->len = len;\n\terb = RB_INSERT(revoked_blob_tree, rbt, rb);\n\tif (erb != NULL) {\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "blob",
            "p",
            "len"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrevoke_by_hash(struct revoked_blob_tree *target, const u_char *p, size_t len)\n{\n\tu_char *blob;\n\tint r;\n\n\t/* need to copy hash, as revoke_blob steals ownership */\n\tif ((blob = malloc(len)) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tmemcpy(blob, p, len);\n\tif ((r = revoke_blob(target, blob, len)) != 0) {\n\t\tfree(blob);\n\t\treturn r;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_krl_revoke_key_explicit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "405-416",
    "snippet": "int\nssh_krl_revoke_key_explicit(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tu_char *blob;\n\tsize_t len;\n\tint r;\n\n\tdebug3(\"%s: revoke type %s\", __func__, sshkey_type(key));\n\tif ((r = plain_key_blob(key, &blob, &len)) != 0)\n\t\treturn r;\n\treturn revoke_blob(&krl->revoked_keys, blob, len);\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "revoke_blob",
          "args": [
            "&krl->revoked_keys",
            "blob",
            "len"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "revoke_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "388-403",
          "snippet": "static int\nrevoke_blob(struct revoked_blob_tree *rbt, u_char *blob, size_t len)\n{\n\tstruct revoked_blob *rb, *erb;\n\n\tif ((rb = calloc(1, sizeof(*rb))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\trb->blob = blob;\n\trb->len = len;\n\terb = RB_INSERT(revoked_blob_tree, rbt, rb);\n\tif (erb != NULL) {\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrevoke_blob(struct revoked_blob_tree *rbt, u_char *blob, size_t len)\n{\n\tstruct revoked_blob *rb, *erb;\n\n\tif ((rb = calloc(1, sizeof(*rb))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\trb->blob = blob;\n\trb->len = len;\n\terb = RB_INSERT(revoked_blob_tree, rbt, rb);\n\tif (erb != NULL) {\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plain_key_blob",
          "args": [
            "key",
            "&blob",
            "&len"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "plain_key_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "368-385",
          "snippet": "static int\nplain_key_blob(const struct sshkey *key, u_char **blob, size_t *blen)\n{\n\tstruct sshkey *kcopy;\n\tint r;\n\n\tif ((r = sshkey_from_private(key, &kcopy)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(kcopy)) {\n\t\tif ((r = sshkey_drop_cert(kcopy)) != 0) {\n\t\t\tsshkey_free(kcopy);\n\t\t\treturn r;\n\t\t}\n\t}\n\tr = sshkey_to_blob(kcopy, blob, blen);\n\tsshkey_free(kcopy);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nplain_key_blob(const struct sshkey *key, u_char **blob, size_t *blen)\n{\n\tstruct sshkey *kcopy;\n\tint r;\n\n\tif ((r = sshkey_from_private(key, &kcopy)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(kcopy)) {\n\t\tif ((r = sshkey_drop_cert(kcopy)) != 0) {\n\t\t\tsshkey_free(kcopy);\n\t\t\treturn r;\n\t\t}\n\t}\n\tr = sshkey_to_blob(kcopy, blob, blen);\n\tsshkey_free(kcopy);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: revoke type %s\"",
            "__func__",
            "sshkey_type(key)"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "key"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_key_explicit(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tu_char *blob;\n\tsize_t len;\n\tint r;\n\n\tdebug3(\"%s: revoke type %s\", __func__, sshkey_type(key));\n\tif ((r = plain_key_blob(key, &blob, &len)) != 0)\n\t\treturn r;\n\treturn revoke_blob(&krl->revoked_keys, blob, len);\n}"
  },
  {
    "function_name": "revoke_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "388-403",
    "snippet": "static int\nrevoke_blob(struct revoked_blob_tree *rbt, u_char *blob, size_t len)\n{\n\tstruct revoked_blob *rb, *erb;\n\n\tif ((rb = calloc(1, sizeof(*rb))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\trb->blob = blob;\n\trb->len = len;\n\terb = RB_INSERT(revoked_blob_tree, rbt, rb);\n\tif (erb != NULL) {\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rb"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_INSERT",
          "args": [
            "revoked_blob_tree",
            "rbt",
            "rb"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*rb)"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrevoke_blob(struct revoked_blob_tree *rbt, u_char *blob, size_t len)\n{\n\tstruct revoked_blob *rb, *erb;\n\n\tif ((rb = calloc(1, sizeof(*rb))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\trb->blob = blob;\n\trb->len = len;\n\terb = RB_INSERT(revoked_blob_tree, rbt, rb);\n\tif (erb != NULL) {\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "plain_key_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "368-385",
    "snippet": "static int\nplain_key_blob(const struct sshkey *key, u_char **blob, size_t *blen)\n{\n\tstruct sshkey *kcopy;\n\tint r;\n\n\tif ((r = sshkey_from_private(key, &kcopy)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(kcopy)) {\n\t\tif ((r = sshkey_drop_cert(kcopy)) != 0) {\n\t\t\tsshkey_free(kcopy);\n\t\t\treturn r;\n\t\t}\n\t}\n\tr = sshkey_to_blob(kcopy, blob, blen);\n\tsshkey_free(kcopy);\n\treturn r;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "kcopy"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_to_blob",
          "args": [
            "kcopy",
            "blob",
            "blen"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "880-884",
          "snippet": "int\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_drop_cert",
          "args": [
            "kcopy"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_drop_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2497-2506",
          "snippet": "int\nsshkey_drop_cert(struct sshkey *k)\n{\n\tif (!sshkey_type_is_cert(k->type))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tcert_free(k->cert);\n\tk->cert = NULL;\n\tk->type = sshkey_type_plain(k->type);\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_drop_cert(struct sshkey *k)\n{\n\tif (!sshkey_type_is_cert(k->type))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tcert_free(k->cert);\n\tk->cert = NULL;\n\tk->type = sshkey_type_plain(k->type);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "kcopy"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "key",
            "&kcopy"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nplain_key_blob(const struct sshkey *key, u_char **blob, size_t *blen)\n{\n\tstruct sshkey *kcopy;\n\tint r;\n\n\tif ((r = sshkey_from_private(key, &kcopy)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(kcopy)) {\n\t\tif ((r = sshkey_drop_cert(kcopy)) != 0) {\n\t\t\tsshkey_free(kcopy);\n\t\t\treturn r;\n\t\t}\n\t}\n\tr = sshkey_to_blob(kcopy, blob, blen);\n\tsshkey_free(kcopy);\n\treturn r;\n}"
  },
  {
    "function_name": "ssh_krl_revoke_cert_by_key_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "342-365",
    "snippet": "int\nssh_krl_revoke_cert_by_key_id(struct ssh_krl *krl, const struct sshkey *ca_key,\n    const char *key_id)\n{\n\tstruct revoked_key_id *rki, *erki;\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\n\tKRL_DBG((\"%s: revoke %s\", __func__, key_id));\n\tif ((rki = calloc(1, sizeof(*rki))) == NULL ||\n\t    (rki->key_id = strdup(key_id)) == NULL) {\n\t\tfree(rki);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\terki = RB_INSERT(revoked_key_id_tree, &rc->revoked_key_ids, rki);\n\tif (erki != NULL) {\n\t\tfree(rki->key_id);\n\t\tfree(rki);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rki"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_INSERT",
          "args": [
            "revoked_key_id_tree",
            "&rc->revoked_key_ids",
            "rki"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "key_id"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*rki)"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: revoke %s\", __func__, key_id)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revoked_certs_for_ca_key",
          "args": [
            "krl",
            "ca_key",
            "&rc",
            "1"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "revoked_certs_for_ca_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "213-246",
          "snippet": "static int\nrevoked_certs_for_ca_key(struct ssh_krl *krl, const struct sshkey *ca_key,\n    struct revoked_certs **rcp, int allow_create)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\t*rcp = NULL;\n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tif ((ca_key == NULL && rc->ca_key == NULL) ||\n\t\t    sshkey_equal(rc->ca_key, ca_key)) {\n\t\t\t*rcp = rc;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!allow_create)\n\t\treturn 0;\n\t/* If this CA doesn't exist in the list then add it now */\n\tif ((rc = calloc(1, sizeof(*rc))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (ca_key == NULL)\n\t\trc->ca_key = NULL;\n\telse if ((r = sshkey_from_private(ca_key, &rc->ca_key)) != 0) {\n\t\tfree(rc);\n\t\treturn r;\n\t}\n\tRB_INIT(&rc->revoked_serials);\n\tRB_INIT(&rc->revoked_key_ids);\n\tTAILQ_INSERT_TAIL(&krl->revoked_certs, rc, entry);\n\tKRL_DBG((\"%s: new CA %s\", __func__,\n\t    ca_key == NULL ? \"*\" : sshkey_type(ca_key)));\n\t*rcp = rc;\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrevoked_certs_for_ca_key(struct ssh_krl *krl, const struct sshkey *ca_key,\n    struct revoked_certs **rcp, int allow_create)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\t*rcp = NULL;\n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tif ((ca_key == NULL && rc->ca_key == NULL) ||\n\t\t    sshkey_equal(rc->ca_key, ca_key)) {\n\t\t\t*rcp = rc;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!allow_create)\n\t\treturn 0;\n\t/* If this CA doesn't exist in the list then add it now */\n\tif ((rc = calloc(1, sizeof(*rc))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (ca_key == NULL)\n\t\trc->ca_key = NULL;\n\telse if ((r = sshkey_from_private(ca_key, &rc->ca_key)) != 0) {\n\t\tfree(rc);\n\t\treturn r;\n\t}\n\tRB_INIT(&rc->revoked_serials);\n\tRB_INIT(&rc->revoked_key_ids);\n\tTAILQ_INSERT_TAIL(&krl->revoked_certs, rc, entry);\n\tKRL_DBG((\"%s: new CA %s\", __func__,\n\t    ca_key == NULL ? \"*\" : sshkey_type(ca_key)));\n\t*rcp = rc;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_cert_by_key_id(struct ssh_krl *krl, const struct sshkey *ca_key,\n    const char *key_id)\n{\n\tstruct revoked_key_id *rki, *erki;\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\n\tKRL_DBG((\"%s: revoke %s\", __func__, key_id));\n\tif ((rki = calloc(1, sizeof(*rki))) == NULL ||\n\t    (rki->key_id = strdup(key_id)) == NULL) {\n\t\tfree(rki);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\terki = RB_INSERT(revoked_key_id_tree, &rc->revoked_key_ids, rki);\n\tif (erki != NULL) {\n\t\tfree(rki->key_id);\n\t\tfree(rki);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_krl_revoke_cert_by_serial_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "328-340",
    "snippet": "int\nssh_krl_revoke_cert_by_serial_range(struct ssh_krl *krl,\n    const struct sshkey *ca_key, u_int64_t lo, u_int64_t hi)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif (lo > hi || lo == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\treturn insert_serial_range(&rc->revoked_serials, lo, hi);\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_serial_range",
          "args": [
            "&rc->revoked_serials",
            "lo",
            "hi"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "insert_serial_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "248-319",
          "snippet": "static int\ninsert_serial_range(struct revoked_serial_tree *rt, u_int64_t lo, u_int64_t hi)\n{\n\tstruct revoked_serial rs, *ers, *crs, *irs;\n\n\tKRL_DBG((\"%s: insert %llu:%llu\", __func__, lo, hi));\n\tmemset(&rs, 0, sizeof(rs));\n\trs.lo = lo;\n\trs.hi = hi;\n\ters = RB_NFIND(revoked_serial_tree, rt, &rs);\n\tif (ers == NULL || serial_cmp(ers, &rs) != 0) {\n\t\t/* No entry matches. Just insert */\n\t\tif ((irs = malloc(sizeof(rs))) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tmemcpy(irs, &rs, sizeof(*irs));\n\t\ters = RB_INSERT(revoked_serial_tree, rt, irs);\n\t\tif (ers != NULL) {\n\t\t\tKRL_DBG((\"%s: bad: ers != NULL\", __func__));\n\t\t\t/* Shouldn't happen */\n\t\t\tfree(irs);\n\t\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t\t}\n\t\ters = irs;\n\t} else {\n\t\tKRL_DBG((\"%s: overlap found %llu:%llu\", __func__,\n\t\t    ers->lo, ers->hi));\n\t\t/*\n\t\t * The inserted entry overlaps an existing one. Grow the\n\t\t * existing entry.\n\t\t */\n\t\tif (ers->lo > lo)\n\t\t\ters->lo = lo;\n\t\tif (ers->hi < hi)\n\t\t\ters->hi = hi;\n\t}\n\n\t/*\n\t * The inserted or revised range might overlap or abut adjacent ones;\n\t * coalesce as necessary.\n\t */\n\n\t/* Check predecessors */\n\twhile ((crs = RB_PREV(revoked_serial_tree, rt, ers)) != NULL) {\n\t\tKRL_DBG((\"%s: pred %llu:%llu\", __func__, crs->lo, crs->hi));\n\t\tif (ers->lo != 0 && crs->hi < ers->lo - 1)\n\t\t\tbreak;\n\t\t/* This entry overlaps. */\n\t\tif (crs->lo < ers->lo) {\n\t\t\ters->lo = crs->lo;\n\t\t\tKRL_DBG((\"%s: pred extend %llu:%llu\", __func__,\n\t\t\t    ers->lo, ers->hi));\n\t\t}\n\t\tRB_REMOVE(revoked_serial_tree, rt, crs);\n\t\tfree(crs);\n\t}\n\t/* Check successors */\n\twhile ((crs = RB_NEXT(revoked_serial_tree, rt, ers)) != NULL) {\n\t\tKRL_DBG((\"%s: succ %llu:%llu\", __func__, crs->lo, crs->hi));\n\t\tif (ers->hi != (u_int64_t)-1 && crs->lo > ers->hi + 1)\n\t\t\tbreak;\n\t\t/* This entry overlaps. */\n\t\tif (crs->hi > ers->hi) {\n\t\t\ters->hi = crs->hi;\n\t\t\tKRL_DBG((\"%s: succ extend %llu:%llu\", __func__,\n\t\t\t    ers->lo, ers->hi));\n\t\t}\n\t\tRB_REMOVE(revoked_serial_tree, rt, crs);\n\t\tfree(crs);\n\t}\n\tKRL_DBG((\"%s: done, final %llu:%llu\", __func__, ers->lo, ers->hi));\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ninsert_serial_range(struct revoked_serial_tree *rt, u_int64_t lo, u_int64_t hi)\n{\n\tstruct revoked_serial rs, *ers, *crs, *irs;\n\n\tKRL_DBG((\"%s: insert %llu:%llu\", __func__, lo, hi));\n\tmemset(&rs, 0, sizeof(rs));\n\trs.lo = lo;\n\trs.hi = hi;\n\ters = RB_NFIND(revoked_serial_tree, rt, &rs);\n\tif (ers == NULL || serial_cmp(ers, &rs) != 0) {\n\t\t/* No entry matches. Just insert */\n\t\tif ((irs = malloc(sizeof(rs))) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tmemcpy(irs, &rs, sizeof(*irs));\n\t\ters = RB_INSERT(revoked_serial_tree, rt, irs);\n\t\tif (ers != NULL) {\n\t\t\tKRL_DBG((\"%s: bad: ers != NULL\", __func__));\n\t\t\t/* Shouldn't happen */\n\t\t\tfree(irs);\n\t\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t\t}\n\t\ters = irs;\n\t} else {\n\t\tKRL_DBG((\"%s: overlap found %llu:%llu\", __func__,\n\t\t    ers->lo, ers->hi));\n\t\t/*\n\t\t * The inserted entry overlaps an existing one. Grow the\n\t\t * existing entry.\n\t\t */\n\t\tif (ers->lo > lo)\n\t\t\ters->lo = lo;\n\t\tif (ers->hi < hi)\n\t\t\ters->hi = hi;\n\t}\n\n\t/*\n\t * The inserted or revised range might overlap or abut adjacent ones;\n\t * coalesce as necessary.\n\t */\n\n\t/* Check predecessors */\n\twhile ((crs = RB_PREV(revoked_serial_tree, rt, ers)) != NULL) {\n\t\tKRL_DBG((\"%s: pred %llu:%llu\", __func__, crs->lo, crs->hi));\n\t\tif (ers->lo != 0 && crs->hi < ers->lo - 1)\n\t\t\tbreak;\n\t\t/* This entry overlaps. */\n\t\tif (crs->lo < ers->lo) {\n\t\t\ters->lo = crs->lo;\n\t\t\tKRL_DBG((\"%s: pred extend %llu:%llu\", __func__,\n\t\t\t    ers->lo, ers->hi));\n\t\t}\n\t\tRB_REMOVE(revoked_serial_tree, rt, crs);\n\t\tfree(crs);\n\t}\n\t/* Check successors */\n\twhile ((crs = RB_NEXT(revoked_serial_tree, rt, ers)) != NULL) {\n\t\tKRL_DBG((\"%s: succ %llu:%llu\", __func__, crs->lo, crs->hi));\n\t\tif (ers->hi != (u_int64_t)-1 && crs->lo > ers->hi + 1)\n\t\t\tbreak;\n\t\t/* This entry overlaps. */\n\t\tif (crs->hi > ers->hi) {\n\t\t\ters->hi = crs->hi;\n\t\t\tKRL_DBG((\"%s: succ extend %llu:%llu\", __func__,\n\t\t\t    ers->lo, ers->hi));\n\t\t}\n\t\tRB_REMOVE(revoked_serial_tree, rt, crs);\n\t\tfree(crs);\n\t}\n\tKRL_DBG((\"%s: done, final %llu:%llu\", __func__, ers->lo, ers->hi));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "revoked_certs_for_ca_key",
          "args": [
            "krl",
            "ca_key",
            "&rc",
            "1"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "revoked_certs_for_ca_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "213-246",
          "snippet": "static int\nrevoked_certs_for_ca_key(struct ssh_krl *krl, const struct sshkey *ca_key,\n    struct revoked_certs **rcp, int allow_create)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\t*rcp = NULL;\n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tif ((ca_key == NULL && rc->ca_key == NULL) ||\n\t\t    sshkey_equal(rc->ca_key, ca_key)) {\n\t\t\t*rcp = rc;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!allow_create)\n\t\treturn 0;\n\t/* If this CA doesn't exist in the list then add it now */\n\tif ((rc = calloc(1, sizeof(*rc))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (ca_key == NULL)\n\t\trc->ca_key = NULL;\n\telse if ((r = sshkey_from_private(ca_key, &rc->ca_key)) != 0) {\n\t\tfree(rc);\n\t\treturn r;\n\t}\n\tRB_INIT(&rc->revoked_serials);\n\tRB_INIT(&rc->revoked_key_ids);\n\tTAILQ_INSERT_TAIL(&krl->revoked_certs, rc, entry);\n\tKRL_DBG((\"%s: new CA %s\", __func__,\n\t    ca_key == NULL ? \"*\" : sshkey_type(ca_key)));\n\t*rcp = rc;\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrevoked_certs_for_ca_key(struct ssh_krl *krl, const struct sshkey *ca_key,\n    struct revoked_certs **rcp, int allow_create)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\t*rcp = NULL;\n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tif ((ca_key == NULL && rc->ca_key == NULL) ||\n\t\t    sshkey_equal(rc->ca_key, ca_key)) {\n\t\t\t*rcp = rc;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!allow_create)\n\t\treturn 0;\n\t/* If this CA doesn't exist in the list then add it now */\n\tif ((rc = calloc(1, sizeof(*rc))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (ca_key == NULL)\n\t\trc->ca_key = NULL;\n\telse if ((r = sshkey_from_private(ca_key, &rc->ca_key)) != 0) {\n\t\tfree(rc);\n\t\treturn r;\n\t}\n\tRB_INIT(&rc->revoked_serials);\n\tRB_INIT(&rc->revoked_key_ids);\n\tTAILQ_INSERT_TAIL(&krl->revoked_certs, rc, entry);\n\tKRL_DBG((\"%s: new CA %s\", __func__,\n\t    ca_key == NULL ? \"*\" : sshkey_type(ca_key)));\n\t*rcp = rc;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_cert_by_serial_range(struct ssh_krl *krl,\n    const struct sshkey *ca_key, u_int64_t lo, u_int64_t hi)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif (lo > hi || lo == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\treturn insert_serial_range(&rc->revoked_serials, lo, hi);\n}"
  },
  {
    "function_name": "ssh_krl_revoke_cert_by_serial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "321-326",
    "snippet": "int\nssh_krl_revoke_cert_by_serial(struct ssh_krl *krl, const struct sshkey *ca_key,\n    u_int64_t serial)\n{\n\treturn ssh_krl_revoke_cert_by_serial_range(krl, ca_key, serial, serial);\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_krl_revoke_cert_by_serial_range",
          "args": [
            "krl",
            "ca_key",
            "serial",
            "serial"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_revoke_cert_by_serial_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "328-340",
          "snippet": "int\nssh_krl_revoke_cert_by_serial_range(struct ssh_krl *krl,\n    const struct sshkey *ca_key, u_int64_t lo, u_int64_t hi)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif (lo > hi || lo == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\treturn insert_serial_range(&rc->revoked_serials, lo, hi);\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_cert_by_serial_range(struct ssh_krl *krl,\n    const struct sshkey *ca_key, u_int64_t lo, u_int64_t hi)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif (lo > hi || lo == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\treturn insert_serial_range(&rc->revoked_serials, lo, hi);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_cert_by_serial(struct ssh_krl *krl, const struct sshkey *ca_key,\n    u_int64_t serial)\n{\n\treturn ssh_krl_revoke_cert_by_serial_range(krl, ca_key, serial, serial);\n}"
  },
  {
    "function_name": "insert_serial_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "248-319",
    "snippet": "static int\ninsert_serial_range(struct revoked_serial_tree *rt, u_int64_t lo, u_int64_t hi)\n{\n\tstruct revoked_serial rs, *ers, *crs, *irs;\n\n\tKRL_DBG((\"%s: insert %llu:%llu\", __func__, lo, hi));\n\tmemset(&rs, 0, sizeof(rs));\n\trs.lo = lo;\n\trs.hi = hi;\n\ters = RB_NFIND(revoked_serial_tree, rt, &rs);\n\tif (ers == NULL || serial_cmp(ers, &rs) != 0) {\n\t\t/* No entry matches. Just insert */\n\t\tif ((irs = malloc(sizeof(rs))) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tmemcpy(irs, &rs, sizeof(*irs));\n\t\ters = RB_INSERT(revoked_serial_tree, rt, irs);\n\t\tif (ers != NULL) {\n\t\t\tKRL_DBG((\"%s: bad: ers != NULL\", __func__));\n\t\t\t/* Shouldn't happen */\n\t\t\tfree(irs);\n\t\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t\t}\n\t\ters = irs;\n\t} else {\n\t\tKRL_DBG((\"%s: overlap found %llu:%llu\", __func__,\n\t\t    ers->lo, ers->hi));\n\t\t/*\n\t\t * The inserted entry overlaps an existing one. Grow the\n\t\t * existing entry.\n\t\t */\n\t\tif (ers->lo > lo)\n\t\t\ters->lo = lo;\n\t\tif (ers->hi < hi)\n\t\t\ters->hi = hi;\n\t}\n\n\t/*\n\t * The inserted or revised range might overlap or abut adjacent ones;\n\t * coalesce as necessary.\n\t */\n\n\t/* Check predecessors */\n\twhile ((crs = RB_PREV(revoked_serial_tree, rt, ers)) != NULL) {\n\t\tKRL_DBG((\"%s: pred %llu:%llu\", __func__, crs->lo, crs->hi));\n\t\tif (ers->lo != 0 && crs->hi < ers->lo - 1)\n\t\t\tbreak;\n\t\t/* This entry overlaps. */\n\t\tif (crs->lo < ers->lo) {\n\t\t\ters->lo = crs->lo;\n\t\t\tKRL_DBG((\"%s: pred extend %llu:%llu\", __func__,\n\t\t\t    ers->lo, ers->hi));\n\t\t}\n\t\tRB_REMOVE(revoked_serial_tree, rt, crs);\n\t\tfree(crs);\n\t}\n\t/* Check successors */\n\twhile ((crs = RB_NEXT(revoked_serial_tree, rt, ers)) != NULL) {\n\t\tKRL_DBG((\"%s: succ %llu:%llu\", __func__, crs->lo, crs->hi));\n\t\tif (ers->hi != (u_int64_t)-1 && crs->lo > ers->hi + 1)\n\t\t\tbreak;\n\t\t/* This entry overlaps. */\n\t\tif (crs->hi > ers->hi) {\n\t\t\ters->hi = crs->hi;\n\t\t\tKRL_DBG((\"%s: succ extend %llu:%llu\", __func__,\n\t\t\t    ers->lo, ers->hi));\n\t\t}\n\t\tRB_REMOVE(revoked_serial_tree, rt, crs);\n\t\tfree(crs);\n\t}\n\tKRL_DBG((\"%s: done, final %llu:%llu\", __func__, ers->lo, ers->hi));\n\treturn 0;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: done, final %llu:%llu\", __func__, ers->lo, ers->hi)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "crs"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_REMOVE",
          "args": [
            "revoked_serial_tree",
            "rt",
            "crs"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: succ extend %llu:%llu\", __func__,\n\t\t\t    ers->lo, ers->hi)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: succ %llu:%llu\", __func__, crs->lo, crs->hi)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_NEXT",
          "args": [
            "revoked_serial_tree",
            "rt",
            "ers"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_REMOVE",
          "args": [
            "revoked_serial_tree",
            "rt",
            "crs"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: pred extend %llu:%llu\", __func__,\n\t\t\t    ers->lo, ers->hi)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: pred %llu:%llu\", __func__, crs->lo, crs->hi)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_PREV",
          "args": [
            "revoked_serial_tree",
            "rt",
            "ers"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: overlap found %llu:%llu\", __func__,\n\t\t    ers->lo, ers->hi)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: bad: ers != NULL\", __func__)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_INSERT",
          "args": [
            "revoked_serial_tree",
            "rt",
            "irs"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "irs",
            "&rs",
            "sizeof(*irs)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(rs)"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "serial_cmp",
          "args": [
            "ers",
            "&rs"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "serial_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "104-110",
          "snippet": "static int\nserial_cmp(struct revoked_serial *a, struct revoked_serial *b)\n{\n\tif (a->hi >= b->lo && a->lo <= b->hi)\n\t\treturn 0;\n\treturn a->lo < b->lo ? -1 : 1;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int serial_cmp(struct revoked_serial *a, struct revoked_serial *b);",
            "static int key_id_cmp(struct revoked_key_id *a, struct revoked_key_id *b);",
            "static int blob_cmp(struct revoked_blob *a, struct revoked_blob *b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int serial_cmp(struct revoked_serial *a, struct revoked_serial *b);\nstatic int key_id_cmp(struct revoked_key_id *a, struct revoked_key_id *b);\nstatic int blob_cmp(struct revoked_blob *a, struct revoked_blob *b);\n\nstatic int\nserial_cmp(struct revoked_serial *a, struct revoked_serial *b)\n{\n\tif (a->hi >= b->lo && a->lo <= b->hi)\n\t\treturn 0;\n\treturn a->lo < b->lo ? -1 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_NFIND",
          "args": [
            "revoked_serial_tree",
            "rt",
            "&rs"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rs",
            "0",
            "sizeof(rs)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: insert %llu:%llu\", __func__, lo, hi)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ninsert_serial_range(struct revoked_serial_tree *rt, u_int64_t lo, u_int64_t hi)\n{\n\tstruct revoked_serial rs, *ers, *crs, *irs;\n\n\tKRL_DBG((\"%s: insert %llu:%llu\", __func__, lo, hi));\n\tmemset(&rs, 0, sizeof(rs));\n\trs.lo = lo;\n\trs.hi = hi;\n\ters = RB_NFIND(revoked_serial_tree, rt, &rs);\n\tif (ers == NULL || serial_cmp(ers, &rs) != 0) {\n\t\t/* No entry matches. Just insert */\n\t\tif ((irs = malloc(sizeof(rs))) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tmemcpy(irs, &rs, sizeof(*irs));\n\t\ters = RB_INSERT(revoked_serial_tree, rt, irs);\n\t\tif (ers != NULL) {\n\t\t\tKRL_DBG((\"%s: bad: ers != NULL\", __func__));\n\t\t\t/* Shouldn't happen */\n\t\t\tfree(irs);\n\t\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t\t}\n\t\ters = irs;\n\t} else {\n\t\tKRL_DBG((\"%s: overlap found %llu:%llu\", __func__,\n\t\t    ers->lo, ers->hi));\n\t\t/*\n\t\t * The inserted entry overlaps an existing one. Grow the\n\t\t * existing entry.\n\t\t */\n\t\tif (ers->lo > lo)\n\t\t\ters->lo = lo;\n\t\tif (ers->hi < hi)\n\t\t\ters->hi = hi;\n\t}\n\n\t/*\n\t * The inserted or revised range might overlap or abut adjacent ones;\n\t * coalesce as necessary.\n\t */\n\n\t/* Check predecessors */\n\twhile ((crs = RB_PREV(revoked_serial_tree, rt, ers)) != NULL) {\n\t\tKRL_DBG((\"%s: pred %llu:%llu\", __func__, crs->lo, crs->hi));\n\t\tif (ers->lo != 0 && crs->hi < ers->lo - 1)\n\t\t\tbreak;\n\t\t/* This entry overlaps. */\n\t\tif (crs->lo < ers->lo) {\n\t\t\ters->lo = crs->lo;\n\t\t\tKRL_DBG((\"%s: pred extend %llu:%llu\", __func__,\n\t\t\t    ers->lo, ers->hi));\n\t\t}\n\t\tRB_REMOVE(revoked_serial_tree, rt, crs);\n\t\tfree(crs);\n\t}\n\t/* Check successors */\n\twhile ((crs = RB_NEXT(revoked_serial_tree, rt, ers)) != NULL) {\n\t\tKRL_DBG((\"%s: succ %llu:%llu\", __func__, crs->lo, crs->hi));\n\t\tif (ers->hi != (u_int64_t)-1 && crs->lo > ers->hi + 1)\n\t\t\tbreak;\n\t\t/* This entry overlaps. */\n\t\tif (crs->hi > ers->hi) {\n\t\t\ters->hi = crs->hi;\n\t\t\tKRL_DBG((\"%s: succ extend %llu:%llu\", __func__,\n\t\t\t    ers->lo, ers->hi));\n\t\t}\n\t\tRB_REMOVE(revoked_serial_tree, rt, crs);\n\t\tfree(crs);\n\t}\n\tKRL_DBG((\"%s: done, final %llu:%llu\", __func__, ers->lo, ers->hi));\n\treturn 0;\n}"
  },
  {
    "function_name": "revoked_certs_for_ca_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "213-246",
    "snippet": "static int\nrevoked_certs_for_ca_key(struct ssh_krl *krl, const struct sshkey *ca_key,\n    struct revoked_certs **rcp, int allow_create)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\t*rcp = NULL;\n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tif ((ca_key == NULL && rc->ca_key == NULL) ||\n\t\t    sshkey_equal(rc->ca_key, ca_key)) {\n\t\t\t*rcp = rc;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!allow_create)\n\t\treturn 0;\n\t/* If this CA doesn't exist in the list then add it now */\n\tif ((rc = calloc(1, sizeof(*rc))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (ca_key == NULL)\n\t\trc->ca_key = NULL;\n\telse if ((r = sshkey_from_private(ca_key, &rc->ca_key)) != 0) {\n\t\tfree(rc);\n\t\treturn r;\n\t}\n\tRB_INIT(&rc->revoked_serials);\n\tRB_INIT(&rc->revoked_key_ids);\n\tTAILQ_INSERT_TAIL(&krl->revoked_certs, rc, entry);\n\tKRL_DBG((\"%s: new CA %s\", __func__,\n\t    ca_key == NULL ? \"*\" : sshkey_type(ca_key)));\n\t*rcp = rc;\n\treturn 0;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KRL_DBG",
          "args": [
            "(\"%s: new CA %s\", __func__,\n\t    ca_key == NULL ? \"*\" : sshkey_type(ca_key))"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "ca_key"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&krl->revoked_certs",
            "rc",
            "entry"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_INIT",
          "args": [
            "&rc->revoked_key_ids"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_INIT",
          "args": [
            "&rc->revoked_serials"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rc"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "ca_key",
            "&rc->ca_key"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*rc)"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "rc->ca_key",
            "ca_key"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH",
          "args": [
            "rc",
            "&krl->revoked_certs",
            "entry"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrevoked_certs_for_ca_key(struct ssh_krl *krl, const struct sshkey *ca_key,\n    struct revoked_certs **rcp, int allow_create)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\t*rcp = NULL;\n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tif ((ca_key == NULL && rc->ca_key == NULL) ||\n\t\t    sshkey_equal(rc->ca_key, ca_key)) {\n\t\t\t*rcp = rc;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!allow_create)\n\t\treturn 0;\n\t/* If this CA doesn't exist in the list then add it now */\n\tif ((rc = calloc(1, sizeof(*rc))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (ca_key == NULL)\n\t\trc->ca_key = NULL;\n\telse if ((r = sshkey_from_private(ca_key, &rc->ca_key)) != 0) {\n\t\tfree(rc);\n\t\treturn r;\n\t}\n\tRB_INIT(&rc->revoked_serials);\n\tRB_INIT(&rc->revoked_key_ids);\n\tTAILQ_INSERT_TAIL(&krl->revoked_certs, rc, entry);\n\tKRL_DBG((\"%s: new CA %s\", __func__,\n\t    ca_key == NULL ? \"*\" : sshkey_type(ca_key)));\n\t*rcp = rc;\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_krl_set_comment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "200-207",
    "snippet": "int\nssh_krl_set_comment(struct ssh_krl *krl, const char *comment)\n{\n\tfree(krl->comment);\n\tif ((krl->comment = strdup(comment)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "comment"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "krl->comment"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_set_comment(struct ssh_krl *krl, const char *comment)\n{\n\tfree(krl->comment);\n\tif ((krl->comment = strdup(comment)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_krl_set_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "194-198",
    "snippet": "void\nssh_krl_set_version(struct ssh_krl *krl, u_int64_t version)\n{\n\tkrl->krl_version = version;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_set_version(struct ssh_krl *krl, u_int64_t version)\n{\n\tkrl->krl_version = version;\n}"
  },
  {
    "function_name": "ssh_krl_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "163-192",
    "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "revoked_certs_free",
          "args": [
            "rc"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "revoked_certs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "145-161",
          "snippet": "static void\nrevoked_certs_free(struct revoked_certs *rc)\n{\n\tstruct revoked_serial *rs, *trs;\n\tstruct revoked_key_id *rki, *trki;\n\n\tRB_FOREACH_SAFE(rs, revoked_serial_tree, &rc->revoked_serials, trs) {\n\t\tRB_REMOVE(revoked_serial_tree, &rc->revoked_serials, rs);\n\t\tfree(rs);\n\t}\n\tRB_FOREACH_SAFE(rki, revoked_key_id_tree, &rc->revoked_key_ids, trki) {\n\t\tRB_REMOVE(revoked_key_id_tree, &rc->revoked_key_ids, rki);\n\t\tfree(rki->key_id);\n\t\tfree(rki);\n\t}\n\tsshkey_free(rc->ca_key);\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nrevoked_certs_free(struct revoked_certs *rc)\n{\n\tstruct revoked_serial *rs, *trs;\n\tstruct revoked_key_id *rki, *trki;\n\n\tRB_FOREACH_SAFE(rs, revoked_serial_tree, &rc->revoked_serials, trs) {\n\t\tRB_REMOVE(revoked_serial_tree, &rc->revoked_serials, rs);\n\t\tfree(rs);\n\t}\n\tRB_FOREACH_SAFE(rki, revoked_key_id_tree, &rc->revoked_key_ids, trki) {\n\t\tRB_REMOVE(revoked_key_id_tree, &rc->revoked_key_ids, rki);\n\t\tfree(rki->key_id);\n\t\tfree(rki);\n\t}\n\tsshkey_free(rc->ca_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&krl->revoked_certs",
            "rc",
            "entry"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH_SAFE",
          "args": [
            "rc",
            "&krl->revoked_certs",
            "entry",
            "trc"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rb"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "RB_REMOVE",
          "args": [
            "revoked_blob_tree",
            "&krl->revoked_sha256s",
            "rb"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_FOREACH_SAFE",
          "args": [
            "rb",
            "revoked_blob_tree",
            "&krl->revoked_sha256s",
            "trb"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_REMOVE",
          "args": [
            "revoked_blob_tree",
            "&krl->revoked_sha1s",
            "rb"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_FOREACH_SAFE",
          "args": [
            "rb",
            "revoked_blob_tree",
            "&krl->revoked_sha1s",
            "trb"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_REMOVE",
          "args": [
            "revoked_blob_tree",
            "&krl->revoked_keys",
            "rb"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_FOREACH_SAFE",
          "args": [
            "rb",
            "revoked_blob_tree",
            "&krl->revoked_keys",
            "trb"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
  },
  {
    "function_name": "revoked_certs_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "145-161",
    "snippet": "static void\nrevoked_certs_free(struct revoked_certs *rc)\n{\n\tstruct revoked_serial *rs, *trs;\n\tstruct revoked_key_id *rki, *trki;\n\n\tRB_FOREACH_SAFE(rs, revoked_serial_tree, &rc->revoked_serials, trs) {\n\t\tRB_REMOVE(revoked_serial_tree, &rc->revoked_serials, rs);\n\t\tfree(rs);\n\t}\n\tRB_FOREACH_SAFE(rki, revoked_key_id_tree, &rc->revoked_key_ids, trki) {\n\t\tRB_REMOVE(revoked_key_id_tree, &rc->revoked_key_ids, rki);\n\t\tfree(rki->key_id);\n\t\tfree(rki);\n\t}\n\tsshkey_free(rc->ca_key);\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "rc->ca_key"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rki"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_REMOVE",
          "args": [
            "revoked_key_id_tree",
            "&rc->revoked_key_ids",
            "rki"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_FOREACH_SAFE",
          "args": [
            "rki",
            "revoked_key_id_tree",
            "&rc->revoked_key_ids",
            "trki"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_REMOVE",
          "args": [
            "revoked_serial_tree",
            "&rc->revoked_serials",
            "rs"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_FOREACH_SAFE",
          "args": [
            "rs",
            "revoked_serial_tree",
            "&rc->revoked_serials",
            "trs"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nrevoked_certs_free(struct revoked_certs *rc)\n{\n\tstruct revoked_serial *rs, *trs;\n\tstruct revoked_key_id *rki, *trki;\n\n\tRB_FOREACH_SAFE(rs, revoked_serial_tree, &rc->revoked_serials, trs) {\n\t\tRB_REMOVE(revoked_serial_tree, &rc->revoked_serials, rs);\n\t\tfree(rs);\n\t}\n\tRB_FOREACH_SAFE(rki, revoked_key_id_tree, &rc->revoked_key_ids, trki) {\n\t\tRB_REMOVE(revoked_key_id_tree, &rc->revoked_key_ids, rki);\n\t\tfree(rki->key_id);\n\t\tfree(rki);\n\t}\n\tsshkey_free(rc->ca_key);\n}"
  },
  {
    "function_name": "ssh_krl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "131-143",
    "snippet": "struct ssh_krl *\nssh_krl_init(void)\n{\n\tstruct ssh_krl *krl;\n\n\tif ((krl = calloc(1, sizeof(*krl))) == NULL)\n\t\treturn NULL;\n\tRB_INIT(&krl->revoked_keys);\n\tRB_INIT(&krl->revoked_sha1s);\n\tRB_INIT(&krl->revoked_sha256s);\n\tTAILQ_INIT(&krl->revoked_certs);\n\treturn krl;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&krl->revoked_certs"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_INIT",
          "args": [
            "&krl->revoked_sha256s"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_INIT",
          "args": [
            "&krl->revoked_sha1s"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_INIT",
          "args": [
            "&krl->revoked_keys"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*krl)"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct ssh_krl *\nssh_krl_init(void)\n{\n\tstruct ssh_krl *krl;\n\n\tif ((krl = calloc(1, sizeof(*krl))) == NULL)\n\t\treturn NULL;\n\tRB_INIT(&krl->revoked_keys);\n\tRB_INIT(&krl->revoked_sha1s);\n\tRB_INIT(&krl->revoked_sha256s);\n\tTAILQ_INIT(&krl->revoked_certs);\n\treturn krl;\n}"
  },
  {
    "function_name": "blob_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "118-129",
    "snippet": "static int\nblob_cmp(struct revoked_blob *a, struct revoked_blob *b)\n{\n\tint r;\n\n\tif (a->len != b->len) {\n\t\tif ((r = memcmp(a->blob, b->blob, MINIMUM(a->len, b->len))) != 0)\n\t\t\treturn r;\n\t\treturn a->len > b->len ? 1 : -1;\n\t} else\n\t\treturn memcmp(a->blob, b->blob, a->len);\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int serial_cmp(struct revoked_serial *a, struct revoked_serial *b);",
      "static int key_id_cmp(struct revoked_key_id *a, struct revoked_key_id *b);",
      "static int blob_cmp(struct revoked_blob *a, struct revoked_blob *b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a->blob",
            "b->blob",
            "a->len"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a->blob",
            "b->blob",
            "MINIMUM(a->len, b->len)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "a->len",
            "b->len"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int serial_cmp(struct revoked_serial *a, struct revoked_serial *b);\nstatic int key_id_cmp(struct revoked_key_id *a, struct revoked_key_id *b);\nstatic int blob_cmp(struct revoked_blob *a, struct revoked_blob *b);\n\nstatic int\nblob_cmp(struct revoked_blob *a, struct revoked_blob *b)\n{\n\tint r;\n\n\tif (a->len != b->len) {\n\t\tif ((r = memcmp(a->blob, b->blob, MINIMUM(a->len, b->len))) != 0)\n\t\t\treturn r;\n\t\treturn a->len > b->len ? 1 : -1;\n\t} else\n\t\treturn memcmp(a->blob, b->blob, a->len);\n}"
  },
  {
    "function_name": "key_id_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "112-116",
    "snippet": "static int\nkey_id_cmp(struct revoked_key_id *a, struct revoked_key_id *b)\n{\n\treturn strcmp(a->key_id, b->key_id);\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int serial_cmp(struct revoked_serial *a, struct revoked_serial *b);",
      "static int key_id_cmp(struct revoked_key_id *a, struct revoked_key_id *b);",
      "static int blob_cmp(struct revoked_blob *a, struct revoked_blob *b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->key_id",
            "b->key_id"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int serial_cmp(struct revoked_serial *a, struct revoked_serial *b);\nstatic int key_id_cmp(struct revoked_key_id *a, struct revoked_key_id *b);\nstatic int blob_cmp(struct revoked_blob *a, struct revoked_blob *b);\n\nstatic int\nkey_id_cmp(struct revoked_key_id *a, struct revoked_key_id *b)\n{\n\treturn strcmp(a->key_id, b->key_id);\n}"
  },
  {
    "function_name": "serial_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
    "lines": "104-110",
    "snippet": "static int\nserial_cmp(struct revoked_serial *a, struct revoked_serial *b)\n{\n\tif (a->hi >= b->lo && a->lo <= b->hi)\n\t\treturn 0;\n\treturn a->lo < b->lo ? -1 : 1;\n}",
    "includes": [
      "#include \"krl.h\"",
      "#include \"bitmap.h\"",
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"misc.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <openbsd-compat/sys-queue.h>",
      "#include <openbsd-compat/sys-tree.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int serial_cmp(struct revoked_serial *a, struct revoked_serial *b);",
      "static int key_id_cmp(struct revoked_key_id *a, struct revoked_key_id *b);",
      "static int blob_cmp(struct revoked_blob *a, struct revoked_blob *b);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int serial_cmp(struct revoked_serial *a, struct revoked_serial *b);\nstatic int key_id_cmp(struct revoked_key_id *a, struct revoked_key_id *b);\nstatic int blob_cmp(struct revoked_blob *a, struct revoked_blob *b);\n\nstatic int\nserial_cmp(struct revoked_serial *a, struct revoked_serial *b)\n{\n\tif (a->hi >= b->lo && a->lo <= b->hi)\n\t\treturn 0;\n\treturn a->lo < b->lo ? -1 : 1;\n}"
  }
]