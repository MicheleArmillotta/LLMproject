[
  {
    "function_name": "rresvport_af",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/rresvport.c",
    "lines": "57-106",
    "snippet": "int\nrresvport_af(int *alport, sa_family_t af)\n{\n\tstruct sockaddr_storage ss;\n\tstruct sockaddr *sa;\n\tu_int16_t *portp;\n\tint s;\n\tsocklen_t salen;\n\n\tmemset(&ss, '\\0', sizeof ss);\n\tsa = (struct sockaddr *)&ss;\n\n\tswitch (af) {\n\tcase AF_INET:\n\t\tsalen = sizeof(struct sockaddr_in);\n\t\tportp = &((struct sockaddr_in *)sa)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsalen = sizeof(struct sockaddr_in6);\n\t\tportp = &((struct sockaddr_in6 *)sa)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\terrno = EPFNOSUPPORT;\n\t\treturn (-1);\n\t}\n\tsa->sa_family = af;\n\t\n\ts = socket(af, SOCK_STREAM, 0);\n\tif (s < 0)\n\t\treturn (-1);\n\n\t*portp = htons(*alport);\n\tif (*alport < IPPORT_RESERVED - 1) {\n\t\tif (bind(s, sa, salen) >= 0)\n\t\t\treturn (s);\n\t\tif (errno != EADDRINUSE) {\n\t\t\t(void)close(s);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t*portp = 0;\n\tsa->sa_family = af;\n\tif (bindresvport_sa(s, sa) == -1) {\n\t\t(void)close(s);\n\t\treturn (-1);\n\t}\n\t*alport = ntohs(*portp);\n\treturn (s);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "*portp"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bindresvport_sa",
          "args": [
            "s",
            "sa"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "bindresvport_sa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bindresvport.c",
          "lines": "52-117",
          "snippet": "int\nbindresvport_sa(int sd, struct sockaddr *sa)\n{\n\tint error, af;\n\tstruct sockaddr_storage myaddr;\n\tstruct sockaddr_in *in;\n\tstruct sockaddr_in6 *in6;\n\tu_int16_t *portp;\n\tu_int16_t port;\n\tsocklen_t salen;\n\tint i;\n\n\tif (sa == NULL) {\n\t\tmemset(&myaddr, 0, sizeof(myaddr));\n\t\tsa = (struct sockaddr *)&myaddr;\n\t\tsalen = sizeof(myaddr);\n\n\t\tif (getsockname(sd, sa, &salen) == -1)\n\t\t\treturn -1;\t/* errno is correctly set */\n\n\t\taf = sa->sa_family;\n\t\tmemset(&myaddr, 0, salen);\n\t} else\n\t\taf = sa->sa_family;\n\n\tif (af == AF_INET) {\n\t\tin = (struct sockaddr_in *)sa;\n\t\tsalen = sizeof(struct sockaddr_in);\n\t\tportp = &in->sin_port;\n\t} else if (af == AF_INET6) {\n\t\tin6 = (struct sockaddr_in6 *)sa;\n\t\tsalen = sizeof(struct sockaddr_in6);\n\t\tportp = &in6->sin6_port;\n\t} else {\n\t\terrno = EPFNOSUPPORT;\n\t\treturn (-1);\n\t}\n\tsa->sa_family = af;\n\n\tport = ntohs(*portp);\n\tif (port == 0)\n\t\tport = arc4random_uniform(NPORTS) + STARTPORT;\n\n\t/* Avoid warning */\n\terror = -1;\n\n\tfor(i = 0; i < NPORTS; i++) {\n\t\t*portp = htons(port);\n\t\t\n\t\terror = bind(sd, sa, salen);\n\n\t\t/* Terminate on success */\n\t\tif (error == 0)\n\t\t\tbreak;\n\t\t\t\n\t\t/* Terminate on errors, except \"address already in use\" */\n\t\tif ((error < 0) && !((errno == EADDRINUSE) || (errno == EINVAL)))\n\t\t\tbreak;\n\t\t\t\n\t\tport++;\n\t\tif (port > ENDPORT)\n\t\t\tport = STARTPORT;\n\t}\n\n\treturn (error);\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define NPORTS\t(ENDPORT - STARTPORT + 1)",
            "#define ENDPORT (IPPORT_RESERVED - 1)",
            "#define STARTPORT 600"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define NPORTS\t(ENDPORT - STARTPORT + 1)\n#define ENDPORT (IPPORT_RESERVED - 1)\n#define STARTPORT 600\n\nint\nbindresvport_sa(int sd, struct sockaddr *sa)\n{\n\tint error, af;\n\tstruct sockaddr_storage myaddr;\n\tstruct sockaddr_in *in;\n\tstruct sockaddr_in6 *in6;\n\tu_int16_t *portp;\n\tu_int16_t port;\n\tsocklen_t salen;\n\tint i;\n\n\tif (sa == NULL) {\n\t\tmemset(&myaddr, 0, sizeof(myaddr));\n\t\tsa = (struct sockaddr *)&myaddr;\n\t\tsalen = sizeof(myaddr);\n\n\t\tif (getsockname(sd, sa, &salen) == -1)\n\t\t\treturn -1;\t/* errno is correctly set */\n\n\t\taf = sa->sa_family;\n\t\tmemset(&myaddr, 0, salen);\n\t} else\n\t\taf = sa->sa_family;\n\n\tif (af == AF_INET) {\n\t\tin = (struct sockaddr_in *)sa;\n\t\tsalen = sizeof(struct sockaddr_in);\n\t\tportp = &in->sin_port;\n\t} else if (af == AF_INET6) {\n\t\tin6 = (struct sockaddr_in6 *)sa;\n\t\tsalen = sizeof(struct sockaddr_in6);\n\t\tportp = &in6->sin6_port;\n\t} else {\n\t\terrno = EPFNOSUPPORT;\n\t\treturn (-1);\n\t}\n\tsa->sa_family = af;\n\n\tport = ntohs(*portp);\n\tif (port == 0)\n\t\tport = arc4random_uniform(NPORTS) + STARTPORT;\n\n\t/* Avoid warning */\n\terror = -1;\n\n\tfor(i = 0; i < NPORTS; i++) {\n\t\t*portp = htons(port);\n\t\t\n\t\terror = bind(sd, sa, salen);\n\n\t\t/* Terminate on success */\n\t\tif (error == 0)\n\t\t\tbreak;\n\t\t\t\n\t\t/* Terminate on errors, except \"address already in use\" */\n\t\tif ((error < 0) && !((errno == EADDRINUSE) || (errno == EINVAL)))\n\t\t\tbreak;\n\t\t\t\n\t\tport++;\n\t\tif (port > ENDPORT)\n\t\t\tport = STARTPORT;\n\t}\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "s",
            "sa",
            "salen"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "*alport"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "af",
            "SOCK_STREAM",
            "0"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "67-111",
          "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ss",
            "'\\0'",
            "sizeof ss"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nrresvport_af(int *alport, sa_family_t af)\n{\n\tstruct sockaddr_storage ss;\n\tstruct sockaddr *sa;\n\tu_int16_t *portp;\n\tint s;\n\tsocklen_t salen;\n\n\tmemset(&ss, '\\0', sizeof ss);\n\tsa = (struct sockaddr *)&ss;\n\n\tswitch (af) {\n\tcase AF_INET:\n\t\tsalen = sizeof(struct sockaddr_in);\n\t\tportp = &((struct sockaddr_in *)sa)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsalen = sizeof(struct sockaddr_in6);\n\t\tportp = &((struct sockaddr_in6 *)sa)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\terrno = EPFNOSUPPORT;\n\t\treturn (-1);\n\t}\n\tsa->sa_family = af;\n\t\n\ts = socket(af, SOCK_STREAM, 0);\n\tif (s < 0)\n\t\treturn (-1);\n\n\t*portp = htons(*alport);\n\tif (*alport < IPPORT_RESERVED - 1) {\n\t\tif (bind(s, sa, salen) >= 0)\n\t\t\treturn (s);\n\t\tif (errno != EADDRINUSE) {\n\t\t\t(void)close(s);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t*portp = 0;\n\tsa->sa_family = af;\n\tif (bindresvport_sa(s, sa) == -1) {\n\t\t(void)close(s);\n\t\treturn (-1);\n\t}\n\t*alport = ntohs(*portp);\n\treturn (s);\n}"
  },
  {
    "function_name": "rresvport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/rresvport.c",
    "lines": "50-54",
    "snippet": "int\nrresvport(int *alport)\n{\n\treturn rresvport_af(alport, AF_INET);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rresvport_af",
          "args": [
            "alport",
            "AF_INET"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "rresvport_af",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/rresvport.c",
          "lines": "57-106",
          "snippet": "int\nrresvport_af(int *alport, sa_family_t af)\n{\n\tstruct sockaddr_storage ss;\n\tstruct sockaddr *sa;\n\tu_int16_t *portp;\n\tint s;\n\tsocklen_t salen;\n\n\tmemset(&ss, '\\0', sizeof ss);\n\tsa = (struct sockaddr *)&ss;\n\n\tswitch (af) {\n\tcase AF_INET:\n\t\tsalen = sizeof(struct sockaddr_in);\n\t\tportp = &((struct sockaddr_in *)sa)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsalen = sizeof(struct sockaddr_in6);\n\t\tportp = &((struct sockaddr_in6 *)sa)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\terrno = EPFNOSUPPORT;\n\t\treturn (-1);\n\t}\n\tsa->sa_family = af;\n\t\n\ts = socket(af, SOCK_STREAM, 0);\n\tif (s < 0)\n\t\treturn (-1);\n\n\t*portp = htons(*alport);\n\tif (*alport < IPPORT_RESERVED - 1) {\n\t\tif (bind(s, sa, salen) >= 0)\n\t\t\treturn (s);\n\t\tif (errno != EADDRINUSE) {\n\t\t\t(void)close(s);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t*portp = 0;\n\tsa->sa_family = af;\n\tif (bindresvport_sa(s, sa) == -1) {\n\t\t(void)close(s);\n\t\treturn (-1);\n\t}\n\t*alport = ntohs(*portp);\n\treturn (s);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nrresvport_af(int *alport, sa_family_t af)\n{\n\tstruct sockaddr_storage ss;\n\tstruct sockaddr *sa;\n\tu_int16_t *portp;\n\tint s;\n\tsocklen_t salen;\n\n\tmemset(&ss, '\\0', sizeof ss);\n\tsa = (struct sockaddr *)&ss;\n\n\tswitch (af) {\n\tcase AF_INET:\n\t\tsalen = sizeof(struct sockaddr_in);\n\t\tportp = &((struct sockaddr_in *)sa)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsalen = sizeof(struct sockaddr_in6);\n\t\tportp = &((struct sockaddr_in6 *)sa)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\terrno = EPFNOSUPPORT;\n\t\treturn (-1);\n\t}\n\tsa->sa_family = af;\n\t\n\ts = socket(af, SOCK_STREAM, 0);\n\tif (s < 0)\n\t\treturn (-1);\n\n\t*portp = htons(*alport);\n\tif (*alport < IPPORT_RESERVED - 1) {\n\t\tif (bind(s, sa, salen) >= 0)\n\t\t\treturn (s);\n\t\tif (errno != EADDRINUSE) {\n\t\t\t(void)close(s);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t*portp = 0;\n\tsa->sa_family = af;\n\tif (bindresvport_sa(s, sa) == -1) {\n\t\t(void)close(s);\n\t\treturn (-1);\n\t}\n\t*alport = ntohs(*portp);\n\treturn (s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nrresvport(int *alport)\n{\n\treturn rresvport_af(alport, AF_INET);\n}"
  }
]