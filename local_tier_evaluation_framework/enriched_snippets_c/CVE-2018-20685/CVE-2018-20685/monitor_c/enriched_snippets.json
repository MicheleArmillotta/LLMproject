[
  {
    "function_name": "mm_answer_gss_userok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1877-1902",
    "snippet": "int\nmm_answer_gss_userok(int sock, struct sshbuf *m)\n{\n\tint r, authenticated;\n\tconst char *displayname;\n\n\tif (!options.gss_authentication)\n\t\tfatal(\"%s: GSSAPI authentication not enabled\", __func__);\n\n\tauthenticated = authctxt->valid && ssh_gssapi_userok(authctxt->user);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, authenticated)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"%s: sending result %d\", __func__, authenticated);\n\tmm_request_send(sock, MONITOR_ANS_GSSUSEROK, m);\n\n\tauth_method = \"gssapi-with-mic\";\n\n\tif ((displayname = ssh_gssapi_displayname()) != NULL)\n\t\tauth2_record_info(authctxt, \"%s\", displayname);\n\n\t/* Monitor loop will terminate if authenticated */\n\treturn (authenticated);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static Authctxt *authctxt;",
      "static char *auth_method = \"unknown\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "auth2_record_info",
          "args": [
            "authctxt",
            "\"%s\"",
            "displayname"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_record_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "680-695",
          "snippet": "void\nauth2_record_info(Authctxt *authctxt, const char *fmt, ...)\n{\n\tva_list ap;\n        int i;\n\n\tfree(authctxt->auth_method_info);\n\tauthctxt->auth_method_info = NULL;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(&authctxt->auth_method_info, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || authctxt->auth_method_info == NULL)\n\t\tfatal(\"%s: vasprintf failed\", __func__);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nvoid\nauth2_record_info(Authctxt *authctxt, const char *fmt, ...)\n{\n\tva_list ap;\n        int i;\n\n\tfree(authctxt->auth_method_info);\n\tauthctxt->auth_method_info = NULL;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(&authctxt->auth_method_info, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || authctxt->auth_method_info == NULL)\n\t\tfatal(\"%s: vasprintf failed\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_displayname",
          "args": [],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_displayname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "396-402",
          "snippet": "const char *ssh_gssapi_displayname(void)\n{\n\tif (gssapi_client.displayname.length == 0 ||\n\t    gssapi_client.displayname.value == NULL)\n\t\treturn NULL;\n\treturn (char *)gssapi_client.displayname.value;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *ssh_gssapi_displayname(void)\n{\n\tif (gssapi_client.displayname.length == 0 ||\n\t    gssapi_client.displayname.value == NULL)\n\t\treturn NULL;\n\treturn (char *)gssapi_client.displayname.value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_GSSUSEROK",
            "m"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: sending result %d\"",
            "__func__",
            "authenticated"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "authenticated"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_userok",
          "args": [
            "authctxt->user"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_userok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "358-383",
          "snippet": "int\nssh_gssapi_userok(char *user)\n{\n\tOM_uint32 lmin;\n\n\tif (gssapi_client.exportedname.length == 0 ||\n\t    gssapi_client.exportedname.value == NULL) {\n\t\tdebug(\"No suitable client data\");\n\t\treturn 0;\n\t}\n\tif (gssapi_client.mech && gssapi_client.mech->userok)\n\t\tif ((*gssapi_client.mech->userok)(&gssapi_client, user))\n\t\t\treturn 1;\n\t\telse {\n\t\t\t/* Destroy delegated credentials if userok fails */\n\t\t\tgss_release_buffer(&lmin, &gssapi_client.displayname);\n\t\t\tgss_release_buffer(&lmin, &gssapi_client.exportedname);\n\t\t\tgss_release_cred(&lmin, &gssapi_client.creds);\n\t\t\texplicit_bzero(&gssapi_client,\n\t\t\t    sizeof(ssh_gssapi_client));\n\t\t\treturn 0;\n\t\t}\n\telse\n\t\tdebug(\"ssh_gssapi_userok: Unknown GSSAPI mechanism\");\n\treturn (0);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_gssapi_userok(char *user)\n{\n\tOM_uint32 lmin;\n\n\tif (gssapi_client.exportedname.length == 0 ||\n\t    gssapi_client.exportedname.value == NULL) {\n\t\tdebug(\"No suitable client data\");\n\t\treturn 0;\n\t}\n\tif (gssapi_client.mech && gssapi_client.mech->userok)\n\t\tif ((*gssapi_client.mech->userok)(&gssapi_client, user))\n\t\t\treturn 1;\n\t\telse {\n\t\t\t/* Destroy delegated credentials if userok fails */\n\t\t\tgss_release_buffer(&lmin, &gssapi_client.displayname);\n\t\t\tgss_release_buffer(&lmin, &gssapi_client.exportedname);\n\t\t\tgss_release_cred(&lmin, &gssapi_client.creds);\n\t\t\texplicit_bzero(&gssapi_client,\n\t\t\t    sizeof(ssh_gssapi_client));\n\t\t\treturn 0;\n\t\t}\n\telse\n\t\tdebug(\"ssh_gssapi_userok: Unknown GSSAPI mechanism\");\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: GSSAPI authentication not enabled\"",
            "__func__"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic Authctxt *authctxt;\nstatic char *auth_method = \"unknown\";\n\nint\nmm_answer_gss_userok(int sock, struct sshbuf *m)\n{\n\tint r, authenticated;\n\tconst char *displayname;\n\n\tif (!options.gss_authentication)\n\t\tfatal(\"%s: GSSAPI authentication not enabled\", __func__);\n\n\tauthenticated = authctxt->valid && ssh_gssapi_userok(authctxt->user);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, authenticated)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"%s: sending result %d\", __func__, authenticated);\n\tmm_request_send(sock, MONITOR_ANS_GSSUSEROK, m);\n\n\tauth_method = \"gssapi-with-mic\";\n\n\tif ((displayname = ssh_gssapi_displayname()) != NULL)\n\t\tauth2_record_info(authctxt, \"%s\", displayname);\n\n\t/* Monitor loop will terminate if authenticated */\n\treturn (authenticated);\n}"
  },
  {
    "function_name": "mm_answer_gss_checkmic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1846-1875",
    "snippet": "int\nmm_answer_gss_checkmic(int sock, struct sshbuf *m)\n{\n\tgss_buffer_desc gssbuf, mic;\n\tOM_uint32 ret;\n\tint r;\n\n\tif (!options.gss_authentication)\n\t\tfatal(\"%s: GSSAPI authentication not enabled\", __func__);\n\n\tif ((r = ssh_gssapi_get_buffer_desc(m, &gssbuf)) != 0 ||\n\t    (r = ssh_gssapi_get_buffer_desc(m, &mic)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tret = ssh_gssapi_checkmic(gsscontext, &gssbuf, &mic);\n\n\tfree(gssbuf.value);\n\tfree(mic.value);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, ret)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tmm_request_send(sock, MONITOR_ANS_GSSCHECKMIC, m);\n\n\tif (!GSS_ERROR(ret))\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "monitor_permit",
          "args": [
            "mon_dispatch",
            "MONITOR_REQ_GSSUSEROK",
            "1"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "240-251",
          "snippet": "static void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_PERMIT\t0x1000\t/* Request is permitted */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n\nstatic void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GSS_ERROR",
          "args": [
            "ret"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_GSSCHECKMIC",
            "m"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "ret"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mic.value"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_checkmic",
          "args": [
            "gsscontext",
            "&gssbuf",
            "&mic"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_checkmic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "386-393",
          "snippet": "OM_uint32\nssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)\n{\n\tctx->major = gss_verify_mic(&ctx->minor, ctx->context,\n\t    gssbuf, gssmic, NULL);\n\n\treturn (ctx->major);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOM_uint32\nssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)\n{\n\tctx->major = gss_verify_mic(&ctx->minor, ctx->context,\n\t    gssbuf, gssmic, NULL);\n\n\treturn (ctx->major);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_get_buffer_desc",
          "args": [
            "m",
            "&mic"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_get_buffer_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-genr.c",
          "lines": "51-63",
          "snippet": "int\nssh_gssapi_get_buffer_desc(struct sshbuf *b, gss_buffer_desc *g)\n{\n\tint r;\n\tu_char *p;\n\tsize_t len;\n\n\tif ((r = sshbuf_get_string(b, &p, &len)) != 0)\n\t\treturn r;\n\tg->value = p;\n\tg->length = len;\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"ssh2.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"ssh2.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_gssapi_get_buffer_desc(struct sshbuf *b, gss_buffer_desc *g)\n{\n\tint r;\n\tu_char *p;\n\tsize_t len;\n\n\tif ((r = sshbuf_get_string(b, &p, &len)) != 0)\n\t\treturn r;\n\tg->value = p;\n\tg->length = len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: GSSAPI authentication not enabled\"",
            "__func__"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\n\nint\nmm_answer_gss_checkmic(int sock, struct sshbuf *m)\n{\n\tgss_buffer_desc gssbuf, mic;\n\tOM_uint32 ret;\n\tint r;\n\n\tif (!options.gss_authentication)\n\t\tfatal(\"%s: GSSAPI authentication not enabled\", __func__);\n\n\tif ((r = ssh_gssapi_get_buffer_desc(m, &gssbuf)) != 0 ||\n\t    (r = ssh_gssapi_get_buffer_desc(m, &mic)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tret = ssh_gssapi_checkmic(gsscontext, &gssbuf, &mic);\n\n\tfree(gssbuf.value);\n\tfree(mic.value);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, ret)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tmm_request_send(sock, MONITOR_ANS_GSSCHECKMIC, m);\n\n\tif (!GSS_ERROR(ret))\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_gss_accept_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1812-1844",
    "snippet": "int\nmm_answer_gss_accept_ctx(int sock, struct sshbuf *m)\n{\n\tgss_buffer_desc in;\n\tgss_buffer_desc out = GSS_C_EMPTY_BUFFER;\n\tOM_uint32 major, minor;\n\tOM_uint32 flags = 0; /* GSI needs this */\n\tint r;\n\n\tif (!options.gss_authentication)\n\t\tfatal(\"%s: GSSAPI authentication not enabled\", __func__);\n\n\tif ((r = ssh_gssapi_get_buffer_desc(m, &in)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmajor = ssh_gssapi_accept_ctx(gsscontext, &in, &out, &flags);\n\tfree(in.value);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, major)) != 0 ||\n\t    (r = sshbuf_put_string(m, out.value, out.length)) != 0 ||\n\t    (r = sshbuf_put_u32(m, flags)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_GSSSTEP, m);\n\n\tgss_release_buffer(&minor, &out);\n\n\tif (major == GSS_S_COMPLETE) {\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 0);\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSCHECKMIC, 1);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "monitor_permit",
          "args": [
            "mon_dispatch",
            "MONITOR_REQ_GSSCHECKMIC",
            "1"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "240-251",
          "snippet": "static void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_PERMIT\t0x1000\t/* Request is permitted */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n\nstatic void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gss_release_buffer",
          "args": [
            "&minor",
            "&out"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_GSSSTEP",
            "m"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "flags"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "m",
            "out.value",
            "out.length"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "in.value"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_accept_ctx",
          "args": [
            "gsscontext",
            "&in",
            "&out",
            "&flags"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_accept_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "175-208",
          "snippet": "OM_uint32\nssh_gssapi_accept_ctx(Gssctxt *ctx, gss_buffer_desc *recv_tok,\n    gss_buffer_desc *send_tok, OM_uint32 *flags)\n{\n\tOM_uint32 status;\n\tgss_OID mech;\n\n\tctx->major = gss_accept_sec_context(&ctx->minor,\n\t    &ctx->context, ctx->creds, recv_tok,\n\t    GSS_C_NO_CHANNEL_BINDINGS, &ctx->client, &mech,\n\t    send_tok, flags, NULL, &ctx->client_creds);\n\n\tif (GSS_ERROR(ctx->major))\n\t\tssh_gssapi_error(ctx);\n\n\tif (ctx->client_creds)\n\t\tdebug(\"Received some client credentials\");\n\telse\n\t\tdebug(\"Got no client credentials\");\n\n\tstatus = ctx->major;\n\n\t/* Now, if we're complete and we have the right flags, then\n\t * we flag the user as also having been authenticated\n\t */\n\n\tif (((flags == NULL) || ((*flags & GSS_C_MUTUAL_FLAG) &&\n\t    (*flags & GSS_C_INTEG_FLAG))) && (ctx->major == GSS_S_COMPLETE)) {\n\t\tif (ssh_gssapi_getclient(ctx, &gssapi_client))\n\t\t\tfatal(\"Couldn't convert client name\");\n\t}\n\n\treturn (status);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOM_uint32\nssh_gssapi_accept_ctx(Gssctxt *ctx, gss_buffer_desc *recv_tok,\n    gss_buffer_desc *send_tok, OM_uint32 *flags)\n{\n\tOM_uint32 status;\n\tgss_OID mech;\n\n\tctx->major = gss_accept_sec_context(&ctx->minor,\n\t    &ctx->context, ctx->creds, recv_tok,\n\t    GSS_C_NO_CHANNEL_BINDINGS, &ctx->client, &mech,\n\t    send_tok, flags, NULL, &ctx->client_creds);\n\n\tif (GSS_ERROR(ctx->major))\n\t\tssh_gssapi_error(ctx);\n\n\tif (ctx->client_creds)\n\t\tdebug(\"Received some client credentials\");\n\telse\n\t\tdebug(\"Got no client credentials\");\n\n\tstatus = ctx->major;\n\n\t/* Now, if we're complete and we have the right flags, then\n\t * we flag the user as also having been authenticated\n\t */\n\n\tif (((flags == NULL) || ((*flags & GSS_C_MUTUAL_FLAG) &&\n\t    (*flags & GSS_C_INTEG_FLAG))) && (ctx->major == GSS_S_COMPLETE)) {\n\t\tif (ssh_gssapi_getclient(ctx, &gssapi_client))\n\t\t\tfatal(\"Couldn't convert client name\");\n\t}\n\n\treturn (status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_get_buffer_desc",
          "args": [
            "m",
            "&in"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_get_buffer_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-genr.c",
          "lines": "51-63",
          "snippet": "int\nssh_gssapi_get_buffer_desc(struct sshbuf *b, gss_buffer_desc *g)\n{\n\tint r;\n\tu_char *p;\n\tsize_t len;\n\n\tif ((r = sshbuf_get_string(b, &p, &len)) != 0)\n\t\treturn r;\n\tg->value = p;\n\tg->length = len;\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"ssh2.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"ssh2.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_gssapi_get_buffer_desc(struct sshbuf *b, gss_buffer_desc *g)\n{\n\tint r;\n\tu_char *p;\n\tsize_t len;\n\n\tif ((r = sshbuf_get_string(b, &p, &len)) != 0)\n\t\treturn r;\n\tg->value = p;\n\tg->length = len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: GSSAPI authentication not enabled\"",
            "__func__"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\n\nint\nmm_answer_gss_accept_ctx(int sock, struct sshbuf *m)\n{\n\tgss_buffer_desc in;\n\tgss_buffer_desc out = GSS_C_EMPTY_BUFFER;\n\tOM_uint32 major, minor;\n\tOM_uint32 flags = 0; /* GSI needs this */\n\tint r;\n\n\tif (!options.gss_authentication)\n\t\tfatal(\"%s: GSSAPI authentication not enabled\", __func__);\n\n\tif ((r = ssh_gssapi_get_buffer_desc(m, &in)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmajor = ssh_gssapi_accept_ctx(gsscontext, &in, &out, &flags);\n\tfree(in.value);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, major)) != 0 ||\n\t    (r = sshbuf_put_string(m, out.value, out.length)) != 0 ||\n\t    (r = sshbuf_put_u32(m, flags)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_GSSSTEP, m);\n\n\tgss_release_buffer(&minor, &out);\n\n\tif (major == GSS_S_COMPLETE) {\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 0);\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSCHECKMIC, 1);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_gss_setup_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1779-1810",
    "snippet": "int\nmm_answer_gss_setup_ctx(int sock, struct sshbuf *m)\n{\n\tgss_OID_desc goid;\n\tOM_uint32 major;\n\tsize_t len;\n\tu_char *p;\n\tint r;\n\n\tif (!options.gss_authentication)\n\t\tfatal(\"%s: GSSAPI authentication not enabled\", __func__);\n\n\tif ((r = sshbuf_get_string(m, &p, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tgoid.elements = p;\n\tgoid.length = len;\n\n\tmajor = ssh_gssapi_server_ctx(&gsscontext, &goid);\n\n\tfree(goid.elements);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, major)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tmm_request_send(sock, MONITOR_ANS_GSSSETUP, m);\n\n\t/* Now we have a context, enable the step */\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 1);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "monitor_permit",
          "args": [
            "mon_dispatch",
            "MONITOR_REQ_GSSSTEP",
            "1"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "240-251",
          "snippet": "static void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_PERMIT\t0x1000\t/* Request is permitted */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n\nstatic void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_GSSSETUP",
            "m"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "major"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "goid.elements"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_server_ctx",
          "args": [
            "&gsscontext",
            "&goid"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_server_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "133-141",
          "snippet": "OM_uint32\nssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID oid)\n{\n\tif (*ctx)\n\t\tssh_gssapi_delete_ctx(ctx);\n\tssh_gssapi_build_ctx(ctx);\n\tssh_gssapi_set_oid(*ctx, oid);\n\treturn (ssh_gssapi_acquire_cred(*ctx));\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOM_uint32\nssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID oid)\n{\n\tif (*ctx)\n\t\tssh_gssapi_delete_ctx(ctx);\n\tssh_gssapi_build_ctx(ctx);\n\tssh_gssapi_set_oid(*ctx, oid);\n\treturn (ssh_gssapi_acquire_cred(*ctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "m",
            "&p",
            "&len"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: GSSAPI authentication not enabled\"",
            "__func__"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\n\nint\nmm_answer_gss_setup_ctx(int sock, struct sshbuf *m)\n{\n\tgss_OID_desc goid;\n\tOM_uint32 major;\n\tsize_t len;\n\tu_char *p;\n\tint r;\n\n\tif (!options.gss_authentication)\n\t\tfatal(\"%s: GSSAPI authentication not enabled\", __func__);\n\n\tif ((r = sshbuf_get_string(m, &p, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tgoid.elements = p;\n\tgoid.length = len;\n\n\tmajor = ssh_gssapi_server_ctx(&gsscontext, &goid);\n\n\tfree(goid.elements);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, major)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tmm_request_send(sock, MONITOR_ANS_GSSSETUP, m);\n\n\t/* Now we have a context, enable the step */\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 1);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "monitor_reinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1772-1776",
    "snippet": "void\nmonitor_reinit(struct monitor *mon)\n{\n\tmonitor_openfds(mon, 0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int monitor_read_log(struct monitor *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "monitor_openfds",
          "args": [
            "mon",
            "0"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_openfds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "1727-1757",
          "snippet": "static void\nmonitor_openfds(struct monitor *mon, int do_logfds)\n{\n\tint pair[2];\n#ifdef SO_ZEROIZE\n\tint on = 1;\n#endif\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)\n\t\tfatal(\"%s: socketpair: %s\", __func__, strerror(errno));\n#ifdef SO_ZEROIZE\n\tif (setsockopt(pair[0], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(0): %.100s\", strerror(errno));\n\tif (setsockopt(pair[1], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(1): %.100s\", strerror(errno));\n#endif\n\tFD_CLOSEONEXEC(pair[0]);\n\tFD_CLOSEONEXEC(pair[1]);\n\tmon->m_recvfd = pair[0];\n\tmon->m_sendfd = pair[1];\n\n\tif (do_logfds) {\n\t\tif (pipe(pair) == -1)\n\t\t\tfatal(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\tFD_CLOSEONEXEC(pair[0]);\n\t\tFD_CLOSEONEXEC(pair[1]);\n\t\tmon->m_log_recvfd = pair[0];\n\t\tmon->m_log_sendfd = pair[1];\n\t} else\n\t\tmon->m_log_recvfd = mon->m_log_sendfd = -1;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int monitor_read_log(struct monitor *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int monitor_read_log(struct monitor *);\n\nstatic void\nmonitor_openfds(struct monitor *mon, int do_logfds)\n{\n\tint pair[2];\n#ifdef SO_ZEROIZE\n\tint on = 1;\n#endif\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)\n\t\tfatal(\"%s: socketpair: %s\", __func__, strerror(errno));\n#ifdef SO_ZEROIZE\n\tif (setsockopt(pair[0], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(0): %.100s\", strerror(errno));\n\tif (setsockopt(pair[1], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(1): %.100s\", strerror(errno));\n#endif\n\tFD_CLOSEONEXEC(pair[0]);\n\tFD_CLOSEONEXEC(pair[1]);\n\tmon->m_recvfd = pair[0];\n\tmon->m_sendfd = pair[1];\n\n\tif (do_logfds) {\n\t\tif (pipe(pair) == -1)\n\t\t\tfatal(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\tFD_CLOSEONEXEC(pair[0]);\n\t\tFD_CLOSEONEXEC(pair[1]);\n\t\tmon->m_log_recvfd = pair[0];\n\t\tmon->m_log_sendfd = pair[1];\n\t} else\n\t\tmon->m_log_recvfd = mon->m_log_sendfd = -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int monitor_read_log(struct monitor *);\n\nvoid\nmonitor_reinit(struct monitor *mon)\n{\n\tmonitor_openfds(mon, 0);\n}"
  },
  {
    "function_name": "monitor_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1761-1770",
    "snippet": "struct monitor *\nmonitor_init(void)\n{\n\tstruct monitor *mon;\n\n\tmon = xcalloc(1, sizeof(*mon));\n\tmonitor_openfds(mon, 1);\n\n\treturn mon;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int monitor_read_log(struct monitor *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "monitor_openfds",
          "args": [
            "mon",
            "1"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_openfds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "1727-1757",
          "snippet": "static void\nmonitor_openfds(struct monitor *mon, int do_logfds)\n{\n\tint pair[2];\n#ifdef SO_ZEROIZE\n\tint on = 1;\n#endif\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)\n\t\tfatal(\"%s: socketpair: %s\", __func__, strerror(errno));\n#ifdef SO_ZEROIZE\n\tif (setsockopt(pair[0], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(0): %.100s\", strerror(errno));\n\tif (setsockopt(pair[1], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(1): %.100s\", strerror(errno));\n#endif\n\tFD_CLOSEONEXEC(pair[0]);\n\tFD_CLOSEONEXEC(pair[1]);\n\tmon->m_recvfd = pair[0];\n\tmon->m_sendfd = pair[1];\n\n\tif (do_logfds) {\n\t\tif (pipe(pair) == -1)\n\t\t\tfatal(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\tFD_CLOSEONEXEC(pair[0]);\n\t\tFD_CLOSEONEXEC(pair[1]);\n\t\tmon->m_log_recvfd = pair[0];\n\t\tmon->m_log_sendfd = pair[1];\n\t} else\n\t\tmon->m_log_recvfd = mon->m_log_sendfd = -1;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int monitor_read_log(struct monitor *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int monitor_read_log(struct monitor *);\n\nstatic void\nmonitor_openfds(struct monitor *mon, int do_logfds)\n{\n\tint pair[2];\n#ifdef SO_ZEROIZE\n\tint on = 1;\n#endif\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)\n\t\tfatal(\"%s: socketpair: %s\", __func__, strerror(errno));\n#ifdef SO_ZEROIZE\n\tif (setsockopt(pair[0], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(0): %.100s\", strerror(errno));\n\tif (setsockopt(pair[1], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(1): %.100s\", strerror(errno));\n#endif\n\tFD_CLOSEONEXEC(pair[0]);\n\tFD_CLOSEONEXEC(pair[1]);\n\tmon->m_recvfd = pair[0];\n\tmon->m_sendfd = pair[1];\n\n\tif (do_logfds) {\n\t\tif (pipe(pair) == -1)\n\t\t\tfatal(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\tFD_CLOSEONEXEC(pair[0]);\n\t\tFD_CLOSEONEXEC(pair[1]);\n\t\tmon->m_log_recvfd = pair[0];\n\t\tmon->m_log_sendfd = pair[1];\n\t} else\n\t\tmon->m_log_recvfd = mon->m_log_sendfd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*mon)"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int monitor_read_log(struct monitor *);\n\nstruct monitor *\nmonitor_init(void)\n{\n\tstruct monitor *mon;\n\n\tmon = xcalloc(1, sizeof(*mon));\n\tmonitor_openfds(mon, 1);\n\n\treturn mon;\n}"
  },
  {
    "function_name": "monitor_openfds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1727-1757",
    "snippet": "static void\nmonitor_openfds(struct monitor *mon, int do_logfds)\n{\n\tint pair[2];\n#ifdef SO_ZEROIZE\n\tint on = 1;\n#endif\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)\n\t\tfatal(\"%s: socketpair: %s\", __func__, strerror(errno));\n#ifdef SO_ZEROIZE\n\tif (setsockopt(pair[0], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(0): %.100s\", strerror(errno));\n\tif (setsockopt(pair[1], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(1): %.100s\", strerror(errno));\n#endif\n\tFD_CLOSEONEXEC(pair[0]);\n\tFD_CLOSEONEXEC(pair[1]);\n\tmon->m_recvfd = pair[0];\n\tmon->m_sendfd = pair[1];\n\n\tif (do_logfds) {\n\t\tif (pipe(pair) == -1)\n\t\t\tfatal(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\tFD_CLOSEONEXEC(pair[0]);\n\t\tFD_CLOSEONEXEC(pair[1]);\n\t\tmon->m_log_recvfd = pair[0];\n\t\tmon->m_log_sendfd = pair[1];\n\t} else\n\t\tmon->m_log_recvfd = mon->m_log_sendfd = -1;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int monitor_read_log(struct monitor *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FD_CLOSEONEXEC",
          "args": [
            "pair[1]"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_CLOSEONEXEC",
          "args": [
            "pair[0]"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: pipe: %s\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pair"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_CLOSEONEXEC",
          "args": [
            "pair[1]"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_CLOSEONEXEC",
          "args": [
            "pair[0]"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"setsockopt SO_ZEROIZE(1): %.100s\"",
            "strerror(errno)"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "pair[1]",
            "SOL_SOCKET",
            "SO_ZEROIZE",
            "&on",
            "sizeof(on)"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "pair[0]",
            "SOL_SOCKET",
            "SO_ZEROIZE",
            "&on",
            "sizeof(on)"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0",
            "pair"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int monitor_read_log(struct monitor *);\n\nstatic void\nmonitor_openfds(struct monitor *mon, int do_logfds)\n{\n\tint pair[2];\n#ifdef SO_ZEROIZE\n\tint on = 1;\n#endif\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)\n\t\tfatal(\"%s: socketpair: %s\", __func__, strerror(errno));\n#ifdef SO_ZEROIZE\n\tif (setsockopt(pair[0], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(0): %.100s\", strerror(errno));\n\tif (setsockopt(pair[1], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(1): %.100s\", strerror(errno));\n#endif\n\tFD_CLOSEONEXEC(pair[0]);\n\tFD_CLOSEONEXEC(pair[1]);\n\tmon->m_recvfd = pair[0];\n\tmon->m_sendfd = pair[1];\n\n\tif (do_logfds) {\n\t\tif (pipe(pair) == -1)\n\t\t\tfatal(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\tFD_CLOSEONEXEC(pair[0]);\n\t\tFD_CLOSEONEXEC(pair[1]);\n\t\tmon->m_log_recvfd = pair[0];\n\t\tmon->m_log_sendfd = pair[1];\n\t} else\n\t\tmon->m_log_recvfd = mon->m_log_sendfd = -1;\n}"
  },
  {
    "function_name": "mm_get_keystate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1707-1717",
    "snippet": "void\nmm_get_keystate(struct monitor *pmonitor)\n{\n\tdebug3(\"%s: Waiting for new keys\", __func__);\n\n\tif ((child_state = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmm_request_receive_expect(pmonitor->m_sendfd, MONITOR_REQ_KEYEXPORT,\n\t    child_state);\n\tdebug3(\"%s: GOT new keys\", __func__);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sshbuf *child_state;",
      "static int monitor_read_log(struct monitor *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: GOT new keys\"",
            "__func__"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_request_receive_expect",
          "args": [
            "pmonitor->m_sendfd",
            "MONITOR_REQ_KEYEXPORT",
            "child_state"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_receive_expect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "163-177",
          "snippet": "void\nmm_request_receive_expect(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tu_char rtype;\n\tint r;\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tmm_request_receive(sock, m);\n\tif ((r = sshbuf_get_u8(m, &rtype)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (rtype != type)\n\t\tfatal(\"%s: read: rtype %d != type %d\", __func__,\n\t\t    rtype, type);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_receive_expect(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tu_char rtype;\n\tint r;\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tmm_request_receive(sock, m);\n\tif ((r = sshbuf_get_u8(m, &rtype)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (rtype != type)\n\t\tfatal(\"%s: read: rtype %d != type %d\", __func__,\n\t\t    rtype, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *child_state;\nstatic int monitor_read_log(struct monitor *);\n\nvoid\nmm_get_keystate(struct monitor *pmonitor)\n{\n\tdebug3(\"%s: Waiting for new keys\", __func__);\n\n\tif ((child_state = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmm_request_receive_expect(pmonitor->m_sendfd, MONITOR_REQ_KEYEXPORT,\n\t    child_state);\n\tdebug3(\"%s: GOT new keys\", __func__);\n}"
  },
  {
    "function_name": "monitor_apply_keystate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1670-1703",
    "snippet": "void\nmonitor_apply_keystate(struct monitor *pmonitor)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tstruct kex *kex;\n\tint r;\n\n\tdebug3(\"%s: packet_set_state\", __func__);\n\tif ((r = ssh_packet_set_state(ssh, child_state)) != 0)\n                fatal(\"%s: packet_set_state: %s\", __func__, ssh_err(r));\n\tsshbuf_free(child_state);\n\tchild_state = NULL;\n\n\tif ((kex = ssh->kex) != NULL) {\n\t\t/* XXX set callbacks */\n#ifdef WITH_OPENSSL\n\t\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\t\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\t\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\t\tkex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif /* WITH_OPENSSL */\n\t\tkex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\t\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\t\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\t\tkex->host_key_index=&get_hostkey_index;\n\t\tkex->sign = sshd_hostkey_sign;\n\t}\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sshbuf *child_state;",
      "static int monitor_read_log(struct monitor *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "child_state"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: packet_set_state: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_set_state",
          "args": [
            "ssh",
            "child_state"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2370-2417",
          "snippet": "int\nssh_packet_set_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tconst u_char *input, *output;\n\tsize_t ilen, olen;\n\tint r;\n\n\tif ((r = kex_from_blob(m, &ssh->kex)) != 0 ||\n\t    (r = newkeys_from_blob(m, ssh, MODE_OUT)) != 0 ||\n\t    (r = newkeys_from_blob(m, ssh, MODE_IN)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->rekey_limit)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->rekey_interval)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_send.seqnr)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_send.blocks)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_send.packets)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_send.bytes)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_read.seqnr)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_read.blocks)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_read.packets)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_read.bytes)) != 0)\n\t\treturn r;\n\t/*\n\t * We set the time here so that in post-auth privsep slave we\n\t * count from the completion of the authentication.\n\t */\n\tstate->rekey_time = monotime();\n\t/* XXX ssh_set_newkeys overrides p_read.packets? XXX */\n\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0 ||\n\t    (r = ssh_set_newkeys(ssh, MODE_OUT)) != 0)\n\t\treturn r;\n\n\tif ((r = ssh_packet_set_postauth(ssh)) != 0)\n\t\treturn r;\n\n\tsshbuf_reset(state->input);\n\tsshbuf_reset(state->output);\n\tif ((r = sshbuf_get_string_direct(m, &input, &ilen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &output, &olen)) != 0 ||\n\t    (r = sshbuf_put(state->input, input, ilen)) != 0 ||\n\t    (r = sshbuf_put(state->output, output, olen)) != 0)\n\t\treturn r;\n\n\tif (sshbuf_len(m))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tdebug3(\"%s: done\", __func__);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_set_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tconst u_char *input, *output;\n\tsize_t ilen, olen;\n\tint r;\n\n\tif ((r = kex_from_blob(m, &ssh->kex)) != 0 ||\n\t    (r = newkeys_from_blob(m, ssh, MODE_OUT)) != 0 ||\n\t    (r = newkeys_from_blob(m, ssh, MODE_IN)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->rekey_limit)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->rekey_interval)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_send.seqnr)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_send.blocks)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_send.packets)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_send.bytes)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_read.seqnr)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_read.blocks)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_read.packets)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_read.bytes)) != 0)\n\t\treturn r;\n\t/*\n\t * We set the time here so that in post-auth privsep slave we\n\t * count from the completion of the authentication.\n\t */\n\tstate->rekey_time = monotime();\n\t/* XXX ssh_set_newkeys overrides p_read.packets? XXX */\n\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0 ||\n\t    (r = ssh_set_newkeys(ssh, MODE_OUT)) != 0)\n\t\treturn r;\n\n\tif ((r = ssh_packet_set_postauth(ssh)) != 0)\n\t\treturn r;\n\n\tsshbuf_reset(state->input);\n\tsshbuf_reset(state->output);\n\tif ((r = sshbuf_get_string_direct(m, &input, &ilen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &output, &olen)) != 0 ||\n\t    (r = sshbuf_put(state->input, input, ilen)) != 0 ||\n\t    (r = sshbuf_put(state->output, output, olen)) != 0)\n\t\treturn r;\n\n\tif (sshbuf_len(m))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tdebug3(\"%s: done\", __func__);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: packet_set_state\"",
            "__func__"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *child_state;\nstatic int monitor_read_log(struct monitor *);\n\nvoid\nmonitor_apply_keystate(struct monitor *pmonitor)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tstruct kex *kex;\n\tint r;\n\n\tdebug3(\"%s: packet_set_state\", __func__);\n\tif ((r = ssh_packet_set_state(ssh, child_state)) != 0)\n                fatal(\"%s: packet_set_state: %s\", __func__, ssh_err(r));\n\tsshbuf_free(child_state);\n\tchild_state = NULL;\n\n\tif ((kex = ssh->kex) != NULL) {\n\t\t/* XXX set callbacks */\n#ifdef WITH_OPENSSL\n\t\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\t\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\t\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\t\tkex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif /* WITH_OPENSSL */\n\t\tkex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\t\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\t\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\t\tkex->host_key_index=&get_hostkey_index;\n\t\tkex->sign = sshd_hostkey_sign;\n\t}\n}"
  },
  {
    "function_name": "monitor_clear_keystate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1659-1668",
    "snippet": "void\nmonitor_clear_keystate(struct monitor *pmonitor)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\n\tssh_clear_newkeys(ssh, MODE_IN);\n\tssh_clear_newkeys(ssh, MODE_OUT);\n\tsshbuf_free(child_state);\n\tchild_state = NULL;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sshbuf *child_state;",
      "static int monitor_read_log(struct monitor *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "child_state"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_clear_newkeys",
          "args": [
            "ssh",
            "MODE_OUT"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_clear_newkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "819-826",
          "snippet": "void\nssh_clear_newkeys(struct ssh *ssh, int mode)\n{\n\tif (ssh->kex && ssh->kex->newkeys[mode]) {\n\t\tkex_free_newkeys(ssh->kex->newkeys[mode]);\n\t\tssh->kex->newkeys[mode] = NULL;\n\t}\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_clear_newkeys(struct ssh *ssh, int mode)\n{\n\tif (ssh->kex && ssh->kex->newkeys[mode]) {\n\t\tkex_free_newkeys(ssh->kex->newkeys[mode]);\n\t\tssh->kex->newkeys[mode] = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *child_state;\nstatic int monitor_read_log(struct monitor *);\n\nvoid\nmonitor_clear_keystate(struct monitor *pmonitor)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\n\tssh_clear_newkeys(ssh, MODE_IN);\n\tssh_clear_newkeys(ssh, MODE_OUT);\n\tsshbuf_free(child_state);\n\tchild_state = NULL;\n}"
  },
  {
    "function_name": "mm_answer_audit_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1643-1656",
    "snippet": "int\nmm_answer_audit_command(int socket, struct sshbuf *m)\n{\n\tchar *cmd;\n\tint r;\n\n\tdebug3(\"%s entering\", __func__);\n\tif ((r = sshbuf_get_cstring(m, &cmd, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t/* sanity check command, if so how? */\n\taudit_run_command(cmd);\n\tfree(cmd);\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cmd"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_run_command",
          "args": [
            "cmd"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "audit_run_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit.c",
          "lines": "177-182",
          "snippet": "void\naudit_run_command(const char *command)\n{\n\tdebug(\"audit run command euid %d user %s command '%.200s'\", geteuid(),\n\t    audit_username(), command);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"audit.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"audit.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\naudit_run_command(const char *command)\n{\n\tdebug(\"audit run command euid %d user %s command '%.200s'\", geteuid(),\n\t    audit_username(), command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&cmd",
            "NULL"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s entering\"",
            "__func__"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\n\nint\nmm_answer_audit_command(int socket, struct sshbuf *m)\n{\n\tchar *cmd;\n\tint r;\n\n\tdebug3(\"%s entering\", __func__);\n\tif ((r = sshbuf_get_cstring(m, &cmd, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t/* sanity check command, if so how? */\n\taudit_run_command(cmd);\n\tfree(cmd);\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_audit_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1614-1641",
    "snippet": "int\nmm_answer_audit_event(int socket, struct sshbuf *m)\n{\n\tu_int n;\n\tssh_audit_event_t event;\n\tint r;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tif ((r = sshbuf_get_u32(m, &n)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tevent = (ssh_audit_event_t)n;\n\tswitch (event) {\n\tcase SSH_AUTH_FAIL_PUBKEY:\n\tcase SSH_AUTH_FAIL_HOSTBASED:\n\tcase SSH_AUTH_FAIL_GSSAPI:\n\tcase SSH_LOGIN_EXCEED_MAXTRIES:\n\tcase SSH_LOGIN_ROOT_DENIED:\n\tcase SSH_CONNECTION_CLOSE:\n\tcase SSH_INVALID_USER:\n\t\taudit_event(event);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"Audit event type %d not permitted\", event);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Audit event type %d not permitted\"",
            "event"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_event",
          "args": [
            "event"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "audit_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit.c",
          "lines": "133-138",
          "snippet": "void\naudit_event(ssh_audit_event_t event)\n{\n\tdebug(\"audit event euid %d user %s event %d (%s)\", geteuid(),\n\t    audit_username(), event, audit_event_lookup(event));\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"audit.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"audit.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\naudit_event(ssh_audit_event_t event)\n{\n\tdebug(\"audit event euid %d user %s event %d (%s)\", geteuid(),\n\t    audit_username(), event, audit_event_lookup(event));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&n"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s entering\"",
            "__func__"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\n\nint\nmm_answer_audit_event(int socket, struct sshbuf *m)\n{\n\tu_int n;\n\tssh_audit_event_t event;\n\tint r;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tif ((r = sshbuf_get_u32(m, &n)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tevent = (ssh_audit_event_t)n;\n\tswitch (event) {\n\tcase SSH_AUTH_FAIL_PUBKEY:\n\tcase SSH_AUTH_FAIL_HOSTBASED:\n\tcase SSH_AUTH_FAIL_GSSAPI:\n\tcase SSH_LOGIN_EXCEED_MAXTRIES:\n\tcase SSH_LOGIN_ROOT_DENIED:\n\tcase SSH_CONNECTION_CLOSE:\n\tcase SSH_INVALID_USER:\n\t\taudit_event(event);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"Audit event type %d not permitted\", event);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_term",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1585-1610",
    "snippet": "int\nmm_answer_term(int sock, struct sshbuf *req)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\textern struct monitor *pmonitor;\n\tint res, status;\n\n\tdebug3(\"%s: tearing down sessions\", __func__);\n\n\t/* The child is terminating */\n\tsession_destroy_all(ssh, &mm_session_close);\n\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\tsshpam_cleanup();\n#endif\n\n\twhile (waitpid(pmonitor->m_pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\texit(1);\n\n\tres = WIFEXITED(status) ? WEXITSTATUS(status) : 1;\n\n\t/* Terminate process */\n\texit(res);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static int monitor_read_log(struct monitor *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "res"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pmonitor->m_pid",
            "&status",
            "0"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpam_cleanup",
          "args": [],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "sshpam_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "649-669",
          "snippet": "void\nsshpam_cleanup(void)\n{\n\tif (sshpam_handle == NULL || (use_privsep && !mm_is_monitor()))\n\t\treturn;\n\tdebug(\"PAM: cleanup\");\n\tpam_set_item(sshpam_handle, PAM_CONV, (const void *)&null_conv);\n\tif (sshpam_session_open) {\n\t\tdebug(\"PAM: closing session\");\n\t\tpam_close_session(sshpam_handle, PAM_SILENT);\n\t\tsshpam_session_open = 0;\n\t}\n\tif (sshpam_cred_established) {\n\t\tdebug(\"PAM: deleting credentials\");\n\t\tpam_setcred(sshpam_handle, PAM_DELETE_CRED);\n\t\tsshpam_cred_established = 0;\n\t}\n\tsshpam_authenticated = 0;\n\tpam_end(sshpam_handle, sshpam_err);\n\tsshpam_handle = NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshpam_cleanup(void)\n{\n\tif (sshpam_handle == NULL || (use_privsep && !mm_is_monitor()))\n\t\treturn;\n\tdebug(\"PAM: cleanup\");\n\tpam_set_item(sshpam_handle, PAM_CONV, (const void *)&null_conv);\n\tif (sshpam_session_open) {\n\t\tdebug(\"PAM: closing session\");\n\t\tpam_close_session(sshpam_handle, PAM_SILENT);\n\t\tsshpam_session_open = 0;\n\t}\n\tif (sshpam_cred_established) {\n\t\tdebug(\"PAM: deleting credentials\");\n\t\tpam_setcred(sshpam_handle, PAM_DELETE_CRED);\n\t\tsshpam_cred_established = 0;\n\t}\n\tsshpam_authenticated = 0;\n\tpam_end(sshpam_handle, sshpam_err);\n\tsshpam_handle = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_destroy_all",
          "args": [
            "ssh",
            "&mm_session_close"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "session_destroy_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2507-2520",
          "snippet": "void\nsession_destroy_all(struct ssh *ssh, void (*closefunc)(Session *))\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used) {\n\t\t\tif (closefunc != NULL)\n\t\t\t\tclosefunc(s);\n\t\t\telse\n\t\t\t\tsession_close(ssh, s);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nvoid\nsession_destroy_all(struct ssh *ssh, void (*closefunc)(Session *))\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used) {\n\t\t\tif (closefunc != NULL)\n\t\t\t\tclosefunc(s);\n\t\t\telse\n\t\t\t\tsession_close(ssh, s);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: tearing down sessions\"",
            "__func__"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\n\nint\nmm_answer_term(int sock, struct sshbuf *req)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\textern struct monitor *pmonitor;\n\tint res, status;\n\n\tdebug3(\"%s: tearing down sessions\", __func__);\n\n\t/* The child is terminating */\n\tsession_destroy_all(ssh, &mm_session_close);\n\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\tsshpam_cleanup();\n#endif\n\n\twhile (waitpid(pmonitor->m_pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\texit(1);\n\n\tres = WIFEXITED(status) ? WEXITSTATUS(status) : 1;\n\n\t/* Terminate process */\n\texit(res);\n}"
  },
  {
    "function_name": "mm_answer_pty_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1567-1583",
    "snippet": "int\nmm_answer_pty_cleanup(int sock, struct sshbuf *m)\n{\n\tSession *s;\n\tchar *tty;\n\tint r;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tif ((r = sshbuf_get_cstring(m, &tty, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif ((s = session_by_tty(tty)) != NULL)\n\t\tmm_session_close(s);\n\tsshbuf_reset(m);\n\tfree(tty);\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tty"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_session_close",
          "args": [
            "s"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "mm_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "1486-1495",
          "snippet": "static void\nmm_session_close(Session *s)\n{\n\tdebug3(\"%s: session %d pid %ld\", __func__, s->self, (long)s->pid);\n\tif (s->ttyfd != -1) {\n\t\tdebug3(\"%s: tty %s ptyfd %d\", __func__, s->tty, s->ptyfd);\n\t\tsession_pty_cleanup2(s);\n\t}\n\tsession_unused(s->self);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmm_session_close(Session *s)\n{\n\tdebug3(\"%s: session %d pid %ld\", __func__, s->self, (long)s->pid);\n\tif (s->ttyfd != -1) {\n\t\tdebug3(\"%s: tty %s ptyfd %d\", __func__, s->tty, s->ptyfd);\n\t\tsession_pty_cleanup2(s);\n\t}\n\tsession_unused(s->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_by_tty",
          "args": [
            "tty"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "session_by_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1834-1848",
          "snippet": "Session *\nsession_by_tty(char *tty)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->ttyfd != -1 && strcmp(s->tty, tty) == 0) {\n\t\t\tdebug(\"session_by_tty: session %d tty %s\", i, tty);\n\t\t\treturn s;\n\t\t}\n\t}\n\tdebug(\"session_by_tty: unknown tty %.100s\", tty);\n\tsession_dump();\n\treturn NULL;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nSession *\nsession_by_tty(char *tty)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->ttyfd != -1 && strcmp(s->tty, tty) == 0) {\n\t\t\tdebug(\"session_by_tty: session %d tty %s\", i, tty);\n\t\t\treturn s;\n\t\t}\n\t}\n\tdebug(\"session_by_tty: unknown tty %.100s\", tty);\n\tsession_dump();\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&tty",
            "NULL"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s entering\"",
            "__func__"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\n\nint\nmm_answer_pty_cleanup(int sock, struct sshbuf *m)\n{\n\tSession *s;\n\tchar *tty;\n\tint r;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tif ((r = sshbuf_get_cstring(m, &tty, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif ((s = session_by_tty(tty)) != NULL)\n\t\tmm_session_close(s);\n\tsshbuf_reset(m);\n\tfree(tty);\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_pty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1497-1565",
    "snippet": "int\nmm_answer_pty(int sock, struct sshbuf *m)\n{\n\textern struct monitor *pmonitor;\n\tSession *s;\n\tint r, res, fd0;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tsshbuf_reset(m);\n\ts = session_new();\n\tif (s == NULL)\n\t\tgoto error;\n\ts->authctxt = authctxt;\n\ts->pw = authctxt->pw;\n\ts->pid = pmonitor->m_pid;\n\tres = pty_allocate(&s->ptyfd, &s->ttyfd, s->tty, sizeof(s->tty));\n\tif (res == 0)\n\t\tgoto error;\n\tpty_setowner(authctxt->pw, s->tty);\n\n\tif ((r = sshbuf_put_u32(m, 1)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, s->tty)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* We need to trick ttyslot */\n\tif (dup2(s->ttyfd, 0) == -1)\n\t\tfatal(\"%s: dup2\", __func__);\n\n\tmm_record_login(s, authctxt->pw);\n\n\t/* Now we can close the file descriptor again */\n\tclose(0);\n\n\t/* send messages generated by record_login */\n\tif ((r = sshbuf_put_stringb(m, loginmsg)) != 0)\n\t\tfatal(\"%s: put login message: %s\", __func__, ssh_err(r));\n\tsshbuf_reset(loginmsg);\n\n\tmm_request_send(sock, MONITOR_ANS_PTY, m);\n\n\tif (mm_send_fd(sock, s->ptyfd) == -1 ||\n\t    mm_send_fd(sock, s->ttyfd) == -1)\n\t\tfatal(\"%s: send fds failed\", __func__);\n\n\t/* make sure nothing uses fd 0 */\n\tif ((fd0 = open(_PATH_DEVNULL, O_RDONLY)) < 0)\n\t\tfatal(\"%s: open(/dev/null): %s\", __func__, strerror(errno));\n\tif (fd0 != 0)\n\t\terror(\"%s: fd0 %d != 0\", __func__, fd0);\n\n\t/* slave is not needed */\n\tclose(s->ttyfd);\n\ts->ttyfd = s->ptyfd;\n\t/* no need to dup() because nobody closes ptyfd */\n\ts->ptymaster = s->ptyfd;\n\n\tdebug3(\"%s: tty %s ptyfd %d\", __func__, s->tty, s->ttyfd);\n\n\treturn (0);\n\n error:\n\tif (s != NULL)\n\t\tmm_session_close(s);\n\tif ((r = sshbuf_put_u32(m, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_PTY, m);\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct sshbuf *loginmsg;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static int monitor_read_log(struct monitor *);",
      "static Authctxt *authctxt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_PTY",
            "m"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "0"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_session_close",
          "args": [
            "s"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "mm_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "1486-1495",
          "snippet": "static void\nmm_session_close(Session *s)\n{\n\tdebug3(\"%s: session %d pid %ld\", __func__, s->self, (long)s->pid);\n\tif (s->ttyfd != -1) {\n\t\tdebug3(\"%s: tty %s ptyfd %d\", __func__, s->tty, s->ptyfd);\n\t\tsession_pty_cleanup2(s);\n\t}\n\tsession_unused(s->self);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmm_session_close(Session *s)\n{\n\tdebug3(\"%s: session %d pid %ld\", __func__, s->self, (long)s->pid);\n\tif (s->ttyfd != -1) {\n\t\tdebug3(\"%s: tty %s ptyfd %d\", __func__, s->tty, s->ptyfd);\n\t\tsession_pty_cleanup2(s);\n\t}\n\tsession_unused(s->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: tty %s ptyfd %d\"",
            "__func__",
            "s->tty",
            "s->ttyfd"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: fd0 %d != 0\"",
            "__func__",
            "fd0"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_DEVNULL",
            "O_RDONLY"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_openfds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "1727-1757",
          "snippet": "static void\nmonitor_openfds(struct monitor *mon, int do_logfds)\n{\n\tint pair[2];\n#ifdef SO_ZEROIZE\n\tint on = 1;\n#endif\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)\n\t\tfatal(\"%s: socketpair: %s\", __func__, strerror(errno));\n#ifdef SO_ZEROIZE\n\tif (setsockopt(pair[0], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(0): %.100s\", strerror(errno));\n\tif (setsockopt(pair[1], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(1): %.100s\", strerror(errno));\n#endif\n\tFD_CLOSEONEXEC(pair[0]);\n\tFD_CLOSEONEXEC(pair[1]);\n\tmon->m_recvfd = pair[0];\n\tmon->m_sendfd = pair[1];\n\n\tif (do_logfds) {\n\t\tif (pipe(pair) == -1)\n\t\t\tfatal(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\tFD_CLOSEONEXEC(pair[0]);\n\t\tFD_CLOSEONEXEC(pair[1]);\n\t\tmon->m_log_recvfd = pair[0];\n\t\tmon->m_log_sendfd = pair[1];\n\t} else\n\t\tmon->m_log_recvfd = mon->m_log_sendfd = -1;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int monitor_read_log(struct monitor *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int monitor_read_log(struct monitor *);\n\nstatic void\nmonitor_openfds(struct monitor *mon, int do_logfds)\n{\n\tint pair[2];\n#ifdef SO_ZEROIZE\n\tint on = 1;\n#endif\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)\n\t\tfatal(\"%s: socketpair: %s\", __func__, strerror(errno));\n#ifdef SO_ZEROIZE\n\tif (setsockopt(pair[0], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(0): %.100s\", strerror(errno));\n\tif (setsockopt(pair[1], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_ZEROIZE(1): %.100s\", strerror(errno));\n#endif\n\tFD_CLOSEONEXEC(pair[0]);\n\tFD_CLOSEONEXEC(pair[1]);\n\tmon->m_recvfd = pair[0];\n\tmon->m_sendfd = pair[1];\n\n\tif (do_logfds) {\n\t\tif (pipe(pair) == -1)\n\t\t\tfatal(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\tFD_CLOSEONEXEC(pair[0]);\n\t\tFD_CLOSEONEXEC(pair[1]);\n\t\tmon->m_log_recvfd = pair[0];\n\t\tmon->m_log_sendfd = pair[1];\n\t} else\n\t\tmon->m_log_recvfd = mon->m_log_sendfd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: send fds failed\"",
            "__func__"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_send_fd",
          "args": [
            "sock",
            "s->ttyfd"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "mm_send_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_fdpass.c",
          "lines": "51-110",
          "snippet": "int\nmm_send_fd(int sock, int fd)\n{\n#if defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tchar ch = '\\0';\n\tssize_t n;\n\tstruct pollfd pfd;\n\n\tmemset(&msg, 0, sizeof(msg));\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&fd;\n\tmsg.msg_accrightslen = sizeof(fd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = (caddr_t)&cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\t*(int *)CMSG_DATA(cmsg) = fd;\n#endif\n\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\n\tpfd.fd = sock;\n\tpfd.events = POLLOUT;\n\twhile ((n = sendmsg(sock, &msg, 0)) == -1 &&\n\t    (errno == EAGAIN || errno == EINTR)) {\n\t\tdebug3(\"%s: sendmsg(%d): %s\", __func__, fd, strerror(errno));\n\t\t(void)poll(&pfd, 1, -1);\n\t}\n\tif (n == -1) {\n\t\terror(\"%s: sendmsg(%d): %s\", __func__, fd,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (n != 1) {\n\t\terror(\"%s: sendmsg: expected sent 1 got %zd\", __func__, n);\n\t\treturn -1;\n\t}\n\treturn 0;\n#else\n\terror(\"%s: file descriptor passing not supported\", __func__);\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include \"monitor_fdpass.h\"",
            "#include \"log.h\"",
            "#  include <sys/poll.h>",
            "# include <poll.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"monitor_fdpass.h\"\n#include \"log.h\"\n#  include <sys/poll.h>\n# include <poll.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmm_send_fd(int sock, int fd)\n{\n#if defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tchar ch = '\\0';\n\tssize_t n;\n\tstruct pollfd pfd;\n\n\tmemset(&msg, 0, sizeof(msg));\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&fd;\n\tmsg.msg_accrightslen = sizeof(fd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = (caddr_t)&cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\t*(int *)CMSG_DATA(cmsg) = fd;\n#endif\n\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\n\tpfd.fd = sock;\n\tpfd.events = POLLOUT;\n\twhile ((n = sendmsg(sock, &msg, 0)) == -1 &&\n\t    (errno == EAGAIN || errno == EINTR)) {\n\t\tdebug3(\"%s: sendmsg(%d): %s\", __func__, fd, strerror(errno));\n\t\t(void)poll(&pfd, 1, -1);\n\t}\n\tif (n == -1) {\n\t\terror(\"%s: sendmsg(%d): %s\", __func__, fd,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (n != 1) {\n\t\terror(\"%s: sendmsg: expected sent 1 got %zd\", __func__, n);\n\t\treturn -1;\n\t}\n\treturn 0;\n#else\n\terror(\"%s: file descriptor passing not supported\", __func__);\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "loginmsg"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "m",
            "loginmsg"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_record_login",
          "args": [
            "s",
            "authctxt->pw"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "mm_record_login",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "1460-1484",
          "snippet": "static void\nmm_record_login(Session *s, struct passwd *pw)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tsocklen_t fromlen;\n\tstruct sockaddr_storage from;\n\n\t/*\n\t * Get IP address of client. If the connection is not a socket, let\n\t * the address be 0.0.0.0.\n\t */\n\tmemset(&from, 0, sizeof(from));\n\tfromlen = sizeof(from);\n\tif (packet_connection_is_on_socket()) {\n\t\tif (getpeername(packet_get_connection_in(),\n\t\t    (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername: %.100s\", strerror(errno));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\t/* Record that there was a login on that tty from the remote host. */\n\trecord_login(s->pid, s->tty, pw->pw_name, pw->pw_uid,\n\t    session_get_remote_name_or_ip(ssh, utmp_len, options.use_dns),\n\t    (struct sockaddr *)&from, fromlen);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern u_int utmp_len;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern u_int utmp_len;\n\nstatic void\nmm_record_login(Session *s, struct passwd *pw)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tsocklen_t fromlen;\n\tstruct sockaddr_storage from;\n\n\t/*\n\t * Get IP address of client. If the connection is not a socket, let\n\t * the address be 0.0.0.0.\n\t */\n\tmemset(&from, 0, sizeof(from));\n\tfromlen = sizeof(from);\n\tif (packet_connection_is_on_socket()) {\n\t\tif (getpeername(packet_get_connection_in(),\n\t\t    (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername: %.100s\", strerror(errno));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\t/* Record that there was a login on that tty from the remote host. */\n\trecord_login(s->pid, s->tty, pw->pw_name, pw->pw_uid,\n\t    session_get_remote_name_or_ip(ssh, utmp_len, options.use_dns),\n\t    (struct sockaddr *)&from, fromlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "s->ttyfd",
            "0"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "m",
            "s->tty"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pty_setowner",
          "args": [
            "authctxt->pw",
            "s->tty"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "pty_setowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
          "lines": "164-215",
          "snippet": "void\npty_setowner(struct passwd *pw, const char *tty)\n{\n\tstruct group *grp;\n\tgid_t gid;\n\tmode_t mode;\n\tstruct stat st;\n\n\t/* Determine the group to make the owner of the tty. */\n\tgrp = getgrnam(\"tty\");\n\tgid = (grp != NULL) ? grp->gr_gid : pw->pw_gid;\n\tmode = (grp != NULL) ? 0620 : 0600;\n\n\t/*\n\t * Change owner and mode of the tty as required.\n\t * Warn but continue if filesystem is read-only and the uids match/\n\t * tty is owned by root.\n\t */\n\tif (stat(tty, &st))\n\t\tfatal(\"stat(%.100s) failed: %.100s\", tty,\n\t\t    strerror(errno));\n\n#ifdef WITH_SELINUX\n\tssh_selinux_setup_pty(pw->pw_name, tty);\n#endif\n\n\tif (st.st_uid != pw->pw_uid || st.st_gid != gid) {\n\t\tif (chown(tty, pw->pw_uid, gid) < 0) {\n\t\t\tif (errno == EROFS &&\n\t\t\t    (st.st_uid == pw->pw_uid || st.st_uid == 0))\n\t\t\t\tdebug(\"chown(%.100s, %u, %u) failed: %.100s\",\n\t\t\t\t    tty, (u_int)pw->pw_uid, (u_int)gid,\n\t\t\t\t    strerror(errno));\n\t\t\telse\n\t\t\t\tfatal(\"chown(%.100s, %u, %u) failed: %.100s\",\n\t\t\t\t    tty, (u_int)pw->pw_uid, (u_int)gid,\n\t\t\t\t    strerror(errno));\n\t\t}\n\t}\n\n\tif ((st.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) != mode) {\n\t\tif (chmod(tty, mode) < 0) {\n\t\t\tif (errno == EROFS &&\n\t\t\t    (st.st_mode & (S_IRGRP | S_IROTH)) == 0)\n\t\t\t\tdebug(\"chmod(%.100s, 0%o) failed: %.100s\",\n\t\t\t\t    tty, (u_int)mode, strerror(errno));\n\t\t\telse\n\t\t\t\tfatal(\"chmod(%.100s, 0%o) failed: %.100s\",\n\t\t\t\t    tty, (u_int)mode, strerror(errno));\n\t\t}\n\t}\n}",
          "includes": [
            "# include <AvailabilityMacros.h>",
            "# include <pty.h>",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshpty.h\"",
            "#include <unistd.h>",
            "# include <util.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\npty_setowner(struct passwd *pw, const char *tty)\n{\n\tstruct group *grp;\n\tgid_t gid;\n\tmode_t mode;\n\tstruct stat st;\n\n\t/* Determine the group to make the owner of the tty. */\n\tgrp = getgrnam(\"tty\");\n\tgid = (grp != NULL) ? grp->gr_gid : pw->pw_gid;\n\tmode = (grp != NULL) ? 0620 : 0600;\n\n\t/*\n\t * Change owner and mode of the tty as required.\n\t * Warn but continue if filesystem is read-only and the uids match/\n\t * tty is owned by root.\n\t */\n\tif (stat(tty, &st))\n\t\tfatal(\"stat(%.100s) failed: %.100s\", tty,\n\t\t    strerror(errno));\n\n#ifdef WITH_SELINUX\n\tssh_selinux_setup_pty(pw->pw_name, tty);\n#endif\n\n\tif (st.st_uid != pw->pw_uid || st.st_gid != gid) {\n\t\tif (chown(tty, pw->pw_uid, gid) < 0) {\n\t\t\tif (errno == EROFS &&\n\t\t\t    (st.st_uid == pw->pw_uid || st.st_uid == 0))\n\t\t\t\tdebug(\"chown(%.100s, %u, %u) failed: %.100s\",\n\t\t\t\t    tty, (u_int)pw->pw_uid, (u_int)gid,\n\t\t\t\t    strerror(errno));\n\t\t\telse\n\t\t\t\tfatal(\"chown(%.100s, %u, %u) failed: %.100s\",\n\t\t\t\t    tty, (u_int)pw->pw_uid, (u_int)gid,\n\t\t\t\t    strerror(errno));\n\t\t}\n\t}\n\n\tif ((st.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) != mode) {\n\t\tif (chmod(tty, mode) < 0) {\n\t\t\tif (errno == EROFS &&\n\t\t\t    (st.st_mode & (S_IRGRP | S_IROTH)) == 0)\n\t\t\t\tdebug(\"chmod(%.100s, 0%o) failed: %.100s\",\n\t\t\t\t    tty, (u_int)mode, strerror(errno));\n\t\t\telse\n\t\t\t\tfatal(\"chmod(%.100s, 0%o) failed: %.100s\",\n\t\t\t\t    tty, (u_int)mode, strerror(errno));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pty_allocate",
          "args": [
            "&s->ptyfd",
            "&s->ttyfd",
            "s->tty",
            "sizeof(s->tty)"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "pty_allocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
          "lines": "63-81",
          "snippet": "int\npty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)\n{\n\t/* openpty(3) exists in OSF/1 and some other os'es */\n\tchar *name;\n\tint i;\n\n\ti = openpty(ptyfd, ttyfd, NULL, NULL, NULL);\n\tif (i < 0) {\n\t\terror(\"openpty: %.100s\", strerror(errno));\n\t\treturn 0;\n\t}\n\tname = ttyname(*ttyfd);\n\tif (!name)\n\t\tfatal(\"openpty returns device for which ttyname fails.\");\n\n\tstrlcpy(namebuf, name, namebuflen);\t/* possible truncation */\n\treturn 1;\n}",
          "includes": [
            "# include <AvailabilityMacros.h>",
            "# include <pty.h>",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshpty.h\"",
            "#include <unistd.h>",
            "# include <util.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)\n{\n\t/* openpty(3) exists in OSF/1 and some other os'es */\n\tchar *name;\n\tint i;\n\n\ti = openpty(ptyfd, ttyfd, NULL, NULL, NULL);\n\tif (i < 0) {\n\t\terror(\"openpty: %.100s\", strerror(errno));\n\t\treturn 0;\n\t}\n\tname = ttyname(*ttyfd);\n\tif (!name)\n\t\tfatal(\"openpty returns device for which ttyname fails.\");\n\n\tstrlcpy(namebuf, name, namebuflen);\t/* possible truncation */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_new",
          "args": [],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "session_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1757-1796",
          "snippet": "Session *\nsession_new(void)\n{\n\tSession *s, *tmp;\n\n\tif (sessions_first_unused == -1) {\n\t\tif (sessions_nalloc >= options.max_sessions)\n\t\t\treturn NULL;\n\t\tdebug2(\"%s: allocate (allocated %d max %d)\",\n\t\t    __func__, sessions_nalloc, options.max_sessions);\n\t\ttmp = xrecallocarray(sessions, sessions_nalloc,\n\t\t    sessions_nalloc + 1, sizeof(*sessions));\n\t\tif (tmp == NULL) {\n\t\t\terror(\"%s: cannot allocate %d sessions\",\n\t\t\t    __func__, sessions_nalloc + 1);\n\t\t\treturn NULL;\n\t\t}\n\t\tsessions = tmp;\n\t\tsession_unused(sessions_nalloc++);\n\t}\n\n\tif (sessions_first_unused >= sessions_nalloc ||\n\t    sessions_first_unused < 0) {\n\t\tfatal(\"%s: insane first_unused %d max %d nalloc %d\",\n\t\t    __func__, sessions_first_unused, options.max_sessions,\n\t\t    sessions_nalloc);\n\t}\n\n\ts = &sessions[sessions_first_unused];\n\tif (s->used) {\n\t\tfatal(\"%s: session %d already used\",\n\t\t    __func__, sessions_first_unused);\n\t}\n\tsessions_first_unused = s->next_unused;\n\ts->used = 1;\n\ts->next_unused = -1;\n\tdebug(\"session_new: session %d\", s->self);\n\n\treturn s;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Session *session_new(void);",
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "static int sessions_first_unused = -1;",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nSession *session_new(void);\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nstatic int sessions_first_unused = -1;\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nSession *\nsession_new(void)\n{\n\tSession *s, *tmp;\n\n\tif (sessions_first_unused == -1) {\n\t\tif (sessions_nalloc >= options.max_sessions)\n\t\t\treturn NULL;\n\t\tdebug2(\"%s: allocate (allocated %d max %d)\",\n\t\t    __func__, sessions_nalloc, options.max_sessions);\n\t\ttmp = xrecallocarray(sessions, sessions_nalloc,\n\t\t    sessions_nalloc + 1, sizeof(*sessions));\n\t\tif (tmp == NULL) {\n\t\t\terror(\"%s: cannot allocate %d sessions\",\n\t\t\t    __func__, sessions_nalloc + 1);\n\t\t\treturn NULL;\n\t\t}\n\t\tsessions = tmp;\n\t\tsession_unused(sessions_nalloc++);\n\t}\n\n\tif (sessions_first_unused >= sessions_nalloc ||\n\t    sessions_first_unused < 0) {\n\t\tfatal(\"%s: insane first_unused %d max %d nalloc %d\",\n\t\t    __func__, sessions_first_unused, options.max_sessions,\n\t\t    sessions_nalloc);\n\t}\n\n\ts = &sessions[sessions_first_unused];\n\tif (s->used) {\n\t\tfatal(\"%s: session %d already used\",\n\t\t    __func__, sessions_first_unused);\n\t}\n\tsessions_first_unused = s->next_unused;\n\ts->used = 1;\n\ts->next_unused = -1;\n\tdebug(\"session_new: session %d\", s->self);\n\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct sshbuf *loginmsg;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\nstatic Authctxt *authctxt;\n\nint\nmm_answer_pty(int sock, struct sshbuf *m)\n{\n\textern struct monitor *pmonitor;\n\tSession *s;\n\tint r, res, fd0;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tsshbuf_reset(m);\n\ts = session_new();\n\tif (s == NULL)\n\t\tgoto error;\n\ts->authctxt = authctxt;\n\ts->pw = authctxt->pw;\n\ts->pid = pmonitor->m_pid;\n\tres = pty_allocate(&s->ptyfd, &s->ttyfd, s->tty, sizeof(s->tty));\n\tif (res == 0)\n\t\tgoto error;\n\tpty_setowner(authctxt->pw, s->tty);\n\n\tif ((r = sshbuf_put_u32(m, 1)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, s->tty)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* We need to trick ttyslot */\n\tif (dup2(s->ttyfd, 0) == -1)\n\t\tfatal(\"%s: dup2\", __func__);\n\n\tmm_record_login(s, authctxt->pw);\n\n\t/* Now we can close the file descriptor again */\n\tclose(0);\n\n\t/* send messages generated by record_login */\n\tif ((r = sshbuf_put_stringb(m, loginmsg)) != 0)\n\t\tfatal(\"%s: put login message: %s\", __func__, ssh_err(r));\n\tsshbuf_reset(loginmsg);\n\n\tmm_request_send(sock, MONITOR_ANS_PTY, m);\n\n\tif (mm_send_fd(sock, s->ptyfd) == -1 ||\n\t    mm_send_fd(sock, s->ttyfd) == -1)\n\t\tfatal(\"%s: send fds failed\", __func__);\n\n\t/* make sure nothing uses fd 0 */\n\tif ((fd0 = open(_PATH_DEVNULL, O_RDONLY)) < 0)\n\t\tfatal(\"%s: open(/dev/null): %s\", __func__, strerror(errno));\n\tif (fd0 != 0)\n\t\terror(\"%s: fd0 %d != 0\", __func__, fd0);\n\n\t/* slave is not needed */\n\tclose(s->ttyfd);\n\ts->ttyfd = s->ptyfd;\n\t/* no need to dup() because nobody closes ptyfd */\n\ts->ptymaster = s->ptyfd;\n\n\tdebug3(\"%s: tty %s ptyfd %d\", __func__, s->tty, s->ttyfd);\n\n\treturn (0);\n\n error:\n\tif (s != NULL)\n\t\tmm_session_close(s);\n\tif ((r = sshbuf_put_u32(m, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_PTY, m);\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_session_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1486-1495",
    "snippet": "static void\nmm_session_close(Session *s)\n{\n\tdebug3(\"%s: session %d pid %ld\", __func__, s->self, (long)s->pid);\n\tif (s->ttyfd != -1) {\n\t\tdebug3(\"%s: tty %s ptyfd %d\", __func__, s->tty, s->ptyfd);\n\t\tsession_pty_cleanup2(s);\n\t}\n\tsession_unused(s->self);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_unused",
          "args": [
            "s->self"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "session_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1736-1755",
          "snippet": "void\nsession_unused(int id)\n{\n\tdebug3(\"%s: session id %d unused\", __func__, id);\n\tif (id >= options.max_sessions ||\n\t    id >= sessions_nalloc) {\n\t\tfatal(\"%s: insane session id %d (max %d nalloc %d)\",\n\t\t    __func__, id, options.max_sessions, sessions_nalloc);\n\t}\n\tmemset(&sessions[id], 0, sizeof(*sessions));\n\tsessions[id].self = id;\n\tsessions[id].used = 0;\n\tsessions[id].chanid = -1;\n\tsessions[id].ptyfd = -1;\n\tsessions[id].ttyfd = -1;\n\tsessions[id].ptymaster = -1;\n\tsessions[id].x11_chanids = NULL;\n\tsessions[id].next_unused = sessions_first_unused;\n\tsessions_first_unused = id;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "static int sessions_first_unused = -1;",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nstatic int sessions_first_unused = -1;\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nvoid\nsession_unused(int id)\n{\n\tdebug3(\"%s: session id %d unused\", __func__, id);\n\tif (id >= options.max_sessions ||\n\t    id >= sessions_nalloc) {\n\t\tfatal(\"%s: insane session id %d (max %d nalloc %d)\",\n\t\t    __func__, id, options.max_sessions, sessions_nalloc);\n\t}\n\tmemset(&sessions[id], 0, sizeof(*sessions));\n\tsessions[id].self = id;\n\tsessions[id].used = 0;\n\tsessions[id].chanid = -1;\n\tsessions[id].ptyfd = -1;\n\tsessions[id].ttyfd = -1;\n\tsessions[id].ptymaster = -1;\n\tsessions[id].x11_chanids = NULL;\n\tsessions[id].next_unused = sessions_first_unused;\n\tsessions_first_unused = id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_pty_cleanup2",
          "args": [
            "s"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "session_pty_cleanup2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2261-2292",
          "snippet": "void\nsession_pty_cleanup2(Session *s)\n{\n\tif (s == NULL) {\n\t\terror(\"%s: no session\", __func__);\n\t\treturn;\n\t}\n\tif (s->ttyfd == -1)\n\t\treturn;\n\n\tdebug(\"%s: session %d release %s\", __func__, s->self, s->tty);\n\n\t/* Record that the user has logged out. */\n\tif (s->pid != 0)\n\t\trecord_logout(s->pid, s->tty, s->pw->pw_name);\n\n\t/* Release the pseudo-tty. */\n\tif (getuid() == 0)\n\t\tpty_release(s->tty);\n\n\t/*\n\t * Close the server side of the socket pairs.  We must do this after\n\t * the pty cleanup, so that another process doesn't get this pty\n\t * while we're still cleaning up.\n\t */\n\tif (s->ptymaster != -1 && close(s->ptymaster) < 0)\n\t\terror(\"close(s->ptymaster/%d): %s\",\n\t\t    s->ptymaster, strerror(errno));\n\n\t/* unlink pty from session */\n\ts->ttyfd = -1;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_pty_cleanup2(Session *s)\n{\n\tif (s == NULL) {\n\t\terror(\"%s: no session\", __func__);\n\t\treturn;\n\t}\n\tif (s->ttyfd == -1)\n\t\treturn;\n\n\tdebug(\"%s: session %d release %s\", __func__, s->self, s->tty);\n\n\t/* Record that the user has logged out. */\n\tif (s->pid != 0)\n\t\trecord_logout(s->pid, s->tty, s->pw->pw_name);\n\n\t/* Release the pseudo-tty. */\n\tif (getuid() == 0)\n\t\tpty_release(s->tty);\n\n\t/*\n\t * Close the server side of the socket pairs.  We must do this after\n\t * the pty cleanup, so that another process doesn't get this pty\n\t * while we're still cleaning up.\n\t */\n\tif (s->ptymaster != -1 && close(s->ptymaster) < 0)\n\t\terror(\"close(s->ptymaster/%d): %s\",\n\t\t    s->ptymaster, strerror(errno));\n\n\t/* unlink pty from session */\n\ts->ttyfd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: tty %s ptyfd %d\"",
            "__func__",
            "s->tty",
            "s->ptyfd"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmm_session_close(Session *s)\n{\n\tdebug3(\"%s: session %d pid %ld\", __func__, s->self, (long)s->pid);\n\tif (s->ttyfd != -1) {\n\t\tdebug3(\"%s: tty %s ptyfd %d\", __func__, s->tty, s->ptyfd);\n\t\tsession_pty_cleanup2(s);\n\t}\n\tsession_unused(s->self);\n}"
  },
  {
    "function_name": "mm_record_login",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1460-1484",
    "snippet": "static void\nmm_record_login(Session *s, struct passwd *pw)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tsocklen_t fromlen;\n\tstruct sockaddr_storage from;\n\n\t/*\n\t * Get IP address of client. If the connection is not a socket, let\n\t * the address be 0.0.0.0.\n\t */\n\tmemset(&from, 0, sizeof(from));\n\tfromlen = sizeof(from);\n\tif (packet_connection_is_on_socket()) {\n\t\tif (getpeername(packet_get_connection_in(),\n\t\t    (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername: %.100s\", strerror(errno));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\t/* Record that there was a login on that tty from the remote host. */\n\trecord_login(s->pid, s->tty, pw->pw_name, pw->pw_uid,\n\t    session_get_remote_name_or_ip(ssh, utmp_len, options.use_dns),\n\t    (struct sockaddr *)&from, fromlen);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "extern u_int utmp_len;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "record_login",
          "args": [
            "s->pid",
            "s->tty",
            "pw->pw_name",
            "pw->pw_uid",
            "session_get_remote_name_or_ip(ssh, utmp_len, options.use_dns)",
            "(struct sockaddr *)&from",
            "fromlen"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "record_login",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshlogin.c",
          "lines": "132-145",
          "snippet": "void\nrecord_login(pid_t pid, const char *tty, const char *user, uid_t uid,\n    const char *host, struct sockaddr *addr, socklen_t addrlen)\n{\n\tstruct logininfo *li;\n\n\t/* save previous login details before writing new */\n\tstore_lastlog_message(user, uid);\n\n\tli = login_alloc_entry(pid, user, host, tty);\n\tlogin_set_addr(li, addr, addrlen);\n\tlogin_login(li);\n\tlogin_free_entry(li);\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshlogin.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssherr.h\"\n#include \"sshlogin.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nrecord_login(pid_t pid, const char *tty, const char *user, uid_t uid,\n    const char *host, struct sockaddr *addr, socklen_t addrlen)\n{\n\tstruct logininfo *li;\n\n\t/* save previous login details before writing new */\n\tstore_lastlog_message(user, uid);\n\n\tli = login_alloc_entry(pid, user, host, tty);\n\tlogin_set_addr(li, addr, addrlen);\n\tlogin_login(li);\n\tlogin_free_entry(li);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_get_remote_name_or_ip",
          "args": [
            "ssh",
            "utmp_len",
            "options.use_dns"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "session_get_remote_name_or_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2703-2713",
          "snippet": "const char *\nsession_get_remote_name_or_ip(struct ssh *ssh, u_int utmp_size, int use_dns)\n{\n\tconst char *remote = \"\";\n\n\tif (utmp_size > 0)\n\t\tremote = auth_get_canonical_hostname(ssh, use_dns);\n\tif (utmp_size == 0 || strlen(remote) > utmp_size)\n\t\tremote = ssh_remote_ipaddr(ssh);\n\treturn remote;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsession_get_remote_name_or_ip(struct ssh *ssh, u_int utmp_size, int use_dns)\n{\n\tconst char *remote = \"\";\n\n\tif (utmp_size > 0)\n\t\tremote = auth_get_canonical_hostname(ssh, use_dns);\n\tif (utmp_size == 0 || strlen(remote) > utmp_size)\n\t\tremote = ssh_remote_ipaddr(ssh);\n\treturn remote;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_exit",
          "args": [
            "255"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"getpeername: %.100s\"",
            "strerror(errno)"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "packet_get_connection_in()",
            "(struct sockaddr *)&from",
            "&fromlen"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_connection_in",
          "args": [],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_connection_is_on_socket",
          "args": [],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&from",
            "0",
            "sizeof(from)"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern u_int utmp_len;\n\nstatic void\nmm_record_login(Session *s, struct passwd *pw)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tsocklen_t fromlen;\n\tstruct sockaddr_storage from;\n\n\t/*\n\t * Get IP address of client. If the connection is not a socket, let\n\t * the address be 0.0.0.0.\n\t */\n\tmemset(&from, 0, sizeof(from));\n\tfromlen = sizeof(from);\n\tif (packet_connection_is_on_socket()) {\n\t\tif (getpeername(packet_get_connection_in(),\n\t\t    (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername: %.100s\", strerror(errno));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\t/* Record that there was a login on that tty from the remote host. */\n\trecord_login(s->pid, s->tty, pw->pw_name, pw->pw_uid,\n\t    session_get_remote_name_or_ip(ssh, utmp_len, options.use_dns),\n\t    (struct sockaddr *)&from, fromlen);\n}"
  },
  {
    "function_name": "mm_answer_keyverify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1386-1458",
    "snippet": "int\nmm_answer_keyverify(int sock, struct sshbuf *m)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tstruct sshkey *key;\n\tu_char *signature, *data, *blob;\n\tchar *sigalg;\n\tsize_t signaturelen, datalen, bloblen;\n\tint r, ret, valid_data = 0, encoded_ret;\n\n\tif ((r = sshbuf_get_string(m, &blob, &bloblen)) != 0 ||\n\t    (r = sshbuf_get_string(m, &signature, &signaturelen)) != 0 ||\n\t    (r = sshbuf_get_string(m, &data, &datalen)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &sigalg, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (hostbased_cuser == NULL || hostbased_chost == NULL ||\n\t  !monitor_allowed_key(blob, bloblen))\n\t\tfatal(\"%s: bad key, not previously allowed\", __func__);\n\n\t/* Empty signature algorithm means NULL. */\n\tif (*sigalg == '\\0') {\n\t\tfree(sigalg);\n\t\tsigalg = NULL;\n\t}\n\n\t/* XXX use sshkey_froms here; need to change key_blob, etc. */\n\tif ((r = sshkey_from_blob(blob, bloblen, &key)) != 0)\n\t\tfatal(\"%s: bad public key blob: %s\", __func__, ssh_err(r));\n\n\tswitch (key_blobtype) {\n\tcase MM_USERKEY:\n\t\tvalid_data = monitor_valid_userblob(data, datalen);\n\t\tauth_method = \"publickey\";\n\t\tbreak;\n\tcase MM_HOSTKEY:\n\t\tvalid_data = monitor_valid_hostbasedblob(data, datalen,\n\t\t    hostbased_cuser, hostbased_chost);\n\t\tauth_method = \"hostbased\";\n\t\tbreak;\n\tdefault:\n\t\tvalid_data = 0;\n\t\tbreak;\n\t}\n\tif (!valid_data)\n\t\tfatal(\"%s: bad signature data blob\", __func__);\n\n\tret = sshkey_verify(key, signature, signaturelen, data, datalen,\n\t    sigalg, active_state->compat);\n\tdebug3(\"%s: %s %p signature %s\", __func__, auth_method, key,\n\t    (ret == 0) ? \"verified\" : \"unverified\");\n\tauth2_record_key(authctxt, ret == 0, key);\n\n\tfree(blob);\n\tfree(signature);\n\tfree(data);\n\tfree(sigalg);\n\n\tif (key_blobtype == MM_USERKEY)\n\t\tauth_activate_options(ssh, key_opts);\n\tmonitor_reset_key_state();\n\n\tsshkey_free(key);\n\tsshbuf_reset(m);\n\n\t/* encode ret != 0 as positive integer, since we're sending u32 */\n\tencoded_ret = (ret != 0);\n\tif ((r = sshbuf_put_u32(m, encoded_ret)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_KEYVERIFY, m);\n\n\treturn ret == 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static Authctxt *authctxt;",
      "static u_char *key_blob = NULL;",
      "static int key_blobtype = MM_NOKEY;",
      "static struct sshauthopt *key_opts = NULL;",
      "static char *hostbased_cuser = NULL;",
      "static char *hostbased_chost = NULL;",
      "static char *auth_method = \"unknown\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_KEYVERIFY",
            "m"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "encoded_ret"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_reset_key_state",
          "args": [],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_reset_key_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "550-564",
          "snippet": "static void\nmonitor_reset_key_state(void)\n{\n\t/* reset state */\n\tfree(key_blob);\n\tfree(hostbased_cuser);\n\tfree(hostbased_chost);\n\tsshauthopt_free(key_opts);\n\tkey_blob = NULL;\n\tkey_bloblen = 0;\n\tkey_blobtype = MM_NOKEY;\n\tkey_opts = NULL;\n\thostbased_cuser = NULL;\n\thostbased_chost = NULL;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u_char *key_blob = NULL;",
            "static size_t key_bloblen = 0;",
            "static int key_blobtype = MM_NOKEY;",
            "static struct sshauthopt *key_opts = NULL;",
            "static char *hostbased_cuser = NULL;",
            "static char *hostbased_chost = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_char *key_blob = NULL;\nstatic size_t key_bloblen = 0;\nstatic int key_blobtype = MM_NOKEY;\nstatic struct sshauthopt *key_opts = NULL;\nstatic char *hostbased_cuser = NULL;\nstatic char *hostbased_chost = NULL;\n\nstatic void\nmonitor_reset_key_state(void)\n{\n\t/* reset state */\n\tfree(key_blob);\n\tfree(hostbased_cuser);\n\tfree(hostbased_chost);\n\tsshauthopt_free(key_opts);\n\tkey_blob = NULL;\n\tkey_bloblen = 0;\n\tkey_blobtype = MM_NOKEY;\n\tkey_opts = NULL;\n\thostbased_cuser = NULL;\n\thostbased_chost = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_activate_options",
          "args": [
            "ssh",
            "key_opts"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "auth_activate_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "1077-1089",
          "snippet": "int\nauth_activate_options(struct ssh *ssh, struct sshauthopt *opts)\n{\n\tstruct sshauthopt *old = auth_opts;\n\tconst char *emsg = NULL;\n\n\tdebug(\"%s: setting new authentication options\", __func__);\n\tif ((auth_opts = sshauthopt_merge(old, opts, &emsg)) == NULL) {\n\t\terror(\"Inconsistent authentication options: %s\", emsg);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern struct sshauthopt *auth_opts;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nint\nauth_activate_options(struct ssh *ssh, struct sshauthopt *opts)\n{\n\tstruct sshauthopt *old = auth_opts;\n\tconst char *emsg = NULL;\n\n\tdebug(\"%s: setting new authentication options\", __func__);\n\tif ((auth_opts = sshauthopt_merge(old, opts, &emsg)) == NULL) {\n\t\terror(\"Inconsistent authentication options: %s\", emsg);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sigalg"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_record_key",
          "args": [
            "authctxt",
            "ret == 0",
            "key"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_record_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "702-728",
          "snippet": "void\nauth2_record_key(Authctxt *authctxt, int authenticated,\n    const struct sshkey *key)\n{\n\tstruct sshkey **tmp, *dup;\n\tint r;\n\n\tif ((r = sshkey_from_private(key, &dup)) != 0)\n\t\tfatal(\"%s: copy key: %s\", __func__, ssh_err(r));\n\tsshkey_free(authctxt->auth_method_key);\n\tauthctxt->auth_method_key = dup;\n\n\tif (!authenticated)\n\t\treturn;\n\n\t/* If authenticated, make sure we don't accept this key again */\n\tif ((r = sshkey_from_private(key, &dup)) != 0)\n\t\tfatal(\"%s: copy key: %s\", __func__, ssh_err(r));\n\tif (authctxt->nprev_keys >= INT_MAX ||\n\t    (tmp = recallocarray(authctxt->prev_keys, authctxt->nprev_keys,\n\t    authctxt->nprev_keys + 1, sizeof(*authctxt->prev_keys))) == NULL)\n\t\tfatal(\"%s: reallocarray failed\", __func__);\n\tauthctxt->prev_keys = tmp;\n\tauthctxt->prev_keys[authctxt->nprev_keys] = dup;\n\tauthctxt->nprev_keys++;\n\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nvoid\nauth2_record_key(Authctxt *authctxt, int authenticated,\n    const struct sshkey *key)\n{\n\tstruct sshkey **tmp, *dup;\n\tint r;\n\n\tif ((r = sshkey_from_private(key, &dup)) != 0)\n\t\tfatal(\"%s: copy key: %s\", __func__, ssh_err(r));\n\tsshkey_free(authctxt->auth_method_key);\n\tauthctxt->auth_method_key = dup;\n\n\tif (!authenticated)\n\t\treturn;\n\n\t/* If authenticated, make sure we don't accept this key again */\n\tif ((r = sshkey_from_private(key, &dup)) != 0)\n\t\tfatal(\"%s: copy key: %s\", __func__, ssh_err(r));\n\tif (authctxt->nprev_keys >= INT_MAX ||\n\t    (tmp = recallocarray(authctxt->prev_keys, authctxt->nprev_keys,\n\t    authctxt->nprev_keys + 1, sizeof(*authctxt->prev_keys))) == NULL)\n\t\tfatal(\"%s: reallocarray failed\", __func__);\n\tauthctxt->prev_keys = tmp;\n\tauthctxt->prev_keys[authctxt->nprev_keys] = dup;\n\tauthctxt->nprev_keys++;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: %s %p signature %s\"",
            "__func__",
            "auth_method",
            "key",
            "(ret == 0) ? \"verified\" : \"unverified\""
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_verify",
          "args": [
            "key",
            "signature",
            "signaturelen",
            "data",
            "datalen",
            "sigalg",
            "active_state->compat"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2427-2459",
          "snippet": "int\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: bad signature data blob\"",
            "__func__"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_valid_hostbasedblob",
          "args": [
            "data",
            "datalen",
            "hostbased_cuser",
            "hostbased_chost"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_valid_hostbasedblob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "1316-1384",
          "snippet": "static int\nmonitor_valid_hostbasedblob(u_char *data, u_int datalen, char *cuser,\n    char *chost)\n{\n\tstruct sshbuf *b;\n\tconst u_char *p;\n\tchar *cp, *userstyle;\n\tsize_t len;\n\tint r, fail = 0;\n\tu_char type;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put(b, data, datalen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &p, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif ((session_id2 == NULL) ||\n\t    (len != session_id2_len) ||\n\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\tfail++;\n\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t    authctxt->style ? \":\" : \"\",\n\t    authctxt->style ? authctxt->style : \"\");\n\tif (strcmp(userstyle, cp) != 0) {\n\t\tlogit(\"wrong user name passed to monitor: \"\n\t\t    \"expected %s != %.100s\", userstyle, cp);\n\t\tfail++;\n\t}\n\tfree(userstyle);\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* service */\n\t    (r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(cp, \"hostbased\") != 0)\n\t\tfail++;\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* pkalg */\n\t    (r = sshbuf_skip_string(b)) != 0)\t/* pkblob */\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* verify client host, strip trailing dot if necessary */\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (((len = strlen(cp)) > 0) && cp[len - 1] == '.')\n\t\tcp[len - 1] = '\\0';\n\tif (strcmp(cp, chost) != 0)\n\t\tfail++;\n\tfree(cp);\n\n\t/* verify client user */\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(cp, cuser) != 0)\n\t\tfail++;\n\tfree(cp);\n\n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\treturn (fail == 0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int mm_answer_moduli(int, struct sshbuf *);",
            "int mm_answer_sign(int, struct sshbuf *);",
            "int mm_answer_pwnamallow(int, struct sshbuf *);",
            "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
            "int mm_answer_authserv(int, struct sshbuf *);",
            "int mm_answer_authpassword(int, struct sshbuf *);",
            "int mm_answer_bsdauthquery(int, struct sshbuf *);",
            "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
            "int mm_answer_keyallowed(int, struct sshbuf *);",
            "int mm_answer_keyverify(int, struct sshbuf *);",
            "int mm_answer_pty(int, struct sshbuf *);",
            "int mm_answer_pty_cleanup(int, struct sshbuf *);",
            "int mm_answer_term(int, struct sshbuf *);",
            "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
            "int mm_answer_rsa_challenge(int, struct sshbuf *);",
            "int mm_answer_rsa_response(int, struct sshbuf *);",
            "int mm_answer_sesskey(int, struct sshbuf *);",
            "int mm_answer_sessid(int, struct sshbuf *);",
            "static int monitor_read_log(struct monitor *);",
            "static Authctxt *authctxt;",
            "static u_int session_id2_len = 0;",
            "static u_char *session_id2 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\nstatic Authctxt *authctxt;\nstatic u_int session_id2_len = 0;\nstatic u_char *session_id2 = NULL;\n\nstatic int\nmonitor_valid_hostbasedblob(u_char *data, u_int datalen, char *cuser,\n    char *chost)\n{\n\tstruct sshbuf *b;\n\tconst u_char *p;\n\tchar *cp, *userstyle;\n\tsize_t len;\n\tint r, fail = 0;\n\tu_char type;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put(b, data, datalen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &p, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif ((session_id2 == NULL) ||\n\t    (len != session_id2_len) ||\n\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\tfail++;\n\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t    authctxt->style ? \":\" : \"\",\n\t    authctxt->style ? authctxt->style : \"\");\n\tif (strcmp(userstyle, cp) != 0) {\n\t\tlogit(\"wrong user name passed to monitor: \"\n\t\t    \"expected %s != %.100s\", userstyle, cp);\n\t\tfail++;\n\t}\n\tfree(userstyle);\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* service */\n\t    (r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(cp, \"hostbased\") != 0)\n\t\tfail++;\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* pkalg */\n\t    (r = sshbuf_skip_string(b)) != 0)\t/* pkblob */\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* verify client host, strip trailing dot if necessary */\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (((len = strlen(cp)) > 0) && cp[len - 1] == '.')\n\t\tcp[len - 1] = '\\0';\n\tif (strcmp(cp, chost) != 0)\n\t\tfail++;\n\tfree(cp);\n\n\t/* verify client user */\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(cp, cuser) != 0)\n\t\tfail++;\n\tfree(cp);\n\n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\treturn (fail == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_valid_userblob",
          "args": [
            "data",
            "datalen"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_valid_userblob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "1249-1314",
          "snippet": "static int\nmonitor_valid_userblob(u_char *data, u_int datalen)\n{\n\tstruct sshbuf *b;\n\tconst u_char *p;\n\tchar *userstyle, *cp;\n\tsize_t len;\n\tu_char type;\n\tint r, fail = 0;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put(b, data, datalen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (datafellows & SSH_OLD_SESSIONID) {\n\t\tp = sshbuf_ptr(b);\n\t\tlen = sshbuf_len(b);\n\t\tif ((session_id2 == NULL) ||\n\t\t    (len < session_id2_len) ||\n\t\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\t\tfail++;\n\t\tif ((r = sshbuf_consume(b, session_id2_len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshbuf_get_string_direct(b, &p, &len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif ((session_id2 == NULL) ||\n\t\t    (len != session_id2_len) ||\n\t\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\t\tfail++;\n\t}\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t    authctxt->style ? \":\" : \"\",\n\t    authctxt->style ? authctxt->style : \"\");\n\tif (strcmp(userstyle, cp) != 0) {\n\t\tlogit(\"wrong user name passed to monitor: \"\n\t\t    \"expected %s != %.100s\", userstyle, cp);\n\t\tfail++;\n\t}\n\tfree(userstyle);\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* service */\n\t    (r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(\"publickey\", cp) != 0)\n\t\tfail++;\n\tfree(cp);\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type == 0)\n\t\tfail++;\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* pkalg */\n\t    (r = sshbuf_skip_string(b)) != 0)\t/* pkblob */\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\treturn (fail == 0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int mm_answer_moduli(int, struct sshbuf *);",
            "int mm_answer_sign(int, struct sshbuf *);",
            "int mm_answer_pwnamallow(int, struct sshbuf *);",
            "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
            "int mm_answer_authserv(int, struct sshbuf *);",
            "int mm_answer_authpassword(int, struct sshbuf *);",
            "int mm_answer_bsdauthquery(int, struct sshbuf *);",
            "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
            "int mm_answer_keyallowed(int, struct sshbuf *);",
            "int mm_answer_keyverify(int, struct sshbuf *);",
            "int mm_answer_pty(int, struct sshbuf *);",
            "int mm_answer_pty_cleanup(int, struct sshbuf *);",
            "int mm_answer_term(int, struct sshbuf *);",
            "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
            "int mm_answer_rsa_challenge(int, struct sshbuf *);",
            "int mm_answer_rsa_response(int, struct sshbuf *);",
            "int mm_answer_sesskey(int, struct sshbuf *);",
            "int mm_answer_sessid(int, struct sshbuf *);",
            "static int monitor_read_log(struct monitor *);",
            "static Authctxt *authctxt;",
            "static u_int session_id2_len = 0;",
            "static u_char *session_id2 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\nstatic Authctxt *authctxt;\nstatic u_int session_id2_len = 0;\nstatic u_char *session_id2 = NULL;\n\nstatic int\nmonitor_valid_userblob(u_char *data, u_int datalen)\n{\n\tstruct sshbuf *b;\n\tconst u_char *p;\n\tchar *userstyle, *cp;\n\tsize_t len;\n\tu_char type;\n\tint r, fail = 0;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put(b, data, datalen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (datafellows & SSH_OLD_SESSIONID) {\n\t\tp = sshbuf_ptr(b);\n\t\tlen = sshbuf_len(b);\n\t\tif ((session_id2 == NULL) ||\n\t\t    (len < session_id2_len) ||\n\t\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\t\tfail++;\n\t\tif ((r = sshbuf_consume(b, session_id2_len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshbuf_get_string_direct(b, &p, &len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif ((session_id2 == NULL) ||\n\t\t    (len != session_id2_len) ||\n\t\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\t\tfail++;\n\t}\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t    authctxt->style ? \":\" : \"\",\n\t    authctxt->style ? authctxt->style : \"\");\n\tif (strcmp(userstyle, cp) != 0) {\n\t\tlogit(\"wrong user name passed to monitor: \"\n\t\t    \"expected %s != %.100s\", userstyle, cp);\n\t\tfail++;\n\t}\n\tfree(userstyle);\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* service */\n\t    (r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(\"publickey\", cp) != 0)\n\t\tfail++;\n\tfree(cp);\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type == 0)\n\t\tfail++;\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* pkalg */\n\t    (r = sshbuf_skip_string(b)) != 0)\t/* pkblob */\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\treturn (fail == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob",
          "args": [
            "blob",
            "bloblen",
            "&key"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2263-2274",
          "snippet": "int\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_allowed_key",
          "args": [
            "blob",
            "bloblen"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_allowed_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "540-548",
          "snippet": "static int\nmonitor_allowed_key(u_char *blob, u_int bloblen)\n{\n\t/* make sure key is allowed */\n\tif (key_blob == NULL || key_bloblen != bloblen ||\n\t    timingsafe_bcmp(key_blob, blob, key_bloblen))\n\t\treturn (0);\n\treturn (1);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u_char *key_blob = NULL;",
            "static size_t key_bloblen = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_char *key_blob = NULL;\nstatic size_t key_bloblen = 0;\n\nstatic int\nmonitor_allowed_key(u_char *blob, u_int bloblen)\n{\n\t/* make sure key is allowed */\n\tif (key_blob == NULL || key_bloblen != bloblen ||\n\t    timingsafe_bcmp(key_blob, blob, key_bloblen))\n\t\treturn (0);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&sigalg",
            "NULL"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "m",
            "&data",
            "&datalen"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic Authctxt *authctxt;\nstatic u_char *key_blob = NULL;\nstatic int key_blobtype = MM_NOKEY;\nstatic struct sshauthopt *key_opts = NULL;\nstatic char *hostbased_cuser = NULL;\nstatic char *hostbased_chost = NULL;\nstatic char *auth_method = \"unknown\";\n\nint\nmm_answer_keyverify(int sock, struct sshbuf *m)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tstruct sshkey *key;\n\tu_char *signature, *data, *blob;\n\tchar *sigalg;\n\tsize_t signaturelen, datalen, bloblen;\n\tint r, ret, valid_data = 0, encoded_ret;\n\n\tif ((r = sshbuf_get_string(m, &blob, &bloblen)) != 0 ||\n\t    (r = sshbuf_get_string(m, &signature, &signaturelen)) != 0 ||\n\t    (r = sshbuf_get_string(m, &data, &datalen)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &sigalg, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (hostbased_cuser == NULL || hostbased_chost == NULL ||\n\t  !monitor_allowed_key(blob, bloblen))\n\t\tfatal(\"%s: bad key, not previously allowed\", __func__);\n\n\t/* Empty signature algorithm means NULL. */\n\tif (*sigalg == '\\0') {\n\t\tfree(sigalg);\n\t\tsigalg = NULL;\n\t}\n\n\t/* XXX use sshkey_froms here; need to change key_blob, etc. */\n\tif ((r = sshkey_from_blob(blob, bloblen, &key)) != 0)\n\t\tfatal(\"%s: bad public key blob: %s\", __func__, ssh_err(r));\n\n\tswitch (key_blobtype) {\n\tcase MM_USERKEY:\n\t\tvalid_data = monitor_valid_userblob(data, datalen);\n\t\tauth_method = \"publickey\";\n\t\tbreak;\n\tcase MM_HOSTKEY:\n\t\tvalid_data = monitor_valid_hostbasedblob(data, datalen,\n\t\t    hostbased_cuser, hostbased_chost);\n\t\tauth_method = \"hostbased\";\n\t\tbreak;\n\tdefault:\n\t\tvalid_data = 0;\n\t\tbreak;\n\t}\n\tif (!valid_data)\n\t\tfatal(\"%s: bad signature data blob\", __func__);\n\n\tret = sshkey_verify(key, signature, signaturelen, data, datalen,\n\t    sigalg, active_state->compat);\n\tdebug3(\"%s: %s %p signature %s\", __func__, auth_method, key,\n\t    (ret == 0) ? \"verified\" : \"unverified\");\n\tauth2_record_key(authctxt, ret == 0, key);\n\n\tfree(blob);\n\tfree(signature);\n\tfree(data);\n\tfree(sigalg);\n\n\tif (key_blobtype == MM_USERKEY)\n\t\tauth_activate_options(ssh, key_opts);\n\tmonitor_reset_key_state();\n\n\tsshkey_free(key);\n\tsshbuf_reset(m);\n\n\t/* encode ret != 0 as positive integer, since we're sending u32 */\n\tencoded_ret = (ret != 0);\n\tif ((r = sshbuf_put_u32(m, encoded_ret)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_KEYVERIFY, m);\n\n\treturn ret == 0;\n}"
  },
  {
    "function_name": "monitor_valid_hostbasedblob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1316-1384",
    "snippet": "static int\nmonitor_valid_hostbasedblob(u_char *data, u_int datalen, char *cuser,\n    char *chost)\n{\n\tstruct sshbuf *b;\n\tconst u_char *p;\n\tchar *cp, *userstyle;\n\tsize_t len;\n\tint r, fail = 0;\n\tu_char type;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put(b, data, datalen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &p, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif ((session_id2 == NULL) ||\n\t    (len != session_id2_len) ||\n\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\tfail++;\n\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t    authctxt->style ? \":\" : \"\",\n\t    authctxt->style ? authctxt->style : \"\");\n\tif (strcmp(userstyle, cp) != 0) {\n\t\tlogit(\"wrong user name passed to monitor: \"\n\t\t    \"expected %s != %.100s\", userstyle, cp);\n\t\tfail++;\n\t}\n\tfree(userstyle);\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* service */\n\t    (r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(cp, \"hostbased\") != 0)\n\t\tfail++;\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* pkalg */\n\t    (r = sshbuf_skip_string(b)) != 0)\t/* pkblob */\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* verify client host, strip trailing dot if necessary */\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (((len = strlen(cp)) > 0) && cp[len - 1] == '.')\n\t\tcp[len - 1] = '\\0';\n\tif (strcmp(cp, chost) != 0)\n\t\tfail++;\n\tfree(cp);\n\n\t/* verify client user */\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(cp, cuser) != 0)\n\t\tfail++;\n\tfree(cp);\n\n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\treturn (fail == 0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static int monitor_read_log(struct monitor *);",
      "static Authctxt *authctxt;",
      "static u_int session_id2_len = 0;",
      "static u_char *session_id2 = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cp"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cp",
            "cuser"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "b",
            "&cp",
            "NULL"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "b"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "b"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "b"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"wrong user name passed to monitor: \"\n\t\t    \"expected %s != %.100s\"",
            "userstyle",
            "cp"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&userstyle",
            "\"%s%s%s\"",
            "authctxt->user",
            "authctxt->style ? \":\" : \"\"",
            "authctxt->style ? authctxt->style : \"\""
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "b",
            "&type"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timingsafe_bcmp",
          "args": [
            "p",
            "session_id2",
            "session_id2_len"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "timingsafe_bcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/timingsafe_bcmp.c",
          "lines": "23-32",
          "snippet": "int\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}",
          "includes": [
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"includes.h\"\n\nint\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string_direct",
          "args": [
            "b",
            "&p",
            "&len"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "b",
            "data",
            "datalen"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\nstatic Authctxt *authctxt;\nstatic u_int session_id2_len = 0;\nstatic u_char *session_id2 = NULL;\n\nstatic int\nmonitor_valid_hostbasedblob(u_char *data, u_int datalen, char *cuser,\n    char *chost)\n{\n\tstruct sshbuf *b;\n\tconst u_char *p;\n\tchar *cp, *userstyle;\n\tsize_t len;\n\tint r, fail = 0;\n\tu_char type;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put(b, data, datalen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &p, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif ((session_id2 == NULL) ||\n\t    (len != session_id2_len) ||\n\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\tfail++;\n\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t    authctxt->style ? \":\" : \"\",\n\t    authctxt->style ? authctxt->style : \"\");\n\tif (strcmp(userstyle, cp) != 0) {\n\t\tlogit(\"wrong user name passed to monitor: \"\n\t\t    \"expected %s != %.100s\", userstyle, cp);\n\t\tfail++;\n\t}\n\tfree(userstyle);\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* service */\n\t    (r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(cp, \"hostbased\") != 0)\n\t\tfail++;\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* pkalg */\n\t    (r = sshbuf_skip_string(b)) != 0)\t/* pkblob */\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* verify client host, strip trailing dot if necessary */\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (((len = strlen(cp)) > 0) && cp[len - 1] == '.')\n\t\tcp[len - 1] = '\\0';\n\tif (strcmp(cp, chost) != 0)\n\t\tfail++;\n\tfree(cp);\n\n\t/* verify client user */\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(cp, cuser) != 0)\n\t\tfail++;\n\tfree(cp);\n\n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\treturn (fail == 0);\n}"
  },
  {
    "function_name": "monitor_valid_userblob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1249-1314",
    "snippet": "static int\nmonitor_valid_userblob(u_char *data, u_int datalen)\n{\n\tstruct sshbuf *b;\n\tconst u_char *p;\n\tchar *userstyle, *cp;\n\tsize_t len;\n\tu_char type;\n\tint r, fail = 0;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put(b, data, datalen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (datafellows & SSH_OLD_SESSIONID) {\n\t\tp = sshbuf_ptr(b);\n\t\tlen = sshbuf_len(b);\n\t\tif ((session_id2 == NULL) ||\n\t\t    (len < session_id2_len) ||\n\t\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\t\tfail++;\n\t\tif ((r = sshbuf_consume(b, session_id2_len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshbuf_get_string_direct(b, &p, &len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif ((session_id2 == NULL) ||\n\t\t    (len != session_id2_len) ||\n\t\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\t\tfail++;\n\t}\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t    authctxt->style ? \":\" : \"\",\n\t    authctxt->style ? authctxt->style : \"\");\n\tif (strcmp(userstyle, cp) != 0) {\n\t\tlogit(\"wrong user name passed to monitor: \"\n\t\t    \"expected %s != %.100s\", userstyle, cp);\n\t\tfail++;\n\t}\n\tfree(userstyle);\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* service */\n\t    (r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(\"publickey\", cp) != 0)\n\t\tfail++;\n\tfree(cp);\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type == 0)\n\t\tfail++;\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* pkalg */\n\t    (r = sshbuf_skip_string(b)) != 0)\t/* pkblob */\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\treturn (fail == 0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static int monitor_read_log(struct monitor *);",
      "static Authctxt *authctxt;",
      "static u_int session_id2_len = 0;",
      "static u_char *session_id2 = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "b"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "b"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "b",
            "&type"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cp"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"publickey\"",
            "cp"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "b",
            "&cp",
            "NULL"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "b"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"wrong user name passed to monitor: \"\n\t\t    \"expected %s != %.100s\"",
            "userstyle",
            "cp"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&userstyle",
            "\"%s%s%s\"",
            "authctxt->user",
            "authctxt->style ? \":\" : \"\"",
            "authctxt->style ? authctxt->style : \"\""
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timingsafe_bcmp",
          "args": [
            "p",
            "session_id2",
            "session_id2_len"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "timingsafe_bcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/timingsafe_bcmp.c",
          "lines": "23-32",
          "snippet": "int\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}",
          "includes": [
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"includes.h\"\n\nint\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string_direct",
          "args": [
            "b",
            "&p",
            "&len"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "b",
            "session_id2_len"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "b"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "b",
            "data",
            "datalen"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\nstatic Authctxt *authctxt;\nstatic u_int session_id2_len = 0;\nstatic u_char *session_id2 = NULL;\n\nstatic int\nmonitor_valid_userblob(u_char *data, u_int datalen)\n{\n\tstruct sshbuf *b;\n\tconst u_char *p;\n\tchar *userstyle, *cp;\n\tsize_t len;\n\tu_char type;\n\tint r, fail = 0;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put(b, data, datalen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (datafellows & SSH_OLD_SESSIONID) {\n\t\tp = sshbuf_ptr(b);\n\t\tlen = sshbuf_len(b);\n\t\tif ((session_id2 == NULL) ||\n\t\t    (len < session_id2_len) ||\n\t\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\t\tfail++;\n\t\tif ((r = sshbuf_consume(b, session_id2_len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshbuf_get_string_direct(b, &p, &len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif ((session_id2 == NULL) ||\n\t\t    (len != session_id2_len) ||\n\t\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\t\tfail++;\n\t}\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t    authctxt->style ? \":\" : \"\",\n\t    authctxt->style ? authctxt->style : \"\");\n\tif (strcmp(userstyle, cp) != 0) {\n\t\tlogit(\"wrong user name passed to monitor: \"\n\t\t    \"expected %s != %.100s\", userstyle, cp);\n\t\tfail++;\n\t}\n\tfree(userstyle);\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* service */\n\t    (r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(\"publickey\", cp) != 0)\n\t\tfail++;\n\tfree(cp);\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type == 0)\n\t\tfail++;\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t/* pkalg */\n\t    (r = sshbuf_skip_string(b)) != 0)\t/* pkblob */\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\treturn (fail == 0);\n}"
  },
  {
    "function_name": "mm_answer_keyallowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1149-1247",
    "snippet": "int\nmm_answer_keyallowed(int sock, struct sshbuf *m)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tstruct sshkey *key = NULL;\n\tchar *cuser, *chost;\n\tu_int pubkey_auth_attempt;\n\tenum mm_keytype type = 0;\n\tint r, allowed = 0;\n\tstruct sshauthopt *opts = NULL;\n\n\tdebug3(\"%s entering\", __func__);\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &cuser, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &chost, NULL)) != 0 ||\n\t    (r = sshkey_froms(m, &key)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &pubkey_auth_attempt)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"%s: key_from_blob: %p\", __func__, key);\n\n\tif (key != NULL && authctxt->valid) {\n\t\t/* These should not make it past the privsep child */\n\t\tif (sshkey_type_plain(key->type) == KEY_RSA &&\n\t\t    (datafellows & SSH_BUG_RSASIGMD5) != 0)\n\t\t\tfatal(\"%s: passed a SSH_BUG_RSASIGMD5 key\", __func__);\n\n\t\tswitch (type) {\n\t\tcase MM_USERKEY:\n\t\t\tauth_method = \"publickey\";\n\t\t\tif (!options.pubkey_authentication)\n\t\t\t\tbreak;\n\t\t\tif (auth2_key_already_used(authctxt, key))\n\t\t\t\tbreak;\n\t\t\tif (!key_base_type_match(auth_method, key,\n\t\t\t    options.pubkey_key_types))\n\t\t\t\tbreak;\n\t\t\tallowed = user_key_allowed(ssh, authctxt->pw, key,\n\t\t\t    pubkey_auth_attempt, &opts);\n\t\t\tbreak;\n\t\tcase MM_HOSTKEY:\n\t\t\tauth_method = \"hostbased\";\n\t\t\tif (!options.hostbased_authentication)\n\t\t\t\tbreak;\n\t\t\tif (auth2_key_already_used(authctxt, key))\n\t\t\t\tbreak;\n\t\t\tif (!key_base_type_match(auth_method, key,\n\t\t\t    options.hostbased_key_types))\n\t\t\t\tbreak;\n\t\t\tallowed = hostbased_key_allowed(authctxt->pw,\n\t\t\t    cuser, chost, key);\n\t\t\tauth2_record_info(authctxt,\n\t\t\t    \"client user \\\"%.100s\\\", client host \\\"%.100s\\\"\",\n\t\t\t    cuser, chost);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"%s: unknown key type %d\", __func__, type);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdebug3(\"%s: %s authentication%s: %s key is %s\", __func__,\n\t    auth_method, pubkey_auth_attempt ? \"\" : \" test\",\n\t    (key == NULL || !authctxt->valid) ? \"invalid\" : sshkey_type(key),\n\t    allowed ? \"allowed\" : \"not allowed\");\n\n\tauth2_record_key(authctxt, 0, key);\n\n\t/* clear temporarily storage (used by verify) */\n\tmonitor_reset_key_state();\n\n\tif (allowed) {\n\t\t/* Save temporarily for comparison in verify */\n\t\tif ((r = sshkey_to_blob(key, &key_blob, &key_bloblen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tkey_blobtype = type;\n\t\tkey_opts = opts;\n\t\thostbased_cuser = cuser;\n\t\thostbased_chost = chost;\n\t} else {\n\t\t/* Log failed attempt */\n\t\tauth_log(authctxt, 0, 0, auth_method, NULL);\n\t\tfree(cuser);\n\t\tfree(chost);\n\t}\n\tsshkey_free(key);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, allowed)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (opts != NULL && (r = sshauthopt_serialise(opts, m, 1)) != 0)\n\t\tfatal(\"%s: sshauthopt_serialise: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_KEYALLOWED, m);\n\n\tif (!allowed)\n\t\tsshauthopt_free(opts);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static Authctxt *authctxt;",
      "static u_char *key_blob = NULL;",
      "static size_t key_bloblen = 0;",
      "static int key_blobtype = MM_NOKEY;",
      "static struct sshauthopt *key_opts = NULL;",
      "static char *hostbased_cuser = NULL;",
      "static char *hostbased_chost = NULL;",
      "static char *auth_method = \"unknown\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshauthopt_free",
          "args": [
            "opts"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_KEYALLOWED",
            "m"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshauthopt_serialise: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_serialise",
          "args": [
            "opts",
            "m",
            "1"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_serialise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "829-874",
          "snippet": "int\nsshauthopt_serialise(const struct sshauthopt *opts, struct sshbuf *m,\n    int untrusted)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t/* Flag and simple integer options */\n\tif ((r = sshbuf_put_u8(m, opts->permit_port_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_agent_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_x11_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_pty_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_user_rc)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->restricted)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->cert_authority)) != 0 ||\n\t    (r = sshbuf_put_u64(m, opts->valid_before)) != 0)\n\t\treturn r;\n\n\t/* tunnel number can be negative to indicate \"unset\" */\n\tif ((r = sshbuf_put_u8(m, opts->force_tun_device == -1)) != 0 ||\n\t    (r = sshbuf_put_u32(m, (opts->force_tun_device < 0) ?\n\t    0 : (u_int)opts->force_tun_device)) != 0)\n\t\treturn r;\n\n\t/* String options; these may be NULL */\n\tif ((r = serialise_nullable_string(m,\n\t    untrusted ? \"yes\" : opts->cert_principals)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t    untrusted ? \"true\" : opts->force_command)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t    untrusted ? NULL : opts->required_from_host_cert)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t     untrusted ? NULL : opts->required_from_host_keys)) != 0)\n\t\treturn r;\n\n\t/* Array options */\n\tif ((r = serialise_array(m, opts->env,\n\t    untrusted ? 0 : opts->nenv)) != 0 ||\n\t    (r = serialise_array(m, opts->permitopen,\n\t    untrusted ? 0 : opts->npermitopen)) != 0 ||\n\t    (r = serialise_array(m, opts->permitlisten,\n\t    untrusted ? 0 : opts->npermitlisten)) != 0)\n\t\treturn r;\n\n\t/* success */\n\treturn 0;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshauthopt_serialise(const struct sshauthopt *opts, struct sshbuf *m,\n    int untrusted)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t/* Flag and simple integer options */\n\tif ((r = sshbuf_put_u8(m, opts->permit_port_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_agent_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_x11_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_pty_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_user_rc)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->restricted)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->cert_authority)) != 0 ||\n\t    (r = sshbuf_put_u64(m, opts->valid_before)) != 0)\n\t\treturn r;\n\n\t/* tunnel number can be negative to indicate \"unset\" */\n\tif ((r = sshbuf_put_u8(m, opts->force_tun_device == -1)) != 0 ||\n\t    (r = sshbuf_put_u32(m, (opts->force_tun_device < 0) ?\n\t    0 : (u_int)opts->force_tun_device)) != 0)\n\t\treturn r;\n\n\t/* String options; these may be NULL */\n\tif ((r = serialise_nullable_string(m,\n\t    untrusted ? \"yes\" : opts->cert_principals)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t    untrusted ? \"true\" : opts->force_command)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t    untrusted ? NULL : opts->required_from_host_cert)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t     untrusted ? NULL : opts->required_from_host_keys)) != 0)\n\t\treturn r;\n\n\t/* Array options */\n\tif ((r = serialise_array(m, opts->env,\n\t    untrusted ? 0 : opts->nenv)) != 0 ||\n\t    (r = serialise_array(m, opts->permitopen,\n\t    untrusted ? 0 : opts->npermitopen)) != 0 ||\n\t    (r = serialise_array(m, opts->permitlisten,\n\t    untrusted ? 0 : opts->npermitlisten)) != 0)\n\t\treturn r;\n\n\t/* success */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "allowed"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "chost"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_log",
          "args": [
            "authctxt",
            "0",
            "0",
            "auth_method",
            "NULL"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "auth_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "310-372",
          "snippet": "void\nauth_log(Authctxt *authctxt, int authenticated, int partial,\n    const char *method, const char *submethod)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tint level = SYSLOG_LEVEL_VERBOSE;\n\tconst char *authmsg;\n\tchar *extra = NULL;\n\n\tif (use_privsep && !mm_is_monitor() && !authctxt->postponed)\n\t\treturn;\n\n\t/* Raise logging level */\n\tif (authenticated == 1 ||\n\t    !authctxt->valid ||\n\t    authctxt->failures >= options.max_authtries / 2 ||\n\t    strcmp(method, \"password\") == 0)\n\t\tlevel = SYSLOG_LEVEL_INFO;\n\n\tif (authctxt->postponed)\n\t\tauthmsg = \"Postponed\";\n\telse if (partial)\n\t\tauthmsg = \"Partial\";\n\telse\n\t\tauthmsg = authenticated ? \"Accepted\" : \"Failed\";\n\n\tif ((extra = format_method_key(authctxt)) == NULL) {\n\t\tif (authctxt->auth_method_info != NULL)\n\t\t\textra = xstrdup(authctxt->auth_method_info);\n\t}\n\n\tdo_log2(level, \"%s %s%s%s for %s%.100s from %.200s port %d ssh2%s%s\",\n\t    authmsg,\n\t    method,\n\t    submethod != NULL ? \"/\" : \"\", submethod == NULL ? \"\" : submethod,\n\t    authctxt->valid ? \"\" : \"invalid user \",\n\t    authctxt->user,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    extra != NULL ? \": \" : \"\",\n\t    extra != NULL ? extra : \"\");\n\n\tfree(extra);\n\n#ifdef CUSTOM_FAILED_LOGIN\n\tif (authenticated == 0 && !authctxt->postponed &&\n\t    (strcmp(method, \"password\") == 0 ||\n\t    strncmp(method, \"keyboard-interactive\", 20) == 0 ||\n\t    strcmp(method, \"challenge-response\") == 0))\n\t\trecord_failed_login(authctxt->user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n# ifdef WITH_AIXAUTHENTICATE\n\tif (authenticated)\n\t\tsys_auth_record_login(authctxt->user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\",\n\t\t    &loginmsg);\n# endif\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\tif (authenticated == 0 && !authctxt->postponed)\n\t\taudit_event(audit_classify_auth(method));\n#endif\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern int use_privsep;",
            "extern struct sshbuf *loginmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern int use_privsep;\nextern struct sshbuf *loginmsg;\n\nvoid\nauth_log(Authctxt *authctxt, int authenticated, int partial,\n    const char *method, const char *submethod)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tint level = SYSLOG_LEVEL_VERBOSE;\n\tconst char *authmsg;\n\tchar *extra = NULL;\n\n\tif (use_privsep && !mm_is_monitor() && !authctxt->postponed)\n\t\treturn;\n\n\t/* Raise logging level */\n\tif (authenticated == 1 ||\n\t    !authctxt->valid ||\n\t    authctxt->failures >= options.max_authtries / 2 ||\n\t    strcmp(method, \"password\") == 0)\n\t\tlevel = SYSLOG_LEVEL_INFO;\n\n\tif (authctxt->postponed)\n\t\tauthmsg = \"Postponed\";\n\telse if (partial)\n\t\tauthmsg = \"Partial\";\n\telse\n\t\tauthmsg = authenticated ? \"Accepted\" : \"Failed\";\n\n\tif ((extra = format_method_key(authctxt)) == NULL) {\n\t\tif (authctxt->auth_method_info != NULL)\n\t\t\textra = xstrdup(authctxt->auth_method_info);\n\t}\n\n\tdo_log2(level, \"%s %s%s%s for %s%.100s from %.200s port %d ssh2%s%s\",\n\t    authmsg,\n\t    method,\n\t    submethod != NULL ? \"/\" : \"\", submethod == NULL ? \"\" : submethod,\n\t    authctxt->valid ? \"\" : \"invalid user \",\n\t    authctxt->user,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    extra != NULL ? \": \" : \"\",\n\t    extra != NULL ? extra : \"\");\n\n\tfree(extra);\n\n#ifdef CUSTOM_FAILED_LOGIN\n\tif (authenticated == 0 && !authctxt->postponed &&\n\t    (strcmp(method, \"password\") == 0 ||\n\t    strncmp(method, \"keyboard-interactive\", 20) == 0 ||\n\t    strcmp(method, \"challenge-response\") == 0))\n\t\trecord_failed_login(authctxt->user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n# ifdef WITH_AIXAUTHENTICATE\n\tif (authenticated)\n\t\tsys_auth_record_login(authctxt->user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\",\n\t\t    &loginmsg);\n# endif\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\tif (authenticated == 0 && !authctxt->postponed)\n\t\taudit_event(audit_classify_auth(method));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_to_blob",
          "args": [
            "key",
            "&key_blob",
            "&key_bloblen"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "880-884",
          "snippet": "int\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_reset_key_state",
          "args": [],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_reset_key_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "550-564",
          "snippet": "static void\nmonitor_reset_key_state(void)\n{\n\t/* reset state */\n\tfree(key_blob);\n\tfree(hostbased_cuser);\n\tfree(hostbased_chost);\n\tsshauthopt_free(key_opts);\n\tkey_blob = NULL;\n\tkey_bloblen = 0;\n\tkey_blobtype = MM_NOKEY;\n\tkey_opts = NULL;\n\thostbased_cuser = NULL;\n\thostbased_chost = NULL;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u_char *key_blob = NULL;",
            "static size_t key_bloblen = 0;",
            "static int key_blobtype = MM_NOKEY;",
            "static struct sshauthopt *key_opts = NULL;",
            "static char *hostbased_cuser = NULL;",
            "static char *hostbased_chost = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_char *key_blob = NULL;\nstatic size_t key_bloblen = 0;\nstatic int key_blobtype = MM_NOKEY;\nstatic struct sshauthopt *key_opts = NULL;\nstatic char *hostbased_cuser = NULL;\nstatic char *hostbased_chost = NULL;\n\nstatic void\nmonitor_reset_key_state(void)\n{\n\t/* reset state */\n\tfree(key_blob);\n\tfree(hostbased_cuser);\n\tfree(hostbased_chost);\n\tsshauthopt_free(key_opts);\n\tkey_blob = NULL;\n\tkey_bloblen = 0;\n\tkey_blobtype = MM_NOKEY;\n\tkey_opts = NULL;\n\thostbased_cuser = NULL;\n\thostbased_chost = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_record_key",
          "args": [
            "authctxt",
            "0",
            "key"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_record_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "702-728",
          "snippet": "void\nauth2_record_key(Authctxt *authctxt, int authenticated,\n    const struct sshkey *key)\n{\n\tstruct sshkey **tmp, *dup;\n\tint r;\n\n\tif ((r = sshkey_from_private(key, &dup)) != 0)\n\t\tfatal(\"%s: copy key: %s\", __func__, ssh_err(r));\n\tsshkey_free(authctxt->auth_method_key);\n\tauthctxt->auth_method_key = dup;\n\n\tif (!authenticated)\n\t\treturn;\n\n\t/* If authenticated, make sure we don't accept this key again */\n\tif ((r = sshkey_from_private(key, &dup)) != 0)\n\t\tfatal(\"%s: copy key: %s\", __func__, ssh_err(r));\n\tif (authctxt->nprev_keys >= INT_MAX ||\n\t    (tmp = recallocarray(authctxt->prev_keys, authctxt->nprev_keys,\n\t    authctxt->nprev_keys + 1, sizeof(*authctxt->prev_keys))) == NULL)\n\t\tfatal(\"%s: reallocarray failed\", __func__);\n\tauthctxt->prev_keys = tmp;\n\tauthctxt->prev_keys[authctxt->nprev_keys] = dup;\n\tauthctxt->nprev_keys++;\n\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nvoid\nauth2_record_key(Authctxt *authctxt, int authenticated,\n    const struct sshkey *key)\n{\n\tstruct sshkey **tmp, *dup;\n\tint r;\n\n\tif ((r = sshkey_from_private(key, &dup)) != 0)\n\t\tfatal(\"%s: copy key: %s\", __func__, ssh_err(r));\n\tsshkey_free(authctxt->auth_method_key);\n\tauthctxt->auth_method_key = dup;\n\n\tif (!authenticated)\n\t\treturn;\n\n\t/* If authenticated, make sure we don't accept this key again */\n\tif ((r = sshkey_from_private(key, &dup)) != 0)\n\t\tfatal(\"%s: copy key: %s\", __func__, ssh_err(r));\n\tif (authctxt->nprev_keys >= INT_MAX ||\n\t    (tmp = recallocarray(authctxt->prev_keys, authctxt->nprev_keys,\n\t    authctxt->nprev_keys + 1, sizeof(*authctxt->prev_keys))) == NULL)\n\t\tfatal(\"%s: reallocarray failed\", __func__);\n\tauthctxt->prev_keys = tmp;\n\tauthctxt->prev_keys[authctxt->nprev_keys] = dup;\n\tauthctxt->nprev_keys++;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: %s authentication%s: %s key is %s\"",
            "__func__",
            "auth_method",
            "pubkey_auth_attempt ? \"\" : \" test\"",
            "(key == NULL || !authctxt->valid) ? \"invalid\" : sshkey_type(key)",
            "allowed ? \"allowed\" : \"not allowed\""
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "key"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_record_info",
          "args": [
            "authctxt",
            "\"client user \\\"%.100s\\\", client host \\\"%.100s\\\"\"",
            "cuser",
            "chost"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_record_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "680-695",
          "snippet": "void\nauth2_record_info(Authctxt *authctxt, const char *fmt, ...)\n{\n\tva_list ap;\n        int i;\n\n\tfree(authctxt->auth_method_info);\n\tauthctxt->auth_method_info = NULL;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(&authctxt->auth_method_info, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || authctxt->auth_method_info == NULL)\n\t\tfatal(\"%s: vasprintf failed\", __func__);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nvoid\nauth2_record_info(Authctxt *authctxt, const char *fmt, ...)\n{\n\tva_list ap;\n        int i;\n\n\tfree(authctxt->auth_method_info);\n\tauthctxt->auth_method_info = NULL;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(&authctxt->auth_method_info, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || authctxt->auth_method_info == NULL)\n\t\tfatal(\"%s: vasprintf failed\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hostbased_key_allowed",
          "args": [
            "authctxt->pw",
            "cuser",
            "chost",
            "key"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "hostbased_key_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-hostbased.c",
          "lines": "169-255",
          "snippet": "int\nhostbased_key_allowed(struct passwd *pw, const char *cuser, char *chost,\n    struct sshkey *key)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tconst char *resolvedname, *ipaddr, *lookup, *reason;\n\tHostStatus host_status;\n\tint len;\n\tchar *fp;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\n\tresolvedname = auth_get_canonical_hostname(ssh, options.use_dns);\n\tipaddr = ssh_remote_ipaddr(ssh);\n\n\tdebug2(\"%s: chost %s resolvedname %s ipaddr %s\", __func__,\n\t    chost, resolvedname, ipaddr);\n\n\tif (((len = strlen(chost)) > 0) && chost[len - 1] == '.') {\n\t\tdebug2(\"stripping trailing dot from chost %s\", chost);\n\t\tchost[len - 1] = '\\0';\n\t}\n\n\tif (options.hostbased_uses_name_from_packet_only) {\n\t\tif (auth_rhosts2(pw, cuser, chost, chost) == 0) {\n\t\t\tdebug2(\"%s: auth_rhosts2 refused \"\n\t\t\t    \"user \\\"%.100s\\\" host \\\"%.100s\\\" (from packet)\",\n\t\t\t    __func__, cuser, chost);\n\t\t\treturn 0;\n\t\t}\n\t\tlookup = chost;\n\t} else {\n\t\tif (strcasecmp(resolvedname, chost) != 0)\n\t\t\tlogit(\"userauth_hostbased mismatch: \"\n\t\t\t    \"client sends %s, but we resolve %s to %s\",\n\t\t\t    chost, ipaddr, resolvedname);\n\t\tif (auth_rhosts2(pw, cuser, resolvedname, ipaddr) == 0) {\n\t\t\tdebug2(\"%s: auth_rhosts2 refused \"\n\t\t\t    \"user \\\"%.100s\\\" host \\\"%.100s\\\" addr \\\"%.100s\\\"\",\n\t\t\t    __func__, cuser, resolvedname, ipaddr);\n\t\t\treturn 0;\n\t\t}\n\t\tlookup = resolvedname;\n\t}\n\tdebug2(\"%s: access allowed by auth_rhosts2\", __func__);\n\n\tif (sshkey_is_cert(key) &&\n\t    sshkey_cert_check_authority(key, 1, 0, lookup, &reason)) {\n\t\terror(\"%s\", reason);\n\t\tauth_debug_add(\"%s\", reason);\n\t\treturn 0;\n\t}\n\n\thost_status = check_key_in_hostfiles(pw, key, lookup,\n\t    _PATH_SSH_SYSTEM_HOSTFILE,\n\t    options.ignore_user_known_hosts ? NULL : _PATH_SSH_USER_HOSTFILE);\n\n\t/* backward compat if no key has been found. */\n\tif (host_status == HOST_NEW) {\n\t\thost_status = check_key_in_hostfiles(pw, key, lookup,\n\t\t    _PATH_SSH_SYSTEM_HOSTFILE2,\n\t\t    options.ignore_user_known_hosts ? NULL :\n\t\t    _PATH_SSH_USER_HOSTFILE2);\n\t}\n\n\tif (host_status == HOST_OK) {\n\t\tif (sshkey_is_cert(key)) {\n\t\t\tif ((fp = sshkey_fingerprint(key->cert->signature_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tverbose(\"Accepted certificate ID \\\"%s\\\" signed by \"\n\t\t\t    \"%s CA %s from %s@%s\", key->cert->key_id,\n\t\t\t    sshkey_type(key->cert->signature_key), fp,\n\t\t\t    cuser, lookup);\n\t\t} else {\n\t\t\tif ((fp = sshkey_fingerprint(key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tverbose(\"Accepted %s public key %s from %s@%s\",\n\t\t\t    sshkey_type(key), fp, cuser, lookup);\n\t\t}\n\t\tfree(fp);\n\t}\n\n\treturn (host_status == HOST_OK);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"pathnames.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"ssherr.h\"\n#include \"pathnames.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nint\nhostbased_key_allowed(struct passwd *pw, const char *cuser, char *chost,\n    struct sshkey *key)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tconst char *resolvedname, *ipaddr, *lookup, *reason;\n\tHostStatus host_status;\n\tint len;\n\tchar *fp;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\n\tresolvedname = auth_get_canonical_hostname(ssh, options.use_dns);\n\tipaddr = ssh_remote_ipaddr(ssh);\n\n\tdebug2(\"%s: chost %s resolvedname %s ipaddr %s\", __func__,\n\t    chost, resolvedname, ipaddr);\n\n\tif (((len = strlen(chost)) > 0) && chost[len - 1] == '.') {\n\t\tdebug2(\"stripping trailing dot from chost %s\", chost);\n\t\tchost[len - 1] = '\\0';\n\t}\n\n\tif (options.hostbased_uses_name_from_packet_only) {\n\t\tif (auth_rhosts2(pw, cuser, chost, chost) == 0) {\n\t\t\tdebug2(\"%s: auth_rhosts2 refused \"\n\t\t\t    \"user \\\"%.100s\\\" host \\\"%.100s\\\" (from packet)\",\n\t\t\t    __func__, cuser, chost);\n\t\t\treturn 0;\n\t\t}\n\t\tlookup = chost;\n\t} else {\n\t\tif (strcasecmp(resolvedname, chost) != 0)\n\t\t\tlogit(\"userauth_hostbased mismatch: \"\n\t\t\t    \"client sends %s, but we resolve %s to %s\",\n\t\t\t    chost, ipaddr, resolvedname);\n\t\tif (auth_rhosts2(pw, cuser, resolvedname, ipaddr) == 0) {\n\t\t\tdebug2(\"%s: auth_rhosts2 refused \"\n\t\t\t    \"user \\\"%.100s\\\" host \\\"%.100s\\\" addr \\\"%.100s\\\"\",\n\t\t\t    __func__, cuser, resolvedname, ipaddr);\n\t\t\treturn 0;\n\t\t}\n\t\tlookup = resolvedname;\n\t}\n\tdebug2(\"%s: access allowed by auth_rhosts2\", __func__);\n\n\tif (sshkey_is_cert(key) &&\n\t    sshkey_cert_check_authority(key, 1, 0, lookup, &reason)) {\n\t\terror(\"%s\", reason);\n\t\tauth_debug_add(\"%s\", reason);\n\t\treturn 0;\n\t}\n\n\thost_status = check_key_in_hostfiles(pw, key, lookup,\n\t    _PATH_SSH_SYSTEM_HOSTFILE,\n\t    options.ignore_user_known_hosts ? NULL : _PATH_SSH_USER_HOSTFILE);\n\n\t/* backward compat if no key has been found. */\n\tif (host_status == HOST_NEW) {\n\t\thost_status = check_key_in_hostfiles(pw, key, lookup,\n\t\t    _PATH_SSH_SYSTEM_HOSTFILE2,\n\t\t    options.ignore_user_known_hosts ? NULL :\n\t\t    _PATH_SSH_USER_HOSTFILE2);\n\t}\n\n\tif (host_status == HOST_OK) {\n\t\tif (sshkey_is_cert(key)) {\n\t\t\tif ((fp = sshkey_fingerprint(key->cert->signature_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tverbose(\"Accepted certificate ID \\\"%s\\\" signed by \"\n\t\t\t    \"%s CA %s from %s@%s\", key->cert->key_id,\n\t\t\t    sshkey_type(key->cert->signature_key), fp,\n\t\t\t    cuser, lookup);\n\t\t} else {\n\t\t\tif ((fp = sshkey_fingerprint(key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tverbose(\"Accepted %s public key %s from %s@%s\",\n\t\t\t    sshkey_type(key), fp, cuser, lookup);\n\t\t}\n\t\tfree(fp);\n\t}\n\n\treturn (host_status == HOST_OK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_base_type_match",
          "args": [
            "auth_method",
            "key",
            "options.hostbased_key_types"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "key_base_type_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "855-876",
          "snippet": "static int\nkey_base_type_match(const char *method, const struct sshkey *key,\n    const char *list)\n{\n\tchar *s, *l, *ol = xstrdup(list);\n\tint found = 0;\n\n\tl = ol;\n\tfor ((s = strsep(&l, \",\")); s && *s != '\\0'; (s = strsep(&l, \",\"))) {\n\t\tif (sshkey_type_from_name(s) == key->type) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\terror(\"%s key type %s is not in permitted list %s\", method,\n\t\t    sshkey_ssh_name(key), list);\n\t}\n\n\tfree(ol);\n\treturn found;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nkey_base_type_match(const char *method, const struct sshkey *key,\n    const char *list)\n{\n\tchar *s, *l, *ol = xstrdup(list);\n\tint found = 0;\n\n\tl = ol;\n\tfor ((s = strsep(&l, \",\")); s && *s != '\\0'; (s = strsep(&l, \",\"))) {\n\t\tif (sshkey_type_from_name(s) == key->type) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\terror(\"%s key type %s is not in permitted list %s\", method,\n\t\t    sshkey_ssh_name(key), list);\n\t}\n\n\tfree(ol);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_key_already_used",
          "args": [
            "authctxt",
            "key"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_key_already_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "731-749",
          "snippet": "int\nauth2_key_already_used(Authctxt *authctxt, const struct sshkey *key)\n{\n\tu_int i;\n\tchar *fp;\n\n\tfor (i = 0; i < authctxt->nprev_keys; i++) {\n\t\tif (sshkey_equal_public(key, authctxt->prev_keys[i])) {\n\t\t\tfp = sshkey_fingerprint(authctxt->prev_keys[i],\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tdebug3(\"%s: key already used: %s %s\", __func__,\n\t\t\t    sshkey_type(authctxt->prev_keys[i]),\n\t\t\t    fp == NULL ? \"UNKNOWN\" : fp);\n\t\t\tfree(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nint\nauth2_key_already_used(Authctxt *authctxt, const struct sshkey *key)\n{\n\tu_int i;\n\tchar *fp;\n\n\tfor (i = 0; i < authctxt->nprev_keys; i++) {\n\t\tif (sshkey_equal_public(key, authctxt->prev_keys[i])) {\n\t\t\tfp = sshkey_fingerprint(authctxt->prev_keys[i],\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tdebug3(\"%s: key already used: %s %s\", __func__,\n\t\t\t    sshkey_type(authctxt->prev_keys[i]),\n\t\t\t    fp == NULL ? \"UNKNOWN\" : fp);\n\t\t\tfree(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_key_allowed",
          "args": [
            "ssh",
            "authctxt->pw",
            "key",
            "pubkey_auth_attempt",
            "&opts"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "user_key_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-pubkey.c",
          "lines": "997-1039",
          "snippet": "int\nuser_key_allowed(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    int auth_attempt, struct sshauthopt **authoptsp)\n{\n\tu_int success, i;\n\tchar *file;\n\tstruct sshauthopt *opts = NULL;\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\tif (sshkey_is_cert(key) &&\n\t    auth_key_is_revoked(key->cert->signature_key))\n\t\treturn 0;\n\n\tif ((success = user_cert_trusted_ca(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tif ((success = user_key_command_allowed2(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tfor (i = 0; !success && i < options.num_authkeys_files; i++) {\n\t\tif (strcasecmp(options.authorized_keys_files[i], \"none\") == 0)\n\t\t\tcontinue;\n\t\tfile = expand_authorized_keys(\n\t\t    options.authorized_keys_files[i], pw);\n\t\tsuccess = user_key_allowed2(ssh, pw, key, file, &opts);\n\t\tfree(file);\n\t}\n\n out:\n\tif (success && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn success;\n}",
          "includes": [
            "#include \"session.h\" /* XXX for child_set_env(); refactor? */",
            "#include \"channels.h\" /* XXX for session.h */",
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"session.h\" /* XXX for child_set_env(); refactor? */\n#include \"channels.h\" /* XXX for session.h */\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nint\nuser_key_allowed(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    int auth_attempt, struct sshauthopt **authoptsp)\n{\n\tu_int success, i;\n\tchar *file;\n\tstruct sshauthopt *opts = NULL;\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\tif (sshkey_is_cert(key) &&\n\t    auth_key_is_revoked(key->cert->signature_key))\n\t\treturn 0;\n\n\tif ((success = user_cert_trusted_ca(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tif ((success = user_key_command_allowed2(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tfor (i = 0; !success && i < options.num_authkeys_files; i++) {\n\t\tif (strcasecmp(options.authorized_keys_files[i], \"none\") == 0)\n\t\t\tcontinue;\n\t\tfile = expand_authorized_keys(\n\t\t    options.authorized_keys_files[i], pw);\n\t\tsuccess = user_key_allowed2(ssh, pw, key, file, &opts);\n\t\tfree(file);\n\t}\n\n out:\n\tif (success && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: passed a SSH_BUG_RSASIGMD5 key\"",
            "__func__"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&pubkey_auth_attempt"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_froms",
          "args": [
            "m",
            "&key"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_froms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2282-2293",
          "snippet": "int\nsshkey_froms(struct sshbuf *buf, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((r = sshbuf_froms(buf, &b)) != 0)\n\t\treturn r;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_froms(struct sshbuf *buf, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((r = sshbuf_froms(buf, &b)) != 0)\n\t\treturn r;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&chost",
            "NULL"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic Authctxt *authctxt;\nstatic u_char *key_blob = NULL;\nstatic size_t key_bloblen = 0;\nstatic int key_blobtype = MM_NOKEY;\nstatic struct sshauthopt *key_opts = NULL;\nstatic char *hostbased_cuser = NULL;\nstatic char *hostbased_chost = NULL;\nstatic char *auth_method = \"unknown\";\n\nint\nmm_answer_keyallowed(int sock, struct sshbuf *m)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tstruct sshkey *key = NULL;\n\tchar *cuser, *chost;\n\tu_int pubkey_auth_attempt;\n\tenum mm_keytype type = 0;\n\tint r, allowed = 0;\n\tstruct sshauthopt *opts = NULL;\n\n\tdebug3(\"%s entering\", __func__);\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &cuser, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &chost, NULL)) != 0 ||\n\t    (r = sshkey_froms(m, &key)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &pubkey_auth_attempt)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"%s: key_from_blob: %p\", __func__, key);\n\n\tif (key != NULL && authctxt->valid) {\n\t\t/* These should not make it past the privsep child */\n\t\tif (sshkey_type_plain(key->type) == KEY_RSA &&\n\t\t    (datafellows & SSH_BUG_RSASIGMD5) != 0)\n\t\t\tfatal(\"%s: passed a SSH_BUG_RSASIGMD5 key\", __func__);\n\n\t\tswitch (type) {\n\t\tcase MM_USERKEY:\n\t\t\tauth_method = \"publickey\";\n\t\t\tif (!options.pubkey_authentication)\n\t\t\t\tbreak;\n\t\t\tif (auth2_key_already_used(authctxt, key))\n\t\t\t\tbreak;\n\t\t\tif (!key_base_type_match(auth_method, key,\n\t\t\t    options.pubkey_key_types))\n\t\t\t\tbreak;\n\t\t\tallowed = user_key_allowed(ssh, authctxt->pw, key,\n\t\t\t    pubkey_auth_attempt, &opts);\n\t\t\tbreak;\n\t\tcase MM_HOSTKEY:\n\t\t\tauth_method = \"hostbased\";\n\t\t\tif (!options.hostbased_authentication)\n\t\t\t\tbreak;\n\t\t\tif (auth2_key_already_used(authctxt, key))\n\t\t\t\tbreak;\n\t\t\tif (!key_base_type_match(auth_method, key,\n\t\t\t    options.hostbased_key_types))\n\t\t\t\tbreak;\n\t\t\tallowed = hostbased_key_allowed(authctxt->pw,\n\t\t\t    cuser, chost, key);\n\t\t\tauth2_record_info(authctxt,\n\t\t\t    \"client user \\\"%.100s\\\", client host \\\"%.100s\\\"\",\n\t\t\t    cuser, chost);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"%s: unknown key type %d\", __func__, type);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdebug3(\"%s: %s authentication%s: %s key is %s\", __func__,\n\t    auth_method, pubkey_auth_attempt ? \"\" : \" test\",\n\t    (key == NULL || !authctxt->valid) ? \"invalid\" : sshkey_type(key),\n\t    allowed ? \"allowed\" : \"not allowed\");\n\n\tauth2_record_key(authctxt, 0, key);\n\n\t/* clear temporarily storage (used by verify) */\n\tmonitor_reset_key_state();\n\n\tif (allowed) {\n\t\t/* Save temporarily for comparison in verify */\n\t\tif ((r = sshkey_to_blob(key, &key_blob, &key_bloblen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tkey_blobtype = type;\n\t\tkey_opts = opts;\n\t\thostbased_cuser = cuser;\n\t\thostbased_chost = chost;\n\t} else {\n\t\t/* Log failed attempt */\n\t\tauth_log(authctxt, 0, 0, auth_method, NULL);\n\t\tfree(cuser);\n\t\tfree(chost);\n\t}\n\tsshkey_free(key);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, allowed)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (opts != NULL && (r = sshauthopt_serialise(opts, m, 1)) != 0)\n\t\tfatal(\"%s: sshauthopt_serialise: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_KEYALLOWED, m);\n\n\tif (!allowed)\n\t\tsshauthopt_free(opts);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_pam_free_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1129-1146",
    "snippet": "int\nmm_answer_pam_free_ctx(int sock, struct sshbuf *m)\n{\n\tint r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;\n\n\tdebug3(\"%s\", __func__);\n\tif (sshpam_ctxt == NULL)\n\t\tfatal(\"%s: no context\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tsshpam_ctxt = sshpam_authok = NULL;\n\tsshbuf_reset(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\t/* Allow another attempt */\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_INIT_CTX, 1);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn r;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static char *auth_method = \"unknown\";",
      "static char *auth_submethod = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "monitor_permit",
          "args": [
            "mon_dispatch",
            "MONITOR_REQ_PAM_INIT_CTX",
            "1"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "240-251",
          "snippet": "static void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_PERMIT\t0x1000\t/* Request is permitted */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n\nstatic void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_PAM_FREE_CTX",
            "m"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sshpam_ctxt"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: no context\"",
            "__func__"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s\"",
            "__func__"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic char *auth_method = \"unknown\";\nstatic char *auth_submethod = NULL;\n\nint\nmm_answer_pam_free_ctx(int sock, struct sshbuf *m)\n{\n\tint r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;\n\n\tdebug3(\"%s\", __func__);\n\tif (sshpam_ctxt == NULL)\n\t\tfatal(\"%s: no context\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tsshpam_ctxt = sshpam_authok = NULL;\n\tsshbuf_reset(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\t/* Allow another attempt */\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_INIT_CTX, 1);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn r;\n}"
  },
  {
    "function_name": "mm_answer_pam_respond",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1091-1127",
    "snippet": "int\nmm_answer_pam_respond(int sock, struct sshbuf *m)\n{\n\tchar **resp;\n\tu_int i, num;\n\tint r, ret;\n\n\tdebug3(\"%s\", __func__);\n\tif (sshpam_ctxt == NULL)\n\t\tfatal(\"%s: no context\", __func__);\n\tsshpam_authok = NULL;\n\tif ((r = sshbuf_get_u32(m, &num)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (num > 0) {\n\t\tresp = xcalloc(num, sizeof(char *));\n\t\tfor (i = 0; i < num; ++i) {\n\t\t\tif ((r = sshbuf_get_cstring(m, &(resp[i]), NULL)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tret = (sshpam_device.respond)(sshpam_ctxt, num, resp);\n\t\tfor (i = 0; i < num; ++i)\n\t\t\tfree(resp[i]);\n\t\tfree(resp);\n\t} else {\n\t\tret = (sshpam_device.respond)(sshpam_ctxt, num, NULL);\n\t}\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, ret)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_PAM_RESPOND, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\tif (ret == 0)\n\t\tsshpam_authok = sshpam_ctxt;\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static char *auth_method = \"unknown\";",
      "static char *auth_submethod = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_PAM_RESPOND",
            "m"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "ret"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sshpam_ctxt",
            "num",
            "NULL"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "resp"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sshpam_ctxt",
            "num",
            "resp"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&(resp[i])",
            "NULL"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "num",
            "sizeof(char *)"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&num"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: no context\"",
            "__func__"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s\"",
            "__func__"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic char *auth_method = \"unknown\";\nstatic char *auth_submethod = NULL;\n\nint\nmm_answer_pam_respond(int sock, struct sshbuf *m)\n{\n\tchar **resp;\n\tu_int i, num;\n\tint r, ret;\n\n\tdebug3(\"%s\", __func__);\n\tif (sshpam_ctxt == NULL)\n\t\tfatal(\"%s: no context\", __func__);\n\tsshpam_authok = NULL;\n\tif ((r = sshbuf_get_u32(m, &num)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (num > 0) {\n\t\tresp = xcalloc(num, sizeof(char *));\n\t\tfor (i = 0; i < num; ++i) {\n\t\t\tif ((r = sshbuf_get_cstring(m, &(resp[i]), NULL)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tret = (sshpam_device.respond)(sshpam_ctxt, num, resp);\n\t\tfor (i = 0; i < num; ++i)\n\t\t\tfree(resp[i]);\n\t\tfree(resp);\n\t} else {\n\t\tret = (sshpam_device.respond)(sshpam_ctxt, num, NULL);\n\t}\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, ret)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_PAM_RESPOND, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\tif (ret == 0)\n\t\tsshpam_authok = sshpam_ctxt;\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_pam_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1050-1089",
    "snippet": "int\nmm_answer_pam_query(int sock, struct sshbuf *m)\n{\n\tchar *name = NULL, *info = NULL, **prompts = NULL;\n\tu_int i, num = 0, *echo_on = 0;\n\tint r, ret;\n\n\tdebug3(\"%s\", __func__);\n\tsshpam_authok = NULL;\n\tif (sshpam_ctxt == NULL)\n\t\tfatal(\"%s: no context\", __func__);\n\tret = (sshpam_device.query)(sshpam_ctxt, &name, &info,\n\t    &num, &prompts, &echo_on);\n\tif (ret == 0 && num == 0)\n\t\tsshpam_authok = sshpam_ctxt;\n\tif (num > 1 || name == NULL || info == NULL)\n\t\tfatal(\"sshpam_device.query failed\");\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_RESPOND, 1);\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, ret)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, info)) != 0 ||\n\t    (r = sshbuf_put_u32(m, sshpam_get_maxtries_reached())) != 0 ||\n\t    (r = sshbuf_put_u32(m, num)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tfree(name);\n\tfree(info);\n\tfor (i = 0; i < num; ++i) {\n\t\tif ((r = sshbuf_put_cstring(m, prompts[i])) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, echo_on[i])) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tfree(prompts[i]);\n\t}\n\tfree(prompts);\n\tfree(echo_on);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\tmm_request_send(sock, MONITOR_ANS_PAM_QUERY, m);\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static char *auth_method = \"unknown\";",
      "static char *auth_submethod = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_PAM_QUERY",
            "m"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "echo_on"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "echo_on[i]"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "m",
            "prompts[i]"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpam_get_maxtries_reached",
          "args": [],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "sshpam_get_maxtries_reached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1333-1337",
          "snippet": "int\nsshpam_get_maxtries_reached(void)\n{\n\treturn sshpam_maxtries_reached;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpam_get_maxtries_reached(void)\n{\n\treturn sshpam_maxtries_reached;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_permit",
          "args": [
            "mon_dispatch",
            "MONITOR_REQ_PAM_RESPOND",
            "1"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "240-251",
          "snippet": "static void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_PERMIT\t0x1000\t/* Request is permitted */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n\nstatic void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sshpam_ctxt",
            "&name",
            "&info",
            "&num",
            "&prompts",
            "&echo_on"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: no context\"",
            "__func__"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s\"",
            "__func__"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic char *auth_method = \"unknown\";\nstatic char *auth_submethod = NULL;\n\nint\nmm_answer_pam_query(int sock, struct sshbuf *m)\n{\n\tchar *name = NULL, *info = NULL, **prompts = NULL;\n\tu_int i, num = 0, *echo_on = 0;\n\tint r, ret;\n\n\tdebug3(\"%s\", __func__);\n\tsshpam_authok = NULL;\n\tif (sshpam_ctxt == NULL)\n\t\tfatal(\"%s: no context\", __func__);\n\tret = (sshpam_device.query)(sshpam_ctxt, &name, &info,\n\t    &num, &prompts, &echo_on);\n\tif (ret == 0 && num == 0)\n\t\tsshpam_authok = sshpam_ctxt;\n\tif (num > 1 || name == NULL || info == NULL)\n\t\tfatal(\"sshpam_device.query failed\");\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_RESPOND, 1);\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, ret)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, info)) != 0 ||\n\t    (r = sshbuf_put_u32(m, sshpam_get_maxtries_reached())) != 0 ||\n\t    (r = sshbuf_put_u32(m, num)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tfree(name);\n\tfree(info);\n\tfor (i = 0; i < num; ++i) {\n\t\tif ((r = sshbuf_put_cstring(m, prompts[i])) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, echo_on[i])) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tfree(prompts[i]);\n\t}\n\tfree(prompts);\n\tfree(echo_on);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\tmm_request_send(sock, MONITOR_ANS_PAM_QUERY, m);\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_pam_init_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1025-1048",
    "snippet": "int\nmm_answer_pam_init_ctx(int sock, struct sshbuf *m)\n{\n\tu_int ok = 0;\n\tint r;\n\n\tdebug3(\"%s\", __func__);\n\tif (!options.kbd_interactive_authentication)\n\t\tfatal(\"%s: kbd-int authentication not enabled\", __func__);\n\tif (sshpam_ctxt != NULL)\n\t\tfatal(\"%s: already called\", __func__);\n\tsshpam_ctxt = (sshpam_device.init_ctx)(authctxt);\n\tsshpam_authok = NULL;\n\tsshbuf_reset(m);\n\tif (sshpam_ctxt != NULL) {\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_FREE_CTX, 1);\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_QUERY, 1);\n\t\tok = 1;\n\t}\n\tif ((r = sshbuf_put_u32(m, ok)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_PAM_INIT_CTX, m);\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static Authctxt *authctxt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_PAM_INIT_CTX",
            "m"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "ok"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_permit",
          "args": [
            "mon_dispatch",
            "MONITOR_REQ_PAM_QUERY",
            "1"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "240-251",
          "snippet": "static void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_PERMIT\t0x1000\t/* Request is permitted */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n\nstatic void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "authctxt"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: already called\"",
            "__func__"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s\"",
            "__func__"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic Authctxt *authctxt;\n\nint\nmm_answer_pam_init_ctx(int sock, struct sshbuf *m)\n{\n\tu_int ok = 0;\n\tint r;\n\n\tdebug3(\"%s\", __func__);\n\tif (!options.kbd_interactive_authentication)\n\t\tfatal(\"%s: kbd-int authentication not enabled\", __func__);\n\tif (sshpam_ctxt != NULL)\n\t\tfatal(\"%s: already called\", __func__);\n\tsshpam_ctxt = (sshpam_device.init_ctx)(authctxt);\n\tsshpam_authok = NULL;\n\tsshbuf_reset(m);\n\tif (sshpam_ctxt != NULL) {\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_FREE_CTX, 1);\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_QUERY, 1);\n\t\tok = 1;\n\t}\n\tif ((r = sshbuf_put_u32(m, ok)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_PAM_INIT_CTX, m);\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_pam_account",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "1002-1020",
    "snippet": "int\nmm_answer_pam_account(int sock, struct sshbuf *m)\n{\n\tu_int ret;\n\tint r;\n\n\tif (!options.use_pam)\n\t\tfatal(\"%s: PAM not enabled\", __func__);\n\n\tret = do_pam_account();\n\n\tif ((r = sshbuf_put_u32(m, ret)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, loginmsg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tmm_request_send(sock, MONITOR_ANS_PAM_ACCOUNT, m);\n\n\treturn (ret);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "extern struct sshbuf *loginmsg;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_PAM_ACCOUNT",
            "m"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "m",
            "loginmsg"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "ret"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_pam_account",
          "args": [],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "do_pam_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1014-1037",
          "snippet": "u_int\ndo_pam_account(void)\n{\n\tdebug(\"%s: called\", __func__);\n\tif (sshpam_account_status != -1)\n\t\treturn (sshpam_account_status);\n\n\texpose_authinfo(__func__);\n\n\tsshpam_err = pam_acct_mgmt(sshpam_handle, 0);\n\tdebug3(\"PAM: %s pam_acct_mgmt = %d (%s)\", __func__, sshpam_err,\n\t    pam_strerror(sshpam_handle, sshpam_err));\n\n\tif (sshpam_err != PAM_SUCCESS && sshpam_err != PAM_NEW_AUTHTOK_REQD) {\n\t\tsshpam_account_status = 0;\n\t\treturn (sshpam_account_status);\n\t}\n\n\tif (sshpam_err == PAM_NEW_AUTHTOK_REQD)\n\t\tsshpam_password_change_required(1);\n\n\tsshpam_account_status = 1;\n\treturn (sshpam_account_status);\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ndo_pam_account(void)\n{\n\tdebug(\"%s: called\", __func__);\n\tif (sshpam_account_status != -1)\n\t\treturn (sshpam_account_status);\n\n\texpose_authinfo(__func__);\n\n\tsshpam_err = pam_acct_mgmt(sshpam_handle, 0);\n\tdebug3(\"PAM: %s pam_acct_mgmt = %d (%s)\", __func__, sshpam_err,\n\t    pam_strerror(sshpam_handle, sshpam_err));\n\n\tif (sshpam_err != PAM_SUCCESS && sshpam_err != PAM_NEW_AUTHTOK_REQD) {\n\t\tsshpam_account_status = 0;\n\t\treturn (sshpam_account_status);\n\t}\n\n\tif (sshpam_err == PAM_NEW_AUTHTOK_REQD)\n\t\tsshpam_password_change_required(1);\n\n\tsshpam_account_status = 1;\n\treturn (sshpam_account_status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: PAM not enabled\"",
            "__func__"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\n\nint\nmm_answer_pam_account(int sock, struct sshbuf *m)\n{\n\tu_int ret;\n\tint r;\n\n\tif (!options.use_pam)\n\t\tfatal(\"%s: PAM not enabled\", __func__);\n\n\tret = do_pam_account();\n\n\tif ((r = sshbuf_put_u32(m, ret)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, loginmsg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tmm_request_send(sock, MONITOR_ANS_PAM_ACCOUNT, m);\n\n\treturn (ret);\n}"
  },
  {
    "function_name": "mm_answer_pam_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "987-1000",
    "snippet": "int\nmm_answer_pam_start(int sock, struct sshbuf *m)\n{\n\tif (!options.use_pam)\n\t\tfatal(\"UsePAM not set, but ended up in %s anyway\", __func__);\n\n\tstart_pam(authctxt);\n\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_ACCOUNT, 1);\n\tif (options.kbd_interactive_authentication)\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_INIT_CTX, 1);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static Authctxt *authctxt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "monitor_permit",
          "args": [
            "mon_dispatch",
            "MONITOR_REQ_PAM_INIT_CTX",
            "1"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "240-251",
          "snippet": "static void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_PERMIT\t0x1000\t/* Request is permitted */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n\nstatic void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_pam",
          "args": [
            "authctxt"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "start_pam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "997-1005",
          "snippet": "void\nstart_pam(Authctxt *authctxt)\n{\n\tif (!options.use_pam)\n\t\tfatal(\"PAM: initialisation requested when UsePAM=no\");\n\n\tif (sshpam_init(authctxt) == -1)\n\t\tfatal(\"PAM: initialisation failed\");\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nstart_pam(Authctxt *authctxt)\n{\n\tif (!options.use_pam)\n\t\tfatal(\"PAM: initialisation requested when UsePAM=no\");\n\n\tif (sshpam_init(authctxt) == -1)\n\t\tfatal(\"PAM: initialisation failed\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"UsePAM not set, but ended up in %s anyway\"",
            "__func__"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic Authctxt *authctxt;\n\nint\nmm_answer_pam_start(int sock, struct sshbuf *m)\n{\n\tif (!options.use_pam)\n\t\tfatal(\"UsePAM not set, but ended up in %s anyway\", __func__);\n\n\tstart_pam(authctxt);\n\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_ACCOUNT, 1);\n\tif (options.kbd_interactive_authentication)\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_INIT_CTX, 1);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_bsdauthrespond",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "953-983",
    "snippet": "int\nmm_answer_bsdauthrespond(int sock, struct sshbuf *m)\n{\n\tchar *response;\n\tint r, authok;\n\n\tif (!options.kbd_interactive_authentication)\n\t\tfatal(\"%s: kbd-int authentication not enabled\", __func__);\n\tif (authctxt->as == NULL)\n\t\tfatal(\"%s: no bsd auth session\", __func__);\n\n\tif ((r = sshbuf_get_cstring(m, &response, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tauthok = options.challenge_response_authentication &&\n\t    auth_userresponse(authctxt->as, response, 0);\n\tauthctxt->as = NULL;\n\tdebug3(\"%s: <%s> = <%d>\", __func__, response, authok);\n\tfree(response);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, authok)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"%s: sending authenticated: %d\", __func__, authok);\n\tmm_request_send(sock, MONITOR_ANS_BSDAUTHRESPOND, m);\n\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"bsdauth\";\n\n\treturn (authok != 0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static Authctxt *authctxt;",
      "static char *auth_method = \"unknown\";",
      "static char *auth_submethod = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_BSDAUTHRESPOND",
            "m"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: sending authenticated: %d\"",
            "__func__",
            "authok"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "authok"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "response"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_userresponse",
          "args": [
            "authctxt->as",
            "response",
            "0"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&response",
            "NULL"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: no bsd auth session\"",
            "__func__"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic Authctxt *authctxt;\nstatic char *auth_method = \"unknown\";\nstatic char *auth_submethod = NULL;\n\nint\nmm_answer_bsdauthrespond(int sock, struct sshbuf *m)\n{\n\tchar *response;\n\tint r, authok;\n\n\tif (!options.kbd_interactive_authentication)\n\t\tfatal(\"%s: kbd-int authentication not enabled\", __func__);\n\tif (authctxt->as == NULL)\n\t\tfatal(\"%s: no bsd auth session\", __func__);\n\n\tif ((r = sshbuf_get_cstring(m, &response, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tauthok = options.challenge_response_authentication &&\n\t    auth_userresponse(authctxt->as, response, 0);\n\tauthctxt->as = NULL;\n\tdebug3(\"%s: <%s> = <%d>\", __func__, response, authok);\n\tfree(response);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, authok)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"%s: sending authenticated: %d\", __func__, authok);\n\tmm_request_send(sock, MONITOR_ANS_BSDAUTHRESPOND, m);\n\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"bsdauth\";\n\n\treturn (authok != 0);\n}"
  },
  {
    "function_name": "mm_answer_bsdauthquery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "919-951",
    "snippet": "int\nmm_answer_bsdauthquery(int sock, struct sshbuf *m)\n{\n\tchar *name, *infotxt;\n\tu_int numprompts, *echo_on, success;\n\tchar **prompts;\n\tint r;\n\n\tif (!options.kbd_interactive_authentication)\n\t\tfatal(\"%s: kbd-int authentication not enabled\", __func__);\n\tsuccess = bsdauth_query(authctxt, &name, &infotxt, &numprompts,\n\t    &prompts, &echo_on) < 0 ? 0 : 1;\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, success)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (success) {\n\t\tif ((r = sshbuf_put_cstring(m, prompts[0])) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\tdebug3(\"%s: sending challenge success: %u\", __func__, success);\n\tmm_request_send(sock, MONITOR_ANS_BSDAUTHQUERY, m);\n\n\tif (success) {\n\t\tfree(name);\n\t\tfree(infotxt);\n\t\tfree(prompts);\n\t\tfree(echo_on);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static Authctxt *authctxt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "echo_on"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_BSDAUTHQUERY",
            "m"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: sending challenge success: %u\"",
            "__func__",
            "success"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "m",
            "prompts[0]"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "success"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bsdauth_query",
          "args": [
            "authctxt",
            "&name",
            "&infotxt",
            "&numprompts",
            "&prompts",
            "&echo_on"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "bsdauth_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-bsdauth.c",
          "lines": "52-95",
          "snippet": "int\nbsdauth_query(void *ctx, char **name, char **infotxt,\n   u_int *numprompts, char ***prompts, u_int **echo_on)\n{\n\tAuthctxt *authctxt = ctx;\n\tchar *challenge = NULL;\n\n\t*infotxt = NULL;\n\t*numprompts = 0;\n\t*prompts = NULL;\n\t*echo_on = NULL;\n\n\tif (authctxt->as != NULL) {\n\t\tdebug2(\"bsdauth_query: try reuse session\");\n\t\tchallenge = auth_getitem(authctxt->as, AUTHV_CHALLENGE);\n\t\tif (challenge == NULL) {\n\t\t\tauth_close(authctxt->as);\n\t\t\tauthctxt->as = NULL;\n\t\t}\n\t}\n\n\tif (challenge == NULL) {\n\t\tdebug2(\"bsdauth_query: new bsd auth session\");\n\t\tdebug3(\"bsdauth_query: style %s\",\n\t\t    authctxt->style ? authctxt->style : \"<default>\");\n\t\tauthctxt->as = auth_userchallenge(authctxt->user,\n\t\t    authctxt->style, \"auth-ssh\", &challenge);\n\t\tif (authctxt->as == NULL)\n\t\t\tchallenge = NULL;\n\t\tdebug2(\"bsdauth_query: <%s>\", challenge ? challenge : \"empty\");\n\t}\n\n\tif (challenge == NULL)\n\t\treturn -1;\n\n\t*name = xstrdup(\"\");\n\t*infotxt = xstrdup(\"\");\n\t*numprompts = 1;\n\t*prompts = xcalloc(*numprompts, sizeof(char *));\n\t*echo_on = xcalloc(*numprompts, sizeof(u_int));\n\t(*prompts)[0] = xstrdup(challenge);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nbsdauth_query(void *ctx, char **name, char **infotxt,\n   u_int *numprompts, char ***prompts, u_int **echo_on)\n{\n\tAuthctxt *authctxt = ctx;\n\tchar *challenge = NULL;\n\n\t*infotxt = NULL;\n\t*numprompts = 0;\n\t*prompts = NULL;\n\t*echo_on = NULL;\n\n\tif (authctxt->as != NULL) {\n\t\tdebug2(\"bsdauth_query: try reuse session\");\n\t\tchallenge = auth_getitem(authctxt->as, AUTHV_CHALLENGE);\n\t\tif (challenge == NULL) {\n\t\t\tauth_close(authctxt->as);\n\t\t\tauthctxt->as = NULL;\n\t\t}\n\t}\n\n\tif (challenge == NULL) {\n\t\tdebug2(\"bsdauth_query: new bsd auth session\");\n\t\tdebug3(\"bsdauth_query: style %s\",\n\t\t    authctxt->style ? authctxt->style : \"<default>\");\n\t\tauthctxt->as = auth_userchallenge(authctxt->user,\n\t\t    authctxt->style, \"auth-ssh\", &challenge);\n\t\tif (authctxt->as == NULL)\n\t\t\tchallenge = NULL;\n\t\tdebug2(\"bsdauth_query: <%s>\", challenge ? challenge : \"empty\");\n\t}\n\n\tif (challenge == NULL)\n\t\treturn -1;\n\n\t*name = xstrdup(\"\");\n\t*infotxt = xstrdup(\"\");\n\t*numprompts = 1;\n\t*prompts = xcalloc(*numprompts, sizeof(char *));\n\t*echo_on = xcalloc(*numprompts, sizeof(u_int));\n\t(*prompts)[0] = xstrdup(challenge);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: kbd-int authentication not enabled\"",
            "__func__"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic Authctxt *authctxt;\n\nint\nmm_answer_bsdauthquery(int sock, struct sshbuf *m)\n{\n\tchar *name, *infotxt;\n\tu_int numprompts, *echo_on, success;\n\tchar **prompts;\n\tint r;\n\n\tif (!options.kbd_interactive_authentication)\n\t\tfatal(\"%s: kbd-int authentication not enabled\", __func__);\n\tsuccess = bsdauth_query(authctxt, &name, &infotxt, &numprompts,\n\t    &prompts, &echo_on) < 0 ? 0 : 1;\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, success)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (success) {\n\t\tif ((r = sshbuf_put_cstring(m, prompts[0])) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\tdebug3(\"%s: sending challenge success: %u\", __func__, success);\n\tmm_request_send(sock, MONITOR_ANS_BSDAUTHQUERY, m);\n\n\tif (success) {\n\t\tfree(name);\n\t\tfree(infotxt);\n\t\tfree(prompts);\n\t\tfree(echo_on);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_authpassword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "878-916",
    "snippet": "int\nmm_answer_authpassword(int sock, struct sshbuf *m)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tstatic int call_count;\n\tchar *passwd;\n\tint r, authenticated;\n\tsize_t plen;\n\n\tif (!options.password_authentication)\n\t\tfatal(\"%s: password authentication not enabled\", __func__);\n\tif ((r = sshbuf_get_cstring(m, &passwd, &plen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t/* Only authenticate if the context is valid */\n\tauthenticated = options.password_authentication &&\n\t    auth_password(ssh, passwd);\n\texplicit_bzero(passwd, plen);\n\tfree(passwd);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, authenticated)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n#ifdef USE_PAM\n\tif ((r = sshbuf_put_u32(m, sshpam_get_maxtries_reached())) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n#endif\n\n\tdebug3(\"%s: sending result %d\", __func__, authenticated);\n\tmm_request_send(sock, MONITOR_ANS_AUTHPASSWORD, m);\n\n\tcall_count++;\n\tif (plen == 0 && call_count == 1)\n\t\tauth_method = \"none\";\n\telse\n\t\tauth_method = \"password\";\n\n\t/* Causes monitor loop to terminate if authenticated */\n\treturn (authenticated);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static int monitor_read_log(struct monitor *);",
      "static char *auth_method = \"unknown\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_AUTHPASSWORD",
            "m"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: sending result %d\"",
            "__func__",
            "authenticated"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "sshpam_get_maxtries_reached()"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpam_get_maxtries_reached",
          "args": [],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "sshpam_get_maxtries_reached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1333-1337",
          "snippet": "int\nsshpam_get_maxtries_reached(void)\n{\n\treturn sshpam_maxtries_reached;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpam_get_maxtries_reached(void)\n{\n\treturn sshpam_maxtries_reached;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "passwd"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "passwd",
            "plen"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_password",
          "args": [
            "ssh",
            "passwd"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "auth_password",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-passwd.c",
          "lines": "76-129",
          "snippet": "int\nauth_password(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(ssh, password);\n\tif (authctxt->force_pwchange)\n\t\tauth_restrict_session(ssh);\n\treturn (result && ok);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_PASSWORD_LEN\t1024"
          ],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_PASSWORD_LEN\t1024\n\nextern ServerOptions options;\n\nint\nauth_password(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(ssh, password);\n\tif (authctxt->force_pwchange)\n\t\tauth_restrict_session(ssh);\n\treturn (result && ok);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&passwd",
            "&plen"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: password authentication not enabled\"",
            "__func__"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\nstatic char *auth_method = \"unknown\";\n\nint\nmm_answer_authpassword(int sock, struct sshbuf *m)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tstatic int call_count;\n\tchar *passwd;\n\tint r, authenticated;\n\tsize_t plen;\n\n\tif (!options.password_authentication)\n\t\tfatal(\"%s: password authentication not enabled\", __func__);\n\tif ((r = sshbuf_get_cstring(m, &passwd, &plen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t/* Only authenticate if the context is valid */\n\tauthenticated = options.password_authentication &&\n\t    auth_password(ssh, passwd);\n\texplicit_bzero(passwd, plen);\n\tfree(passwd);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, authenticated)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n#ifdef USE_PAM\n\tif ((r = sshbuf_put_u32(m, sshpam_get_maxtries_reached())) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n#endif\n\n\tdebug3(\"%s: sending result %d\", __func__, authenticated);\n\tmm_request_send(sock, MONITOR_ANS_AUTHPASSWORD, m);\n\n\tcall_count++;\n\tif (plen == 0 && call_count == 1)\n\t\tauth_method = \"none\";\n\telse\n\t\tauth_method = \"password\";\n\n\t/* Causes monitor loop to terminate if authenticated */\n\treturn (authenticated);\n}"
  },
  {
    "function_name": "key_base_type_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "855-876",
    "snippet": "static int\nkey_base_type_match(const char *method, const struct sshkey *key,\n    const char *list)\n{\n\tchar *s, *l, *ol = xstrdup(list);\n\tint found = 0;\n\n\tl = ol;\n\tfor ((s = strsep(&l, \",\")); s && *s != '\\0'; (s = strsep(&l, \",\"))) {\n\t\tif (sshkey_type_from_name(s) == key->type) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\terror(\"%s key type %s is not in permitted list %s\", method,\n\t\t    sshkey_ssh_name(key), list);\n\t}\n\n\tfree(ol);\n\treturn found;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ol"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s key type %s is not in permitted list %s\"",
            "method",
            "sshkey_ssh_name(key)",
            "list"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "key"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "s"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&l",
            "\",\""
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "xstrsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keyscan.c",
          "lines": "162-178",
          "snippet": "static char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}",
          "includes": [
            "#include \"dns.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"myproposal.h\"",
            "#include \"compat.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <openssl/bn.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/resource.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"compat.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <netdb.h>\n#include <openssl/bn.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/resource.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "list"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nkey_base_type_match(const char *method, const struct sshkey *key,\n    const char *list)\n{\n\tchar *s, *l, *ol = xstrdup(list);\n\tint found = 0;\n\n\tl = ol;\n\tfor ((s = strsep(&l, \",\")); s && *s != '\\0'; (s = strsep(&l, \",\"))) {\n\t\tif (sshkey_type_from_name(s) == key->type) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\terror(\"%s key type %s is not in permitted list %s\", method,\n\t\t    sshkey_ssh_name(key), list);\n\t}\n\n\tfree(ol);\n\treturn found;\n}"
  },
  {
    "function_name": "mm_answer_authserv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "828-847",
    "snippet": "int\nmm_answer_authserv(int sock, struct sshbuf *m)\n{\n\tint r;\n\n\tmonitor_permit_authentications(1);\n\n\tif ((r = sshbuf_get_cstring(m, &authctxt->service, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &authctxt->style, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"%s: service=%s, style=%s\",\n\t    __func__, authctxt->service, authctxt->style);\n\n\tif (strlen(authctxt->style) == 0) {\n\t\tfree(authctxt->style);\n\t\tauthctxt->style = NULL;\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static Authctxt *authctxt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "authctxt->style"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "authctxt->style"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: service=%s, style=%s\"",
            "__func__",
            "authctxt->service",
            "authctxt->style"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&authctxt->style",
            "NULL"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_permit_authentications",
          "args": [
            "1"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_permit_authentications",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "253-265",
          "snippet": "static void\nmonitor_permit_authentications(int permit)\n{\n\tstruct mon_table *ent = mon_dispatch;\n\n\twhile (ent->f != NULL) {\n\t\tif (ent->flags & MON_AUTH) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t}\n\t\tent++;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_PERMIT\t0x1000\t/* Request is permitted */",
            "#define MON_AUTH\t(MON_ISAUTH|MON_AUTHDECIDE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n#define MON_AUTH\t(MON_ISAUTH|MON_AUTHDECIDE)\n\nstatic void\nmonitor_permit_authentications(int permit)\n{\n\tstruct mon_table *ent = mon_dispatch;\n\n\twhile (ent->f != NULL) {\n\t\tif (ent->flags & MON_AUTH) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t}\n\t\tent++;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic Authctxt *authctxt;\n\nint\nmm_answer_authserv(int sock, struct sshbuf *m)\n{\n\tint r;\n\n\tmonitor_permit_authentications(1);\n\n\tif ((r = sshbuf_get_cstring(m, &authctxt->service, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &authctxt->style, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"%s: service=%s, style=%s\",\n\t    __func__, authctxt->service, authctxt->style);\n\n\tif (strlen(authctxt->style) == 0) {\n\t\tfree(authctxt->style);\n\t\tauthctxt->style = NULL;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_auth2_read_banner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "813-826",
    "snippet": "int mm_answer_auth2_read_banner(int sock, struct sshbuf *m)\n{\n\tchar *banner;\n\tint r;\n\n\tsshbuf_reset(m);\n\tbanner = auth2_read_banner();\n\tif ((r = sshbuf_put_cstring(m, banner != NULL ? banner : \"\")) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_AUTH2_READ_BANNER, m);\n\tfree(banner);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "banner"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_AUTH2_READ_BANNER",
            "m"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "m",
            "banner != NULL ? banner : \"\""
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_read_banner",
          "args": [],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_read_banner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "107-138",
          "snippet": "char *\nauth2_read_banner(void)\n{\n\tstruct stat st;\n\tchar *banner = NULL;\n\tsize_t len, n;\n\tint fd;\n\n\tif ((fd = open(options.banner, O_RDONLY)) == -1)\n\t\treturn (NULL);\n\tif (fstat(fd, &st) == -1) {\n\t\tclose(fd);\n\t\treturn (NULL);\n\t}\n\tif (st.st_size <= 0 || st.st_size > 1*1024*1024) {\n\t\tclose(fd);\n\t\treturn (NULL);\n\t}\n\n\tlen = (size_t)st.st_size;\t\t/* truncate */\n\tbanner = xmalloc(len + 1);\n\tn = atomicio(read, fd, banner, len);\n\tclose(fd);\n\n\tif (n != len) {\n\t\tfree(banner);\n\t\treturn (NULL);\n\t}\n\tbanner[n] = '\\0';\n\n\treturn (banner);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nchar *\nauth2_read_banner(void)\n{\n\tstruct stat st;\n\tchar *banner = NULL;\n\tsize_t len, n;\n\tint fd;\n\n\tif ((fd = open(options.banner, O_RDONLY)) == -1)\n\t\treturn (NULL);\n\tif (fstat(fd, &st) == -1) {\n\t\tclose(fd);\n\t\treturn (NULL);\n\t}\n\tif (st.st_size <= 0 || st.st_size > 1*1024*1024) {\n\t\tclose(fd);\n\t\treturn (NULL);\n\t}\n\n\tlen = (size_t)st.st_size;\t\t/* truncate */\n\tbanner = xmalloc(len + 1);\n\tn = atomicio(read, fd, banner, len);\n\tclose(fd);\n\n\tif (n != len) {\n\t\tfree(banner);\n\t\treturn (NULL);\n\t}\n\tbanner[n] = '\\0';\n\n\treturn (banner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\n\nint mm_answer_auth2_read_banner(int sock, struct sshbuf *m)\n{\n\tchar *banner;\n\tint r;\n\n\tsshbuf_reset(m);\n\tbanner = auth2_read_banner();\n\tif ((r = sshbuf_put_cstring(m, banner != NULL ? banner : \"\")) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_AUTH2_READ_BANNER, m);\n\tfree(banner);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_pwnamallow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "712-811",
    "snippet": "int\nmm_answer_pwnamallow(int sock, struct sshbuf *m)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tchar *username;\n\tstruct passwd *pwent;\n\tint r, allowed = 0;\n\tu_int i;\n\n\tdebug3(\"%s\", __func__);\n\n\tif (authctxt->attempt++ != 0)\n\t\tfatal(\"%s: multiple attempts for getpwnam\", __func__);\n\n\tif ((r = sshbuf_get_cstring(m, &username, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tpwent = getpwnamallow(username);\n\n\tauthctxt->user = xstrdup(username);\n\tsetproctitle(\"%s [priv]\", pwent ? username : \"unknown\");\n\tfree(username);\n\n\tsshbuf_reset(m);\n\n\tif (pwent == NULL) {\n\t\tif ((r = sshbuf_put_u8(m, 0)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tauthctxt->pw = fakepw();\n\t\tgoto out;\n\t}\n\n\tallowed = 1;\n\tauthctxt->pw = pwent;\n\tauthctxt->valid = 1;\n\n\t/* XXX don't sent pwent to unpriv; send fake class/dir/shell too */\n\tif ((r = sshbuf_put_u8(m, 1)) != 0 ||\n\t    (r = sshbuf_put_string(m, pwent, sizeof(*pwent))) != 0 ||\n\t    (r = sshbuf_put_cstring(m, pwent->pw_name)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, \"*\")) != 0 ||\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\t    (r = sshbuf_put_cstring(m, pwent->pw_gecos)) != 0 ||\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\t    (r = sshbuf_put_cstring(m, pwent->pw_class)) != 0 ||\n#endif\n\t    (r = sshbuf_put_cstring(m, pwent->pw_dir)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, pwent->pw_shell)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n out:\n\tssh_packet_set_log_preamble(ssh, \"%suser %s\",\n\t    authctxt->valid ? \"authenticating\" : \"invalid \", authctxt->user);\n\tif ((r = sshbuf_put_string(m, &options, sizeof(options))) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n#define M_CP_STROPT(x) do { \\\n\t\tif (options.x != NULL) { \\\n\t\t\tif ((r = sshbuf_put_cstring(m, options.x)) != 0) \\\n\t\t\t\tfatal(\"%s: buffer error: %s\", \\\n\t\t\t\t    __func__, ssh_err(r)); \\\n\t\t} \\\n\t} while (0)\n#define M_CP_STRARRAYOPT(x, nx) do { \\\n\t\tfor (i = 0; i < options.nx; i++) { \\\n\t\t\tif ((r = sshbuf_put_cstring(m, options.x[i])) != 0) \\\n\t\t\t\tfatal(\"%s: buffer error: %s\", \\\n\t\t\t\t    __func__, ssh_err(r)); \\\n\t\t} \\\n\t} while (0)\n\t/* See comment in servconf.h */\n\tCOPY_MATCH_STRING_OPTS();\n#undef M_CP_STROPT\n#undef M_CP_STRARRAYOPT\n\n\t/* Create valid auth method lists */\n\tif (auth2_setup_methods_lists(authctxt) != 0) {\n\t\t/*\n\t\t * The monitor will continue long enough to let the child\n\t\t * run to it's packet_disconnect(), but it must not allow any\n\t\t * authentication to succeed.\n\t\t */\n\t\tdebug(\"%s: no valid authentication method lists\", __func__);\n\t}\n\n\tdebug3(\"%s: sending MONITOR_ANS_PWNAM: %d\", __func__, allowed);\n\tmm_request_send(sock, MONITOR_ANS_PWNAM, m);\n\n\t/* Allow service/style information on the auth context */\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_AUTHSERV, 1);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_AUTH2_READ_BANNER, 1);\n\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_START, 1);\n#endif\n\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static int monitor_read_log(struct monitor *);",
      "static Authctxt *authctxt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "monitor_permit",
          "args": [
            "mon_dispatch",
            "MONITOR_REQ_PAM_START",
            "1"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "240-251",
          "snippet": "static void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_PERMIT\t0x1000\t/* Request is permitted */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n\nstatic void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_PWNAM",
            "m"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: sending MONITOR_ANS_PWNAM: %d\"",
            "__func__",
            "allowed"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_setup_methods_lists",
          "args": [
            "authctxt"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_setup_methods_lists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "556-585",
          "snippet": "int\nauth2_setup_methods_lists(Authctxt *authctxt)\n{\n\tu_int i;\n\n\tif (options.num_auth_methods == 0)\n\t\treturn 0;\n\tdebug3(\"%s: checking methods\", __func__);\n\tauthctxt->auth_methods = xcalloc(options.num_auth_methods,\n\t    sizeof(*authctxt->auth_methods));\n\tauthctxt->num_auth_methods = 0;\n\tfor (i = 0; i < options.num_auth_methods; i++) {\n\t\tif (auth2_methods_valid(options.auth_methods[i], 1) != 0) {\n\t\t\tlogit(\"Authentication methods list \\\"%s\\\" contains \"\n\t\t\t    \"disabled method, skipping\",\n\t\t\t    options.auth_methods[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"authentication methods list %d: %s\",\n\t\t    authctxt->num_auth_methods, options.auth_methods[i]);\n\t\tauthctxt->auth_methods[authctxt->num_auth_methods++] =\n\t\t    xstrdup(options.auth_methods[i]);\n\t}\n\tif (authctxt->num_auth_methods == 0) {\n\t\terror(\"No AuthenticationMethods left after eliminating \"\n\t\t    \"disabled methods\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nint\nauth2_setup_methods_lists(Authctxt *authctxt)\n{\n\tu_int i;\n\n\tif (options.num_auth_methods == 0)\n\t\treturn 0;\n\tdebug3(\"%s: checking methods\", __func__);\n\tauthctxt->auth_methods = xcalloc(options.num_auth_methods,\n\t    sizeof(*authctxt->auth_methods));\n\tauthctxt->num_auth_methods = 0;\n\tfor (i = 0; i < options.num_auth_methods; i++) {\n\t\tif (auth2_methods_valid(options.auth_methods[i], 1) != 0) {\n\t\t\tlogit(\"Authentication methods list \\\"%s\\\" contains \"\n\t\t\t    \"disabled method, skipping\",\n\t\t\t    options.auth_methods[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"authentication methods list %d: %s\",\n\t\t    authctxt->num_auth_methods, options.auth_methods[i]);\n\t\tauthctxt->auth_methods[authctxt->num_auth_methods++] =\n\t\t    xstrdup(options.auth_methods[i]);\n\t}\n\tif (authctxt->num_auth_methods == 0) {\n\t\terror(\"No AuthenticationMethods left after eliminating \"\n\t\t    \"disabled methods\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPY_MATCH_STRING_OPTS",
          "args": [],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "m",
            "&options",
            "sizeof(options)"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_set_log_preamble",
          "args": [
            "ssh",
            "\"%suser %s\"",
            "authctxt->valid ? \"authenticating\" : \"invalid \"",
            "authctxt->user"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_set_log_preamble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "347-364",
          "snippet": "int\nssh_packet_set_log_preamble(struct ssh *ssh, const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tfree(ssh->log_preamble);\n\tif (fmt == NULL)\n\t\tssh->log_preamble = NULL;\n\telse {\n\t\tva_start(args, fmt);\n\t\tr = vasprintf(&ssh->log_preamble, fmt, args);\n\t\tva_end(args);\n\t\tif (r < 0 || ssh->log_preamble == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_set_log_preamble(struct ssh *ssh, const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tfree(ssh->log_preamble);\n\tif (fmt == NULL)\n\t\tssh->log_preamble = NULL;\n\telse {\n\t\tva_start(args, fmt);\n\t\tr = vasprintf(&ssh->log_preamble, fmt, args);\n\t\tva_end(args);\n\t\tif (r < 0 || ssh->log_preamble == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "m",
            "pwent->pw_shell"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAVE_STRUCT_PASSWD_PW_CLASS",
          "args": [
            "r = sshbuf_put_cstring(m, pwent->pw_class)"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAVE_STRUCT_PASSWD_PW_GECOS",
          "args": [
            "r = sshbuf_put_cstring(m, pwent->pw_gecos)"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "m",
            "1"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fakepw",
          "args": [],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "fakepw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "717-738",
          "snippet": "struct passwd *\nfakepw(void)\n{\n\tstatic struct passwd fake;\n\n\tmemset(&fake, 0, sizeof(fake));\n\tfake.pw_name = \"NOUSER\";\n\tfake.pw_passwd =\n\t    \"$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK\";\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\tfake.pw_gecos = \"NOUSER\";\n#endif\n\tfake.pw_uid = privsep_pw == NULL ? (uid_t)-1 : privsep_pw->pw_uid;\n\tfake.pw_gid = privsep_pw == NULL ? (gid_t)-1 : privsep_pw->pw_gid;\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\tfake.pw_class = \"\";\n#endif\n\tfake.pw_dir = \"/nonexist\";\n\tfake.pw_shell = \"/nonexist\";\n\n\treturn (&fake);\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct passwd *privsep_pw;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct passwd *privsep_pw;\n\nstruct passwd *\nfakepw(void)\n{\n\tstatic struct passwd fake;\n\n\tmemset(&fake, 0, sizeof(fake));\n\tfake.pw_name = \"NOUSER\";\n\tfake.pw_passwd =\n\t    \"$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK\";\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\tfake.pw_gecos = \"NOUSER\";\n#endif\n\tfake.pw_uid = privsep_pw == NULL ? (uid_t)-1 : privsep_pw->pw_uid;\n\tfake.pw_gid = privsep_pw == NULL ? (gid_t)-1 : privsep_pw->pw_gid;\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\tfake.pw_class = \"\";\n#endif\n\tfake.pw_dir = \"/nonexist\";\n\tfake.pw_shell = \"/nonexist\";\n\n\treturn (&fake);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "username"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setproctitle",
          "args": [
            "\"%s [priv]\"",
            "pwent ? username : \"unknown\""
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "setproctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setproctitle.c",
          "lines": "122-167",
          "snippet": "void\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}",
          "includes": [
            "#include <vis.h>",
            "#include <string.h>",
            "#include <sys/pstat.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SPT_REUSEARGV\t2\t/* cover argv with title information */",
            "#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */",
            "#define SPT_NONE\t0\t/* don't use it at all */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vis.h>\n#include <string.h>\n#include <sys/pstat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\n#define SPT_REUSEARGV\t2\t/* cover argv with title information */\n#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */\n#define SPT_NONE\t0\t/* don't use it at all */\n\nvoid\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "username"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpwnamallow",
          "args": [
            "username"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "getpwnamallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "560-632",
          "snippet": "struct passwd *\ngetpwnamallow(const char *user)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n#ifdef HAVE_LOGIN_CAP\n\textern login_cap_t *lc;\n#ifdef BSD_AUTH\n\tauth_session_t *as;\n#endif\n#endif\n\tstruct passwd *pw;\n\tstruct connection_info *ci = get_connection_info(1, options.use_dns);\n\n\tci->user = user;\n\tparse_server_match_config(&options, ci);\n\tlog_change_level(options.log_level);\n\tprocess_permitopen(ssh, &options);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_setauthdb(user);\n#endif\n\n\tpw = getpwnam(user);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_restoreauthdb();\n#endif\n#ifdef HAVE_CYGWIN\n\t/*\n\t * Windows usernames are case-insensitive.  To avoid later problems\n\t * when trying to match the username, the user is only allowed to\n\t * login if the username is given in the same case as stored in the\n\t * user database.\n\t */\n\tif (pw != NULL && strcmp(user, pw->pw_name) != 0) {\n\t\tlogit(\"Login name %.100s does not match stored username %.100s\",\n\t\t    user, pw->pw_name);\n\t\tpw = NULL;\n\t}\n#endif\n\tif (pw == NULL) {\n\t\tlogit(\"Invalid user %.100s from %.100s port %d\",\n\t\t    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#ifdef CUSTOM_FAILED_LOGIN\n\t\trecord_failed_login(user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(SSH_INVALID_USER);\n#endif /* SSH_AUDIT_EVENTS */\n\t\treturn (NULL);\n\t}\n\tif (!allowed_user(pw))\n\t\treturn (NULL);\n#ifdef HAVE_LOGIN_CAP\n\tif ((lc = login_getclass(pw->pw_class)) == NULL) {\n\t\tdebug(\"unable to get login class: %s\", user);\n\t\treturn (NULL);\n\t}\n#ifdef BSD_AUTH\n\tif ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||\n\t    auth_approval(as, lc, pw->pw_name, \"ssh\") <= 0) {\n\t\tdebug(\"Approval failure for %s\", user);\n\t\tpw = NULL;\n\t}\n\tif (as != NULL)\n\t\tauth_close(as);\n#endif\n#endif\n\tif (pw != NULL)\n\t\treturn (pwcopy(pw));\n\treturn (NULL);\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstruct passwd *\ngetpwnamallow(const char *user)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n#ifdef HAVE_LOGIN_CAP\n\textern login_cap_t *lc;\n#ifdef BSD_AUTH\n\tauth_session_t *as;\n#endif\n#endif\n\tstruct passwd *pw;\n\tstruct connection_info *ci = get_connection_info(1, options.use_dns);\n\n\tci->user = user;\n\tparse_server_match_config(&options, ci);\n\tlog_change_level(options.log_level);\n\tprocess_permitopen(ssh, &options);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_setauthdb(user);\n#endif\n\n\tpw = getpwnam(user);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_restoreauthdb();\n#endif\n#ifdef HAVE_CYGWIN\n\t/*\n\t * Windows usernames are case-insensitive.  To avoid later problems\n\t * when trying to match the username, the user is only allowed to\n\t * login if the username is given in the same case as stored in the\n\t * user database.\n\t */\n\tif (pw != NULL && strcmp(user, pw->pw_name) != 0) {\n\t\tlogit(\"Login name %.100s does not match stored username %.100s\",\n\t\t    user, pw->pw_name);\n\t\tpw = NULL;\n\t}\n#endif\n\tif (pw == NULL) {\n\t\tlogit(\"Invalid user %.100s from %.100s port %d\",\n\t\t    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#ifdef CUSTOM_FAILED_LOGIN\n\t\trecord_failed_login(user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(SSH_INVALID_USER);\n#endif /* SSH_AUDIT_EVENTS */\n\t\treturn (NULL);\n\t}\n\tif (!allowed_user(pw))\n\t\treturn (NULL);\n#ifdef HAVE_LOGIN_CAP\n\tif ((lc = login_getclass(pw->pw_class)) == NULL) {\n\t\tdebug(\"unable to get login class: %s\", user);\n\t\treturn (NULL);\n\t}\n#ifdef BSD_AUTH\n\tif ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||\n\t    auth_approval(as, lc, pw->pw_name, \"ssh\") <= 0) {\n\t\tdebug(\"Approval failure for %s\", user);\n\t\tpw = NULL;\n\t}\n\tif (as != NULL)\n\t\tauth_close(as);\n#endif\n#endif\n\tif (pw != NULL)\n\t\treturn (pwcopy(pw));\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&username",
            "NULL"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: multiple attempts for getpwnam\"",
            "__func__"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\nstatic Authctxt *authctxt;\n\nint\nmm_answer_pwnamallow(int sock, struct sshbuf *m)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tchar *username;\n\tstruct passwd *pwent;\n\tint r, allowed = 0;\n\tu_int i;\n\n\tdebug3(\"%s\", __func__);\n\n\tif (authctxt->attempt++ != 0)\n\t\tfatal(\"%s: multiple attempts for getpwnam\", __func__);\n\n\tif ((r = sshbuf_get_cstring(m, &username, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tpwent = getpwnamallow(username);\n\n\tauthctxt->user = xstrdup(username);\n\tsetproctitle(\"%s [priv]\", pwent ? username : \"unknown\");\n\tfree(username);\n\n\tsshbuf_reset(m);\n\n\tif (pwent == NULL) {\n\t\tif ((r = sshbuf_put_u8(m, 0)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tauthctxt->pw = fakepw();\n\t\tgoto out;\n\t}\n\n\tallowed = 1;\n\tauthctxt->pw = pwent;\n\tauthctxt->valid = 1;\n\n\t/* XXX don't sent pwent to unpriv; send fake class/dir/shell too */\n\tif ((r = sshbuf_put_u8(m, 1)) != 0 ||\n\t    (r = sshbuf_put_string(m, pwent, sizeof(*pwent))) != 0 ||\n\t    (r = sshbuf_put_cstring(m, pwent->pw_name)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, \"*\")) != 0 ||\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\t    (r = sshbuf_put_cstring(m, pwent->pw_gecos)) != 0 ||\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\t    (r = sshbuf_put_cstring(m, pwent->pw_class)) != 0 ||\n#endif\n\t    (r = sshbuf_put_cstring(m, pwent->pw_dir)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, pwent->pw_shell)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n out:\n\tssh_packet_set_log_preamble(ssh, \"%suser %s\",\n\t    authctxt->valid ? \"authenticating\" : \"invalid \", authctxt->user);\n\tif ((r = sshbuf_put_string(m, &options, sizeof(options))) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n#define M_CP_STROPT(x) do { \\\n\t\tif (options.x != NULL) { \\\n\t\t\tif ((r = sshbuf_put_cstring(m, options.x)) != 0) \\\n\t\t\t\tfatal(\"%s: buffer error: %s\", \\\n\t\t\t\t    __func__, ssh_err(r)); \\\n\t\t} \\\n\t} while (0)\n#define M_CP_STRARRAYOPT(x, nx) do { \\\n\t\tfor (i = 0; i < options.nx; i++) { \\\n\t\t\tif ((r = sshbuf_put_cstring(m, options.x[i])) != 0) \\\n\t\t\t\tfatal(\"%s: buffer error: %s\", \\\n\t\t\t\t    __func__, ssh_err(r)); \\\n\t\t} \\\n\t} while (0)\n\t/* See comment in servconf.h */\n\tCOPY_MATCH_STRING_OPTS();\n#undef M_CP_STROPT\n#undef M_CP_STRARRAYOPT\n\n\t/* Create valid auth method lists */\n\tif (auth2_setup_methods_lists(authctxt) != 0) {\n\t\t/*\n\t\t * The monitor will continue long enough to let the child\n\t\t * run to it's packet_disconnect(), but it must not allow any\n\t\t * authentication to succeed.\n\t\t */\n\t\tdebug(\"%s: no valid authentication method lists\", __func__);\n\t}\n\n\tdebug3(\"%s: sending MONITOR_ANS_PWNAM: %d\", __func__, allowed);\n\tmm_request_send(sock, MONITOR_ANS_PWNAM, m);\n\n\t/* Allow service/style information on the auth context */\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_AUTHSERV, 1);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_AUTH2_READ_BANNER, 1);\n\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_START, 1);\n#endif\n\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_sign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "609-708",
    "snippet": "int\nmm_answer_sign(int sock, struct sshbuf *m)\n{\n\tstruct ssh *ssh = active_state; \t/* XXX */\n\textern int auth_sock;\t\t\t/* XXX move to state struct? */\n\tstruct sshkey *key;\n\tstruct sshbuf *sigbuf = NULL;\n\tu_char *p = NULL, *signature = NULL;\n\tchar *alg = NULL;\n\tsize_t datlen, siglen, alglen;\n\tint r, is_proof = 0;\n\tu_int keyid, compat;\n\tconst char proof_req[] = \"hostkeys-prove-00@openssh.com\";\n\n\tdebug3(\"%s\", __func__);\n\n\tif ((r = sshbuf_get_u32(m, &keyid)) != 0 ||\n\t    (r = sshbuf_get_string(m, &p, &datlen)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &alg, &alglen)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &compat)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (keyid > INT_MAX)\n\t\tfatal(\"%s: invalid key ID\", __func__);\n\n\t/*\n\t * Supported KEX types use SHA1 (20 bytes), SHA256 (32 bytes),\n\t * SHA384 (48 bytes) and SHA512 (64 bytes).\n\t *\n\t * Otherwise, verify the signature request is for a hostkey\n\t * proof.\n\t *\n\t * XXX perform similar check for KEX signature requests too?\n\t * it's not trivial, since what is signed is the hash, rather\n\t * than the full kex structure...\n\t */\n\tif (datlen != 20 && datlen != 32 && datlen != 48 && datlen != 64) {\n\t\t/*\n\t\t * Construct expected hostkey proof and compare it to what\n\t\t * the client sent us.\n\t\t */\n\t\tif (session_id2_len == 0) /* hostkeys is never first */\n\t\t\tfatal(\"%s: bad data length: %zu\", __func__, datlen);\n\t\tif ((key = get_hostkey_public_by_index(keyid, ssh)) == NULL)\n\t\t\tfatal(\"%s: no hostkey for index %d\", __func__, keyid);\n\t\tif ((sigbuf = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new\", __func__);\n\t\tif ((r = sshbuf_put_cstring(sigbuf, proof_req)) != 0 ||\n\t\t    (r = sshbuf_put_string(sigbuf, session_id2,\n\t\t    session_id2_len)) != 0 ||\n\t\t    (r = sshkey_puts(key, sigbuf)) != 0)\n\t\t\tfatal(\"%s: couldn't prepare private key \"\n\t\t\t    \"proof buffer: %s\", __func__, ssh_err(r));\n\t\tif (datlen != sshbuf_len(sigbuf) ||\n\t\t    memcmp(p, sshbuf_ptr(sigbuf), sshbuf_len(sigbuf)) != 0)\n\t\t\tfatal(\"%s: bad data length: %zu, hostkey proof len %zu\",\n\t\t\t    __func__, datlen, sshbuf_len(sigbuf));\n\t\tsshbuf_free(sigbuf);\n\t\tis_proof = 1;\n\t}\n\n\t/* save session id, it will be passed on the first call */\n\tif (session_id2_len == 0) {\n\t\tsession_id2_len = datlen;\n\t\tsession_id2 = xmalloc(session_id2_len);\n\t\tmemcpy(session_id2, p, session_id2_len);\n\t}\n\n\tif ((key = get_hostkey_by_index(keyid)) != NULL) {\n\t\tif ((r = sshkey_sign(key, &signature, &siglen, p, datlen, alg,\n\t\t    compat)) != 0)\n\t\t\tfatal(\"%s: sshkey_sign failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t} else if ((key = get_hostkey_public_by_index(keyid, ssh)) != NULL &&\n\t    auth_sock > 0) {\n\t\tif ((r = ssh_agent_sign(auth_sock, key, &signature, &siglen,\n\t\t    p, datlen, alg, compat)) != 0) {\n\t\t\tfatal(\"%s: ssh_agent_sign failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t} else\n\t\tfatal(\"%s: no hostkey from index %d\", __func__, keyid);\n\n\tdebug3(\"%s: %s signature %p(%zu)\", __func__,\n\t    is_proof ? \"KEX\" : \"hostkey proof\", signature, siglen);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_string(m, signature, siglen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tfree(alg);\n\tfree(p);\n\tfree(signature);\n\n\tmm_request_send(sock, MONITOR_ANS_SIGN, m);\n\n\t/* Turn on permissions for getpwnam */\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PWNAM, 1);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static u_int session_id2_len = 0;",
      "static u_char *session_id2 = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "monitor_permit",
          "args": [
            "mon_dispatch",
            "MONITOR_REQ_PWNAM",
            "1"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "240-251",
          "snippet": "static void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_PERMIT\t0x1000\t/* Request is permitted */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n\nstatic void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_SIGN",
            "m"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "signature"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "m",
            "signature",
            "siglen"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: %s signature %p(%zu)\"",
            "__func__",
            "is_proof ? \"KEX\" : \"hostkey proof\"",
            "signature",
            "siglen"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_agent_sign",
          "args": [
            "auth_sock",
            "key",
            "&signature",
            "&siglen",
            "p",
            "datlen",
            "alg",
            "compat"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_agent_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "340-390",
          "snippet": "int\nssh_agent_sign(int sock, const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tstruct sshbuf *msg;\n\tu_char *sig = NULL, type = 0;\n\tsize_t len = 0;\n\tu_int flags = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tflags |= agent_encode_alg(key, alg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||\n\t    (r = sshkey_puts(key, msg)) != 0 ||\n\t    (r = sshbuf_put_string(msg, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, flags)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_SIGN_RESPONSE) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_string(msg, &sig, &len)) != 0)\n\t\tgoto out;\n\t/* Check what we actually got back from the agent. */\n\tif ((r = sshkey_check_sigtype(sig, len, alg)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*sigp = sig;\n\t*lenp = len;\n\tsig = NULL;\n\tlen = 0;\n\tr = 0;\n out:\n\tfreezero(sig, len);\n\tsshbuf_free(msg);\n\treturn r;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_agent_sign(int sock, const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tstruct sshbuf *msg;\n\tu_char *sig = NULL, type = 0;\n\tsize_t len = 0;\n\tu_int flags = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tflags |= agent_encode_alg(key, alg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||\n\t    (r = sshkey_puts(key, msg)) != 0 ||\n\t    (r = sshbuf_put_string(msg, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, flags)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_SIGN_RESPONSE) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_string(msg, &sig, &len)) != 0)\n\t\tgoto out;\n\t/* Check what we actually got back from the agent. */\n\tif ((r = sshkey_check_sigtype(sig, len, alg)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*sigp = sig;\n\t*lenp = len;\n\tsig = NULL;\n\tlen = 0;\n\tr = 0;\n out:\n\tfreezero(sig, len);\n\tsshbuf_free(msg);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hostkey_public_by_index",
          "args": [
            "keyid",
            "ssh"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "get_hostkey_public_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "807-813",
          "snippet": "struct sshkey *\nget_hostkey_public_by_index(int ind, struct ssh *ssh)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_pubkeys[ind]);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\n\nstruct sshkey *\nget_hostkey_public_by_index(int ind, struct ssh *ssh)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_pubkeys[ind]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_sign",
          "args": [
            "key",
            "&signature",
            "&siglen",
            "p",
            "datlen",
            "alg",
            "compat"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2385-2421",
          "snippet": "int\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hostkey_by_index",
          "args": [
            "keyid"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "get_hostkey_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "799-805",
          "snippet": "struct sshkey *\nget_hostkey_by_index(int ind)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_keys[ind]);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\n\nstruct sshkey *\nget_hostkey_by_index(int ind)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_keys[ind]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "session_id2",
            "p",
            "session_id2_len"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "session_id2_len"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "sigbuf"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "sigbuf"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "p",
            "sshbuf_ptr(sigbuf)",
            "sshbuf_len(sigbuf)"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "sigbuf"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_puts",
          "args": [
            "key",
            "sigbuf"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "836-840",
          "snippet": "int\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "sigbuf",
            "proof_req"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&compat"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&alg",
            "&alglen"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "m",
            "&p",
            "&datlen"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic u_int session_id2_len = 0;\nstatic u_char *session_id2 = NULL;\n\nint\nmm_answer_sign(int sock, struct sshbuf *m)\n{\n\tstruct ssh *ssh = active_state; \t/* XXX */\n\textern int auth_sock;\t\t\t/* XXX move to state struct? */\n\tstruct sshkey *key;\n\tstruct sshbuf *sigbuf = NULL;\n\tu_char *p = NULL, *signature = NULL;\n\tchar *alg = NULL;\n\tsize_t datlen, siglen, alglen;\n\tint r, is_proof = 0;\n\tu_int keyid, compat;\n\tconst char proof_req[] = \"hostkeys-prove-00@openssh.com\";\n\n\tdebug3(\"%s\", __func__);\n\n\tif ((r = sshbuf_get_u32(m, &keyid)) != 0 ||\n\t    (r = sshbuf_get_string(m, &p, &datlen)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &alg, &alglen)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &compat)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (keyid > INT_MAX)\n\t\tfatal(\"%s: invalid key ID\", __func__);\n\n\t/*\n\t * Supported KEX types use SHA1 (20 bytes), SHA256 (32 bytes),\n\t * SHA384 (48 bytes) and SHA512 (64 bytes).\n\t *\n\t * Otherwise, verify the signature request is for a hostkey\n\t * proof.\n\t *\n\t * XXX perform similar check for KEX signature requests too?\n\t * it's not trivial, since what is signed is the hash, rather\n\t * than the full kex structure...\n\t */\n\tif (datlen != 20 && datlen != 32 && datlen != 48 && datlen != 64) {\n\t\t/*\n\t\t * Construct expected hostkey proof and compare it to what\n\t\t * the client sent us.\n\t\t */\n\t\tif (session_id2_len == 0) /* hostkeys is never first */\n\t\t\tfatal(\"%s: bad data length: %zu\", __func__, datlen);\n\t\tif ((key = get_hostkey_public_by_index(keyid, ssh)) == NULL)\n\t\t\tfatal(\"%s: no hostkey for index %d\", __func__, keyid);\n\t\tif ((sigbuf = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new\", __func__);\n\t\tif ((r = sshbuf_put_cstring(sigbuf, proof_req)) != 0 ||\n\t\t    (r = sshbuf_put_string(sigbuf, session_id2,\n\t\t    session_id2_len)) != 0 ||\n\t\t    (r = sshkey_puts(key, sigbuf)) != 0)\n\t\t\tfatal(\"%s: couldn't prepare private key \"\n\t\t\t    \"proof buffer: %s\", __func__, ssh_err(r));\n\t\tif (datlen != sshbuf_len(sigbuf) ||\n\t\t    memcmp(p, sshbuf_ptr(sigbuf), sshbuf_len(sigbuf)) != 0)\n\t\t\tfatal(\"%s: bad data length: %zu, hostkey proof len %zu\",\n\t\t\t    __func__, datlen, sshbuf_len(sigbuf));\n\t\tsshbuf_free(sigbuf);\n\t\tis_proof = 1;\n\t}\n\n\t/* save session id, it will be passed on the first call */\n\tif (session_id2_len == 0) {\n\t\tsession_id2_len = datlen;\n\t\tsession_id2 = xmalloc(session_id2_len);\n\t\tmemcpy(session_id2, p, session_id2_len);\n\t}\n\n\tif ((key = get_hostkey_by_index(keyid)) != NULL) {\n\t\tif ((r = sshkey_sign(key, &signature, &siglen, p, datlen, alg,\n\t\t    compat)) != 0)\n\t\t\tfatal(\"%s: sshkey_sign failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t} else if ((key = get_hostkey_public_by_index(keyid, ssh)) != NULL &&\n\t    auth_sock > 0) {\n\t\tif ((r = ssh_agent_sign(auth_sock, key, &signature, &siglen,\n\t\t    p, datlen, alg, compat)) != 0) {\n\t\t\tfatal(\"%s: ssh_agent_sign failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t} else\n\t\tfatal(\"%s: no hostkey from index %d\", __func__, keyid);\n\n\tdebug3(\"%s: %s signature %p(%zu)\", __func__,\n\t    is_proof ? \"KEX\" : \"hostkey proof\", signature, siglen);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_string(m, signature, siglen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tfree(alg);\n\tfree(p);\n\tfree(signature);\n\n\tmm_request_send(sock, MONITOR_ANS_SIGN, m);\n\n\t/* Turn on permissions for getpwnam */\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PWNAM, 1);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "mm_answer_moduli",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "567-606",
    "snippet": "int\nmm_answer_moduli(int sock, struct sshbuf *m)\n{\n\tDH *dh;\n\tconst BIGNUM *dh_p, *dh_g;\n\tint r;\n\tu_int min, want, max;\n\n\tif ((r = sshbuf_get_u32(m, &min)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &want)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &max)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"%s: got parameters: %d %d %d\",\n\t    __func__, min, want, max);\n\t/* We need to check here, too, in case the child got corrupted */\n\tif (max < min || want < min || max < want)\n\t\tfatal(\"%s: bad parameters: %d %d %d\",\n\t\t    __func__, min, want, max);\n\n\tsshbuf_reset(m);\n\n\tdh = choose_dh(min, want, max);\n\tif (dh == NULL) {\n\t\tif ((r = sshbuf_put_u8(m, 0)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\treturn (0);\n\t} else {\n\t\t/* Send first bignum */\n\t\tDH_get0_pqg(dh, &dh_p, NULL, &dh_g);\n\t\tif ((r = sshbuf_put_u8(m, 1)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(m, dh_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(m, dh_g)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t\tDH_free(dh);\n\t}\n\tmm_request_send(sock, MONITOR_ANS_MODULI, m);\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_request_send",
          "args": [
            "sock",
            "MONITOR_ANS_MODULI",
            "m"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "121-137",
          "snippet": "void\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal(\"%s: bad length %zu\", __func__, mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DH_free",
          "args": [
            "dh"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_bignum2",
          "args": [
            "m",
            "dh_g"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_bignum2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-crypto.c",
          "lines": "146-166",
          "snippet": "int\nsshbuf_put_bignum2(struct sshbuf *buf, const BIGNUM *v)\n{\n\tu_char d[SSHBUF_MAX_BIGNUM + 1];\n\tint len = BN_num_bytes(v), prepend = 0, r;\n\n\tif (len < 0 || len > SSHBUF_MAX_BIGNUM)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*d = '\\0';\n\tif (BN_bn2bin(v, d + 1) != len)\n\t\treturn SSH_ERR_INTERNAL_ERROR; /* Shouldn't happen */\n\t/* If MSB is set, prepend a \\0 */\n\tif (len > 0 && (d[1] & 0x80) != 0)\n\t\tprepend = 1;\n\tif ((r = sshbuf_put_string(buf, d + 1 - prepend, len + prepend)) < 0) {\n\t\texplicit_bzero(d, sizeof(d));\n\t\treturn r;\n\t}\n\texplicit_bzero(d, sizeof(d));\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n# include <openssl/ec.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_bignum2(struct sshbuf *buf, const BIGNUM *v)\n{\n\tu_char d[SSHBUF_MAX_BIGNUM + 1];\n\tint len = BN_num_bytes(v), prepend = 0, r;\n\n\tif (len < 0 || len > SSHBUF_MAX_BIGNUM)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*d = '\\0';\n\tif (BN_bn2bin(v, d + 1) != len)\n\t\treturn SSH_ERR_INTERNAL_ERROR; /* Shouldn't happen */\n\t/* If MSB is set, prepend a \\0 */\n\tif (len > 0 && (d[1] & 0x80) != 0)\n\t\tprepend = 1;\n\tif ((r = sshbuf_put_string(buf, d + 1 - prepend, len + prepend)) < 0) {\n\t\texplicit_bzero(d, sizeof(d));\n\t\treturn r;\n\t}\n\texplicit_bzero(d, sizeof(d));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "m",
            "1"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DH_get0_pqg",
          "args": [
            "dh",
            "&dh_p",
            "NULL",
            "&dh_g"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "DH_get0_pqg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "451-460",
          "snippet": "void\nDH_get0_pqg(const DH *dh, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)\n{\n\tif (p != NULL)\n\t\t*p = dh->p;\n\tif (q != NULL)\n\t\t*q = dh->q;\n\tif (g != NULL)\n\t\t*g = dh->g;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nDH_get0_pqg(const DH *dh, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)\n{\n\tif (p != NULL)\n\t\t*p = dh->p;\n\tif (q != NULL)\n\t\t*q = dh->q;\n\tif (g != NULL)\n\t\t*g = dh->g;\n}"
        }
      },
      {
        "call_info": {
          "callee": "choose_dh",
          "args": [
            "min",
            "want",
            "max"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "choose_dh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dh.c",
          "lines": "146-218",
          "snippet": "DH *\nchoose_dh(int min, int wantbits, int max)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t linesize = 0;\n\tint best, bestcount, which, linenum;\n\tstruct dhgroup dhg;\n\n\tif ((f = fopen(_PATH_DH_MODULI, \"r\")) == NULL) {\n\t\tlogit(\"WARNING: could not open %s (%s), using fixed modulus\",\n\t\t    _PATH_DH_MODULI, strerror(errno));\n\t\treturn (dh_new_group_fallback(max));\n\t}\n\n\tlinenum = 0;\n\tbest = bestcount = 0;\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\tif (!parse_prime(linenum, line, &dhg))\n\t\t\tcontinue;\n\t\tBN_clear_free(dhg.g);\n\t\tBN_clear_free(dhg.p);\n\n\t\tif (dhg.size > max || dhg.size < min)\n\t\t\tcontinue;\n\n\t\tif ((dhg.size > wantbits && dhg.size < best) ||\n\t\t    (dhg.size > best && best < wantbits)) {\n\t\t\tbest = dhg.size;\n\t\t\tbestcount = 0;\n\t\t}\n\t\tif (dhg.size == best)\n\t\t\tbestcount++;\n\t}\n\tfree(line);\n\tline = NULL;\n\tlinesize = 0;\n\trewind(f);\n\n\tif (bestcount == 0) {\n\t\tfclose(f);\n\t\tlogit(\"WARNING: no suitable primes in %s\", _PATH_DH_MODULI);\n\t\treturn (dh_new_group_fallback(max));\n\t}\n\twhich = arc4random_uniform(bestcount);\n\n\tlinenum = 0;\n\tbestcount = 0;\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\tif (!parse_prime(linenum, line, &dhg))\n\t\t\tcontinue;\n\t\tif ((dhg.size > max || dhg.size < min) ||\n\t\t    dhg.size != best ||\n\t\t    bestcount++ != which) {\n\t\t\tBN_clear_free(dhg.g);\n\t\t\tBN_clear_free(dhg.p);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tfree(line);\n\tline = NULL;\n\tfclose(f);\n\tif (bestcount != which + 1) {\n\t\tlogit(\"WARNING: selected prime disappeared in %s, giving up\",\n\t\t    _PATH_DH_MODULI);\n\t\treturn (dh_new_group_fallback(max));\n\t}\n\n\treturn (dh_new_group(dhg.g, dhg.p));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"dh.h\"",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"dh.h\"\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include \"includes.h\"\n\nDH *\nchoose_dh(int min, int wantbits, int max)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t linesize = 0;\n\tint best, bestcount, which, linenum;\n\tstruct dhgroup dhg;\n\n\tif ((f = fopen(_PATH_DH_MODULI, \"r\")) == NULL) {\n\t\tlogit(\"WARNING: could not open %s (%s), using fixed modulus\",\n\t\t    _PATH_DH_MODULI, strerror(errno));\n\t\treturn (dh_new_group_fallback(max));\n\t}\n\n\tlinenum = 0;\n\tbest = bestcount = 0;\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\tif (!parse_prime(linenum, line, &dhg))\n\t\t\tcontinue;\n\t\tBN_clear_free(dhg.g);\n\t\tBN_clear_free(dhg.p);\n\n\t\tif (dhg.size > max || dhg.size < min)\n\t\t\tcontinue;\n\n\t\tif ((dhg.size > wantbits && dhg.size < best) ||\n\t\t    (dhg.size > best && best < wantbits)) {\n\t\t\tbest = dhg.size;\n\t\t\tbestcount = 0;\n\t\t}\n\t\tif (dhg.size == best)\n\t\t\tbestcount++;\n\t}\n\tfree(line);\n\tline = NULL;\n\tlinesize = 0;\n\trewind(f);\n\n\tif (bestcount == 0) {\n\t\tfclose(f);\n\t\tlogit(\"WARNING: no suitable primes in %s\", _PATH_DH_MODULI);\n\t\treturn (dh_new_group_fallback(max));\n\t}\n\twhich = arc4random_uniform(bestcount);\n\n\tlinenum = 0;\n\tbestcount = 0;\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\tif (!parse_prime(linenum, line, &dhg))\n\t\t\tcontinue;\n\t\tif ((dhg.size > max || dhg.size < min) ||\n\t\t    dhg.size != best ||\n\t\t    bestcount++ != which) {\n\t\t\tBN_clear_free(dhg.g);\n\t\t\tBN_clear_free(dhg.p);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tfree(line);\n\tline = NULL;\n\tfclose(f);\n\tif (bestcount != which + 1) {\n\t\tlogit(\"WARNING: selected prime disappeared in %s, giving up\",\n\t\t    _PATH_DH_MODULI);\n\t\treturn (dh_new_group_fallback(max));\n\t}\n\n\treturn (dh_new_group(dhg.g, dhg.p));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: got parameters: %d %d %d\"",
            "__func__",
            "min",
            "want",
            "max"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&max"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\n\nint\nmm_answer_moduli(int sock, struct sshbuf *m)\n{\n\tDH *dh;\n\tconst BIGNUM *dh_p, *dh_g;\n\tint r;\n\tu_int min, want, max;\n\n\tif ((r = sshbuf_get_u32(m, &min)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &want)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &max)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"%s: got parameters: %d %d %d\",\n\t    __func__, min, want, max);\n\t/* We need to check here, too, in case the child got corrupted */\n\tif (max < min || want < min || max < want)\n\t\tfatal(\"%s: bad parameters: %d %d %d\",\n\t\t    __func__, min, want, max);\n\n\tsshbuf_reset(m);\n\n\tdh = choose_dh(min, want, max);\n\tif (dh == NULL) {\n\t\tif ((r = sshbuf_put_u8(m, 0)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\treturn (0);\n\t} else {\n\t\t/* Send first bignum */\n\t\tDH_get0_pqg(dh, &dh_p, NULL, &dh_g);\n\t\tif ((r = sshbuf_put_u8(m, 1)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(m, dh_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(m, dh_g)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t\tDH_free(dh);\n\t}\n\tmm_request_send(sock, MONITOR_ANS_MODULI, m);\n\treturn (0);\n}"
  },
  {
    "function_name": "monitor_reset_key_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "550-564",
    "snippet": "static void\nmonitor_reset_key_state(void)\n{\n\t/* reset state */\n\tfree(key_blob);\n\tfree(hostbased_cuser);\n\tfree(hostbased_chost);\n\tsshauthopt_free(key_opts);\n\tkey_blob = NULL;\n\tkey_bloblen = 0;\n\tkey_blobtype = MM_NOKEY;\n\tkey_opts = NULL;\n\thostbased_cuser = NULL;\n\thostbased_chost = NULL;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u_char *key_blob = NULL;",
      "static size_t key_bloblen = 0;",
      "static int key_blobtype = MM_NOKEY;",
      "static struct sshauthopt *key_opts = NULL;",
      "static char *hostbased_cuser = NULL;",
      "static char *hostbased_chost = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshauthopt_free",
          "args": [
            "key_opts"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "hostbased_chost"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_char *key_blob = NULL;\nstatic size_t key_bloblen = 0;\nstatic int key_blobtype = MM_NOKEY;\nstatic struct sshauthopt *key_opts = NULL;\nstatic char *hostbased_cuser = NULL;\nstatic char *hostbased_chost = NULL;\n\nstatic void\nmonitor_reset_key_state(void)\n{\n\t/* reset state */\n\tfree(key_blob);\n\tfree(hostbased_cuser);\n\tfree(hostbased_chost);\n\tsshauthopt_free(key_opts);\n\tkey_blob = NULL;\n\tkey_bloblen = 0;\n\tkey_blobtype = MM_NOKEY;\n\tkey_opts = NULL;\n\thostbased_cuser = NULL;\n\thostbased_chost = NULL;\n}"
  },
  {
    "function_name": "monitor_allowed_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "540-548",
    "snippet": "static int\nmonitor_allowed_key(u_char *blob, u_int bloblen)\n{\n\t/* make sure key is allowed */\n\tif (key_blob == NULL || key_bloblen != bloblen ||\n\t    timingsafe_bcmp(key_blob, blob, key_bloblen))\n\t\treturn (0);\n\treturn (1);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u_char *key_blob = NULL;",
      "static size_t key_bloblen = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timingsafe_bcmp",
          "args": [
            "key_blob",
            "blob",
            "key_bloblen"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "timingsafe_bcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/timingsafe_bcmp.c",
          "lines": "23-32",
          "snippet": "int\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}",
          "includes": [
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"includes.h\"\n\nint\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_char *key_blob = NULL;\nstatic size_t key_bloblen = 0;\n\nstatic int\nmonitor_allowed_key(u_char *blob, u_int bloblen)\n{\n\t/* make sure key is allowed */\n\tif (key_blob == NULL || key_bloblen != bloblen ||\n\t    timingsafe_bcmp(key_blob, blob, key_bloblen))\n\t\treturn (0);\n\treturn (1);\n}"
  },
  {
    "function_name": "monitor_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "466-537",
    "snippet": "int\nmonitor_read(struct monitor *pmonitor, struct mon_table *ent,\n    struct mon_table **pent)\n{\n\tstruct sshbuf *m;\n\tint r, ret;\n\tu_char type;\n\tstruct pollfd pfd[2];\n\n\tfor (;;) {\n\t\tmemset(&pfd, 0, sizeof(pfd));\n\t\tpfd[0].fd = pmonitor->m_sendfd;\n\t\tpfd[0].events = POLLIN;\n\t\tpfd[1].fd = pmonitor->m_log_recvfd;\n\t\tpfd[1].events = pfd[1].fd == -1 ? 0 : POLLIN;\n\t\tif (poll(pfd, pfd[1].fd == -1 ? 1 : 2, -1) == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"%s: poll: %s\", __func__, strerror(errno));\n\t\t}\n\t\tif (pfd[1].revents) {\n\t\t\t/*\n\t\t\t * Drain all log messages before processing next\n\t\t\t * monitor request.\n\t\t\t */\n\t\t\tmonitor_read_log(pmonitor);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pfd[0].revents)\n\t\t\tbreak;  /* Continues below */\n\t}\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\tmm_request_receive(pmonitor->m_sendfd, m);\n\tif ((r = sshbuf_get_u8(m, &type)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"%s: checking request %d\", __func__, type);\n\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type)\n\t\t\tbreak;\n\t\tent++;\n\t}\n\n\tif (ent->f != NULL) {\n\t\tif (!(ent->flags & MON_PERMIT))\n\t\t\tfatal(\"%s: unpermitted request %d\", __func__,\n\t\t\t    type);\n\t\tret = (*ent->f)(pmonitor->m_sendfd, m);\n\t\tsshbuf_free(m);\n\n\t\t/* The child may use this request only once, disable it */\n\t\tif (ent->flags & MON_ONCE) {\n\t\t\tdebug2(\"%s: %d used once, disabling now\", __func__,\n\t\t\t    type);\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t}\n\n\t\tif (pent != NULL)\n\t\t\t*pent = ent;\n\n\t\treturn ret;\n\t}\n\n\tfatal(\"%s: unsupported request: %d\", __func__, type);\n\n\t/* NOTREACHED */\n\treturn (-1);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MON_PERMIT\t0x1000\t/* Request is permitted */",
      "#define MON_ONCE\t0x0010\t/* Disable after calling */"
    ],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static int monitor_read_log(struct monitor *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: unsupported request: %d\"",
            "__func__",
            "type"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: %d used once, disabling now\"",
            "__func__",
            "type"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "m"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pmonitor->m_sendfd",
            "m"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: checking request %d\"",
            "__func__",
            "type"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "m",
            "&type"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_request_receive",
          "args": [
            "pmonitor->m_sendfd",
            "m"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_receive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "139-161",
          "snippet": "void\nmm_request_receive(int sock, struct sshbuf *m)\n{\n\tu_char buf[4], *p = NULL;\n\tu_int msg_len;\n\tint r;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tif (atomicio(read, sock, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tif (errno == EPIPE)\n\t\t\tcleanup_exit(255);\n\t\tfatal(\"%s: read: %s\", __func__, strerror(errno));\n\t}\n\tmsg_len = PEEK_U32(buf);\n\tif (msg_len > 256 * 1024)\n\t\tfatal(\"%s: read: bad msg_len %d\", __func__, msg_len);\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (atomicio(read, sock, p, msg_len) != msg_len)\n\t\tfatal(\"%s: read: %s\", __func__, strerror(errno));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_receive(int sock, struct sshbuf *m)\n{\n\tu_char buf[4], *p = NULL;\n\tu_int msg_len;\n\tint r;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tif (atomicio(read, sock, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tif (errno == EPIPE)\n\t\t\tcleanup_exit(255);\n\t\tfatal(\"%s: read: %s\", __func__, strerror(errno));\n\t}\n\tmsg_len = PEEK_U32(buf);\n\tif (msg_len > 256 * 1024)\n\t\tfatal(\"%s: read: bad msg_len %d\", __func__, msg_len);\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (atomicio(read, sock, p, msg_len) != msg_len)\n\t\tfatal(\"%s: read: %s\", __func__, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_read_log",
          "args": [
            "pmonitor"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_read_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "414-464",
          "snippet": "static int\nmonitor_read_log(struct monitor *pmonitor)\n{\n\tstruct sshbuf *logmsg;\n\tu_int len, level;\n\tchar *msg;\n\tu_char *p;\n\tint r;\n\n\tif ((logmsg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\t/* Read length */\n\tif ((r = sshbuf_reserve(logmsg, 4, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tif (atomicio(read, pmonitor->m_log_recvfd, p, 4) != 4) {\n\t\tif (errno == EPIPE) {\n\t\t\tsshbuf_free(logmsg);\n\t\t\tdebug(\"%s: child log fd closed\", __func__);\n\t\t\tclose(pmonitor->m_log_recvfd);\n\t\t\tpmonitor->m_log_recvfd = -1;\n\t\t\treturn -1;\n\t\t}\n\t\tfatal(\"%s: log fd read: %s\", __func__, strerror(errno));\n\t}\n\tif ((r = sshbuf_get_u32(logmsg, &len)) != 0)\n\t\tfatal(\"%s: get len: %s\", __func__, ssh_err(r));\n\tif (len <= 4 || len > 8192)\n\t\tfatal(\"%s: invalid log message length %u\", __func__, len);\n\n\t/* Read severity, message */\n\tsshbuf_reset(logmsg);\n\tif ((r = sshbuf_reserve(logmsg, len, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tif (atomicio(read, pmonitor->m_log_recvfd, p, len) != len)\n\t\tfatal(\"%s: log fd read: %s\", __func__, strerror(errno));\n\tif ((r = sshbuf_get_u32(logmsg, &level)) != 0 ||\n\t    (r = sshbuf_get_cstring(logmsg, &msg, NULL)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\n\t/* Log it */\n\tif (log_level_name(level) == NULL)\n\t\tfatal(\"%s: invalid log level %u (corrupted message?)\",\n\t\t    __func__, level);\n\tdo_log2(level, \"%s [preauth]\", msg);\n\n\tsshbuf_free(logmsg);\n\tfree(msg);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int mm_answer_moduli(int, struct sshbuf *);",
            "int mm_answer_sign(int, struct sshbuf *);",
            "int mm_answer_pwnamallow(int, struct sshbuf *);",
            "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
            "int mm_answer_authserv(int, struct sshbuf *);",
            "int mm_answer_authpassword(int, struct sshbuf *);",
            "int mm_answer_bsdauthquery(int, struct sshbuf *);",
            "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
            "int mm_answer_keyallowed(int, struct sshbuf *);",
            "int mm_answer_keyverify(int, struct sshbuf *);",
            "int mm_answer_pty(int, struct sshbuf *);",
            "int mm_answer_pty_cleanup(int, struct sshbuf *);",
            "int mm_answer_term(int, struct sshbuf *);",
            "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
            "int mm_answer_rsa_challenge(int, struct sshbuf *);",
            "int mm_answer_rsa_response(int, struct sshbuf *);",
            "int mm_answer_sesskey(int, struct sshbuf *);",
            "int mm_answer_sessid(int, struct sshbuf *);",
            "static int monitor_read_log(struct monitor *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\n\nstatic int\nmonitor_read_log(struct monitor *pmonitor)\n{\n\tstruct sshbuf *logmsg;\n\tu_int len, level;\n\tchar *msg;\n\tu_char *p;\n\tint r;\n\n\tif ((logmsg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\t/* Read length */\n\tif ((r = sshbuf_reserve(logmsg, 4, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tif (atomicio(read, pmonitor->m_log_recvfd, p, 4) != 4) {\n\t\tif (errno == EPIPE) {\n\t\t\tsshbuf_free(logmsg);\n\t\t\tdebug(\"%s: child log fd closed\", __func__);\n\t\t\tclose(pmonitor->m_log_recvfd);\n\t\t\tpmonitor->m_log_recvfd = -1;\n\t\t\treturn -1;\n\t\t}\n\t\tfatal(\"%s: log fd read: %s\", __func__, strerror(errno));\n\t}\n\tif ((r = sshbuf_get_u32(logmsg, &len)) != 0)\n\t\tfatal(\"%s: get len: %s\", __func__, ssh_err(r));\n\tif (len <= 4 || len > 8192)\n\t\tfatal(\"%s: invalid log message length %u\", __func__, len);\n\n\t/* Read severity, message */\n\tsshbuf_reset(logmsg);\n\tif ((r = sshbuf_reserve(logmsg, len, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tif (atomicio(read, pmonitor->m_log_recvfd, p, len) != len)\n\t\tfatal(\"%s: log fd read: %s\", __func__, strerror(errno));\n\tif ((r = sshbuf_get_u32(logmsg, &level)) != 0 ||\n\t    (r = sshbuf_get_cstring(logmsg, &msg, NULL)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\n\t/* Log it */\n\tif (log_level_name(level) == NULL)\n\t\tfatal(\"%s: invalid log level %u (corrupted message?)\",\n\t\t    __func__, level);\n\tdo_log2(level, \"%s [preauth]\", msg);\n\n\tsshbuf_free(logmsg);\n\tfree(msg);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "pfd",
            "pfd[1].fd == -1 ? 1 : 2",
            "-1"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "after_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "888-941",
          "snippet": "static void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int sockets_alloc = 0;",
            "SocketEntry *sockets = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&pfd",
            "0",
            "sizeof(pfd)"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n#define MON_ONCE\t0x0010\t/* Disable after calling */\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\n\nint\nmonitor_read(struct monitor *pmonitor, struct mon_table *ent,\n    struct mon_table **pent)\n{\n\tstruct sshbuf *m;\n\tint r, ret;\n\tu_char type;\n\tstruct pollfd pfd[2];\n\n\tfor (;;) {\n\t\tmemset(&pfd, 0, sizeof(pfd));\n\t\tpfd[0].fd = pmonitor->m_sendfd;\n\t\tpfd[0].events = POLLIN;\n\t\tpfd[1].fd = pmonitor->m_log_recvfd;\n\t\tpfd[1].events = pfd[1].fd == -1 ? 0 : POLLIN;\n\t\tif (poll(pfd, pfd[1].fd == -1 ? 1 : 2, -1) == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"%s: poll: %s\", __func__, strerror(errno));\n\t\t}\n\t\tif (pfd[1].revents) {\n\t\t\t/*\n\t\t\t * Drain all log messages before processing next\n\t\t\t * monitor request.\n\t\t\t */\n\t\t\tmonitor_read_log(pmonitor);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pfd[0].revents)\n\t\t\tbreak;  /* Continues below */\n\t}\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\tmm_request_receive(pmonitor->m_sendfd, m);\n\tif ((r = sshbuf_get_u8(m, &type)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"%s: checking request %d\", __func__, type);\n\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type)\n\t\t\tbreak;\n\t\tent++;\n\t}\n\n\tif (ent->f != NULL) {\n\t\tif (!(ent->flags & MON_PERMIT))\n\t\t\tfatal(\"%s: unpermitted request %d\", __func__,\n\t\t\t    type);\n\t\tret = (*ent->f)(pmonitor->m_sendfd, m);\n\t\tsshbuf_free(m);\n\n\t\t/* The child may use this request only once, disable it */\n\t\tif (ent->flags & MON_ONCE) {\n\t\t\tdebug2(\"%s: %d used once, disabling now\", __func__,\n\t\t\t    type);\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t}\n\n\t\tif (pent != NULL)\n\t\t\t*pent = ent;\n\n\t\treturn ret;\n\t}\n\n\tfatal(\"%s: unsupported request: %d\", __func__, type);\n\n\t/* NOTREACHED */\n\treturn (-1);\n}"
  },
  {
    "function_name": "monitor_read_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "414-464",
    "snippet": "static int\nmonitor_read_log(struct monitor *pmonitor)\n{\n\tstruct sshbuf *logmsg;\n\tu_int len, level;\n\tchar *msg;\n\tu_char *p;\n\tint r;\n\n\tif ((logmsg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\t/* Read length */\n\tif ((r = sshbuf_reserve(logmsg, 4, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tif (atomicio(read, pmonitor->m_log_recvfd, p, 4) != 4) {\n\t\tif (errno == EPIPE) {\n\t\t\tsshbuf_free(logmsg);\n\t\t\tdebug(\"%s: child log fd closed\", __func__);\n\t\t\tclose(pmonitor->m_log_recvfd);\n\t\t\tpmonitor->m_log_recvfd = -1;\n\t\t\treturn -1;\n\t\t}\n\t\tfatal(\"%s: log fd read: %s\", __func__, strerror(errno));\n\t}\n\tif ((r = sshbuf_get_u32(logmsg, &len)) != 0)\n\t\tfatal(\"%s: get len: %s\", __func__, ssh_err(r));\n\tif (len <= 4 || len > 8192)\n\t\tfatal(\"%s: invalid log message length %u\", __func__, len);\n\n\t/* Read severity, message */\n\tsshbuf_reset(logmsg);\n\tif ((r = sshbuf_reserve(logmsg, len, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tif (atomicio(read, pmonitor->m_log_recvfd, p, len) != len)\n\t\tfatal(\"%s: log fd read: %s\", __func__, strerror(errno));\n\tif ((r = sshbuf_get_u32(logmsg, &level)) != 0 ||\n\t    (r = sshbuf_get_cstring(logmsg, &msg, NULL)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\n\t/* Log it */\n\tif (log_level_name(level) == NULL)\n\t\tfatal(\"%s: invalid log level %u (corrupted message?)\",\n\t\t    __func__, level);\n\tdo_log2(level, \"%s [preauth]\", msg);\n\n\tsshbuf_free(logmsg);\n\tfree(msg);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static int monitor_read_log(struct monitor *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "msg"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "logmsg"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_log2",
          "args": [
            "level",
            "\"%s [preauth]\"",
            "msg"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "do_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "390-398",
          "snippet": "void\ndo_log2(LogLevel level, const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(level, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndo_log2(LogLevel level, const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(level, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: invalid log level %u (corrupted message?)\"",
            "__func__",
            "level"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_level_name",
          "args": [
            "level"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "log_level_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "149-158",
          "snippet": "const char *\nlog_level_name(LogLevel level)\n{\n\tu_int i;\n\n\tfor (i = 0; log_levels[i].name != NULL; i++)\n\t\tif (log_levels[i].val == level)\n\t\t\treturn log_levels[i].name;\n\treturn NULL;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tLogLevel val;\n} log_levels[] =\n{\n\t{ \"QUIET\",\tSYSLOG_LEVEL_QUIET },\n\t{ \"FATAL\",\tSYSLOG_LEVEL_FATAL },\n\t{ \"ERROR\",\tSYSLOG_LEVEL_ERROR },\n\t{ \"INFO\",\tSYSLOG_LEVEL_INFO },\n\t{ \"VERBOSE\",\tSYSLOG_LEVEL_VERBOSE },\n\t{ \"DEBUG\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG1\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG2\",\tSYSLOG_LEVEL_DEBUG2 },\n\t{ \"DEBUG3\",\tSYSLOG_LEVEL_DEBUG3 },\n\t{ NULL,\t\tSYSLOG_LEVEL_NOT_SET }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tLogLevel val;\n} log_levels[] =\n{\n\t{ \"QUIET\",\tSYSLOG_LEVEL_QUIET },\n\t{ \"FATAL\",\tSYSLOG_LEVEL_FATAL },\n\t{ \"ERROR\",\tSYSLOG_LEVEL_ERROR },\n\t{ \"INFO\",\tSYSLOG_LEVEL_INFO },\n\t{ \"VERBOSE\",\tSYSLOG_LEVEL_VERBOSE },\n\t{ \"DEBUG\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG1\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG2\",\tSYSLOG_LEVEL_DEBUG2 },\n\t{ \"DEBUG3\",\tSYSLOG_LEVEL_DEBUG3 },\n\t{ NULL,\t\tSYSLOG_LEVEL_NOT_SET }\n};\n\nconst char *\nlog_level_name(LogLevel level)\n{\n\tu_int i;\n\n\tfor (i = 0; log_levels[i].name != NULL; i++)\n\t\tif (log_levels[i].val == level)\n\t\t\treturn log_levels[i].name;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "logmsg",
            "&msg",
            "NULL"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "logmsg",
            "&level"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "read",
            "pmonitor->m_log_recvfd",
            "p",
            "len"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reserve",
          "args": [
            "logmsg",
            "len",
            "&p"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "343-361",
          "snippet": "int\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "logmsg"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pmonitor->m_log_recvfd"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "mm_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "1486-1495",
          "snippet": "static void\nmm_session_close(Session *s)\n{\n\tdebug3(\"%s: session %d pid %ld\", __func__, s->self, (long)s->pid);\n\tif (s->ttyfd != -1) {\n\t\tdebug3(\"%s: tty %s ptyfd %d\", __func__, s->tty, s->ptyfd);\n\t\tsession_pty_cleanup2(s);\n\t}\n\tsession_unused(s->self);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmm_session_close(Session *s)\n{\n\tdebug3(\"%s: session %d pid %ld\", __func__, s->self, (long)s->pid);\n\tif (s->ttyfd != -1) {\n\t\tdebug3(\"%s: tty %s ptyfd %d\", __func__, s->tty, s->ptyfd);\n\t\tsession_pty_cleanup2(s);\n\t}\n\tsession_unused(s->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: child log fd closed\"",
            "__func__"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\n\nstatic int\nmonitor_read_log(struct monitor *pmonitor)\n{\n\tstruct sshbuf *logmsg;\n\tu_int len, level;\n\tchar *msg;\n\tu_char *p;\n\tint r;\n\n\tif ((logmsg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\t/* Read length */\n\tif ((r = sshbuf_reserve(logmsg, 4, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tif (atomicio(read, pmonitor->m_log_recvfd, p, 4) != 4) {\n\t\tif (errno == EPIPE) {\n\t\t\tsshbuf_free(logmsg);\n\t\t\tdebug(\"%s: child log fd closed\", __func__);\n\t\t\tclose(pmonitor->m_log_recvfd);\n\t\t\tpmonitor->m_log_recvfd = -1;\n\t\t\treturn -1;\n\t\t}\n\t\tfatal(\"%s: log fd read: %s\", __func__, strerror(errno));\n\t}\n\tif ((r = sshbuf_get_u32(logmsg, &len)) != 0)\n\t\tfatal(\"%s: get len: %s\", __func__, ssh_err(r));\n\tif (len <= 4 || len > 8192)\n\t\tfatal(\"%s: invalid log message length %u\", __func__, len);\n\n\t/* Read severity, message */\n\tsshbuf_reset(logmsg);\n\tif ((r = sshbuf_reserve(logmsg, len, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tif (atomicio(read, pmonitor->m_log_recvfd, p, len) != len)\n\t\tfatal(\"%s: log fd read: %s\", __func__, strerror(errno));\n\tif ((r = sshbuf_get_u32(logmsg, &level)) != 0 ||\n\t    (r = sshbuf_get_cstring(logmsg, &msg, NULL)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\n\t/* Log it */\n\tif (log_level_name(level) == NULL)\n\t\tfatal(\"%s: invalid log level %u (corrupted message?)\",\n\t\t    __func__, level);\n\tdo_log2(level, \"%s [preauth]\", msg);\n\n\tsshbuf_free(logmsg);\n\tfree(msg);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "monitor_child_postauth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "384-412",
    "snippet": "void\nmonitor_child_postauth(struct monitor *pmonitor)\n{\n\tclose(pmonitor->m_recvfd);\n\tpmonitor->m_recvfd = -1;\n\n\tmonitor_set_child_handler(pmonitor->m_pid);\n\tsignal(SIGHUP, &monitor_child_handler);\n\tsignal(SIGTERM, &monitor_child_handler);\n\tsignal(SIGINT, &monitor_child_handler);\n#ifdef SIGXFSZ\n\tsignal(SIGXFSZ, SIG_IGN);\n#endif\n\n\tmon_dispatch = mon_dispatch_postauth20;\n\n\t/* Permit requests for moduli and signatures */\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_MODULI, 1);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_SIGN, 1);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_TERM, 1);\n\n\tif (auth_opts->permit_pty_flag) {\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PTY, 1);\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PTYCLEANUP, 1);\n\t}\n\n\tfor (;;)\n\t\tmonitor_read(pmonitor, mon_dispatch, NULL);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct sshauthopt *auth_opts;",
      "static int monitor_read_log(struct monitor *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "monitor_read",
          "args": [
            "pmonitor",
            "mon_dispatch",
            "NULL"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "466-537",
          "snippet": "int\nmonitor_read(struct monitor *pmonitor, struct mon_table *ent,\n    struct mon_table **pent)\n{\n\tstruct sshbuf *m;\n\tint r, ret;\n\tu_char type;\n\tstruct pollfd pfd[2];\n\n\tfor (;;) {\n\t\tmemset(&pfd, 0, sizeof(pfd));\n\t\tpfd[0].fd = pmonitor->m_sendfd;\n\t\tpfd[0].events = POLLIN;\n\t\tpfd[1].fd = pmonitor->m_log_recvfd;\n\t\tpfd[1].events = pfd[1].fd == -1 ? 0 : POLLIN;\n\t\tif (poll(pfd, pfd[1].fd == -1 ? 1 : 2, -1) == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"%s: poll: %s\", __func__, strerror(errno));\n\t\t}\n\t\tif (pfd[1].revents) {\n\t\t\t/*\n\t\t\t * Drain all log messages before processing next\n\t\t\t * monitor request.\n\t\t\t */\n\t\t\tmonitor_read_log(pmonitor);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pfd[0].revents)\n\t\t\tbreak;  /* Continues below */\n\t}\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\tmm_request_receive(pmonitor->m_sendfd, m);\n\tif ((r = sshbuf_get_u8(m, &type)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"%s: checking request %d\", __func__, type);\n\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type)\n\t\t\tbreak;\n\t\tent++;\n\t}\n\n\tif (ent->f != NULL) {\n\t\tif (!(ent->flags & MON_PERMIT))\n\t\t\tfatal(\"%s: unpermitted request %d\", __func__,\n\t\t\t    type);\n\t\tret = (*ent->f)(pmonitor->m_sendfd, m);\n\t\tsshbuf_free(m);\n\n\t\t/* The child may use this request only once, disable it */\n\t\tif (ent->flags & MON_ONCE) {\n\t\t\tdebug2(\"%s: %d used once, disabling now\", __func__,\n\t\t\t    type);\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t}\n\n\t\tif (pent != NULL)\n\t\t\t*pent = ent;\n\n\t\treturn ret;\n\t}\n\n\tfatal(\"%s: unsupported request: %d\", __func__, type);\n\n\t/* NOTREACHED */\n\treturn (-1);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_PERMIT\t0x1000\t/* Request is permitted */",
            "#define MON_ONCE\t0x0010\t/* Disable after calling */"
          ],
          "globals_used": [
            "int mm_answer_moduli(int, struct sshbuf *);",
            "int mm_answer_sign(int, struct sshbuf *);",
            "int mm_answer_pwnamallow(int, struct sshbuf *);",
            "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
            "int mm_answer_authserv(int, struct sshbuf *);",
            "int mm_answer_authpassword(int, struct sshbuf *);",
            "int mm_answer_bsdauthquery(int, struct sshbuf *);",
            "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
            "int mm_answer_keyallowed(int, struct sshbuf *);",
            "int mm_answer_keyverify(int, struct sshbuf *);",
            "int mm_answer_pty(int, struct sshbuf *);",
            "int mm_answer_pty_cleanup(int, struct sshbuf *);",
            "int mm_answer_term(int, struct sshbuf *);",
            "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
            "int mm_answer_rsa_challenge(int, struct sshbuf *);",
            "int mm_answer_rsa_response(int, struct sshbuf *);",
            "int mm_answer_sesskey(int, struct sshbuf *);",
            "int mm_answer_sessid(int, struct sshbuf *);",
            "static int monitor_read_log(struct monitor *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n#define MON_ONCE\t0x0010\t/* Disable after calling */\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\n\nint\nmonitor_read(struct monitor *pmonitor, struct mon_table *ent,\n    struct mon_table **pent)\n{\n\tstruct sshbuf *m;\n\tint r, ret;\n\tu_char type;\n\tstruct pollfd pfd[2];\n\n\tfor (;;) {\n\t\tmemset(&pfd, 0, sizeof(pfd));\n\t\tpfd[0].fd = pmonitor->m_sendfd;\n\t\tpfd[0].events = POLLIN;\n\t\tpfd[1].fd = pmonitor->m_log_recvfd;\n\t\tpfd[1].events = pfd[1].fd == -1 ? 0 : POLLIN;\n\t\tif (poll(pfd, pfd[1].fd == -1 ? 1 : 2, -1) == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"%s: poll: %s\", __func__, strerror(errno));\n\t\t}\n\t\tif (pfd[1].revents) {\n\t\t\t/*\n\t\t\t * Drain all log messages before processing next\n\t\t\t * monitor request.\n\t\t\t */\n\t\t\tmonitor_read_log(pmonitor);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pfd[0].revents)\n\t\t\tbreak;  /* Continues below */\n\t}\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\tmm_request_receive(pmonitor->m_sendfd, m);\n\tif ((r = sshbuf_get_u8(m, &type)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"%s: checking request %d\", __func__, type);\n\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type)\n\t\t\tbreak;\n\t\tent++;\n\t}\n\n\tif (ent->f != NULL) {\n\t\tif (!(ent->flags & MON_PERMIT))\n\t\t\tfatal(\"%s: unpermitted request %d\", __func__,\n\t\t\t    type);\n\t\tret = (*ent->f)(pmonitor->m_sendfd, m);\n\t\tsshbuf_free(m);\n\n\t\t/* The child may use this request only once, disable it */\n\t\tif (ent->flags & MON_ONCE) {\n\t\t\tdebug2(\"%s: %d used once, disabling now\", __func__,\n\t\t\t    type);\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t}\n\n\t\tif (pent != NULL)\n\t\t\t*pent = ent;\n\n\t\treturn ret;\n\t}\n\n\tfatal(\"%s: unsupported request: %d\", __func__, type);\n\n\t/* NOTREACHED */\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_permit",
          "args": [
            "mon_dispatch",
            "MONITOR_REQ_PTYCLEANUP",
            "1"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "240-251",
          "snippet": "static void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_PERMIT\t0x1000\t/* Request is permitted */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n\nstatic void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGXFSZ",
            "SIG_IGN"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_set_child_handler",
          "args": [
            "pmonitor->m_pid"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_set_child_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "372-376",
          "snippet": "static void\nmonitor_set_child_handler(pid_t pid)\n{\n\tmonitor_child_pid = pid;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static pid_t monitor_child_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic pid_t monitor_child_pid;\n\nstatic void\nmonitor_set_child_handler(pid_t pid)\n{\n\tmonitor_child_pid = pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pmonitor->m_recvfd"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "mm_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "1486-1495",
          "snippet": "static void\nmm_session_close(Session *s)\n{\n\tdebug3(\"%s: session %d pid %ld\", __func__, s->self, (long)s->pid);\n\tif (s->ttyfd != -1) {\n\t\tdebug3(\"%s: tty %s ptyfd %d\", __func__, s->tty, s->ptyfd);\n\t\tsession_pty_cleanup2(s);\n\t}\n\tsession_unused(s->self);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmm_session_close(Session *s)\n{\n\tdebug3(\"%s: session %d pid %ld\", __func__, s->self, (long)s->pid);\n\tif (s->ttyfd != -1) {\n\t\tdebug3(\"%s: tty %s ptyfd %d\", __func__, s->tty, s->ptyfd);\n\t\tsession_pty_cleanup2(s);\n\t}\n\tsession_unused(s->self);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct sshauthopt *auth_opts;\nstatic int monitor_read_log(struct monitor *);\n\nvoid\nmonitor_child_postauth(struct monitor *pmonitor)\n{\n\tclose(pmonitor->m_recvfd);\n\tpmonitor->m_recvfd = -1;\n\n\tmonitor_set_child_handler(pmonitor->m_pid);\n\tsignal(SIGHUP, &monitor_child_handler);\n\tsignal(SIGTERM, &monitor_child_handler);\n\tsignal(SIGINT, &monitor_child_handler);\n#ifdef SIGXFSZ\n\tsignal(SIGXFSZ, SIG_IGN);\n#endif\n\n\tmon_dispatch = mon_dispatch_postauth20;\n\n\t/* Permit requests for moduli and signatures */\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_MODULI, 1);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_SIGN, 1);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_TERM, 1);\n\n\tif (auth_opts->permit_pty_flag) {\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PTY, 1);\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PTYCLEANUP, 1);\n\t}\n\n\tfor (;;)\n\t\tmonitor_read(pmonitor, mon_dispatch, NULL);\n}"
  },
  {
    "function_name": "monitor_child_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "378-382",
    "snippet": "static void\nmonitor_child_handler(int sig)\n{\n\tkill(monitor_child_pid, sig);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static pid_t monitor_child_pid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "monitor_child_pid",
            "sig"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic pid_t monitor_child_pid;\n\nstatic void\nmonitor_child_handler(int sig)\n{\n\tkill(monitor_child_pid, sig);\n}"
  },
  {
    "function_name": "monitor_set_child_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "372-376",
    "snippet": "static void\nmonitor_set_child_handler(pid_t pid)\n{\n\tmonitor_child_pid = pid;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static pid_t monitor_child_pid;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic pid_t monitor_child_pid;\n\nstatic void\nmonitor_set_child_handler(pid_t pid)\n{\n\tmonitor_child_pid = pid;\n}"
  },
  {
    "function_name": "monitor_child_preauth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "267-370",
    "snippet": "void\nmonitor_child_preauth(Authctxt *_authctxt, struct monitor *pmonitor)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tstruct mon_table *ent;\n\tint authenticated = 0, partial = 0;\n\n\tdebug3(\"preauth child monitor started\");\n\n\tif (pmonitor->m_recvfd >= 0)\n\t\tclose(pmonitor->m_recvfd);\n\tif (pmonitor->m_log_sendfd >= 0)\n\t\tclose(pmonitor->m_log_sendfd);\n\tpmonitor->m_log_sendfd = pmonitor->m_recvfd = -1;\n\n\tauthctxt = _authctxt;\n\tmemset(authctxt, 0, sizeof(*authctxt));\n\tssh->authctxt = authctxt;\n\n\tauthctxt->loginmsg = loginmsg;\n\n\tmon_dispatch = mon_dispatch_proto20;\n\t/* Permit requests for moduli and signatures */\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_MODULI, 1);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_SIGN, 1);\n\n\t/* The first few requests do not require asynchronous access */\n\twhile (!authenticated) {\n\t\tpartial = 0;\n\t\tauth_method = \"unknown\";\n\t\tauth_submethod = NULL;\n\t\tauth2_authctxt_reset_info(authctxt);\n\n\t\tauthenticated = (monitor_read(pmonitor, mon_dispatch, &ent) == 1);\n\n\t\t/* Special handling for multiple required authentications */\n\t\tif (options.num_auth_methods != 0) {\n\t\t\tif (authenticated &&\n\t\t\t    !auth2_update_methods_lists(authctxt,\n\t\t\t    auth_method, auth_submethod)) {\n\t\t\t\tdebug3(\"%s: method %s: partial\", __func__,\n\t\t\t\t    auth_method);\n\t\t\t\tauthenticated = 0;\n\t\t\t\tpartial = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (authenticated) {\n\t\t\tif (!(ent->flags & MON_AUTHDECIDE))\n\t\t\t\tfatal(\"%s: unexpected authentication from %d\",\n\t\t\t\t    __func__, ent->type);\n\t\t\tif (authctxt->pw->pw_uid == 0 &&\n\t\t\t    !auth_root_allowed(ssh, auth_method))\n\t\t\t\tauthenticated = 0;\n#ifdef USE_PAM\n\t\t\t/* PAM needs to perform account checks after auth */\n\t\t\tif (options.use_pam && authenticated) {\n\t\t\t\tstruct sshbuf *m;\n\n\t\t\t\tif ((m = sshbuf_new()) == NULL)\n\t\t\t\t\tfatal(\"%s: sshbuf_new failed\",\n\t\t\t\t\t    __func__);\n\t\t\t\tmm_request_receive_expect(pmonitor->m_sendfd,\n\t\t\t\t    MONITOR_REQ_PAM_ACCOUNT, m);\n\t\t\t\tauthenticated = mm_answer_pam_account(\n\t\t\t\t    pmonitor->m_sendfd, m);\n\t\t\t\tsshbuf_free(m);\n\t\t\t}\n#endif\n\t\t}\n\t\tif (ent->flags & (MON_AUTHDECIDE|MON_ALOG)) {\n\t\t\tauth_log(authctxt, authenticated, partial,\n\t\t\t    auth_method, auth_submethod);\n\t\t\tif (!partial && !authenticated)\n\t\t\t\tauthctxt->failures++;\n\t\t\tif (authenticated || partial) {\n\t\t\t\tauth2_update_session_info(authctxt,\n\t\t\t\t    auth_method, auth_submethod);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!authctxt->valid)\n\t\tfatal(\"%s: authenticated invalid user\", __func__);\n\tif (strcmp(auth_method, \"unknown\") == 0)\n\t\tfatal(\"%s: authentication method name unknown\", __func__);\n\n\tdebug(\"%s: %s has been authenticated by privileged process\",\n\t    __func__, authctxt->user);\n\tssh->authctxt = NULL;\n\tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n\n\tmm_get_keystate(pmonitor);\n\n\t/* Drain any buffered messages from the child */\n\twhile (pmonitor->m_log_recvfd != -1 && monitor_read_log(pmonitor) == 0)\n\t\t;\n\n\tif (pmonitor->m_recvfd >= 0)\n\t\tclose(pmonitor->m_recvfd);\n\tif (pmonitor->m_log_sendfd >= 0)\n\t\tclose(pmonitor->m_log_sendfd);\n\tpmonitor->m_sendfd = pmonitor->m_log_recvfd = -1;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MON_ALOG\t0x0020\t/* Log auth attempt without authenticating */",
      "#define MON_AUTHDECIDE\t0x0008\t/* Decides Authentication */"
    ],
    "globals_used": [
      "extern ServerOptions options;",
      "extern struct sshbuf *loginmsg;",
      "int mm_answer_moduli(int, struct sshbuf *);",
      "int mm_answer_sign(int, struct sshbuf *);",
      "int mm_answer_pwnamallow(int, struct sshbuf *);",
      "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
      "int mm_answer_authserv(int, struct sshbuf *);",
      "int mm_answer_authpassword(int, struct sshbuf *);",
      "int mm_answer_bsdauthquery(int, struct sshbuf *);",
      "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
      "int mm_answer_keyallowed(int, struct sshbuf *);",
      "int mm_answer_keyverify(int, struct sshbuf *);",
      "int mm_answer_pty(int, struct sshbuf *);",
      "int mm_answer_pty_cleanup(int, struct sshbuf *);",
      "int mm_answer_term(int, struct sshbuf *);",
      "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
      "int mm_answer_rsa_challenge(int, struct sshbuf *);",
      "int mm_answer_rsa_response(int, struct sshbuf *);",
      "int mm_answer_sesskey(int, struct sshbuf *);",
      "int mm_answer_sessid(int, struct sshbuf *);",
      "static int monitor_read_log(struct monitor *);",
      "static Authctxt *authctxt;",
      "static char *auth_method = \"unknown\";",
      "static char *auth_submethod = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pmonitor->m_log_sendfd"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "mm_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "1486-1495",
          "snippet": "static void\nmm_session_close(Session *s)\n{\n\tdebug3(\"%s: session %d pid %ld\", __func__, s->self, (long)s->pid);\n\tif (s->ttyfd != -1) {\n\t\tdebug3(\"%s: tty %s ptyfd %d\", __func__, s->tty, s->ptyfd);\n\t\tsession_pty_cleanup2(s);\n\t}\n\tsession_unused(s->self);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmm_session_close(Session *s)\n{\n\tdebug3(\"%s: session %d pid %ld\", __func__, s->self, (long)s->pid);\n\tif (s->ttyfd != -1) {\n\t\tdebug3(\"%s: tty %s ptyfd %d\", __func__, s->tty, s->ptyfd);\n\t\tsession_pty_cleanup2(s);\n\t}\n\tsession_unused(s->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_read_log",
          "args": [
            "pmonitor"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_read_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "414-464",
          "snippet": "static int\nmonitor_read_log(struct monitor *pmonitor)\n{\n\tstruct sshbuf *logmsg;\n\tu_int len, level;\n\tchar *msg;\n\tu_char *p;\n\tint r;\n\n\tif ((logmsg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\t/* Read length */\n\tif ((r = sshbuf_reserve(logmsg, 4, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tif (atomicio(read, pmonitor->m_log_recvfd, p, 4) != 4) {\n\t\tif (errno == EPIPE) {\n\t\t\tsshbuf_free(logmsg);\n\t\t\tdebug(\"%s: child log fd closed\", __func__);\n\t\t\tclose(pmonitor->m_log_recvfd);\n\t\t\tpmonitor->m_log_recvfd = -1;\n\t\t\treturn -1;\n\t\t}\n\t\tfatal(\"%s: log fd read: %s\", __func__, strerror(errno));\n\t}\n\tif ((r = sshbuf_get_u32(logmsg, &len)) != 0)\n\t\tfatal(\"%s: get len: %s\", __func__, ssh_err(r));\n\tif (len <= 4 || len > 8192)\n\t\tfatal(\"%s: invalid log message length %u\", __func__, len);\n\n\t/* Read severity, message */\n\tsshbuf_reset(logmsg);\n\tif ((r = sshbuf_reserve(logmsg, len, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tif (atomicio(read, pmonitor->m_log_recvfd, p, len) != len)\n\t\tfatal(\"%s: log fd read: %s\", __func__, strerror(errno));\n\tif ((r = sshbuf_get_u32(logmsg, &level)) != 0 ||\n\t    (r = sshbuf_get_cstring(logmsg, &msg, NULL)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\n\t/* Log it */\n\tif (log_level_name(level) == NULL)\n\t\tfatal(\"%s: invalid log level %u (corrupted message?)\",\n\t\t    __func__, level);\n\tdo_log2(level, \"%s [preauth]\", msg);\n\n\tsshbuf_free(logmsg);\n\tfree(msg);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int mm_answer_moduli(int, struct sshbuf *);",
            "int mm_answer_sign(int, struct sshbuf *);",
            "int mm_answer_pwnamallow(int, struct sshbuf *);",
            "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
            "int mm_answer_authserv(int, struct sshbuf *);",
            "int mm_answer_authpassword(int, struct sshbuf *);",
            "int mm_answer_bsdauthquery(int, struct sshbuf *);",
            "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
            "int mm_answer_keyallowed(int, struct sshbuf *);",
            "int mm_answer_keyverify(int, struct sshbuf *);",
            "int mm_answer_pty(int, struct sshbuf *);",
            "int mm_answer_pty_cleanup(int, struct sshbuf *);",
            "int mm_answer_term(int, struct sshbuf *);",
            "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
            "int mm_answer_rsa_challenge(int, struct sshbuf *);",
            "int mm_answer_rsa_response(int, struct sshbuf *);",
            "int mm_answer_sesskey(int, struct sshbuf *);",
            "int mm_answer_sessid(int, struct sshbuf *);",
            "static int monitor_read_log(struct monitor *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\n\nstatic int\nmonitor_read_log(struct monitor *pmonitor)\n{\n\tstruct sshbuf *logmsg;\n\tu_int len, level;\n\tchar *msg;\n\tu_char *p;\n\tint r;\n\n\tif ((logmsg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\t/* Read length */\n\tif ((r = sshbuf_reserve(logmsg, 4, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tif (atomicio(read, pmonitor->m_log_recvfd, p, 4) != 4) {\n\t\tif (errno == EPIPE) {\n\t\t\tsshbuf_free(logmsg);\n\t\t\tdebug(\"%s: child log fd closed\", __func__);\n\t\t\tclose(pmonitor->m_log_recvfd);\n\t\t\tpmonitor->m_log_recvfd = -1;\n\t\t\treturn -1;\n\t\t}\n\t\tfatal(\"%s: log fd read: %s\", __func__, strerror(errno));\n\t}\n\tif ((r = sshbuf_get_u32(logmsg, &len)) != 0)\n\t\tfatal(\"%s: get len: %s\", __func__, ssh_err(r));\n\tif (len <= 4 || len > 8192)\n\t\tfatal(\"%s: invalid log message length %u\", __func__, len);\n\n\t/* Read severity, message */\n\tsshbuf_reset(logmsg);\n\tif ((r = sshbuf_reserve(logmsg, len, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tif (atomicio(read, pmonitor->m_log_recvfd, p, len) != len)\n\t\tfatal(\"%s: log fd read: %s\", __func__, strerror(errno));\n\tif ((r = sshbuf_get_u32(logmsg, &level)) != 0 ||\n\t    (r = sshbuf_get_cstring(logmsg, &msg, NULL)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\n\t/* Log it */\n\tif (log_level_name(level) == NULL)\n\t\tfatal(\"%s: invalid log level %u (corrupted message?)\",\n\t\t    __func__, level);\n\tdo_log2(level, \"%s [preauth]\", msg);\n\n\tsshbuf_free(logmsg);\n\tfree(msg);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_get_keystate",
          "args": [
            "pmonitor"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "mm_get_keystate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "1707-1717",
          "snippet": "void\nmm_get_keystate(struct monitor *pmonitor)\n{\n\tdebug3(\"%s: Waiting for new keys\", __func__);\n\n\tif ((child_state = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmm_request_receive_expect(pmonitor->m_sendfd, MONITOR_REQ_KEYEXPORT,\n\t    child_state);\n\tdebug3(\"%s: GOT new keys\", __func__);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *child_state;",
            "static int monitor_read_log(struct monitor *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *child_state;\nstatic int monitor_read_log(struct monitor *);\n\nvoid\nmm_get_keystate(struct monitor *pmonitor)\n{\n\tdebug3(\"%s: Waiting for new keys\", __func__);\n\n\tif ((child_state = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmm_request_receive_expect(pmonitor->m_sendfd, MONITOR_REQ_KEYEXPORT,\n\t    child_state);\n\tdebug3(\"%s: GOT new keys\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_set_log_preamble",
          "args": [
            "ssh",
            "\"user %s\"",
            "authctxt->user"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_set_log_preamble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "347-364",
          "snippet": "int\nssh_packet_set_log_preamble(struct ssh *ssh, const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tfree(ssh->log_preamble);\n\tif (fmt == NULL)\n\t\tssh->log_preamble = NULL;\n\telse {\n\t\tva_start(args, fmt);\n\t\tr = vasprintf(&ssh->log_preamble, fmt, args);\n\t\tva_end(args);\n\t\tif (r < 0 || ssh->log_preamble == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_set_log_preamble(struct ssh *ssh, const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tfree(ssh->log_preamble);\n\tif (fmt == NULL)\n\t\tssh->log_preamble = NULL;\n\telse {\n\t\tva_start(args, fmt);\n\t\tr = vasprintf(&ssh->log_preamble, fmt, args);\n\t\tva_end(args);\n\t\tif (r < 0 || ssh->log_preamble == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: %s has been authenticated by privileged process\"",
            "__func__",
            "authctxt->user"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: authentication method name unknown\"",
            "__func__"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "auth_method",
            "\"unknown\""
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_update_session_info",
          "args": [
            "authctxt",
            "auth_method",
            "auth_submethod"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_update_session_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "755-793",
          "snippet": "void\nauth2_update_session_info(Authctxt *authctxt, const char *method,\n    const char *submethod)\n{\n\tint r;\n\n\tif (authctxt->session_info == NULL) {\n\t\tif ((authctxt->session_info = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new\", __func__);\n\t}\n\n\t/* Append method[/submethod] */\n\tif ((r = sshbuf_putf(authctxt->session_info, \"%s%s%s\",\n\t    method, submethod == NULL ? \"\" : \"/\",\n\t    submethod == NULL ? \"\" : submethod)) != 0)\n\t\tfatal(\"%s: append method: %s\", __func__, ssh_err(r));\n\n\t/* Append key if present */\n\tif (authctxt->auth_method_key != NULL) {\n\t\tif ((r = sshbuf_put_u8(authctxt->session_info, ' ')) != 0 ||\n\t\t    (r = sshkey_format_text(authctxt->auth_method_key,\n\t\t    authctxt->session_info)) != 0)\n\t\t\tfatal(\"%s: append key: %s\", __func__, ssh_err(r));\n\t}\n\n\tif (authctxt->auth_method_info != NULL) {\n\t\t/* Ensure no ambiguity here */\n\t\tif (strchr(authctxt->auth_method_info, '\\n') != NULL)\n\t\t\tfatal(\"%s: auth_method_info contains \\\\n\", __func__);\n\t\tif ((r = sshbuf_put_u8(authctxt->session_info, ' ')) != 0 ||\n\t\t    (r = sshbuf_putf(authctxt->session_info, \"%s\",\n\t\t    authctxt->auth_method_info)) != 0) {\n\t\t\tfatal(\"%s: append method info: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshbuf_put_u8(authctxt->session_info, '\\n')) != 0)\n\t\tfatal(\"%s: append: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nvoid\nauth2_update_session_info(Authctxt *authctxt, const char *method,\n    const char *submethod)\n{\n\tint r;\n\n\tif (authctxt->session_info == NULL) {\n\t\tif ((authctxt->session_info = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new\", __func__);\n\t}\n\n\t/* Append method[/submethod] */\n\tif ((r = sshbuf_putf(authctxt->session_info, \"%s%s%s\",\n\t    method, submethod == NULL ? \"\" : \"/\",\n\t    submethod == NULL ? \"\" : submethod)) != 0)\n\t\tfatal(\"%s: append method: %s\", __func__, ssh_err(r));\n\n\t/* Append key if present */\n\tif (authctxt->auth_method_key != NULL) {\n\t\tif ((r = sshbuf_put_u8(authctxt->session_info, ' ')) != 0 ||\n\t\t    (r = sshkey_format_text(authctxt->auth_method_key,\n\t\t    authctxt->session_info)) != 0)\n\t\t\tfatal(\"%s: append key: %s\", __func__, ssh_err(r));\n\t}\n\n\tif (authctxt->auth_method_info != NULL) {\n\t\t/* Ensure no ambiguity here */\n\t\tif (strchr(authctxt->auth_method_info, '\\n') != NULL)\n\t\t\tfatal(\"%s: auth_method_info contains \\\\n\", __func__);\n\t\tif ((r = sshbuf_put_u8(authctxt->session_info, ' ')) != 0 ||\n\t\t    (r = sshbuf_putf(authctxt->session_info, \"%s\",\n\t\t    authctxt->auth_method_info)) != 0) {\n\t\t\tfatal(\"%s: append method info: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshbuf_put_u8(authctxt->session_info, '\\n')) != 0)\n\t\tfatal(\"%s: append: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_log",
          "args": [
            "authctxt",
            "authenticated",
            "partial",
            "auth_method",
            "auth_submethod"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "auth_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "310-372",
          "snippet": "void\nauth_log(Authctxt *authctxt, int authenticated, int partial,\n    const char *method, const char *submethod)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tint level = SYSLOG_LEVEL_VERBOSE;\n\tconst char *authmsg;\n\tchar *extra = NULL;\n\n\tif (use_privsep && !mm_is_monitor() && !authctxt->postponed)\n\t\treturn;\n\n\t/* Raise logging level */\n\tif (authenticated == 1 ||\n\t    !authctxt->valid ||\n\t    authctxt->failures >= options.max_authtries / 2 ||\n\t    strcmp(method, \"password\") == 0)\n\t\tlevel = SYSLOG_LEVEL_INFO;\n\n\tif (authctxt->postponed)\n\t\tauthmsg = \"Postponed\";\n\telse if (partial)\n\t\tauthmsg = \"Partial\";\n\telse\n\t\tauthmsg = authenticated ? \"Accepted\" : \"Failed\";\n\n\tif ((extra = format_method_key(authctxt)) == NULL) {\n\t\tif (authctxt->auth_method_info != NULL)\n\t\t\textra = xstrdup(authctxt->auth_method_info);\n\t}\n\n\tdo_log2(level, \"%s %s%s%s for %s%.100s from %.200s port %d ssh2%s%s\",\n\t    authmsg,\n\t    method,\n\t    submethod != NULL ? \"/\" : \"\", submethod == NULL ? \"\" : submethod,\n\t    authctxt->valid ? \"\" : \"invalid user \",\n\t    authctxt->user,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    extra != NULL ? \": \" : \"\",\n\t    extra != NULL ? extra : \"\");\n\n\tfree(extra);\n\n#ifdef CUSTOM_FAILED_LOGIN\n\tif (authenticated == 0 && !authctxt->postponed &&\n\t    (strcmp(method, \"password\") == 0 ||\n\t    strncmp(method, \"keyboard-interactive\", 20) == 0 ||\n\t    strcmp(method, \"challenge-response\") == 0))\n\t\trecord_failed_login(authctxt->user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n# ifdef WITH_AIXAUTHENTICATE\n\tif (authenticated)\n\t\tsys_auth_record_login(authctxt->user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\",\n\t\t    &loginmsg);\n# endif\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\tif (authenticated == 0 && !authctxt->postponed)\n\t\taudit_event(audit_classify_auth(method));\n#endif\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern int use_privsep;",
            "extern struct sshbuf *loginmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern int use_privsep;\nextern struct sshbuf *loginmsg;\n\nvoid\nauth_log(Authctxt *authctxt, int authenticated, int partial,\n    const char *method, const char *submethod)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tint level = SYSLOG_LEVEL_VERBOSE;\n\tconst char *authmsg;\n\tchar *extra = NULL;\n\n\tif (use_privsep && !mm_is_monitor() && !authctxt->postponed)\n\t\treturn;\n\n\t/* Raise logging level */\n\tif (authenticated == 1 ||\n\t    !authctxt->valid ||\n\t    authctxt->failures >= options.max_authtries / 2 ||\n\t    strcmp(method, \"password\") == 0)\n\t\tlevel = SYSLOG_LEVEL_INFO;\n\n\tif (authctxt->postponed)\n\t\tauthmsg = \"Postponed\";\n\telse if (partial)\n\t\tauthmsg = \"Partial\";\n\telse\n\t\tauthmsg = authenticated ? \"Accepted\" : \"Failed\";\n\n\tif ((extra = format_method_key(authctxt)) == NULL) {\n\t\tif (authctxt->auth_method_info != NULL)\n\t\t\textra = xstrdup(authctxt->auth_method_info);\n\t}\n\n\tdo_log2(level, \"%s %s%s%s for %s%.100s from %.200s port %d ssh2%s%s\",\n\t    authmsg,\n\t    method,\n\t    submethod != NULL ? \"/\" : \"\", submethod == NULL ? \"\" : submethod,\n\t    authctxt->valid ? \"\" : \"invalid user \",\n\t    authctxt->user,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    extra != NULL ? \": \" : \"\",\n\t    extra != NULL ? extra : \"\");\n\n\tfree(extra);\n\n#ifdef CUSTOM_FAILED_LOGIN\n\tif (authenticated == 0 && !authctxt->postponed &&\n\t    (strcmp(method, \"password\") == 0 ||\n\t    strncmp(method, \"keyboard-interactive\", 20) == 0 ||\n\t    strcmp(method, \"challenge-response\") == 0))\n\t\trecord_failed_login(authctxt->user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n# ifdef WITH_AIXAUTHENTICATE\n\tif (authenticated)\n\t\tsys_auth_record_login(authctxt->user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\",\n\t\t    &loginmsg);\n# endif\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\tif (authenticated == 0 && !authctxt->postponed)\n\t\taudit_event(audit_classify_auth(method));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "m"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_answer_pam_account",
          "args": [
            "pmonitor->m_sendfd",
            "m"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "mm_answer_pam_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "1002-1020",
          "snippet": "int\nmm_answer_pam_account(int sock, struct sshbuf *m)\n{\n\tu_int ret;\n\tint r;\n\n\tif (!options.use_pam)\n\t\tfatal(\"%s: PAM not enabled\", __func__);\n\n\tret = do_pam_account();\n\n\tif ((r = sshbuf_put_u32(m, ret)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, loginmsg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tmm_request_send(sock, MONITOR_ANS_PAM_ACCOUNT, m);\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern struct sshbuf *loginmsg;",
            "int mm_answer_moduli(int, struct sshbuf *);",
            "int mm_answer_sign(int, struct sshbuf *);",
            "int mm_answer_pwnamallow(int, struct sshbuf *);",
            "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
            "int mm_answer_authserv(int, struct sshbuf *);",
            "int mm_answer_authpassword(int, struct sshbuf *);",
            "int mm_answer_bsdauthquery(int, struct sshbuf *);",
            "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
            "int mm_answer_keyallowed(int, struct sshbuf *);",
            "int mm_answer_keyverify(int, struct sshbuf *);",
            "int mm_answer_pty(int, struct sshbuf *);",
            "int mm_answer_pty_cleanup(int, struct sshbuf *);",
            "int mm_answer_term(int, struct sshbuf *);",
            "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
            "int mm_answer_rsa_challenge(int, struct sshbuf *);",
            "int mm_answer_rsa_response(int, struct sshbuf *);",
            "int mm_answer_sesskey(int, struct sshbuf *);",
            "int mm_answer_sessid(int, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\n\nint\nmm_answer_pam_account(int sock, struct sshbuf *m)\n{\n\tu_int ret;\n\tint r;\n\n\tif (!options.use_pam)\n\t\tfatal(\"%s: PAM not enabled\", __func__);\n\n\tret = do_pam_account();\n\n\tif ((r = sshbuf_put_u32(m, ret)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, loginmsg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tmm_request_send(sock, MONITOR_ANS_PAM_ACCOUNT, m);\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_request_receive_expect",
          "args": [
            "pmonitor->m_sendfd",
            "MONITOR_REQ_PAM_ACCOUNT",
            "m"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "mm_request_receive_expect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "163-177",
          "snippet": "void\nmm_request_receive_expect(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tu_char rtype;\n\tint r;\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tmm_request_receive(sock, m);\n\tif ((r = sshbuf_get_u8(m, &rtype)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (rtype != type)\n\t\tfatal(\"%s: read: rtype %d != type %d\", __func__,\n\t\t    rtype, type);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_request_receive_expect(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tu_char rtype;\n\tint r;\n\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\n\tmm_request_receive(sock, m);\n\tif ((r = sshbuf_get_u8(m, &rtype)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (rtype != type)\n\t\tfatal(\"%s: read: rtype %d != type %d\", __func__,\n\t\t    rtype, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_root_allowed",
          "args": [
            "ssh",
            "auth_method"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "auth_root_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "393-415",
          "snippet": "int\nauth_root_allowed(struct ssh *ssh, const char *method)\n{\n\tswitch (options.permit_root_login) {\n\tcase PERMIT_YES:\n\t\treturn 1;\n\tcase PERMIT_NO_PASSWD:\n\t\tif (strcmp(method, \"publickey\") == 0 ||\n\t\t    strcmp(method, \"hostbased\") == 0 ||\n\t\t    strcmp(method, \"gssapi-with-mic\") == 0)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase PERMIT_FORCED_ONLY:\n\t\tif (auth_opts->force_command != NULL) {\n\t\t\tlogit(\"Root login accepted for forced command.\");\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\t}\n\tlogit(\"ROOT LOGIN REFUSED FROM %.200s port %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\treturn 0;\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern struct sshauthopt *auth_opts;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nint\nauth_root_allowed(struct ssh *ssh, const char *method)\n{\n\tswitch (options.permit_root_login) {\n\tcase PERMIT_YES:\n\t\treturn 1;\n\tcase PERMIT_NO_PASSWD:\n\t\tif (strcmp(method, \"publickey\") == 0 ||\n\t\t    strcmp(method, \"hostbased\") == 0 ||\n\t\t    strcmp(method, \"gssapi-with-mic\") == 0)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase PERMIT_FORCED_ONLY:\n\t\tif (auth_opts->force_command != NULL) {\n\t\t\tlogit(\"Root login accepted for forced command.\");\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\t}\n\tlogit(\"ROOT LOGIN REFUSED FROM %.200s port %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: unexpected authentication from %d\"",
            "__func__",
            "ent->type"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_update_methods_lists",
          "args": [
            "authctxt",
            "auth_method",
            "auth_submethod"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_update_methods_lists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "645-668",
          "snippet": "int\nauth2_update_methods_lists(Authctxt *authctxt, const char *method,\n    const char *submethod)\n{\n\tu_int i, found = 0;\n\n\tdebug3(\"%s: updating methods list after \\\"%s\\\"\", __func__, method);\n\tfor (i = 0; i < authctxt->num_auth_methods; i++) {\n\t\tif (!remove_method(&(authctxt->auth_methods[i]), method,\n\t\t    submethod))\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tif (*authctxt->auth_methods[i] == '\\0') {\n\t\t\tdebug2(\"authentication methods list %d complete\", i);\n\t\t\treturn 1;\n\t\t}\n\t\tdebug3(\"authentication methods list %d remaining: \\\"%s\\\"\",\n\t\t    i, authctxt->auth_methods[i]);\n\t}\n\t/* This should not happen, but would be bad if it did */\n\tif (!found)\n\t\tfatal(\"%s: method not in AuthenticationMethods\", __func__);\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nint\nauth2_update_methods_lists(Authctxt *authctxt, const char *method,\n    const char *submethod)\n{\n\tu_int i, found = 0;\n\n\tdebug3(\"%s: updating methods list after \\\"%s\\\"\", __func__, method);\n\tfor (i = 0; i < authctxt->num_auth_methods; i++) {\n\t\tif (!remove_method(&(authctxt->auth_methods[i]), method,\n\t\t    submethod))\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tif (*authctxt->auth_methods[i] == '\\0') {\n\t\t\tdebug2(\"authentication methods list %d complete\", i);\n\t\t\treturn 1;\n\t\t}\n\t\tdebug3(\"authentication methods list %d remaining: \\\"%s\\\"\",\n\t\t    i, authctxt->auth_methods[i]);\n\t}\n\t/* This should not happen, but would be bad if it did */\n\tif (!found)\n\t\tfatal(\"%s: method not in AuthenticationMethods\", __func__);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_read",
          "args": [
            "pmonitor",
            "mon_dispatch",
            "&ent"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "466-537",
          "snippet": "int\nmonitor_read(struct monitor *pmonitor, struct mon_table *ent,\n    struct mon_table **pent)\n{\n\tstruct sshbuf *m;\n\tint r, ret;\n\tu_char type;\n\tstruct pollfd pfd[2];\n\n\tfor (;;) {\n\t\tmemset(&pfd, 0, sizeof(pfd));\n\t\tpfd[0].fd = pmonitor->m_sendfd;\n\t\tpfd[0].events = POLLIN;\n\t\tpfd[1].fd = pmonitor->m_log_recvfd;\n\t\tpfd[1].events = pfd[1].fd == -1 ? 0 : POLLIN;\n\t\tif (poll(pfd, pfd[1].fd == -1 ? 1 : 2, -1) == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"%s: poll: %s\", __func__, strerror(errno));\n\t\t}\n\t\tif (pfd[1].revents) {\n\t\t\t/*\n\t\t\t * Drain all log messages before processing next\n\t\t\t * monitor request.\n\t\t\t */\n\t\t\tmonitor_read_log(pmonitor);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pfd[0].revents)\n\t\t\tbreak;  /* Continues below */\n\t}\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\tmm_request_receive(pmonitor->m_sendfd, m);\n\tif ((r = sshbuf_get_u8(m, &type)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"%s: checking request %d\", __func__, type);\n\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type)\n\t\t\tbreak;\n\t\tent++;\n\t}\n\n\tif (ent->f != NULL) {\n\t\tif (!(ent->flags & MON_PERMIT))\n\t\t\tfatal(\"%s: unpermitted request %d\", __func__,\n\t\t\t    type);\n\t\tret = (*ent->f)(pmonitor->m_sendfd, m);\n\t\tsshbuf_free(m);\n\n\t\t/* The child may use this request only once, disable it */\n\t\tif (ent->flags & MON_ONCE) {\n\t\t\tdebug2(\"%s: %d used once, disabling now\", __func__,\n\t\t\t    type);\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t}\n\n\t\tif (pent != NULL)\n\t\t\t*pent = ent;\n\n\t\treturn ret;\n\t}\n\n\tfatal(\"%s: unsupported request: %d\", __func__, type);\n\n\t/* NOTREACHED */\n\treturn (-1);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_PERMIT\t0x1000\t/* Request is permitted */",
            "#define MON_ONCE\t0x0010\t/* Disable after calling */"
          ],
          "globals_used": [
            "int mm_answer_moduli(int, struct sshbuf *);",
            "int mm_answer_sign(int, struct sshbuf *);",
            "int mm_answer_pwnamallow(int, struct sshbuf *);",
            "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
            "int mm_answer_authserv(int, struct sshbuf *);",
            "int mm_answer_authpassword(int, struct sshbuf *);",
            "int mm_answer_bsdauthquery(int, struct sshbuf *);",
            "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
            "int mm_answer_keyallowed(int, struct sshbuf *);",
            "int mm_answer_keyverify(int, struct sshbuf *);",
            "int mm_answer_pty(int, struct sshbuf *);",
            "int mm_answer_pty_cleanup(int, struct sshbuf *);",
            "int mm_answer_term(int, struct sshbuf *);",
            "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
            "int mm_answer_rsa_challenge(int, struct sshbuf *);",
            "int mm_answer_rsa_response(int, struct sshbuf *);",
            "int mm_answer_sesskey(int, struct sshbuf *);",
            "int mm_answer_sessid(int, struct sshbuf *);",
            "static int monitor_read_log(struct monitor *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n#define MON_ONCE\t0x0010\t/* Disable after calling */\n\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\n\nint\nmonitor_read(struct monitor *pmonitor, struct mon_table *ent,\n    struct mon_table **pent)\n{\n\tstruct sshbuf *m;\n\tint r, ret;\n\tu_char type;\n\tstruct pollfd pfd[2];\n\n\tfor (;;) {\n\t\tmemset(&pfd, 0, sizeof(pfd));\n\t\tpfd[0].fd = pmonitor->m_sendfd;\n\t\tpfd[0].events = POLLIN;\n\t\tpfd[1].fd = pmonitor->m_log_recvfd;\n\t\tpfd[1].events = pfd[1].fd == -1 ? 0 : POLLIN;\n\t\tif (poll(pfd, pfd[1].fd == -1 ? 1 : 2, -1) == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"%s: poll: %s\", __func__, strerror(errno));\n\t\t}\n\t\tif (pfd[1].revents) {\n\t\t\t/*\n\t\t\t * Drain all log messages before processing next\n\t\t\t * monitor request.\n\t\t\t */\n\t\t\tmonitor_read_log(pmonitor);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pfd[0].revents)\n\t\t\tbreak;  /* Continues below */\n\t}\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\tmm_request_receive(pmonitor->m_sendfd, m);\n\tif ((r = sshbuf_get_u8(m, &type)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"%s: checking request %d\", __func__, type);\n\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type)\n\t\t\tbreak;\n\t\tent++;\n\t}\n\n\tif (ent->f != NULL) {\n\t\tif (!(ent->flags & MON_PERMIT))\n\t\t\tfatal(\"%s: unpermitted request %d\", __func__,\n\t\t\t    type);\n\t\tret = (*ent->f)(pmonitor->m_sendfd, m);\n\t\tsshbuf_free(m);\n\n\t\t/* The child may use this request only once, disable it */\n\t\tif (ent->flags & MON_ONCE) {\n\t\t\tdebug2(\"%s: %d used once, disabling now\", __func__,\n\t\t\t    type);\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t}\n\n\t\tif (pent != NULL)\n\t\t\t*pent = ent;\n\n\t\treturn ret;\n\t}\n\n\tfatal(\"%s: unsupported request: %d\", __func__, type);\n\n\t/* NOTREACHED */\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_authctxt_reset_info",
          "args": [
            "authctxt"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_authctxt_reset_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "671-677",
          "snippet": "void auth2_authctxt_reset_info(Authctxt *authctxt)\n{\n\tsshkey_free(authctxt->auth_method_key);\n\tfree(authctxt->auth_method_info);\n\tauthctxt->auth_method_key = NULL;\n\tauthctxt->auth_method_info = NULL;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nvoid auth2_authctxt_reset_info(Authctxt *authctxt)\n{\n\tsshkey_free(authctxt->auth_method_key);\n\tfree(authctxt->auth_method_info);\n\tauthctxt->auth_method_key = NULL;\n\tauthctxt->auth_method_info = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_permit",
          "args": [
            "mon_dispatch",
            "MONITOR_REQ_SIGN",
            "1"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "240-251",
          "snippet": "static void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_PERMIT\t0x1000\t/* Request is permitted */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n\nstatic void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "authctxt",
            "0",
            "sizeof(*authctxt)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_ALOG\t0x0020\t/* Log auth attempt without authenticating */\n#define MON_AUTHDECIDE\t0x0008\t/* Decides Authentication */\n\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\nstatic Authctxt *authctxt;\nstatic char *auth_method = \"unknown\";\nstatic char *auth_submethod = NULL;\n\nvoid\nmonitor_child_preauth(Authctxt *_authctxt, struct monitor *pmonitor)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tstruct mon_table *ent;\n\tint authenticated = 0, partial = 0;\n\n\tdebug3(\"preauth child monitor started\");\n\n\tif (pmonitor->m_recvfd >= 0)\n\t\tclose(pmonitor->m_recvfd);\n\tif (pmonitor->m_log_sendfd >= 0)\n\t\tclose(pmonitor->m_log_sendfd);\n\tpmonitor->m_log_sendfd = pmonitor->m_recvfd = -1;\n\n\tauthctxt = _authctxt;\n\tmemset(authctxt, 0, sizeof(*authctxt));\n\tssh->authctxt = authctxt;\n\n\tauthctxt->loginmsg = loginmsg;\n\n\tmon_dispatch = mon_dispatch_proto20;\n\t/* Permit requests for moduli and signatures */\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_MODULI, 1);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_SIGN, 1);\n\n\t/* The first few requests do not require asynchronous access */\n\twhile (!authenticated) {\n\t\tpartial = 0;\n\t\tauth_method = \"unknown\";\n\t\tauth_submethod = NULL;\n\t\tauth2_authctxt_reset_info(authctxt);\n\n\t\tauthenticated = (monitor_read(pmonitor, mon_dispatch, &ent) == 1);\n\n\t\t/* Special handling for multiple required authentications */\n\t\tif (options.num_auth_methods != 0) {\n\t\t\tif (authenticated &&\n\t\t\t    !auth2_update_methods_lists(authctxt,\n\t\t\t    auth_method, auth_submethod)) {\n\t\t\t\tdebug3(\"%s: method %s: partial\", __func__,\n\t\t\t\t    auth_method);\n\t\t\t\tauthenticated = 0;\n\t\t\t\tpartial = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (authenticated) {\n\t\t\tif (!(ent->flags & MON_AUTHDECIDE))\n\t\t\t\tfatal(\"%s: unexpected authentication from %d\",\n\t\t\t\t    __func__, ent->type);\n\t\t\tif (authctxt->pw->pw_uid == 0 &&\n\t\t\t    !auth_root_allowed(ssh, auth_method))\n\t\t\t\tauthenticated = 0;\n#ifdef USE_PAM\n\t\t\t/* PAM needs to perform account checks after auth */\n\t\t\tif (options.use_pam && authenticated) {\n\t\t\t\tstruct sshbuf *m;\n\n\t\t\t\tif ((m = sshbuf_new()) == NULL)\n\t\t\t\t\tfatal(\"%s: sshbuf_new failed\",\n\t\t\t\t\t    __func__);\n\t\t\t\tmm_request_receive_expect(pmonitor->m_sendfd,\n\t\t\t\t    MONITOR_REQ_PAM_ACCOUNT, m);\n\t\t\t\tauthenticated = mm_answer_pam_account(\n\t\t\t\t    pmonitor->m_sendfd, m);\n\t\t\t\tsshbuf_free(m);\n\t\t\t}\n#endif\n\t\t}\n\t\tif (ent->flags & (MON_AUTHDECIDE|MON_ALOG)) {\n\t\t\tauth_log(authctxt, authenticated, partial,\n\t\t\t    auth_method, auth_submethod);\n\t\t\tif (!partial && !authenticated)\n\t\t\t\tauthctxt->failures++;\n\t\t\tif (authenticated || partial) {\n\t\t\t\tauth2_update_session_info(authctxt,\n\t\t\t\t    auth_method, auth_submethod);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!authctxt->valid)\n\t\tfatal(\"%s: authenticated invalid user\", __func__);\n\tif (strcmp(auth_method, \"unknown\") == 0)\n\t\tfatal(\"%s: authentication method name unknown\", __func__);\n\n\tdebug(\"%s: %s has been authenticated by privileged process\",\n\t    __func__, authctxt->user);\n\tssh->authctxt = NULL;\n\tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n\n\tmm_get_keystate(pmonitor);\n\n\t/* Drain any buffered messages from the child */\n\twhile (pmonitor->m_log_recvfd != -1 && monitor_read_log(pmonitor) == 0)\n\t\t;\n\n\tif (pmonitor->m_recvfd >= 0)\n\t\tclose(pmonitor->m_recvfd);\n\tif (pmonitor->m_log_sendfd >= 0)\n\t\tclose(pmonitor->m_log_sendfd);\n\tpmonitor->m_sendfd = pmonitor->m_log_recvfd = -1;\n}"
  },
  {
    "function_name": "monitor_permit_authentications",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "253-265",
    "snippet": "static void\nmonitor_permit_authentications(int permit)\n{\n\tstruct mon_table *ent = mon_dispatch;\n\n\twhile (ent->f != NULL) {\n\t\tif (ent->flags & MON_AUTH) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t}\n\t\tent++;\n\t}\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MON_PERMIT\t0x1000\t/* Request is permitted */",
      "#define MON_AUTH\t(MON_ISAUTH|MON_AUTHDECIDE)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n#define MON_AUTH\t(MON_ISAUTH|MON_AUTHDECIDE)\n\nstatic void\nmonitor_permit_authentications(int permit)\n{\n\tstruct mon_table *ent = mon_dispatch;\n\n\twhile (ent->f != NULL) {\n\t\tif (ent->flags & MON_AUTH) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t}\n\t\tent++;\n\t}\n}"
  },
  {
    "function_name": "monitor_permit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
    "lines": "240-251",
    "snippet": "static void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"match.h\"",
      "#include \"authfd.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"canohost.h\"",
      "#include \"sshlogin.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"auth-options.h\"",
      "#include \"packet.h\"",
      "#include \"auth-pam.h\"",
      "#include \"dh.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"atomicio.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "#include <openssl/dh.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MON_PERMIT\t0x1000\t/* Request is permitted */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_PERMIT\t0x1000\t/* Request is permitted */\n\nstatic void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}"
  }
]