[
  {
    "function_name": "maybe_add_key_to_agent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "1550-1577",
    "snippet": "void\nmaybe_add_key_to_agent(char *authfile, const struct sshkey *private,\n    char *comment, char *passphrase)\n{\n\tint auth_sock = -1, r;\n\n\tif (options.add_keys_to_agent == 0)\n\t\treturn;\n\n\tif ((r = ssh_get_authentication_socket(&auth_sock)) != 0) {\n\t\tdebug3(\"no authentication agent, not adding key\");\n\t\treturn;\n\t}\n\n\tif (options.add_keys_to_agent == 2 &&\n\t    !ask_permission(\"Add key %s (%s) to agent?\", authfile, comment)) {\n\t\tdebug3(\"user denied adding this key\");\n\t\tclose(auth_sock);\n\t\treturn;\n\t}\n\n\tif ((r = ssh_add_identity_constrained(auth_sock, private, comment, 0,\n\t    (options.add_keys_to_agent == 3), 0)) == 0)\n\t\tdebug(\"identity added to agent: %s\", authfile);\n\telse\n\t\tdebug(\"could not add identity to agent: %s (%d)\", authfile, r);\n\tclose(auth_sock);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "static int show_other_keys(struct hostkeys *, struct sshkey *);",
      "static void warn_changed_key(struct sshkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "auth_sock"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"could not add identity to agent: %s (%d)\"",
            "authfile",
            "r"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_add_identity_constrained",
          "args": [
            "auth_sock",
            "private",
            "comment",
            "0",
            "(options.add_keys_to_agent == 3)",
            "0"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_add_identity_constrained",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "423-471",
          "snippet": "int\nssh_add_identity_constrained(int sock, const struct sshkey *key,\n    const char *comment, u_int life, u_int confirm, u_int maxsign)\n{\n\tstruct sshbuf *msg;\n\tint r, constrained = (life || confirm || maxsign);\n\tu_char type;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n#endif\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\ttype = constrained ?\n\t\t    SSH2_AGENTC_ADD_ID_CONSTRAINED :\n\t\t    SSH2_AGENTC_ADD_IDENTITY;\n\t\tif ((r = sshbuf_put_u8(msg, type)) != 0 ||\n\t\t    (r = sshkey_private_serialize_maxsign(key, msg, maxsign,\n\t\t    NULL)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg, comment)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (constrained &&\n\t    (r = encode_constraints(msg, life, confirm, maxsign)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tr = decode_reply(type);\n out:\n\tsshbuf_free(msg);\n\treturn r;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_add_identity_constrained(int sock, const struct sshkey *key,\n    const char *comment, u_int life, u_int confirm, u_int maxsign)\n{\n\tstruct sshbuf *msg;\n\tint r, constrained = (life || confirm || maxsign);\n\tu_char type;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n#endif\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\ttype = constrained ?\n\t\t    SSH2_AGENTC_ADD_ID_CONSTRAINED :\n\t\t    SSH2_AGENTC_ADD_IDENTITY;\n\t\tif ((r = sshbuf_put_u8(msg, type)) != 0 ||\n\t\t    (r = sshkey_private_serialize_maxsign(key, msg, maxsign,\n\t\t    NULL)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg, comment)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (constrained &&\n\t    (r = encode_constraints(msg, life, confirm, maxsign)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tr = decode_reply(type);\n out:\n\tsshbuf_free(msg);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask_permission",
          "args": [
            "\"Add key %s (%s) to agent?\"",
            "authfile",
            "comment"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "ask_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "168-192",
          "snippet": "int\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);\n\tif (p != NULL) {\n\t\t/*\n\t\t * Accept empty responses and responses consisting\n\t\t * of the word \"yes\" as affirmative.\n\t\t */\n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);\n\tif (p != NULL) {\n\t\t/*\n\t\t * Accept empty responses and responses consisting\n\t\t * of the word \"yes\" as affirmative.\n\t\t */\n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_authentication_socket",
          "args": [
            "&auth_sock"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_get_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "86-120",
          "snippet": "int\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\nvoid\nmaybe_add_key_to_agent(char *authfile, const struct sshkey *private,\n    char *comment, char *passphrase)\n{\n\tint auth_sock = -1, r;\n\n\tif (options.add_keys_to_agent == 0)\n\t\treturn;\n\n\tif ((r = ssh_get_authentication_socket(&auth_sock)) != 0) {\n\t\tdebug3(\"no authentication agent, not adding key\");\n\t\treturn;\n\t}\n\n\tif (options.add_keys_to_agent == 2 &&\n\t    !ask_permission(\"Add key %s (%s) to agent?\", authfile, comment)) {\n\t\tdebug3(\"user denied adding this key\");\n\t\tclose(auth_sock);\n\t\treturn;\n\t}\n\n\tif ((r = ssh_add_identity_constrained(auth_sock, private, comment, 0,\n\t    (options.add_keys_to_agent == 3), 0)) == 0)\n\t\tdebug(\"identity added to agent: %s\", authfile);\n\telse\n\t\tdebug(\"could not add identity to agent: %s (%d)\", authfile, r);\n\tclose(auth_sock);\n}"
  },
  {
    "function_name": "ssh_local_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "1513-1548",
    "snippet": "int\nssh_local_cmd(const char *args)\n{\n\tchar *shell;\n\tpid_t pid;\n\tint status;\n\tvoid (*osighand)(int);\n\n\tif (!options.permit_local_command ||\n\t    args == NULL || !*args)\n\t\treturn (1);\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\tosighand = signal(SIGCHLD, SIG_DFL);\n\tpid = fork();\n\tif (pid == 0) {\n\t\tsignal(SIGPIPE, SIG_DFL);\n\t\tdebug3(\"Executing %s -c \\\"%s\\\"\", shell, args);\n\t\texecl(shell, shell, \"-c\", args, (char *)NULL);\n\t\terror(\"Couldn't execute %s -c \\\"%s\\\": %s\",\n\t\t    shell, args, strerror(errno));\n\t\t_exit(1);\n\t} else if (pid == -1)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\tsignal(SIGCHLD, osighand);\n\n\tif (!WIFEXITED(status))\n\t\treturn (1);\n\n\treturn (WEXITSTATUS(status));\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGCHLD",
            "osighand"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Couldn't wait for child: %s\"",
            "strerror(errno)"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't execute %s -c \\\"%s\\\": %s\"",
            "shell",
            "args",
            "strerror(errno)"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execl",
          "args": [
            "shell",
            "shell",
            "\"-c\"",
            "args",
            "(char *)NULL"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Executing %s -c \\\"%s\\\"\"",
            "shell",
            "args"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SHELL\""
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nint\nssh_local_cmd(const char *args)\n{\n\tchar *shell;\n\tpid_t pid;\n\tint status;\n\tvoid (*osighand)(int);\n\n\tif (!options.permit_local_command ||\n\t    args == NULL || !*args)\n\t\treturn (1);\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\tosighand = signal(SIGCHLD, SIG_DFL);\n\tpid = fork();\n\tif (pid == 0) {\n\t\tsignal(SIGPIPE, SIG_DFL);\n\t\tdebug3(\"Executing %s -c \\\"%s\\\"\", shell, args);\n\t\texecl(shell, shell, \"-c\", args, (char *)NULL);\n\t\terror(\"Couldn't execute %s -c \\\"%s\\\": %s\",\n\t\t    shell, args, strerror(errno));\n\t\t_exit(1);\n\t} else if (pid == -1)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\tsignal(SIGCHLD, osighand);\n\n\tif (!WIFEXITED(status))\n\t\treturn (1);\n\n\treturn (WEXITSTATUS(status));\n}"
  },
  {
    "function_name": "warn_changed_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "1487-1508",
    "snippet": "static void\nwarn_changed_key(struct sshkey *host_key)\n{\n\tchar *fp;\n\n\tfp = sshkey_fingerprint(host_key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT);\n\tif (fp == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\");\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\");\n\terror(\"Someone could be eavesdropping on you right now (man-in-the-middle attack)!\");\n\terror(\"It is also possible that a host key has just been changed.\");\n\terror(\"The fingerprint for the %s key sent by the remote host is\\n%s.\",\n\t    sshkey_type(host_key), fp);\n\terror(\"Please contact your system administrator.\");\n\n\tfree(fp);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "static int show_other_keys(struct hostkeys *, struct sshkey *);",
      "static void warn_changed_key(struct sshkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fp"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Please contact your system administrator.\""
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "host_key"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshkey_fingerprint fail\"",
            "__func__"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "host_key",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\nstatic void\nwarn_changed_key(struct sshkey *host_key)\n{\n\tchar *fp;\n\n\tfp = sshkey_fingerprint(host_key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT);\n\tif (fp == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\");\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\");\n\terror(\"Someone could be eavesdropping on you right now (man-in-the-middle attack)!\");\n\terror(\"It is also possible that a host key has just been changed.\");\n\terror(\"The fingerprint for the %s key sent by the remote host is\\n%s.\",\n\t    sshkey_type(host_key), fp);\n\terror(\"Please contact your system administrator.\");\n\n\tfree(fp);\n}"
  },
  {
    "function_name": "show_other_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "1446-1485",
    "snippet": "static int\nshow_other_keys(struct hostkeys *hostkeys, struct sshkey *key)\n{\n\tint type[] = {\n\t\tKEY_RSA,\n\t\tKEY_DSA,\n\t\tKEY_ECDSA,\n\t\tKEY_ED25519,\n\t\tKEY_XMSS,\n\t\t-1\n\t};\n\tint i, ret = 0;\n\tchar *fp, *ra;\n\tconst struct hostkey_entry *found;\n\n\tfor (i = 0; type[i] != -1; i++) {\n\t\tif (type[i] == key->type)\n\t\t\tcontinue;\n\t\tif (!lookup_key_in_hostkeys_by_type(hostkeys, type[i], &found))\n\t\t\tcontinue;\n\t\tfp = sshkey_fingerprint(found->key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\tra = sshkey_fingerprint(found->key,\n\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\tif (fp == NULL || ra == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\tlogit(\"WARNING: %s key found for host %s\\n\"\n\t\t    \"in %s:%lu\\n\"\n\t\t    \"%s key fingerprint %s.\",\n\t\t    sshkey_type(found->key),\n\t\t    found->host, found->file, found->line,\n\t\t    sshkey_type(found->key), fp);\n\t\tif (options.visual_host_key)\n\t\t\tlogit(\"%s\", ra);\n\t\tfree(ra);\n\t\tfree(fp);\n\t\tret = 1;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "static int show_other_keys(struct hostkeys *, struct sshkey *);",
      "static void warn_changed_key(struct sshkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fp"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s\"",
            "ra"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "found->key"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshkey_fingerprint fail\"",
            "__func__"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "found->key",
            "options.fingerprint_hash",
            "SSH_FP_RANDOMART"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_key_in_hostkeys_by_type",
          "args": [
            "hostkeys",
            "type[i]",
            "&found"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_key_in_hostkeys_by_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "404-410",
          "snippet": "int\nlookup_key_in_hostkeys_by_type(struct hostkeys *hostkeys, int keytype,\n    const struct hostkey_entry **found)\n{\n\treturn (check_hostkeys_by_key_or_type(hostkeys, NULL, keytype,\n\t    found) == HOST_FOUND);\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nlookup_key_in_hostkeys_by_type(struct hostkeys *hostkeys, int keytype,\n    const struct hostkey_entry **found)\n{\n\treturn (check_hostkeys_by_key_or_type(hostkeys, NULL, keytype,\n\t    found) == HOST_FOUND);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\nstatic int\nshow_other_keys(struct hostkeys *hostkeys, struct sshkey *key)\n{\n\tint type[] = {\n\t\tKEY_RSA,\n\t\tKEY_DSA,\n\t\tKEY_ECDSA,\n\t\tKEY_ED25519,\n\t\tKEY_XMSS,\n\t\t-1\n\t};\n\tint i, ret = 0;\n\tchar *fp, *ra;\n\tconst struct hostkey_entry *found;\n\n\tfor (i = 0; type[i] != -1; i++) {\n\t\tif (type[i] == key->type)\n\t\t\tcontinue;\n\t\tif (!lookup_key_in_hostkeys_by_type(hostkeys, type[i], &found))\n\t\t\tcontinue;\n\t\tfp = sshkey_fingerprint(found->key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\tra = sshkey_fingerprint(found->key,\n\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\tif (fp == NULL || ra == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\tlogit(\"WARNING: %s key found for host %s\\n\"\n\t\t    \"in %s:%lu\\n\"\n\t\t    \"%s key fingerprint %s.\",\n\t\t    sshkey_type(found->key),\n\t\t    found->host, found->file, found->line,\n\t\t    sshkey_type(found->key), fp);\n\t\tif (options.visual_host_key)\n\t\t\tlogit(\"%s\", ra);\n\t\tfree(ra);\n\t\tfree(fp);\n\t\tret = 1;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ssh_put_password",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "1427-1443",
    "snippet": "void\nssh_put_password(char *password)\n{\n\tint size;\n\tchar *padded;\n\n\tif (datafellows & SSH_BUG_PASSWORDPAD) {\n\t\tpacket_put_cstring(password);\n\t\treturn;\n\t}\n\tsize = ROUNDUP(strlen(password) + 1, 32);\n\tpadded = xcalloc(1, size);\n\tstrlcpy(padded, password, size);\n\tpacket_put_string(padded, size);\n\texplicit_bzero(padded, size);\n\tfree(padded);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "padded"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "padded",
            "size"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_put_string",
          "args": [
            "padded",
            "size"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "padded",
            "password",
            "size"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "size"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ROUNDUP",
          "args": [
            "strlen(password) + 1",
            "32"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "password"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "password"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_put_password(char *password)\n{\n\tint size;\n\tchar *padded;\n\n\tif (datafellows & SSH_BUG_PASSWORDPAD) {\n\t\tpacket_put_cstring(password);\n\t\treturn;\n\t}\n\tsize = ROUNDUP(strlen(password) + 1, 32);\n\tpadded = xcalloc(1, size);\n\tstrlcpy(padded, password, size);\n\tpacket_put_string(padded, size);\n\texplicit_bzero(padded, size);\n\tfree(padded);\n}"
  },
  {
    "function_name": "ssh_login",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "1399-1425",
    "snippet": "void\nssh_login(Sensitive *sensitive, const char *orighost,\n    struct sockaddr *hostaddr, u_short port, struct passwd *pw, int timeout_ms)\n{\n\tchar *host;\n\tchar *server_user, *local_user;\n\n\tlocal_user = xstrdup(pw->pw_name);\n\tserver_user = options.user ? options.user : local_user;\n\n\t/* Convert the user-supplied hostname into all lowercase. */\n\thost = xstrdup(orighost);\n\tlowercase(host);\n\n\t/* Exchange protocol version identification strings with the server. */\n\tssh_exchange_identification(timeout_ms);\n\n\t/* Put the connection into non-blocking mode. */\n\tpacket_set_nonblocking();\n\n\t/* key exchange */\n\t/* authenticate user */\n\tdebug(\"Authenticating to %s:%d as '%s'\", host, port, server_user);\n\tssh_kex2(host, hostaddr, port);\n\tssh_userauth2(local_user, server_user, host, sensitive);\n\tfree(local_user);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "local_user"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_userauth2",
          "args": [
            "local_user",
            "server_user",
            "host",
            "sensitive"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_userauth2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "367-416",
          "snippet": "void\nssh_userauth2(const char *local_user, const char *server_user, char *host,\n    Sensitive *sensitive)\n{\n\tstruct ssh *ssh = active_state;\n\tAuthctxt authctxt;\n\tint r;\n\n\tif (options.challenge_response_authentication)\n\t\toptions.kbd_interactive_authentication = 1;\n\tif (options.preferred_authentications == NULL)\n\t\toptions.preferred_authentications = authmethods_get();\n\n\t/* setup authentication context */\n\tmemset(&authctxt, 0, sizeof(authctxt));\n\tauthctxt.server_user = server_user;\n\tauthctxt.local_user = local_user;\n\tauthctxt.host = host;\n\tauthctxt.service = \"ssh-connection\";\t\t/* service name */\n\tauthctxt.success = 0;\n\tauthctxt.method = authmethod_lookup(\"none\");\n\tauthctxt.authlist = NULL;\n\tauthctxt.methoddata = NULL;\n\tauthctxt.sensitive = sensitive;\n\tauthctxt.active_ktype = authctxt.oktypes = authctxt.ktypes = NULL;\n\tauthctxt.info_req_seen = 0;\n\tauthctxt.agent_fd = -1;\n\tpubkey_prepare(&authctxt);\n\tif (authctxt.method == NULL)\n\t\tfatal(\"ssh_userauth2: internal error: cannot send userauth none request\");\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_SERVICE_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"ssh-userauth\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tssh->authctxt = &authctxt;\n\tssh_dispatch_init(ssh, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_ext_info);\n\tssh_dispatch_set(ssh, SSH2_MSG_SERVICE_ACCEPT, &input_userauth_service_accept);\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt.success);\t/* loop until success */\n\tssh->authctxt = NULL;\n\n\tpubkey_cleanup(&authctxt);\n\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);\n\n\tif (!authctxt.success)\n\t\tfatal(\"Authentication failed.\");\n\tdebug(\"Authentication succeeded (%s).\", authctxt.method->name);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);",
            "static Authmethod *authmethod_get(char *authlist);",
            "static Authmethod *authmethod_lookup(const char *name);",
            "static char *authmethods_get(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_get(char *authlist);\nstatic Authmethod *authmethod_lookup(const char *name);\nstatic char *authmethods_get(void);\n\nvoid\nssh_userauth2(const char *local_user, const char *server_user, char *host,\n    Sensitive *sensitive)\n{\n\tstruct ssh *ssh = active_state;\n\tAuthctxt authctxt;\n\tint r;\n\n\tif (options.challenge_response_authentication)\n\t\toptions.kbd_interactive_authentication = 1;\n\tif (options.preferred_authentications == NULL)\n\t\toptions.preferred_authentications = authmethods_get();\n\n\t/* setup authentication context */\n\tmemset(&authctxt, 0, sizeof(authctxt));\n\tauthctxt.server_user = server_user;\n\tauthctxt.local_user = local_user;\n\tauthctxt.host = host;\n\tauthctxt.service = \"ssh-connection\";\t\t/* service name */\n\tauthctxt.success = 0;\n\tauthctxt.method = authmethod_lookup(\"none\");\n\tauthctxt.authlist = NULL;\n\tauthctxt.methoddata = NULL;\n\tauthctxt.sensitive = sensitive;\n\tauthctxt.active_ktype = authctxt.oktypes = authctxt.ktypes = NULL;\n\tauthctxt.info_req_seen = 0;\n\tauthctxt.agent_fd = -1;\n\tpubkey_prepare(&authctxt);\n\tif (authctxt.method == NULL)\n\t\tfatal(\"ssh_userauth2: internal error: cannot send userauth none request\");\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_SERVICE_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"ssh-userauth\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tssh->authctxt = &authctxt;\n\tssh_dispatch_init(ssh, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_ext_info);\n\tssh_dispatch_set(ssh, SSH2_MSG_SERVICE_ACCEPT, &input_userauth_service_accept);\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt.success);\t/* loop until success */\n\tssh->authctxt = NULL;\n\n\tpubkey_cleanup(&authctxt);\n\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);\n\n\tif (!authctxt.success)\n\t\tfatal(\"Authentication failed.\");\n\tdebug(\"Authentication succeeded (%s).\", authctxt.method->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_kex2",
          "args": [
            "host",
            "hostaddr",
            "port"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_kex2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "157-241",
          "snippet": "void\nssh_kex2(char *host, struct sockaddr *hostaddr, u_short port)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *s, *all_key;\n\tstruct kex *kex;\n\tint r;\n\n\txxx_host = host;\n\txxx_hostaddr = hostaddr;\n\n\tif ((s = kex_names_cat(options.kex_algorithms, \"ext-info-c\")) == NULL)\n\t\tfatal(\"%s: kex_names_cat\", __func__);\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(s);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] =\n\t    compat_cipher_proposal(options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] =\n\t    compat_cipher_proposal(options.ciphers);\n\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = options.compression ?\n\t    \"zlib@openssh.com,zlib,none\" : \"none,zlib@openssh.com,zlib\";\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\tif (options.hostkeyalgorithms != NULL) {\n\t\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\t\tif (kex_assemble_names(&options.hostkeyalgorithms,\n\t\t    KEX_DEFAULT_PK_ALG, all_key) != 0)\n\t\t\tfatal(\"%s: kex_assemble_namelist\", __func__);\n\t\tfree(all_key);\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(options.hostkeyalgorithms);\n\t} else {\n\t\t/* Enforce default */\n\t\toptions.hostkeyalgorithms = xstrdup(KEX_DEFAULT_PK_ALG);\n\t\t/* Prefer algorithms that we already have keys for */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(\n\t\t    order_hostkeyalgs(host, hostaddr, port));\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tpacket_set_rekey_limits(options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\t/* start key exchange */\n\tif ((r = kex_setup(active_state, myproposal)) != 0)\n\t\tfatal(\"kex_setup: %s\", ssh_err(r));\n\tkex = active_state->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_client;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_client;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_client;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\tkex->kex[KEX_ECDH_SHA2] = kexecdh_client;\n# endif\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kexc25519_client;\n\tkex->client_version_string=client_version_string;\n\tkex->server_version_string=server_version_string;\n\tkex->verify_host_key=&verify_host_key_callback;\n\n\tssh_dispatch_run_fatal(active_state, DISPATCH_BLOCK, &kex->done);\n\n\t/* remove ext-info from the KEX proposals for rekeying */\n\tmyproposal[PROPOSAL_KEX_ALGS] =\n\t    compat_kex_proposal(options.kex_algorithms);\n\tif ((r = kex_prop2buf(kex->my, myproposal)) != 0)\n\t\tfatal(\"kex_prop2buf: %s\", ssh_err(r));\n\n\tsession_id2 = kex->session_id;\n\tsession_id2_len = kex->session_id_len;\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"markus\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n#endif\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *client_version_string;",
            "extern char *server_version_string;",
            "extern Options options;",
            "u_char *session_id2 = NULL;",
            "u_int session_id2_len = 0;",
            "char *xxx_host;",
            "struct sockaddr *xxx_hostaddr;",
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *client_version_string;\nextern char *server_version_string;\nextern Options options;\nu_char *session_id2 = NULL;\nu_int session_id2_len = 0;\nchar *xxx_host;\nstruct sockaddr *xxx_hostaddr;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nvoid\nssh_kex2(char *host, struct sockaddr *hostaddr, u_short port)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *s, *all_key;\n\tstruct kex *kex;\n\tint r;\n\n\txxx_host = host;\n\txxx_hostaddr = hostaddr;\n\n\tif ((s = kex_names_cat(options.kex_algorithms, \"ext-info-c\")) == NULL)\n\t\tfatal(\"%s: kex_names_cat\", __func__);\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(s);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] =\n\t    compat_cipher_proposal(options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] =\n\t    compat_cipher_proposal(options.ciphers);\n\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = options.compression ?\n\t    \"zlib@openssh.com,zlib,none\" : \"none,zlib@openssh.com,zlib\";\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\tif (options.hostkeyalgorithms != NULL) {\n\t\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\t\tif (kex_assemble_names(&options.hostkeyalgorithms,\n\t\t    KEX_DEFAULT_PK_ALG, all_key) != 0)\n\t\t\tfatal(\"%s: kex_assemble_namelist\", __func__);\n\t\tfree(all_key);\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(options.hostkeyalgorithms);\n\t} else {\n\t\t/* Enforce default */\n\t\toptions.hostkeyalgorithms = xstrdup(KEX_DEFAULT_PK_ALG);\n\t\t/* Prefer algorithms that we already have keys for */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(\n\t\t    order_hostkeyalgs(host, hostaddr, port));\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tpacket_set_rekey_limits(options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\t/* start key exchange */\n\tif ((r = kex_setup(active_state, myproposal)) != 0)\n\t\tfatal(\"kex_setup: %s\", ssh_err(r));\n\tkex = active_state->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_client;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_client;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_client;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\tkex->kex[KEX_ECDH_SHA2] = kexecdh_client;\n# endif\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kexc25519_client;\n\tkex->client_version_string=client_version_string;\n\tkex->server_version_string=server_version_string;\n\tkex->verify_host_key=&verify_host_key_callback;\n\n\tssh_dispatch_run_fatal(active_state, DISPATCH_BLOCK, &kex->done);\n\n\t/* remove ext-info from the KEX proposals for rekeying */\n\tmyproposal[PROPOSAL_KEX_ALGS] =\n\t    compat_kex_proposal(options.kex_algorithms);\n\tif ((r = kex_prop2buf(kex->my, myproposal)) != 0)\n\t\tfatal(\"kex_prop2buf: %s\", ssh_err(r));\n\n\tsession_id2 = kex->session_id;\n\tsession_id2_len = kex->session_id_len;\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"markus\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Authenticating to %s:%d as '%s'\"",
            "host",
            "port",
            "server_user"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_set_nonblocking",
          "args": [],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_exchange_identification",
          "args": [
            "timeout_ms"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_exchange_identification",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "620-705",
          "snippet": "void\nssh_exchange_identification(int timeout_ms)\n{\n\tchar buf[256], remote_version[256];\t/* must be same size! */\n\tint remote_major, remote_minor, mismatch;\n\tint connection_in = packet_get_connection_in();\n\tint connection_out = packet_get_connection_out();\n\tu_int i, n;\n\tsize_t len;\n\tint rc;\n\n\tsend_client_banner(connection_out, 0);\n\n\t/* Read other side's version identification. */\n\tfor (n = 0;;) {\n\t\tfor (i = 0; i < sizeof(buf) - 1; i++) {\n\t\t\tif (timeout_ms > 0) {\n\t\t\t\trc = waitrfd(connection_in, &timeout_ms);\n\t\t\t\tif (rc == -1 && errno == ETIMEDOUT) {\n\t\t\t\t\tfatal(\"Connection timed out during \"\n\t\t\t\t\t    \"banner exchange\");\n\t\t\t\t} else if (rc == -1) {\n\t\t\t\t\tfatal(\"%s: %s\",\n\t\t\t\t\t    __func__, strerror(errno));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlen = atomicio(read, connection_in, &buf[i], 1);\n\t\t\tif (len != 1 && errno == EPIPE)\n\t\t\t\tfatal(\"ssh_exchange_identification: \"\n\t\t\t\t    \"Connection closed by remote host\");\n\t\t\telse if (len != 1)\n\t\t\t\tfatal(\"ssh_exchange_identification: \"\n\t\t\t\t    \"read: %.100s\", strerror(errno));\n\t\t\tif (buf[i] == '\\r') {\n\t\t\t\tbuf[i] = '\\n';\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tcontinue;\t\t/**XXX wait for \\n */\n\t\t\t}\n\t\t\tif (buf[i] == '\\n') {\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++n > 65536)\n\t\t\t\tfatal(\"ssh_exchange_identification: \"\n\t\t\t\t    \"No banner received\");\n\t\t}\n\t\tbuf[sizeof(buf) - 1] = 0;\n\t\tif (strncmp(buf, \"SSH-\", 4) == 0)\n\t\t\tbreak;\n\t\tdebug(\"ssh_exchange_identification: %s\", buf);\n\t}\n\tserver_version_string = xstrdup(buf);\n\n\t/*\n\t * Check that the versions match.  In future this might accept\n\t * several versions and set appropriate flags to handle them.\n\t */\n\tif (sscanf(server_version_string, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3)\n\t\tfatal(\"Bad remote protocol version identification: '%.100s'\", buf);\n\tdebug(\"Remote protocol version %d.%d, remote software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\n\tactive_state->compat = compat_datafellows(remote_version);\n\tmismatch = 0;\n\n\tswitch (remote_major) {\n\tcase 2:\n\t\tbreak;\n\tcase 1:\n\t\tif (remote_minor != 99)\n\t\t\tmismatch = 1;\n\t\tbreak;\n\tdefault:\n\t\tmismatch = 1;\n\t\tbreak;\n\t}\n\tif (mismatch)\n\t\tfatal(\"Protocol major versions differ: %d vs. %d\",\n\t\t    PROTOCOL_MAJOR_2, remote_major);\n\tif ((datafellows & SSH_BUG_RSASIGMD5) != 0)\n\t\tlogit(\"Server version \\\"%.100s\\\" uses unsafe RSA signature \"\n\t\t    \"scheme; disabling use of RSA keys\", remote_version);\n\tchop(server_version_string);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *server_version_string = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *server_version_string = NULL;\n\nvoid\nssh_exchange_identification(int timeout_ms)\n{\n\tchar buf[256], remote_version[256];\t/* must be same size! */\n\tint remote_major, remote_minor, mismatch;\n\tint connection_in = packet_get_connection_in();\n\tint connection_out = packet_get_connection_out();\n\tu_int i, n;\n\tsize_t len;\n\tint rc;\n\n\tsend_client_banner(connection_out, 0);\n\n\t/* Read other side's version identification. */\n\tfor (n = 0;;) {\n\t\tfor (i = 0; i < sizeof(buf) - 1; i++) {\n\t\t\tif (timeout_ms > 0) {\n\t\t\t\trc = waitrfd(connection_in, &timeout_ms);\n\t\t\t\tif (rc == -1 && errno == ETIMEDOUT) {\n\t\t\t\t\tfatal(\"Connection timed out during \"\n\t\t\t\t\t    \"banner exchange\");\n\t\t\t\t} else if (rc == -1) {\n\t\t\t\t\tfatal(\"%s: %s\",\n\t\t\t\t\t    __func__, strerror(errno));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlen = atomicio(read, connection_in, &buf[i], 1);\n\t\t\tif (len != 1 && errno == EPIPE)\n\t\t\t\tfatal(\"ssh_exchange_identification: \"\n\t\t\t\t    \"Connection closed by remote host\");\n\t\t\telse if (len != 1)\n\t\t\t\tfatal(\"ssh_exchange_identification: \"\n\t\t\t\t    \"read: %.100s\", strerror(errno));\n\t\t\tif (buf[i] == '\\r') {\n\t\t\t\tbuf[i] = '\\n';\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tcontinue;\t\t/**XXX wait for \\n */\n\t\t\t}\n\t\t\tif (buf[i] == '\\n') {\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++n > 65536)\n\t\t\t\tfatal(\"ssh_exchange_identification: \"\n\t\t\t\t    \"No banner received\");\n\t\t}\n\t\tbuf[sizeof(buf) - 1] = 0;\n\t\tif (strncmp(buf, \"SSH-\", 4) == 0)\n\t\t\tbreak;\n\t\tdebug(\"ssh_exchange_identification: %s\", buf);\n\t}\n\tserver_version_string = xstrdup(buf);\n\n\t/*\n\t * Check that the versions match.  In future this might accept\n\t * several versions and set appropriate flags to handle them.\n\t */\n\tif (sscanf(server_version_string, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3)\n\t\tfatal(\"Bad remote protocol version identification: '%.100s'\", buf);\n\tdebug(\"Remote protocol version %d.%d, remote software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\n\tactive_state->compat = compat_datafellows(remote_version);\n\tmismatch = 0;\n\n\tswitch (remote_major) {\n\tcase 2:\n\t\tbreak;\n\tcase 1:\n\t\tif (remote_minor != 99)\n\t\t\tmismatch = 1;\n\t\tbreak;\n\tdefault:\n\t\tmismatch = 1;\n\t\tbreak;\n\t}\n\tif (mismatch)\n\t\tfatal(\"Protocol major versions differ: %d vs. %d\",\n\t\t    PROTOCOL_MAJOR_2, remote_major);\n\tif ((datafellows & SSH_BUG_RSASIGMD5) != 0)\n\t\tlogit(\"Server version \\\"%.100s\\\" uses unsafe RSA signature \"\n\t\t    \"scheme; disabling use of RSA keys\", remote_version);\n\tchop(server_version_string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lowercase",
          "args": [
            "host"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "lowercase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1480-1485",
          "snippet": "void\nlowercase(char *s)\n{\n\tfor (; *s; s++)\n\t\t*s = tolower((u_char)*s);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlowercase(char *s)\n{\n\tfor (; *s; s++)\n\t\t*s = tolower((u_char)*s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "orighost"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nvoid\nssh_login(Sensitive *sensitive, const char *orighost,\n    struct sockaddr *hostaddr, u_short port, struct passwd *pw, int timeout_ms)\n{\n\tchar *host;\n\tchar *server_user, *local_user;\n\n\tlocal_user = xstrdup(pw->pw_name);\n\tserver_user = options.user ? options.user : local_user;\n\n\t/* Convert the user-supplied hostname into all lowercase. */\n\thost = xstrdup(orighost);\n\tlowercase(host);\n\n\t/* Exchange protocol version identification strings with the server. */\n\tssh_exchange_identification(timeout_ms);\n\n\t/* Put the connection into non-blocking mode. */\n\tpacket_set_nonblocking();\n\n\t/* key exchange */\n\t/* authenticate user */\n\tdebug(\"Authenticating to %s:%d as '%s'\", host, port, server_user);\n\tssh_kex2(host, hostaddr, port);\n\tssh_userauth2(local_user, server_user, host, sensitive);\n\tfree(local_user);\n}"
  },
  {
    "function_name": "verify_host_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "1280-1390",
    "snippet": "int\nverify_host_key(char *host, struct sockaddr *hostaddr, struct sshkey *host_key)\n{\n\tu_int i;\n\tint r = -1, flags = 0;\n\tchar valid[64], *fp = NULL, *cafp = NULL;\n\tstruct sshkey *plain = NULL;\n\n\tif ((fp = sshkey_fingerprint(host_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: fingerprint host key: %s\", __func__, ssh_err(r));\n\t\tr = -1;\n\t\tgoto out;\n\t}\n\n\tif (sshkey_is_cert(host_key)) {\n\t\tif ((cafp = sshkey_fingerprint(host_key->cert->signature_key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\t\terror(\"%s: fingerprint CA key: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tsshkey_format_cert_validity(host_key->cert,\n\t\t    valid, sizeof(valid));\n\t\tdebug(\"Server host certificate: %s %s, serial %llu \"\n\t\t    \"ID \\\"%s\\\" CA %s %s valid %s\",\n\t\t    sshkey_ssh_name(host_key), fp,\n\t\t    (unsigned long long)host_key->cert->serial,\n\t\t    host_key->cert->key_id,\n\t\t    sshkey_ssh_name(host_key->cert->signature_key), cafp,\n\t\t    valid);\n\t\tfor (i = 0; i < host_key->cert->nprincipals; i++) {\n\t\t\tdebug2(\"Server host certificate hostname: %s\",\n\t\t\t    host_key->cert->principals[i]);\n\t\t}\n\t} else {\n\t\tdebug(\"Server host key: %s %s\", sshkey_ssh_name(host_key), fp);\n\t}\n\n\tif (sshkey_equal(previous_host_key, host_key)) {\n\t\tdebug2(\"%s: server host key %s %s matches cached key\",\n\t\t    __func__, sshkey_type(host_key), fp);\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\n\t/* Check in RevokedHostKeys file if specified */\n\tif (options.revoked_host_keys != NULL) {\n\t\tr = sshkey_check_revoked(host_key, options.revoked_host_keys);\n\t\tswitch (r) {\n\t\tcase 0:\n\t\t\tbreak; /* not revoked */\n\t\tcase SSH_ERR_KEY_REVOKED:\n\t\t\terror(\"Host key %s %s revoked by file %s\",\n\t\t\t    sshkey_type(host_key), fp,\n\t\t\t    options.revoked_host_keys);\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terror(\"Error checking host key %s %s in \"\n\t\t\t    \"revoked keys file %s: %s\", sshkey_type(host_key),\n\t\t\t    fp, options.revoked_host_keys, ssh_err(r));\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (options.verify_host_key_dns) {\n\t\t/*\n\t\t * XXX certs are not yet supported for DNS, so downgrade\n\t\t * them and try the plain key.\n\t\t */\n\t\tif ((r = sshkey_from_private(host_key, &plain)) != 0)\n\t\t\tgoto out;\n\t\tif (sshkey_is_cert(plain))\n\t\t\tsshkey_drop_cert(plain);\n\t\tif (verify_host_key_dns(host, hostaddr, plain, &flags) == 0) {\n\t\t\tif (flags & DNS_VERIFY_FOUND) {\n\t\t\t\tif (options.verify_host_key_dns == 1 &&\n\t\t\t\t    flags & DNS_VERIFY_MATCH &&\n\t\t\t\t    flags & DNS_VERIFY_SECURE) {\n\t\t\t\t\tr = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (flags & DNS_VERIFY_MATCH) {\n\t\t\t\t\tmatching_host_key_dns = 1;\n\t\t\t\t} else {\n\t\t\t\t\twarn_changed_key(plain);\n\t\t\t\t\terror(\"Update the SSHFP RR in DNS \"\n\t\t\t\t\t    \"with the new host key to get rid \"\n\t\t\t\t\t    \"of this message.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tr = check_host_key(host, hostaddr, options.port, host_key, RDRW,\n\t    options.user_hostfiles, options.num_user_hostfiles,\n\t    options.system_hostfiles, options.num_system_hostfiles);\n\nout:\n\tsshkey_free(plain);\n\tfree(fp);\n\tfree(cafp);\n\tif (r == 0 && host_key != NULL) {\n\t\tsshkey_free(previous_host_key);\n\t\tr = sshkey_from_private(host_key, &previous_host_key);\n\t}\n\n\treturn r;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define RDRW\t0"
    ],
    "globals_used": [
      "struct sshkey *previous_host_key = NULL;",
      "static int matching_host_key_dns = 0;",
      "extern Options options;",
      "static int show_other_keys(struct hostkeys *, struct sshkey *);",
      "static void warn_changed_key(struct sshkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "host_key",
            "&previous_host_key"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "previous_host_key"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cafp"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_host_key",
          "args": [
            "host",
            "hostaddr",
            "options.port",
            "host_key",
            "RDRW",
            "options.user_hostfiles",
            "options.num_user_hostfiles",
            "options.system_hostfiles",
            "options.num_system_hostfiles"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "check_host_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "838-1277",
          "snippet": "static int\ncheck_host_key(char *hostname, struct sockaddr *hostaddr, u_short port,\n    struct sshkey *host_key, int readonly,\n    char **user_hostfiles, u_int num_user_hostfiles,\n    char **system_hostfiles, u_int num_system_hostfiles)\n{\n\tHostStatus host_status;\n\tHostStatus ip_status;\n\tstruct sshkey *raw_key = NULL;\n\tchar *ip = NULL, *host = NULL;\n\tchar hostline[1000], *hostp, *fp, *ra;\n\tchar msg[1024];\n\tconst char *type;\n\tconst struct hostkey_entry *host_found, *ip_found;\n\tint len, cancelled_forwarding = 0;\n\tint local = sockaddr_is_local(hostaddr);\n\tint r, want_cert = sshkey_is_cert(host_key), host_ip_differ = 0;\n\tint hostkey_trusted = 0; /* Known or explicitly accepted by user */\n\tstruct hostkeys *host_hostkeys, *ip_hostkeys;\n\tu_int i;\n\n\t/*\n\t * Force accepting of the host key for loopback/localhost. The\n\t * problem is that if the home directory is NFS-mounted to multiple\n\t * machines, localhost will refer to a different machine in each of\n\t * them, and the user will get bogus HOST_CHANGED warnings.  This\n\t * essentially disables host authentication for localhost; however,\n\t * this is probably not a real problem.\n\t */\n\tif (options.no_host_authentication_for_localhost == 1 && local &&\n\t    options.host_key_alias == NULL) {\n\t\tdebug(\"Forcing accepting of host key for \"\n\t\t    \"loopback/localhost.\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Prepare the hostname and address strings used for hostkey lookup.\n\t * In some cases, these will have a port number appended.\n\t */\n\tget_hostfile_hostname_ipaddr(hostname, hostaddr, port, &host, &ip);\n\n\t/*\n\t * Turn off check_host_ip if the connection is to localhost, via proxy\n\t * command or if we don't have a hostname to compare with\n\t */\n\tif (options.check_host_ip && (local ||\n\t    strcmp(hostname, ip) == 0 || options.proxy_command != NULL))\n\t\toptions.check_host_ip = 0;\n\n\thost_hostkeys = init_hostkeys();\n\tfor (i = 0; i < num_user_hostfiles; i++)\n\t\tload_hostkeys(host_hostkeys, host, user_hostfiles[i]);\n\tfor (i = 0; i < num_system_hostfiles; i++)\n\t\tload_hostkeys(host_hostkeys, host, system_hostfiles[i]);\n\n\tip_hostkeys = NULL;\n\tif (!want_cert && options.check_host_ip) {\n\t\tip_hostkeys = init_hostkeys();\n\t\tfor (i = 0; i < num_user_hostfiles; i++)\n\t\t\tload_hostkeys(ip_hostkeys, ip, user_hostfiles[i]);\n\t\tfor (i = 0; i < num_system_hostfiles; i++)\n\t\t\tload_hostkeys(ip_hostkeys, ip, system_hostfiles[i]);\n\t}\n\n retry:\n\t/* Reload these as they may have changed on cert->key downgrade */\n\twant_cert = sshkey_is_cert(host_key);\n\ttype = sshkey_type(host_key);\n\n\t/*\n\t * Check if the host key is present in the user's list of known\n\t * hosts or in the systemwide list.\n\t */\n\thost_status = check_key_in_hostkeys(host_hostkeys, host_key,\n\t    &host_found);\n\n\t/*\n\t * Also perform check for the ip address, skip the check if we are\n\t * localhost, looking for a certificate, or the hostname was an ip\n\t * address to begin with.\n\t */\n\tif (!want_cert && ip_hostkeys != NULL) {\n\t\tip_status = check_key_in_hostkeys(ip_hostkeys, host_key,\n\t\t    &ip_found);\n\t\tif (host_status == HOST_CHANGED &&\n\t\t    (ip_status != HOST_CHANGED || \n\t\t    (ip_found != NULL &&\n\t\t    !sshkey_equal(ip_found->key, host_found->key))))\n\t\t\thost_ip_differ = 1;\n\t} else\n\t\tip_status = host_status;\n\n\tswitch (host_status) {\n\tcase HOST_OK:\n\t\t/* The host is known and the key matches. */\n\t\tdebug(\"Host '%.200s' is known and matches the %s host %s.\",\n\t\t    host, type, want_cert ? \"certificate\" : \"key\");\n\t\tdebug(\"Found %s in %s:%lu\", want_cert ? \"CA key\" : \"key\",\n\t\t    host_found->file, host_found->line);\n\t\tif (want_cert &&\n\t\t    !check_host_cert(options.host_key_alias == NULL ?\n\t\t    hostname : options.host_key_alias, host_key))\n\t\t\tgoto fail;\n\t\tif (options.check_host_ip && ip_status == HOST_NEW) {\n\t\t\tif (readonly || want_cert)\n\t\t\t\tlogit(\"%s host key for IP address \"\n\t\t\t\t    \"'%.128s' not in list of known hosts.\",\n\t\t\t\t    type, ip);\n\t\t\telse if (!add_host_to_hostfile(user_hostfiles[0], ip,\n\t\t\t    host_key, options.hash_known_hosts))\n\t\t\t\tlogit(\"Failed to add the %s host key for IP \"\n\t\t\t\t    \"address '%.128s' to the list of known \"\n\t\t\t\t    \"hosts (%.500s).\", type, ip,\n\t\t\t\t    user_hostfiles[0]);\n\t\t\telse\n\t\t\t\tlogit(\"Warning: Permanently added the %s host \"\n\t\t\t\t    \"key for IP address '%.128s' to the list \"\n\t\t\t\t    \"of known hosts.\", type, ip);\n\t\t} else if (options.visual_host_key) {\n\t\t\tfp = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tra = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tlogit(\"Host key fingerprint is %s\\n%s\", fp, ra);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t}\n\t\thostkey_trusted = 1;\n\t\tbreak;\n\tcase HOST_NEW:\n\t\tif (options.host_key_alias == NULL && port != 0 &&\n\t\t    port != SSH_DEFAULT_PORT) {\n\t\t\tdebug(\"checking without port identifier\");\n\t\t\tif (check_host_key(hostname, hostaddr, 0, host_key,\n\t\t\t    ROQUIET, user_hostfiles, num_user_hostfiles,\n\t\t\t    system_hostfiles, num_system_hostfiles) == 0) {\n\t\t\t\tdebug(\"found matching key w/out port\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (readonly || want_cert)\n\t\t\tgoto fail;\n\t\t/* The host is new. */\n\t\tif (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_YES) {\n\t\t\t/*\n\t\t\t * User has requested strict host key checking.  We\n\t\t\t * will not add the host key automatically.  The only\n\t\t\t * alternative left is to abort.\n\t\t\t */\n\t\t\terror(\"No %s host key is known for %.200s and you \"\n\t\t\t    \"have requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t} else if (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_ASK) {\n\t\t\tchar msg1[1024], msg2[1024];\n\n\t\t\tif (show_other_keys(host_hostkeys, host_key))\n\t\t\t\tsnprintf(msg1, sizeof(msg1),\n\t\t\t\t    \"\\nbut keys of different type are already\"\n\t\t\t\t    \" known for this host.\");\n\t\t\telse\n\t\t\t\tsnprintf(msg1, sizeof(msg1), \".\");\n\t\t\t/* The default */\n\t\t\tfp = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tra = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tmsg2[0] = '\\0';\n\t\t\tif (options.verify_host_key_dns) {\n\t\t\t\tif (matching_host_key_dns)\n\t\t\t\t\tsnprintf(msg2, sizeof(msg2),\n\t\t\t\t\t    \"Matching host key fingerprint\"\n\t\t\t\t\t    \" found in DNS.\\n\");\n\t\t\t\telse\n\t\t\t\t\tsnprintf(msg2, sizeof(msg2),\n\t\t\t\t\t    \"No matching host key fingerprint\"\n\t\t\t\t\t    \" found in DNS.\\n\");\n\t\t\t}\n\t\t\tsnprintf(msg, sizeof(msg),\n\t\t\t    \"The authenticity of host '%.200s (%s)' can't be \"\n\t\t\t    \"established%s\\n\"\n\t\t\t    \"%s key fingerprint is %s.%s%s\\n%s\"\n\t\t\t    \"Are you sure you want to continue connecting \"\n\t\t\t    \"(yes/no)? \",\n\t\t\t    host, ip, msg1, type, fp,\n\t\t\t    options.visual_host_key ? \"\\n\" : \"\",\n\t\t\t    options.visual_host_key ? ra : \"\",\n\t\t\t    msg2);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t\tif (!confirm(msg))\n\t\t\t\tgoto fail;\n\t\t\thostkey_trusted = 1; /* user explicitly confirmed */\n\t\t}\n\t\t/*\n\t\t * If in \"new\" or \"off\" strict mode, add the key automatically\n\t\t * to the local known_hosts file.\n\t\t */\n\t\tif (options.check_host_ip && ip_status == HOST_NEW) {\n\t\t\tsnprintf(hostline, sizeof(hostline), \"%s,%s\", host, ip);\n\t\t\thostp = hostline;\n\t\t\tif (options.hash_known_hosts) {\n\t\t\t\t/* Add hash of host and IP separately */\n\t\t\t\tr = add_host_to_hostfile(user_hostfiles[0],\n\t\t\t\t    host, host_key, options.hash_known_hosts) &&\n\t\t\t\t    add_host_to_hostfile(user_hostfiles[0], ip,\n\t\t\t\t    host_key, options.hash_known_hosts);\n\t\t\t} else {\n\t\t\t\t/* Add unhashed \"host,ip\" */\n\t\t\t\tr = add_host_to_hostfile(user_hostfiles[0],\n\t\t\t\t    hostline, host_key,\n\t\t\t\t    options.hash_known_hosts);\n\t\t\t}\n\t\t} else {\n\t\t\tr = add_host_to_hostfile(user_hostfiles[0], host,\n\t\t\t    host_key, options.hash_known_hosts);\n\t\t\thostp = host;\n\t\t}\n\n\t\tif (!r)\n\t\t\tlogit(\"Failed to add the host to the list of known \"\n\t\t\t    \"hosts (%.500s).\", user_hostfiles[0]);\n\t\telse\n\t\t\tlogit(\"Warning: Permanently added '%.200s' (%s) to the \"\n\t\t\t    \"list of known hosts.\", hostp, type);\n\t\tbreak;\n\tcase HOST_REVOKED:\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"@       WARNING: REVOKED HOST KEY DETECTED!               @\");\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"The %s host key for %s is marked as revoked.\", type, host);\n\t\terror(\"This could mean that a stolen key is being used to\");\n\t\terror(\"impersonate this host.\");\n\n\t\t/*\n\t\t * If strict host key checking is in use, the user will have\n\t\t * to edit the key manually and we can only abort.\n\t\t */\n\t\tif (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\terror(\"%s host key for %.200s was revoked and you have \"\n\t\t\t    \"requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t}\n\t\tgoto continue_unsafe;\n\n\tcase HOST_CHANGED:\n\t\tif (want_cert) {\n\t\t\t/*\n\t\t\t * This is only a debug() since it is valid to have\n\t\t\t * CAs with wildcard DNS matches that don't match\n\t\t\t * all hosts that one might visit.\n\t\t\t */\n\t\t\tdebug(\"Host certificate authority does not \"\n\t\t\t    \"match %s in %s:%lu\", CA_MARKER,\n\t\t\t    host_found->file, host_found->line);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (readonly == ROQUIET)\n\t\t\tgoto fail;\n\t\tif (options.check_host_ip && host_ip_differ) {\n\t\t\tchar *key_msg;\n\t\t\tif (ip_status == HOST_NEW)\n\t\t\t\tkey_msg = \"is unknown\";\n\t\t\telse if (ip_status == HOST_OK)\n\t\t\t\tkey_msg = \"is unchanged\";\n\t\t\telse\n\t\t\t\tkey_msg = \"has a different value\";\n\t\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\t\terror(\"@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @\");\n\t\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\t\terror(\"The %s host key for %s has changed,\", type, host);\n\t\t\terror(\"and the key for the corresponding IP address %s\", ip);\n\t\t\terror(\"%s. This could either mean that\", key_msg);\n\t\t\terror(\"DNS SPOOFING is happening or the IP address for the host\");\n\t\t\terror(\"and its host key have changed at the same time.\");\n\t\t\tif (ip_status != HOST_NEW)\n\t\t\t\terror(\"Offending key for IP in %s:%lu\",\n\t\t\t\t    ip_found->file, ip_found->line);\n\t\t}\n\t\t/* The host key has changed. */\n\t\twarn_changed_key(host_key);\n\t\terror(\"Add correct host key in %.100s to get rid of this message.\",\n\t\t    user_hostfiles[0]);\n\t\terror(\"Offending %s key in %s:%lu\",\n\t\t    sshkey_type(host_found->key),\n\t\t    host_found->file, host_found->line);\n\n\t\t/*\n\t\t * If strict host key checking is in use, the user will have\n\t\t * to edit the key manually and we can only abort.\n\t\t */\n\t\tif (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\terror(\"%s host key for %.200s has changed and you have \"\n\t\t\t    \"requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t}\n\n continue_unsafe:\n\t\t/*\n\t\t * If strict host key checking has not been requested, allow\n\t\t * the connection but without MITM-able authentication or\n\t\t * forwarding.\n\t\t */\n\t\tif (options.password_authentication) {\n\t\t\terror(\"Password authentication is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.password_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.kbd_interactive_authentication) {\n\t\t\terror(\"Keyboard-interactive authentication is disabled\"\n\t\t\t    \" to avoid man-in-the-middle attacks.\");\n\t\t\toptions.kbd_interactive_authentication = 0;\n\t\t\toptions.challenge_response_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.challenge_response_authentication) {\n\t\t\terror(\"Challenge/response authentication is disabled\"\n\t\t\t    \" to avoid man-in-the-middle attacks.\");\n\t\t\toptions.challenge_response_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.forward_agent) {\n\t\t\terror(\"Agent forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.forward_agent = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.forward_x11) {\n\t\t\terror(\"X11 forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.forward_x11 = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.num_local_forwards > 0 ||\n\t\t    options.num_remote_forwards > 0) {\n\t\t\terror(\"Port forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.num_local_forwards =\n\t\t\t    options.num_remote_forwards = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.tun_open != SSH_TUNMODE_NO) {\n\t\t\terror(\"Tunnel forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.tun_open = SSH_TUNMODE_NO;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.exit_on_forward_failure && cancelled_forwarding)\n\t\t\tfatal(\"Error: forwarding disabled due to host key \"\n\t\t\t    \"check failure\");\n\t\t\n\t\t/*\n\t\t * XXX Should permit the user to change to use the new id.\n\t\t * This could be done by converting the host key to an\n\t\t * identifying sentence, tell that the host identifies itself\n\t\t * by that sentence, and ask the user if he/she wishes to\n\t\t * accept the authentication.\n\t\t */\n\t\tbreak;\n\tcase HOST_FOUND:\n\t\tfatal(\"internal error\");\n\t\tbreak;\n\t}\n\n\tif (options.check_host_ip && host_status != HOST_CHANGED &&\n\t    ip_status == HOST_CHANGED) {\n\t\tsnprintf(msg, sizeof(msg),\n\t\t    \"Warning: the %s host key for '%.200s' \"\n\t\t    \"differs from the key for the IP address '%.128s'\"\n\t\t    \"\\nOffending key for IP in %s:%lu\",\n\t\t    type, host, ip, ip_found->file, ip_found->line);\n\t\tif (host_status == HOST_OK) {\n\t\t\tlen = strlen(msg);\n\t\t\tsnprintf(msg + len, sizeof(msg) - len,\n\t\t\t    \"\\nMatching host key in %s:%lu\",\n\t\t\t    host_found->file, host_found->line);\n\t\t}\n\t\tif (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_ASK) {\n\t\t\tstrlcat(msg, \"\\nAre you sure you want \"\n\t\t\t    \"to continue connecting (yes/no)? \", sizeof(msg));\n\t\t\tif (!confirm(msg))\n\t\t\t\tgoto fail;\n\t\t} else if (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\tlogit(\"%s\", msg);\n\t\t\terror(\"Exiting, you have requested strict checking.\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tlogit(\"%s\", msg);\n\t\t}\n\t}\n\n\tif (!hostkey_trusted && options.update_hostkeys) {\n\t\tdebug(\"%s: hostkey not known or explicitly trusted: \"\n\t\t    \"disabling UpdateHostkeys\", __func__);\n\t\toptions.update_hostkeys = 0;\n\t}\n\n\tfree(ip);\n\tfree(host);\n\tif (host_hostkeys != NULL)\n\t\tfree_hostkeys(host_hostkeys);\n\tif (ip_hostkeys != NULL)\n\t\tfree_hostkeys(ip_hostkeys);\n\treturn 0;\n\nfail:\n\tif (want_cert && host_status != HOST_REVOKED) {\n\t\t/*\n\t\t * No matching certificate. Downgrade cert to raw key and\n\t\t * search normally.\n\t\t */\n\t\tdebug(\"No matching CA found. Retry with plain key\");\n\t\tif ((r = sshkey_from_private(host_key, &raw_key)) != 0)\n\t\t\tfatal(\"%s: sshkey_from_private: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tif ((r = sshkey_drop_cert(raw_key)) != 0)\n\t\t\tfatal(\"Couldn't drop certificate: %s\", ssh_err(r));\n\t\thost_key = raw_key;\n\t\tgoto retry;\n\t}\n\tsshkey_free(raw_key);\n\tfree(ip);\n\tfree(host);\n\tif (host_hostkeys != NULL)\n\t\tfree_hostkeys(host_hostkeys);\n\tif (ip_hostkeys != NULL)\n\t\tfree_hostkeys(ip_hostkeys);\n\treturn -1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define ROQUIET\t2"
          ],
          "globals_used": [
            "static int matching_host_key_dns = 0;",
            "extern Options options;",
            "static int show_other_keys(struct hostkeys *, struct sshkey *);",
            "static void warn_changed_key(struct sshkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define ROQUIET\t2\n\nstatic int matching_host_key_dns = 0;\nextern Options options;\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\nstatic int\ncheck_host_key(char *hostname, struct sockaddr *hostaddr, u_short port,\n    struct sshkey *host_key, int readonly,\n    char **user_hostfiles, u_int num_user_hostfiles,\n    char **system_hostfiles, u_int num_system_hostfiles)\n{\n\tHostStatus host_status;\n\tHostStatus ip_status;\n\tstruct sshkey *raw_key = NULL;\n\tchar *ip = NULL, *host = NULL;\n\tchar hostline[1000], *hostp, *fp, *ra;\n\tchar msg[1024];\n\tconst char *type;\n\tconst struct hostkey_entry *host_found, *ip_found;\n\tint len, cancelled_forwarding = 0;\n\tint local = sockaddr_is_local(hostaddr);\n\tint r, want_cert = sshkey_is_cert(host_key), host_ip_differ = 0;\n\tint hostkey_trusted = 0; /* Known or explicitly accepted by user */\n\tstruct hostkeys *host_hostkeys, *ip_hostkeys;\n\tu_int i;\n\n\t/*\n\t * Force accepting of the host key for loopback/localhost. The\n\t * problem is that if the home directory is NFS-mounted to multiple\n\t * machines, localhost will refer to a different machine in each of\n\t * them, and the user will get bogus HOST_CHANGED warnings.  This\n\t * essentially disables host authentication for localhost; however,\n\t * this is probably not a real problem.\n\t */\n\tif (options.no_host_authentication_for_localhost == 1 && local &&\n\t    options.host_key_alias == NULL) {\n\t\tdebug(\"Forcing accepting of host key for \"\n\t\t    \"loopback/localhost.\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Prepare the hostname and address strings used for hostkey lookup.\n\t * In some cases, these will have a port number appended.\n\t */\n\tget_hostfile_hostname_ipaddr(hostname, hostaddr, port, &host, &ip);\n\n\t/*\n\t * Turn off check_host_ip if the connection is to localhost, via proxy\n\t * command or if we don't have a hostname to compare with\n\t */\n\tif (options.check_host_ip && (local ||\n\t    strcmp(hostname, ip) == 0 || options.proxy_command != NULL))\n\t\toptions.check_host_ip = 0;\n\n\thost_hostkeys = init_hostkeys();\n\tfor (i = 0; i < num_user_hostfiles; i++)\n\t\tload_hostkeys(host_hostkeys, host, user_hostfiles[i]);\n\tfor (i = 0; i < num_system_hostfiles; i++)\n\t\tload_hostkeys(host_hostkeys, host, system_hostfiles[i]);\n\n\tip_hostkeys = NULL;\n\tif (!want_cert && options.check_host_ip) {\n\t\tip_hostkeys = init_hostkeys();\n\t\tfor (i = 0; i < num_user_hostfiles; i++)\n\t\t\tload_hostkeys(ip_hostkeys, ip, user_hostfiles[i]);\n\t\tfor (i = 0; i < num_system_hostfiles; i++)\n\t\t\tload_hostkeys(ip_hostkeys, ip, system_hostfiles[i]);\n\t}\n\n retry:\n\t/* Reload these as they may have changed on cert->key downgrade */\n\twant_cert = sshkey_is_cert(host_key);\n\ttype = sshkey_type(host_key);\n\n\t/*\n\t * Check if the host key is present in the user's list of known\n\t * hosts or in the systemwide list.\n\t */\n\thost_status = check_key_in_hostkeys(host_hostkeys, host_key,\n\t    &host_found);\n\n\t/*\n\t * Also perform check for the ip address, skip the check if we are\n\t * localhost, looking for a certificate, or the hostname was an ip\n\t * address to begin with.\n\t */\n\tif (!want_cert && ip_hostkeys != NULL) {\n\t\tip_status = check_key_in_hostkeys(ip_hostkeys, host_key,\n\t\t    &ip_found);\n\t\tif (host_status == HOST_CHANGED &&\n\t\t    (ip_status != HOST_CHANGED || \n\t\t    (ip_found != NULL &&\n\t\t    !sshkey_equal(ip_found->key, host_found->key))))\n\t\t\thost_ip_differ = 1;\n\t} else\n\t\tip_status = host_status;\n\n\tswitch (host_status) {\n\tcase HOST_OK:\n\t\t/* The host is known and the key matches. */\n\t\tdebug(\"Host '%.200s' is known and matches the %s host %s.\",\n\t\t    host, type, want_cert ? \"certificate\" : \"key\");\n\t\tdebug(\"Found %s in %s:%lu\", want_cert ? \"CA key\" : \"key\",\n\t\t    host_found->file, host_found->line);\n\t\tif (want_cert &&\n\t\t    !check_host_cert(options.host_key_alias == NULL ?\n\t\t    hostname : options.host_key_alias, host_key))\n\t\t\tgoto fail;\n\t\tif (options.check_host_ip && ip_status == HOST_NEW) {\n\t\t\tif (readonly || want_cert)\n\t\t\t\tlogit(\"%s host key for IP address \"\n\t\t\t\t    \"'%.128s' not in list of known hosts.\",\n\t\t\t\t    type, ip);\n\t\t\telse if (!add_host_to_hostfile(user_hostfiles[0], ip,\n\t\t\t    host_key, options.hash_known_hosts))\n\t\t\t\tlogit(\"Failed to add the %s host key for IP \"\n\t\t\t\t    \"address '%.128s' to the list of known \"\n\t\t\t\t    \"hosts (%.500s).\", type, ip,\n\t\t\t\t    user_hostfiles[0]);\n\t\t\telse\n\t\t\t\tlogit(\"Warning: Permanently added the %s host \"\n\t\t\t\t    \"key for IP address '%.128s' to the list \"\n\t\t\t\t    \"of known hosts.\", type, ip);\n\t\t} else if (options.visual_host_key) {\n\t\t\tfp = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tra = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tlogit(\"Host key fingerprint is %s\\n%s\", fp, ra);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t}\n\t\thostkey_trusted = 1;\n\t\tbreak;\n\tcase HOST_NEW:\n\t\tif (options.host_key_alias == NULL && port != 0 &&\n\t\t    port != SSH_DEFAULT_PORT) {\n\t\t\tdebug(\"checking without port identifier\");\n\t\t\tif (check_host_key(hostname, hostaddr, 0, host_key,\n\t\t\t    ROQUIET, user_hostfiles, num_user_hostfiles,\n\t\t\t    system_hostfiles, num_system_hostfiles) == 0) {\n\t\t\t\tdebug(\"found matching key w/out port\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (readonly || want_cert)\n\t\t\tgoto fail;\n\t\t/* The host is new. */\n\t\tif (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_YES) {\n\t\t\t/*\n\t\t\t * User has requested strict host key checking.  We\n\t\t\t * will not add the host key automatically.  The only\n\t\t\t * alternative left is to abort.\n\t\t\t */\n\t\t\terror(\"No %s host key is known for %.200s and you \"\n\t\t\t    \"have requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t} else if (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_ASK) {\n\t\t\tchar msg1[1024], msg2[1024];\n\n\t\t\tif (show_other_keys(host_hostkeys, host_key))\n\t\t\t\tsnprintf(msg1, sizeof(msg1),\n\t\t\t\t    \"\\nbut keys of different type are already\"\n\t\t\t\t    \" known for this host.\");\n\t\t\telse\n\t\t\t\tsnprintf(msg1, sizeof(msg1), \".\");\n\t\t\t/* The default */\n\t\t\tfp = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tra = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tmsg2[0] = '\\0';\n\t\t\tif (options.verify_host_key_dns) {\n\t\t\t\tif (matching_host_key_dns)\n\t\t\t\t\tsnprintf(msg2, sizeof(msg2),\n\t\t\t\t\t    \"Matching host key fingerprint\"\n\t\t\t\t\t    \" found in DNS.\\n\");\n\t\t\t\telse\n\t\t\t\t\tsnprintf(msg2, sizeof(msg2),\n\t\t\t\t\t    \"No matching host key fingerprint\"\n\t\t\t\t\t    \" found in DNS.\\n\");\n\t\t\t}\n\t\t\tsnprintf(msg, sizeof(msg),\n\t\t\t    \"The authenticity of host '%.200s (%s)' can't be \"\n\t\t\t    \"established%s\\n\"\n\t\t\t    \"%s key fingerprint is %s.%s%s\\n%s\"\n\t\t\t    \"Are you sure you want to continue connecting \"\n\t\t\t    \"(yes/no)? \",\n\t\t\t    host, ip, msg1, type, fp,\n\t\t\t    options.visual_host_key ? \"\\n\" : \"\",\n\t\t\t    options.visual_host_key ? ra : \"\",\n\t\t\t    msg2);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t\tif (!confirm(msg))\n\t\t\t\tgoto fail;\n\t\t\thostkey_trusted = 1; /* user explicitly confirmed */\n\t\t}\n\t\t/*\n\t\t * If in \"new\" or \"off\" strict mode, add the key automatically\n\t\t * to the local known_hosts file.\n\t\t */\n\t\tif (options.check_host_ip && ip_status == HOST_NEW) {\n\t\t\tsnprintf(hostline, sizeof(hostline), \"%s,%s\", host, ip);\n\t\t\thostp = hostline;\n\t\t\tif (options.hash_known_hosts) {\n\t\t\t\t/* Add hash of host and IP separately */\n\t\t\t\tr = add_host_to_hostfile(user_hostfiles[0],\n\t\t\t\t    host, host_key, options.hash_known_hosts) &&\n\t\t\t\t    add_host_to_hostfile(user_hostfiles[0], ip,\n\t\t\t\t    host_key, options.hash_known_hosts);\n\t\t\t} else {\n\t\t\t\t/* Add unhashed \"host,ip\" */\n\t\t\t\tr = add_host_to_hostfile(user_hostfiles[0],\n\t\t\t\t    hostline, host_key,\n\t\t\t\t    options.hash_known_hosts);\n\t\t\t}\n\t\t} else {\n\t\t\tr = add_host_to_hostfile(user_hostfiles[0], host,\n\t\t\t    host_key, options.hash_known_hosts);\n\t\t\thostp = host;\n\t\t}\n\n\t\tif (!r)\n\t\t\tlogit(\"Failed to add the host to the list of known \"\n\t\t\t    \"hosts (%.500s).\", user_hostfiles[0]);\n\t\telse\n\t\t\tlogit(\"Warning: Permanently added '%.200s' (%s) to the \"\n\t\t\t    \"list of known hosts.\", hostp, type);\n\t\tbreak;\n\tcase HOST_REVOKED:\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"@       WARNING: REVOKED HOST KEY DETECTED!               @\");\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"The %s host key for %s is marked as revoked.\", type, host);\n\t\terror(\"This could mean that a stolen key is being used to\");\n\t\terror(\"impersonate this host.\");\n\n\t\t/*\n\t\t * If strict host key checking is in use, the user will have\n\t\t * to edit the key manually and we can only abort.\n\t\t */\n\t\tif (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\terror(\"%s host key for %.200s was revoked and you have \"\n\t\t\t    \"requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t}\n\t\tgoto continue_unsafe;\n\n\tcase HOST_CHANGED:\n\t\tif (want_cert) {\n\t\t\t/*\n\t\t\t * This is only a debug() since it is valid to have\n\t\t\t * CAs with wildcard DNS matches that don't match\n\t\t\t * all hosts that one might visit.\n\t\t\t */\n\t\t\tdebug(\"Host certificate authority does not \"\n\t\t\t    \"match %s in %s:%lu\", CA_MARKER,\n\t\t\t    host_found->file, host_found->line);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (readonly == ROQUIET)\n\t\t\tgoto fail;\n\t\tif (options.check_host_ip && host_ip_differ) {\n\t\t\tchar *key_msg;\n\t\t\tif (ip_status == HOST_NEW)\n\t\t\t\tkey_msg = \"is unknown\";\n\t\t\telse if (ip_status == HOST_OK)\n\t\t\t\tkey_msg = \"is unchanged\";\n\t\t\telse\n\t\t\t\tkey_msg = \"has a different value\";\n\t\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\t\terror(\"@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @\");\n\t\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\t\terror(\"The %s host key for %s has changed,\", type, host);\n\t\t\terror(\"and the key for the corresponding IP address %s\", ip);\n\t\t\terror(\"%s. This could either mean that\", key_msg);\n\t\t\terror(\"DNS SPOOFING is happening or the IP address for the host\");\n\t\t\terror(\"and its host key have changed at the same time.\");\n\t\t\tif (ip_status != HOST_NEW)\n\t\t\t\terror(\"Offending key for IP in %s:%lu\",\n\t\t\t\t    ip_found->file, ip_found->line);\n\t\t}\n\t\t/* The host key has changed. */\n\t\twarn_changed_key(host_key);\n\t\terror(\"Add correct host key in %.100s to get rid of this message.\",\n\t\t    user_hostfiles[0]);\n\t\terror(\"Offending %s key in %s:%lu\",\n\t\t    sshkey_type(host_found->key),\n\t\t    host_found->file, host_found->line);\n\n\t\t/*\n\t\t * If strict host key checking is in use, the user will have\n\t\t * to edit the key manually and we can only abort.\n\t\t */\n\t\tif (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\terror(\"%s host key for %.200s has changed and you have \"\n\t\t\t    \"requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t}\n\n continue_unsafe:\n\t\t/*\n\t\t * If strict host key checking has not been requested, allow\n\t\t * the connection but without MITM-able authentication or\n\t\t * forwarding.\n\t\t */\n\t\tif (options.password_authentication) {\n\t\t\terror(\"Password authentication is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.password_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.kbd_interactive_authentication) {\n\t\t\terror(\"Keyboard-interactive authentication is disabled\"\n\t\t\t    \" to avoid man-in-the-middle attacks.\");\n\t\t\toptions.kbd_interactive_authentication = 0;\n\t\t\toptions.challenge_response_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.challenge_response_authentication) {\n\t\t\terror(\"Challenge/response authentication is disabled\"\n\t\t\t    \" to avoid man-in-the-middle attacks.\");\n\t\t\toptions.challenge_response_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.forward_agent) {\n\t\t\terror(\"Agent forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.forward_agent = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.forward_x11) {\n\t\t\terror(\"X11 forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.forward_x11 = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.num_local_forwards > 0 ||\n\t\t    options.num_remote_forwards > 0) {\n\t\t\terror(\"Port forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.num_local_forwards =\n\t\t\t    options.num_remote_forwards = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.tun_open != SSH_TUNMODE_NO) {\n\t\t\terror(\"Tunnel forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.tun_open = SSH_TUNMODE_NO;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.exit_on_forward_failure && cancelled_forwarding)\n\t\t\tfatal(\"Error: forwarding disabled due to host key \"\n\t\t\t    \"check failure\");\n\t\t\n\t\t/*\n\t\t * XXX Should permit the user to change to use the new id.\n\t\t * This could be done by converting the host key to an\n\t\t * identifying sentence, tell that the host identifies itself\n\t\t * by that sentence, and ask the user if he/she wishes to\n\t\t * accept the authentication.\n\t\t */\n\t\tbreak;\n\tcase HOST_FOUND:\n\t\tfatal(\"internal error\");\n\t\tbreak;\n\t}\n\n\tif (options.check_host_ip && host_status != HOST_CHANGED &&\n\t    ip_status == HOST_CHANGED) {\n\t\tsnprintf(msg, sizeof(msg),\n\t\t    \"Warning: the %s host key for '%.200s' \"\n\t\t    \"differs from the key for the IP address '%.128s'\"\n\t\t    \"\\nOffending key for IP in %s:%lu\",\n\t\t    type, host, ip, ip_found->file, ip_found->line);\n\t\tif (host_status == HOST_OK) {\n\t\t\tlen = strlen(msg);\n\t\t\tsnprintf(msg + len, sizeof(msg) - len,\n\t\t\t    \"\\nMatching host key in %s:%lu\",\n\t\t\t    host_found->file, host_found->line);\n\t\t}\n\t\tif (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_ASK) {\n\t\t\tstrlcat(msg, \"\\nAre you sure you want \"\n\t\t\t    \"to continue connecting (yes/no)? \", sizeof(msg));\n\t\t\tif (!confirm(msg))\n\t\t\t\tgoto fail;\n\t\t} else if (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\tlogit(\"%s\", msg);\n\t\t\terror(\"Exiting, you have requested strict checking.\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tlogit(\"%s\", msg);\n\t\t}\n\t}\n\n\tif (!hostkey_trusted && options.update_hostkeys) {\n\t\tdebug(\"%s: hostkey not known or explicitly trusted: \"\n\t\t    \"disabling UpdateHostkeys\", __func__);\n\t\toptions.update_hostkeys = 0;\n\t}\n\n\tfree(ip);\n\tfree(host);\n\tif (host_hostkeys != NULL)\n\t\tfree_hostkeys(host_hostkeys);\n\tif (ip_hostkeys != NULL)\n\t\tfree_hostkeys(ip_hostkeys);\n\treturn 0;\n\nfail:\n\tif (want_cert && host_status != HOST_REVOKED) {\n\t\t/*\n\t\t * No matching certificate. Downgrade cert to raw key and\n\t\t * search normally.\n\t\t */\n\t\tdebug(\"No matching CA found. Retry with plain key\");\n\t\tif ((r = sshkey_from_private(host_key, &raw_key)) != 0)\n\t\t\tfatal(\"%s: sshkey_from_private: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tif ((r = sshkey_drop_cert(raw_key)) != 0)\n\t\t\tfatal(\"Couldn't drop certificate: %s\", ssh_err(r));\n\t\thost_key = raw_key;\n\t\tgoto retry;\n\t}\n\tsshkey_free(raw_key);\n\tfree(ip);\n\tfree(host);\n\tif (host_hostkeys != NULL)\n\t\tfree_hostkeys(host_hostkeys);\n\tif (ip_hostkeys != NULL)\n\t\tfree_hostkeys(ip_hostkeys);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Update the SSHFP RR in DNS \"\n\t\t\t\t\t    \"with the new host key to get rid \"\n\t\t\t\t\t    \"of this message.\""
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_changed_key",
          "args": [
            "plain"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "warn_changed_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "1487-1508",
          "snippet": "static void\nwarn_changed_key(struct sshkey *host_key)\n{\n\tchar *fp;\n\n\tfp = sshkey_fingerprint(host_key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT);\n\tif (fp == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\");\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\");\n\terror(\"Someone could be eavesdropping on you right now (man-in-the-middle attack)!\");\n\terror(\"It is also possible that a host key has just been changed.\");\n\terror(\"The fingerprint for the %s key sent by the remote host is\\n%s.\",\n\t    sshkey_type(host_key), fp);\n\terror(\"Please contact your system administrator.\");\n\n\tfree(fp);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static int show_other_keys(struct hostkeys *, struct sshkey *);",
            "static void warn_changed_key(struct sshkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\nstatic void\nwarn_changed_key(struct sshkey *host_key)\n{\n\tchar *fp;\n\n\tfp = sshkey_fingerprint(host_key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT);\n\tif (fp == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\");\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\");\n\terror(\"Someone could be eavesdropping on you right now (man-in-the-middle attack)!\");\n\terror(\"It is also possible that a host key has just been changed.\");\n\terror(\"The fingerprint for the %s key sent by the remote host is\\n%s.\",\n\t    sshkey_type(host_key), fp);\n\terror(\"Please contact your system administrator.\");\n\n\tfree(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_host_key_dns",
          "args": [
            "host",
            "hostaddr",
            "plain",
            "&flags"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "verify_host_key_dns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dns.c",
          "lines": "208-314",
          "snippet": "int\nverify_host_key_dns(const char *hostname, struct sockaddr *address,\n    struct sshkey *hostkey, int *flags)\n{\n\tu_int counter;\n\tint result;\n\tstruct rrsetinfo *fingerprints = NULL;\n\n\tu_int8_t hostkey_algorithm;\n\tu_int8_t hostkey_digest_type = SSHFP_HASH_RESERVED;\n\tu_char *hostkey_digest;\n\tsize_t hostkey_digest_len;\n\n\tu_int8_t dnskey_algorithm;\n\tu_int8_t dnskey_digest_type;\n\tu_char *dnskey_digest;\n\tsize_t dnskey_digest_len;\n\n\t*flags = 0;\n\n\tdebug3(\"verify_host_key_dns\");\n\tif (hostkey == NULL)\n\t\tfatal(\"No key to look up!\");\n\n\tif (is_numeric_hostname(hostname)) {\n\t\tdebug(\"skipped DNS lookup for numerical hostname\");\n\t\treturn -1;\n\t}\n\n\tresult = getrrsetbyname(hostname, DNS_RDATACLASS_IN,\n\t    DNS_RDATATYPE_SSHFP, 0, &fingerprints);\n\tif (result) {\n\t\tverbose(\"DNS lookup error: %s\", dns_result_totext(result));\n\t\treturn -1;\n\t}\n\n\tif (fingerprints->rri_flags & RRSET_VALIDATED) {\n\t\t*flags |= DNS_VERIFY_SECURE;\n\t\tdebug(\"found %d secure fingerprints in DNS\",\n\t\t    fingerprints->rri_nrdatas);\n\t} else {\n\t\tdebug(\"found %d insecure fingerprints in DNS\",\n\t\t    fingerprints->rri_nrdatas);\n\t}\n\n\t/* Initialize default host key parameters */\n\tif (!dns_read_key(&hostkey_algorithm, &hostkey_digest_type,\n\t    &hostkey_digest, &hostkey_digest_len, hostkey)) {\n\t\terror(\"Error calculating host key fingerprint.\");\n\t\tfreerrset(fingerprints);\n\t\treturn -1;\n\t}\n\n\tif (fingerprints->rri_nrdatas)\n\t\t*flags |= DNS_VERIFY_FOUND;\n\n\tfor (counter = 0; counter < fingerprints->rri_nrdatas; counter++) {\n\t\t/*\n\t\t * Extract the key from the answer. Ignore any badly\n\t\t * formatted fingerprints.\n\t\t */\n\t\tif (!dns_read_rdata(&dnskey_algorithm, &dnskey_digest_type,\n\t\t    &dnskey_digest, &dnskey_digest_len,\n\t\t    fingerprints->rri_rdatas[counter].rdi_data,\n\t\t    fingerprints->rri_rdatas[counter].rdi_length)) {\n\t\t\tverbose(\"Error parsing fingerprint from DNS.\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hostkey_digest_type != dnskey_digest_type) {\n\t\t\thostkey_digest_type = dnskey_digest_type;\n\t\t\tfree(hostkey_digest);\n\n\t\t\t/* Initialize host key parameters */\n\t\t\tif (!dns_read_key(&hostkey_algorithm,\n\t\t\t    &hostkey_digest_type, &hostkey_digest,\n\t\t\t    &hostkey_digest_len, hostkey)) {\n\t\t\t\terror(\"Error calculating key fingerprint.\");\n\t\t\t\tfreerrset(fingerprints);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/* Check if the current key is the same as the given key */\n\t\tif (hostkey_algorithm == dnskey_algorithm &&\n\t\t    hostkey_digest_type == dnskey_digest_type) {\n\t\t\tif (hostkey_digest_len == dnskey_digest_len &&\n\t\t\t    timingsafe_bcmp(hostkey_digest, dnskey_digest,\n\t\t\t    hostkey_digest_len) == 0)\n\t\t\t\t*flags |= DNS_VERIFY_MATCH;\n\t\t}\n\t\tfree(dnskey_digest);\n\t}\n\n\tfree(hostkey_digest); /* from sshkey_fingerprint_raw() */\n\tfreerrset(fingerprints);\n\n\tif (*flags & DNS_VERIFY_FOUND)\n\t\tif (*flags & DNS_VERIFY_MATCH)\n\t\t\tdebug(\"matching host key fingerprint found in DNS\");\n\t\telse\n\t\t\tdebug(\"mismatching host key fingerprint found in DNS\");\n\telse\n\t\tdebug(\"no host key fingerprint found in DNS\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"dns.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"log.h\"\n#include \"dns.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nverify_host_key_dns(const char *hostname, struct sockaddr *address,\n    struct sshkey *hostkey, int *flags)\n{\n\tu_int counter;\n\tint result;\n\tstruct rrsetinfo *fingerprints = NULL;\n\n\tu_int8_t hostkey_algorithm;\n\tu_int8_t hostkey_digest_type = SSHFP_HASH_RESERVED;\n\tu_char *hostkey_digest;\n\tsize_t hostkey_digest_len;\n\n\tu_int8_t dnskey_algorithm;\n\tu_int8_t dnskey_digest_type;\n\tu_char *dnskey_digest;\n\tsize_t dnskey_digest_len;\n\n\t*flags = 0;\n\n\tdebug3(\"verify_host_key_dns\");\n\tif (hostkey == NULL)\n\t\tfatal(\"No key to look up!\");\n\n\tif (is_numeric_hostname(hostname)) {\n\t\tdebug(\"skipped DNS lookup for numerical hostname\");\n\t\treturn -1;\n\t}\n\n\tresult = getrrsetbyname(hostname, DNS_RDATACLASS_IN,\n\t    DNS_RDATATYPE_SSHFP, 0, &fingerprints);\n\tif (result) {\n\t\tverbose(\"DNS lookup error: %s\", dns_result_totext(result));\n\t\treturn -1;\n\t}\n\n\tif (fingerprints->rri_flags & RRSET_VALIDATED) {\n\t\t*flags |= DNS_VERIFY_SECURE;\n\t\tdebug(\"found %d secure fingerprints in DNS\",\n\t\t    fingerprints->rri_nrdatas);\n\t} else {\n\t\tdebug(\"found %d insecure fingerprints in DNS\",\n\t\t    fingerprints->rri_nrdatas);\n\t}\n\n\t/* Initialize default host key parameters */\n\tif (!dns_read_key(&hostkey_algorithm, &hostkey_digest_type,\n\t    &hostkey_digest, &hostkey_digest_len, hostkey)) {\n\t\terror(\"Error calculating host key fingerprint.\");\n\t\tfreerrset(fingerprints);\n\t\treturn -1;\n\t}\n\n\tif (fingerprints->rri_nrdatas)\n\t\t*flags |= DNS_VERIFY_FOUND;\n\n\tfor (counter = 0; counter < fingerprints->rri_nrdatas; counter++) {\n\t\t/*\n\t\t * Extract the key from the answer. Ignore any badly\n\t\t * formatted fingerprints.\n\t\t */\n\t\tif (!dns_read_rdata(&dnskey_algorithm, &dnskey_digest_type,\n\t\t    &dnskey_digest, &dnskey_digest_len,\n\t\t    fingerprints->rri_rdatas[counter].rdi_data,\n\t\t    fingerprints->rri_rdatas[counter].rdi_length)) {\n\t\t\tverbose(\"Error parsing fingerprint from DNS.\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hostkey_digest_type != dnskey_digest_type) {\n\t\t\thostkey_digest_type = dnskey_digest_type;\n\t\t\tfree(hostkey_digest);\n\n\t\t\t/* Initialize host key parameters */\n\t\t\tif (!dns_read_key(&hostkey_algorithm,\n\t\t\t    &hostkey_digest_type, &hostkey_digest,\n\t\t\t    &hostkey_digest_len, hostkey)) {\n\t\t\t\terror(\"Error calculating key fingerprint.\");\n\t\t\t\tfreerrset(fingerprints);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/* Check if the current key is the same as the given key */\n\t\tif (hostkey_algorithm == dnskey_algorithm &&\n\t\t    hostkey_digest_type == dnskey_digest_type) {\n\t\t\tif (hostkey_digest_len == dnskey_digest_len &&\n\t\t\t    timingsafe_bcmp(hostkey_digest, dnskey_digest,\n\t\t\t    hostkey_digest_len) == 0)\n\t\t\t\t*flags |= DNS_VERIFY_MATCH;\n\t\t}\n\t\tfree(dnskey_digest);\n\t}\n\n\tfree(hostkey_digest); /* from sshkey_fingerprint_raw() */\n\tfreerrset(fingerprints);\n\n\tif (*flags & DNS_VERIFY_FOUND)\n\t\tif (*flags & DNS_VERIFY_MATCH)\n\t\t\tdebug(\"matching host key fingerprint found in DNS\");\n\t\telse\n\t\t\tdebug(\"mismatching host key fingerprint found in DNS\");\n\telse\n\t\tdebug(\"no host key fingerprint found in DNS\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_drop_cert",
          "args": [
            "plain"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_drop_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2497-2506",
          "snippet": "int\nsshkey_drop_cert(struct sshkey *k)\n{\n\tif (!sshkey_type_is_cert(k->type))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tcert_free(k->cert);\n\tk->cert = NULL;\n\tk->type = sshkey_type_plain(k->type);\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_drop_cert(struct sshkey *k)\n{\n\tif (!sshkey_type_is_cert(k->type))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tcert_free(k->cert);\n\tk->cert = NULL;\n\tk->type = sshkey_type_plain(k->type);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "plain"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "host_key"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_check_revoked",
          "args": [
            "host_key",
            "options.revoked_host_keys"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_check_revoked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "512-537",
          "snippet": "int\nsshkey_check_revoked(struct sshkey *key, const char *revoked_keys_file)\n{\n\tint r;\n\n\tr = ssh_krl_file_contains_key(revoked_keys_file, key);\n\t/* If this was not a KRL to begin with then continue below */\n\tif (r != SSH_ERR_KRL_BAD_MAGIC)\n\t\treturn r;\n\n\t/*\n\t * If the file is not a KRL or we can't handle KRLs then attempt to\n\t * parse the file as a flat list of keys.\n\t */\n\tswitch ((r = sshkey_in_file(key, revoked_keys_file, 0, 1))) {\n\tcase 0:\n\t\t/* Key found => revoked */\n\t\treturn SSH_ERR_KEY_REVOKED;\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\t/* Key not found => not revoked */\n\t\treturn 0;\n\tdefault:\n\t\t/* Some other error occurred */\n\t\treturn r;\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_check_revoked(struct sshkey *key, const char *revoked_keys_file)\n{\n\tint r;\n\n\tr = ssh_krl_file_contains_key(revoked_keys_file, key);\n\t/* If this was not a KRL to begin with then continue below */\n\tif (r != SSH_ERR_KRL_BAD_MAGIC)\n\t\treturn r;\n\n\t/*\n\t * If the file is not a KRL or we can't handle KRLs then attempt to\n\t * parse the file as a flat list of keys.\n\t */\n\tswitch ((r = sshkey_in_file(key, revoked_keys_file, 0, 1))) {\n\tcase 0:\n\t\t/* Key found => revoked */\n\t\treturn SSH_ERR_KEY_REVOKED;\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\t/* Key not found => not revoked */\n\t\treturn 0;\n\tdefault:\n\t\t/* Some other error occurred */\n\t\treturn r;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: server host key %s %s matches cached key\"",
            "__func__",
            "sshkey_type(host_key)",
            "fp"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "previous_host_key",
            "host_key"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Server host key: %s %s\"",
            "sshkey_ssh_name(host_key)",
            "fp"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "host_key"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_format_cert_validity",
          "args": [
            "host_key->cert",
            "valid",
            "sizeof(valid)"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_format_cert_validity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2730-2765",
          "snippet": "size_t\nsshkey_format_cert_validity(const struct sshkey_cert *cert, char *s, size_t l)\n{\n\tchar from[32], to[32], ret[64];\n\ttime_t tt;\n\tstruct tm *tm;\n\n\t*from = *to = '\\0';\n\tif (cert->valid_after == 0 &&\n\t    cert->valid_before == 0xffffffffffffffffULL)\n\t\treturn strlcpy(s, \"forever\", l);\n\n\tif (cert->valid_after != 0) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_after > INT_MAX ?\n\t\t    INT_MAX : cert->valid_after;\n\t\ttm = localtime(&tt);\n\t\tstrftime(from, sizeof(from), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\tif (cert->valid_before != 0xffffffffffffffffULL) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_before > INT_MAX ?\n\t\t    INT_MAX : cert->valid_before;\n\t\ttm = localtime(&tt);\n\t\tstrftime(to, sizeof(to), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\n\tif (cert->valid_after == 0)\n\t\tsnprintf(ret, sizeof(ret), \"before %s\", to);\n\telse if (cert->valid_before == 0xffffffffffffffffULL)\n\t\tsnprintf(ret, sizeof(ret), \"after %s\", from);\n\telse\n\t\tsnprintf(ret, sizeof(ret), \"from %s to %s\", from, to);\n\n\treturn strlcpy(s, ret, l);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_format_cert_validity(const struct sshkey_cert *cert, char *s, size_t l)\n{\n\tchar from[32], to[32], ret[64];\n\ttime_t tt;\n\tstruct tm *tm;\n\n\t*from = *to = '\\0';\n\tif (cert->valid_after == 0 &&\n\t    cert->valid_before == 0xffffffffffffffffULL)\n\t\treturn strlcpy(s, \"forever\", l);\n\n\tif (cert->valid_after != 0) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_after > INT_MAX ?\n\t\t    INT_MAX : cert->valid_after;\n\t\ttm = localtime(&tt);\n\t\tstrftime(from, sizeof(from), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\tif (cert->valid_before != 0xffffffffffffffffULL) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_before > INT_MAX ?\n\t\t    INT_MAX : cert->valid_before;\n\t\ttm = localtime(&tt);\n\t\tstrftime(to, sizeof(to), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\n\tif (cert->valid_after == 0)\n\t\tsnprintf(ret, sizeof(ret), \"before %s\", to);\n\telse if (cert->valid_before == 0xffffffffffffffffULL)\n\t\tsnprintf(ret, sizeof(ret), \"after %s\", from);\n\telse\n\t\tsnprintf(ret, sizeof(ret), \"from %s to %s\", from, to);\n\n\treturn strlcpy(s, ret, l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "host_key->cert->signature_key",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RDRW\t0\n\nstruct sshkey *previous_host_key = NULL;\nstatic int matching_host_key_dns = 0;\nextern Options options;\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\nint\nverify_host_key(char *host, struct sockaddr *hostaddr, struct sshkey *host_key)\n{\n\tu_int i;\n\tint r = -1, flags = 0;\n\tchar valid[64], *fp = NULL, *cafp = NULL;\n\tstruct sshkey *plain = NULL;\n\n\tif ((fp = sshkey_fingerprint(host_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: fingerprint host key: %s\", __func__, ssh_err(r));\n\t\tr = -1;\n\t\tgoto out;\n\t}\n\n\tif (sshkey_is_cert(host_key)) {\n\t\tif ((cafp = sshkey_fingerprint(host_key->cert->signature_key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\t\terror(\"%s: fingerprint CA key: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tsshkey_format_cert_validity(host_key->cert,\n\t\t    valid, sizeof(valid));\n\t\tdebug(\"Server host certificate: %s %s, serial %llu \"\n\t\t    \"ID \\\"%s\\\" CA %s %s valid %s\",\n\t\t    sshkey_ssh_name(host_key), fp,\n\t\t    (unsigned long long)host_key->cert->serial,\n\t\t    host_key->cert->key_id,\n\t\t    sshkey_ssh_name(host_key->cert->signature_key), cafp,\n\t\t    valid);\n\t\tfor (i = 0; i < host_key->cert->nprincipals; i++) {\n\t\t\tdebug2(\"Server host certificate hostname: %s\",\n\t\t\t    host_key->cert->principals[i]);\n\t\t}\n\t} else {\n\t\tdebug(\"Server host key: %s %s\", sshkey_ssh_name(host_key), fp);\n\t}\n\n\tif (sshkey_equal(previous_host_key, host_key)) {\n\t\tdebug2(\"%s: server host key %s %s matches cached key\",\n\t\t    __func__, sshkey_type(host_key), fp);\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\n\t/* Check in RevokedHostKeys file if specified */\n\tif (options.revoked_host_keys != NULL) {\n\t\tr = sshkey_check_revoked(host_key, options.revoked_host_keys);\n\t\tswitch (r) {\n\t\tcase 0:\n\t\t\tbreak; /* not revoked */\n\t\tcase SSH_ERR_KEY_REVOKED:\n\t\t\terror(\"Host key %s %s revoked by file %s\",\n\t\t\t    sshkey_type(host_key), fp,\n\t\t\t    options.revoked_host_keys);\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terror(\"Error checking host key %s %s in \"\n\t\t\t    \"revoked keys file %s: %s\", sshkey_type(host_key),\n\t\t\t    fp, options.revoked_host_keys, ssh_err(r));\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (options.verify_host_key_dns) {\n\t\t/*\n\t\t * XXX certs are not yet supported for DNS, so downgrade\n\t\t * them and try the plain key.\n\t\t */\n\t\tif ((r = sshkey_from_private(host_key, &plain)) != 0)\n\t\t\tgoto out;\n\t\tif (sshkey_is_cert(plain))\n\t\t\tsshkey_drop_cert(plain);\n\t\tif (verify_host_key_dns(host, hostaddr, plain, &flags) == 0) {\n\t\t\tif (flags & DNS_VERIFY_FOUND) {\n\t\t\t\tif (options.verify_host_key_dns == 1 &&\n\t\t\t\t    flags & DNS_VERIFY_MATCH &&\n\t\t\t\t    flags & DNS_VERIFY_SECURE) {\n\t\t\t\t\tr = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (flags & DNS_VERIFY_MATCH) {\n\t\t\t\t\tmatching_host_key_dns = 1;\n\t\t\t\t} else {\n\t\t\t\t\twarn_changed_key(plain);\n\t\t\t\t\terror(\"Update the SSHFP RR in DNS \"\n\t\t\t\t\t    \"with the new host key to get rid \"\n\t\t\t\t\t    \"of this message.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tr = check_host_key(host, hostaddr, options.port, host_key, RDRW,\n\t    options.user_hostfiles, options.num_user_hostfiles,\n\t    options.system_hostfiles, options.num_system_hostfiles);\n\nout:\n\tsshkey_free(plain);\n\tfree(fp);\n\tfree(cafp);\n\tif (r == 0 && host_key != NULL) {\n\t\tsshkey_free(previous_host_key);\n\t\tr = sshkey_from_private(host_key, &previous_host_key);\n\t}\n\n\treturn r;\n}"
  },
  {
    "function_name": "check_host_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "838-1277",
    "snippet": "static int\ncheck_host_key(char *hostname, struct sockaddr *hostaddr, u_short port,\n    struct sshkey *host_key, int readonly,\n    char **user_hostfiles, u_int num_user_hostfiles,\n    char **system_hostfiles, u_int num_system_hostfiles)\n{\n\tHostStatus host_status;\n\tHostStatus ip_status;\n\tstruct sshkey *raw_key = NULL;\n\tchar *ip = NULL, *host = NULL;\n\tchar hostline[1000], *hostp, *fp, *ra;\n\tchar msg[1024];\n\tconst char *type;\n\tconst struct hostkey_entry *host_found, *ip_found;\n\tint len, cancelled_forwarding = 0;\n\tint local = sockaddr_is_local(hostaddr);\n\tint r, want_cert = sshkey_is_cert(host_key), host_ip_differ = 0;\n\tint hostkey_trusted = 0; /* Known or explicitly accepted by user */\n\tstruct hostkeys *host_hostkeys, *ip_hostkeys;\n\tu_int i;\n\n\t/*\n\t * Force accepting of the host key for loopback/localhost. The\n\t * problem is that if the home directory is NFS-mounted to multiple\n\t * machines, localhost will refer to a different machine in each of\n\t * them, and the user will get bogus HOST_CHANGED warnings.  This\n\t * essentially disables host authentication for localhost; however,\n\t * this is probably not a real problem.\n\t */\n\tif (options.no_host_authentication_for_localhost == 1 && local &&\n\t    options.host_key_alias == NULL) {\n\t\tdebug(\"Forcing accepting of host key for \"\n\t\t    \"loopback/localhost.\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Prepare the hostname and address strings used for hostkey lookup.\n\t * In some cases, these will have a port number appended.\n\t */\n\tget_hostfile_hostname_ipaddr(hostname, hostaddr, port, &host, &ip);\n\n\t/*\n\t * Turn off check_host_ip if the connection is to localhost, via proxy\n\t * command or if we don't have a hostname to compare with\n\t */\n\tif (options.check_host_ip && (local ||\n\t    strcmp(hostname, ip) == 0 || options.proxy_command != NULL))\n\t\toptions.check_host_ip = 0;\n\n\thost_hostkeys = init_hostkeys();\n\tfor (i = 0; i < num_user_hostfiles; i++)\n\t\tload_hostkeys(host_hostkeys, host, user_hostfiles[i]);\n\tfor (i = 0; i < num_system_hostfiles; i++)\n\t\tload_hostkeys(host_hostkeys, host, system_hostfiles[i]);\n\n\tip_hostkeys = NULL;\n\tif (!want_cert && options.check_host_ip) {\n\t\tip_hostkeys = init_hostkeys();\n\t\tfor (i = 0; i < num_user_hostfiles; i++)\n\t\t\tload_hostkeys(ip_hostkeys, ip, user_hostfiles[i]);\n\t\tfor (i = 0; i < num_system_hostfiles; i++)\n\t\t\tload_hostkeys(ip_hostkeys, ip, system_hostfiles[i]);\n\t}\n\n retry:\n\t/* Reload these as they may have changed on cert->key downgrade */\n\twant_cert = sshkey_is_cert(host_key);\n\ttype = sshkey_type(host_key);\n\n\t/*\n\t * Check if the host key is present in the user's list of known\n\t * hosts or in the systemwide list.\n\t */\n\thost_status = check_key_in_hostkeys(host_hostkeys, host_key,\n\t    &host_found);\n\n\t/*\n\t * Also perform check for the ip address, skip the check if we are\n\t * localhost, looking for a certificate, or the hostname was an ip\n\t * address to begin with.\n\t */\n\tif (!want_cert && ip_hostkeys != NULL) {\n\t\tip_status = check_key_in_hostkeys(ip_hostkeys, host_key,\n\t\t    &ip_found);\n\t\tif (host_status == HOST_CHANGED &&\n\t\t    (ip_status != HOST_CHANGED || \n\t\t    (ip_found != NULL &&\n\t\t    !sshkey_equal(ip_found->key, host_found->key))))\n\t\t\thost_ip_differ = 1;\n\t} else\n\t\tip_status = host_status;\n\n\tswitch (host_status) {\n\tcase HOST_OK:\n\t\t/* The host is known and the key matches. */\n\t\tdebug(\"Host '%.200s' is known and matches the %s host %s.\",\n\t\t    host, type, want_cert ? \"certificate\" : \"key\");\n\t\tdebug(\"Found %s in %s:%lu\", want_cert ? \"CA key\" : \"key\",\n\t\t    host_found->file, host_found->line);\n\t\tif (want_cert &&\n\t\t    !check_host_cert(options.host_key_alias == NULL ?\n\t\t    hostname : options.host_key_alias, host_key))\n\t\t\tgoto fail;\n\t\tif (options.check_host_ip && ip_status == HOST_NEW) {\n\t\t\tif (readonly || want_cert)\n\t\t\t\tlogit(\"%s host key for IP address \"\n\t\t\t\t    \"'%.128s' not in list of known hosts.\",\n\t\t\t\t    type, ip);\n\t\t\telse if (!add_host_to_hostfile(user_hostfiles[0], ip,\n\t\t\t    host_key, options.hash_known_hosts))\n\t\t\t\tlogit(\"Failed to add the %s host key for IP \"\n\t\t\t\t    \"address '%.128s' to the list of known \"\n\t\t\t\t    \"hosts (%.500s).\", type, ip,\n\t\t\t\t    user_hostfiles[0]);\n\t\t\telse\n\t\t\t\tlogit(\"Warning: Permanently added the %s host \"\n\t\t\t\t    \"key for IP address '%.128s' to the list \"\n\t\t\t\t    \"of known hosts.\", type, ip);\n\t\t} else if (options.visual_host_key) {\n\t\t\tfp = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tra = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tlogit(\"Host key fingerprint is %s\\n%s\", fp, ra);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t}\n\t\thostkey_trusted = 1;\n\t\tbreak;\n\tcase HOST_NEW:\n\t\tif (options.host_key_alias == NULL && port != 0 &&\n\t\t    port != SSH_DEFAULT_PORT) {\n\t\t\tdebug(\"checking without port identifier\");\n\t\t\tif (check_host_key(hostname, hostaddr, 0, host_key,\n\t\t\t    ROQUIET, user_hostfiles, num_user_hostfiles,\n\t\t\t    system_hostfiles, num_system_hostfiles) == 0) {\n\t\t\t\tdebug(\"found matching key w/out port\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (readonly || want_cert)\n\t\t\tgoto fail;\n\t\t/* The host is new. */\n\t\tif (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_YES) {\n\t\t\t/*\n\t\t\t * User has requested strict host key checking.  We\n\t\t\t * will not add the host key automatically.  The only\n\t\t\t * alternative left is to abort.\n\t\t\t */\n\t\t\terror(\"No %s host key is known for %.200s and you \"\n\t\t\t    \"have requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t} else if (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_ASK) {\n\t\t\tchar msg1[1024], msg2[1024];\n\n\t\t\tif (show_other_keys(host_hostkeys, host_key))\n\t\t\t\tsnprintf(msg1, sizeof(msg1),\n\t\t\t\t    \"\\nbut keys of different type are already\"\n\t\t\t\t    \" known for this host.\");\n\t\t\telse\n\t\t\t\tsnprintf(msg1, sizeof(msg1), \".\");\n\t\t\t/* The default */\n\t\t\tfp = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tra = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tmsg2[0] = '\\0';\n\t\t\tif (options.verify_host_key_dns) {\n\t\t\t\tif (matching_host_key_dns)\n\t\t\t\t\tsnprintf(msg2, sizeof(msg2),\n\t\t\t\t\t    \"Matching host key fingerprint\"\n\t\t\t\t\t    \" found in DNS.\\n\");\n\t\t\t\telse\n\t\t\t\t\tsnprintf(msg2, sizeof(msg2),\n\t\t\t\t\t    \"No matching host key fingerprint\"\n\t\t\t\t\t    \" found in DNS.\\n\");\n\t\t\t}\n\t\t\tsnprintf(msg, sizeof(msg),\n\t\t\t    \"The authenticity of host '%.200s (%s)' can't be \"\n\t\t\t    \"established%s\\n\"\n\t\t\t    \"%s key fingerprint is %s.%s%s\\n%s\"\n\t\t\t    \"Are you sure you want to continue connecting \"\n\t\t\t    \"(yes/no)? \",\n\t\t\t    host, ip, msg1, type, fp,\n\t\t\t    options.visual_host_key ? \"\\n\" : \"\",\n\t\t\t    options.visual_host_key ? ra : \"\",\n\t\t\t    msg2);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t\tif (!confirm(msg))\n\t\t\t\tgoto fail;\n\t\t\thostkey_trusted = 1; /* user explicitly confirmed */\n\t\t}\n\t\t/*\n\t\t * If in \"new\" or \"off\" strict mode, add the key automatically\n\t\t * to the local known_hosts file.\n\t\t */\n\t\tif (options.check_host_ip && ip_status == HOST_NEW) {\n\t\t\tsnprintf(hostline, sizeof(hostline), \"%s,%s\", host, ip);\n\t\t\thostp = hostline;\n\t\t\tif (options.hash_known_hosts) {\n\t\t\t\t/* Add hash of host and IP separately */\n\t\t\t\tr = add_host_to_hostfile(user_hostfiles[0],\n\t\t\t\t    host, host_key, options.hash_known_hosts) &&\n\t\t\t\t    add_host_to_hostfile(user_hostfiles[0], ip,\n\t\t\t\t    host_key, options.hash_known_hosts);\n\t\t\t} else {\n\t\t\t\t/* Add unhashed \"host,ip\" */\n\t\t\t\tr = add_host_to_hostfile(user_hostfiles[0],\n\t\t\t\t    hostline, host_key,\n\t\t\t\t    options.hash_known_hosts);\n\t\t\t}\n\t\t} else {\n\t\t\tr = add_host_to_hostfile(user_hostfiles[0], host,\n\t\t\t    host_key, options.hash_known_hosts);\n\t\t\thostp = host;\n\t\t}\n\n\t\tif (!r)\n\t\t\tlogit(\"Failed to add the host to the list of known \"\n\t\t\t    \"hosts (%.500s).\", user_hostfiles[0]);\n\t\telse\n\t\t\tlogit(\"Warning: Permanently added '%.200s' (%s) to the \"\n\t\t\t    \"list of known hosts.\", hostp, type);\n\t\tbreak;\n\tcase HOST_REVOKED:\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"@       WARNING: REVOKED HOST KEY DETECTED!               @\");\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"The %s host key for %s is marked as revoked.\", type, host);\n\t\terror(\"This could mean that a stolen key is being used to\");\n\t\terror(\"impersonate this host.\");\n\n\t\t/*\n\t\t * If strict host key checking is in use, the user will have\n\t\t * to edit the key manually and we can only abort.\n\t\t */\n\t\tif (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\terror(\"%s host key for %.200s was revoked and you have \"\n\t\t\t    \"requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t}\n\t\tgoto continue_unsafe;\n\n\tcase HOST_CHANGED:\n\t\tif (want_cert) {\n\t\t\t/*\n\t\t\t * This is only a debug() since it is valid to have\n\t\t\t * CAs with wildcard DNS matches that don't match\n\t\t\t * all hosts that one might visit.\n\t\t\t */\n\t\t\tdebug(\"Host certificate authority does not \"\n\t\t\t    \"match %s in %s:%lu\", CA_MARKER,\n\t\t\t    host_found->file, host_found->line);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (readonly == ROQUIET)\n\t\t\tgoto fail;\n\t\tif (options.check_host_ip && host_ip_differ) {\n\t\t\tchar *key_msg;\n\t\t\tif (ip_status == HOST_NEW)\n\t\t\t\tkey_msg = \"is unknown\";\n\t\t\telse if (ip_status == HOST_OK)\n\t\t\t\tkey_msg = \"is unchanged\";\n\t\t\telse\n\t\t\t\tkey_msg = \"has a different value\";\n\t\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\t\terror(\"@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @\");\n\t\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\t\terror(\"The %s host key for %s has changed,\", type, host);\n\t\t\terror(\"and the key for the corresponding IP address %s\", ip);\n\t\t\terror(\"%s. This could either mean that\", key_msg);\n\t\t\terror(\"DNS SPOOFING is happening or the IP address for the host\");\n\t\t\terror(\"and its host key have changed at the same time.\");\n\t\t\tif (ip_status != HOST_NEW)\n\t\t\t\terror(\"Offending key for IP in %s:%lu\",\n\t\t\t\t    ip_found->file, ip_found->line);\n\t\t}\n\t\t/* The host key has changed. */\n\t\twarn_changed_key(host_key);\n\t\terror(\"Add correct host key in %.100s to get rid of this message.\",\n\t\t    user_hostfiles[0]);\n\t\terror(\"Offending %s key in %s:%lu\",\n\t\t    sshkey_type(host_found->key),\n\t\t    host_found->file, host_found->line);\n\n\t\t/*\n\t\t * If strict host key checking is in use, the user will have\n\t\t * to edit the key manually and we can only abort.\n\t\t */\n\t\tif (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\terror(\"%s host key for %.200s has changed and you have \"\n\t\t\t    \"requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t}\n\n continue_unsafe:\n\t\t/*\n\t\t * If strict host key checking has not been requested, allow\n\t\t * the connection but without MITM-able authentication or\n\t\t * forwarding.\n\t\t */\n\t\tif (options.password_authentication) {\n\t\t\terror(\"Password authentication is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.password_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.kbd_interactive_authentication) {\n\t\t\terror(\"Keyboard-interactive authentication is disabled\"\n\t\t\t    \" to avoid man-in-the-middle attacks.\");\n\t\t\toptions.kbd_interactive_authentication = 0;\n\t\t\toptions.challenge_response_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.challenge_response_authentication) {\n\t\t\terror(\"Challenge/response authentication is disabled\"\n\t\t\t    \" to avoid man-in-the-middle attacks.\");\n\t\t\toptions.challenge_response_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.forward_agent) {\n\t\t\terror(\"Agent forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.forward_agent = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.forward_x11) {\n\t\t\terror(\"X11 forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.forward_x11 = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.num_local_forwards > 0 ||\n\t\t    options.num_remote_forwards > 0) {\n\t\t\terror(\"Port forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.num_local_forwards =\n\t\t\t    options.num_remote_forwards = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.tun_open != SSH_TUNMODE_NO) {\n\t\t\terror(\"Tunnel forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.tun_open = SSH_TUNMODE_NO;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.exit_on_forward_failure && cancelled_forwarding)\n\t\t\tfatal(\"Error: forwarding disabled due to host key \"\n\t\t\t    \"check failure\");\n\t\t\n\t\t/*\n\t\t * XXX Should permit the user to change to use the new id.\n\t\t * This could be done by converting the host key to an\n\t\t * identifying sentence, tell that the host identifies itself\n\t\t * by that sentence, and ask the user if he/she wishes to\n\t\t * accept the authentication.\n\t\t */\n\t\tbreak;\n\tcase HOST_FOUND:\n\t\tfatal(\"internal error\");\n\t\tbreak;\n\t}\n\n\tif (options.check_host_ip && host_status != HOST_CHANGED &&\n\t    ip_status == HOST_CHANGED) {\n\t\tsnprintf(msg, sizeof(msg),\n\t\t    \"Warning: the %s host key for '%.200s' \"\n\t\t    \"differs from the key for the IP address '%.128s'\"\n\t\t    \"\\nOffending key for IP in %s:%lu\",\n\t\t    type, host, ip, ip_found->file, ip_found->line);\n\t\tif (host_status == HOST_OK) {\n\t\t\tlen = strlen(msg);\n\t\t\tsnprintf(msg + len, sizeof(msg) - len,\n\t\t\t    \"\\nMatching host key in %s:%lu\",\n\t\t\t    host_found->file, host_found->line);\n\t\t}\n\t\tif (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_ASK) {\n\t\t\tstrlcat(msg, \"\\nAre you sure you want \"\n\t\t\t    \"to continue connecting (yes/no)? \", sizeof(msg));\n\t\t\tif (!confirm(msg))\n\t\t\t\tgoto fail;\n\t\t} else if (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\tlogit(\"%s\", msg);\n\t\t\terror(\"Exiting, you have requested strict checking.\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tlogit(\"%s\", msg);\n\t\t}\n\t}\n\n\tif (!hostkey_trusted && options.update_hostkeys) {\n\t\tdebug(\"%s: hostkey not known or explicitly trusted: \"\n\t\t    \"disabling UpdateHostkeys\", __func__);\n\t\toptions.update_hostkeys = 0;\n\t}\n\n\tfree(ip);\n\tfree(host);\n\tif (host_hostkeys != NULL)\n\t\tfree_hostkeys(host_hostkeys);\n\tif (ip_hostkeys != NULL)\n\t\tfree_hostkeys(ip_hostkeys);\n\treturn 0;\n\nfail:\n\tif (want_cert && host_status != HOST_REVOKED) {\n\t\t/*\n\t\t * No matching certificate. Downgrade cert to raw key and\n\t\t * search normally.\n\t\t */\n\t\tdebug(\"No matching CA found. Retry with plain key\");\n\t\tif ((r = sshkey_from_private(host_key, &raw_key)) != 0)\n\t\t\tfatal(\"%s: sshkey_from_private: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tif ((r = sshkey_drop_cert(raw_key)) != 0)\n\t\t\tfatal(\"Couldn't drop certificate: %s\", ssh_err(r));\n\t\thost_key = raw_key;\n\t\tgoto retry;\n\t}\n\tsshkey_free(raw_key);\n\tfree(ip);\n\tfree(host);\n\tif (host_hostkeys != NULL)\n\t\tfree_hostkeys(host_hostkeys);\n\tif (ip_hostkeys != NULL)\n\t\tfree_hostkeys(ip_hostkeys);\n\treturn -1;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define ROQUIET\t2"
    ],
    "globals_used": [
      "static int matching_host_key_dns = 0;",
      "extern Options options;",
      "static int show_other_keys(struct hostkeys *, struct sshkey *);",
      "static void warn_changed_key(struct sshkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_hostkeys",
          "args": [
            "ip_hostkeys"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "free_hostkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "291-305",
          "snippet": "void\nfree_hostkeys(struct hostkeys *hostkeys)\n{\n\tu_int i;\n\n\tfor (i = 0; i < hostkeys->num_entries; i++) {\n\t\tfree(hostkeys->entries[i].host);\n\t\tfree(hostkeys->entries[i].file);\n\t\tsshkey_free(hostkeys->entries[i].key);\n\t\texplicit_bzero(hostkeys->entries + i, sizeof(*hostkeys->entries));\n\t}\n\tfree(hostkeys->entries);\n\texplicit_bzero(hostkeys, sizeof(*hostkeys));\n\tfree(hostkeys);\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfree_hostkeys(struct hostkeys *hostkeys)\n{\n\tu_int i;\n\n\tfor (i = 0; i < hostkeys->num_entries; i++) {\n\t\tfree(hostkeys->entries[i].host);\n\t\tfree(hostkeys->entries[i].file);\n\t\tsshkey_free(hostkeys->entries[i].key);\n\t\texplicit_bzero(hostkeys->entries + i, sizeof(*hostkeys->entries));\n\t}\n\tfree(hostkeys->entries);\n\texplicit_bzero(hostkeys, sizeof(*hostkeys));\n\tfree(hostkeys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "host"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "raw_key"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Couldn't drop certificate: %s\"",
            "ssh_err(r)"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_drop_cert",
          "args": [
            "raw_key"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_drop_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2497-2506",
          "snippet": "int\nsshkey_drop_cert(struct sshkey *k)\n{\n\tif (!sshkey_type_is_cert(k->type))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tcert_free(k->cert);\n\tk->cert = NULL;\n\tk->type = sshkey_type_plain(k->type);\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_drop_cert(struct sshkey *k)\n{\n\tif (!sshkey_type_is_cert(k->type))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tcert_free(k->cert);\n\tk->cert = NULL;\n\tk->type = sshkey_type_plain(k->type);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshkey_from_private: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "host_key",
            "&raw_key"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"No matching CA found. Retry with plain key\""
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s\"",
            "msg"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Exiting, you have requested strict checking.\""
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "confirm",
          "args": [
            "msg"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "708-730",
          "snippet": "static int\nconfirm(const char *prompt)\n{\n\tconst char *msg, *again = \"Please type 'yes' or 'no': \";\n\tchar *p;\n\tint ret = -1;\n\n\tif (options.batch_mode)\n\t\treturn 0;\n\tfor (msg = prompt;;msg = again) {\n\t\tp = read_passphrase(msg, RP_ECHO);\n\t\tif (p == NULL)\n\t\t\treturn 0;\n\t\tp[strcspn(p, \"\\n\")] = '\\0';\n\t\tif (p[0] == '\\0' || strcasecmp(p, \"no\") == 0)\n\t\t\tret = 0;\n\t\telse if (strcasecmp(p, \"yes\") == 0)\n\t\t\tret = 1;\n\t\tfree(p);\n\t\tif (ret != -1)\n\t\t\treturn ret;\n\t}\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nconfirm(const char *prompt)\n{\n\tconst char *msg, *again = \"Please type 'yes' or 'no': \";\n\tchar *p;\n\tint ret = -1;\n\n\tif (options.batch_mode)\n\t\treturn 0;\n\tfor (msg = prompt;;msg = again) {\n\t\tp = read_passphrase(msg, RP_ECHO);\n\t\tif (p == NULL)\n\t\t\treturn 0;\n\t\tp[strcspn(p, \"\\n\")] = '\\0';\n\t\tif (p[0] == '\\0' || strcasecmp(p, \"no\") == 0)\n\t\t\tret = 0;\n\t\telse if (strcasecmp(p, \"yes\") == 0)\n\t\t\tret = 1;\n\t\tfree(p);\n\t\tif (ret != -1)\n\t\t\treturn ret;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "msg",
            "\"\\nAre you sure you want \"\n\t\t\t    \"to continue connecting (yes/no)? \"",
            "sizeof(msg)"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "strlcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcat.c",
          "lines": "34-60",
          "snippet": "size_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "msg + len",
            "sizeof(msg) - len",
            "\"\\nMatching host key in %s:%lu\"",
            "host_found->file",
            "host_found->line"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "msg"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "host_found->key"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_changed_key",
          "args": [
            "host_key"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "warn_changed_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "1487-1508",
          "snippet": "static void\nwarn_changed_key(struct sshkey *host_key)\n{\n\tchar *fp;\n\n\tfp = sshkey_fingerprint(host_key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT);\n\tif (fp == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\");\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\");\n\terror(\"Someone could be eavesdropping on you right now (man-in-the-middle attack)!\");\n\terror(\"It is also possible that a host key has just been changed.\");\n\terror(\"The fingerprint for the %s key sent by the remote host is\\n%s.\",\n\t    sshkey_type(host_key), fp);\n\terror(\"Please contact your system administrator.\");\n\n\tfree(fp);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static int show_other_keys(struct hostkeys *, struct sshkey *);",
            "static void warn_changed_key(struct sshkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\nstatic void\nwarn_changed_key(struct sshkey *host_key)\n{\n\tchar *fp;\n\n\tfp = sshkey_fingerprint(host_key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT);\n\tif (fp == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\");\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\");\n\terror(\"Someone could be eavesdropping on you right now (man-in-the-middle attack)!\");\n\terror(\"It is also possible that a host key has just been changed.\");\n\terror(\"The fingerprint for the %s key sent by the remote host is\\n%s.\",\n\t    sshkey_type(host_key), fp);\n\terror(\"Please contact your system administrator.\");\n\n\tfree(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_host_to_hostfile",
          "args": [
            "user_hostfiles[0]",
            "host",
            "host_key",
            "options.hash_known_hosts"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "add_host_to_hostfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "447-462",
          "snippet": "int\nadd_host_to_hostfile(const char *filename, const char *host,\n    const struct sshkey *key, int store_hash)\n{\n\tFILE *f;\n\tint success;\n\n\tif (key == NULL)\n\t\treturn 1;\t/* XXX ? */\n\tf = fopen(filename, \"a\");\n\tif (!f)\n\t\treturn 0;\n\tsuccess = write_host_entry(f, host, NULL, key, store_hash);\n\tfclose(f);\n\treturn success;\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nadd_host_to_hostfile(const char *filename, const char *host,\n    const struct sshkey *key, int store_hash)\n{\n\tFILE *f;\n\tint success;\n\n\tif (key == NULL)\n\t\treturn 1;\t/* XXX ? */\n\tf = fopen(filename, \"a\");\n\tif (!f)\n\t\treturn 0;\n\tsuccess = write_host_entry(f, host, NULL, key, store_hash);\n\tfclose(f);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "host_key",
            "options.fingerprint_hash",
            "SSH_FP_RANDOMART"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_other_keys",
          "args": [
            "host_hostkeys",
            "host_key"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "show_other_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "1446-1485",
          "snippet": "static int\nshow_other_keys(struct hostkeys *hostkeys, struct sshkey *key)\n{\n\tint type[] = {\n\t\tKEY_RSA,\n\t\tKEY_DSA,\n\t\tKEY_ECDSA,\n\t\tKEY_ED25519,\n\t\tKEY_XMSS,\n\t\t-1\n\t};\n\tint i, ret = 0;\n\tchar *fp, *ra;\n\tconst struct hostkey_entry *found;\n\n\tfor (i = 0; type[i] != -1; i++) {\n\t\tif (type[i] == key->type)\n\t\t\tcontinue;\n\t\tif (!lookup_key_in_hostkeys_by_type(hostkeys, type[i], &found))\n\t\t\tcontinue;\n\t\tfp = sshkey_fingerprint(found->key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\tra = sshkey_fingerprint(found->key,\n\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\tif (fp == NULL || ra == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\tlogit(\"WARNING: %s key found for host %s\\n\"\n\t\t    \"in %s:%lu\\n\"\n\t\t    \"%s key fingerprint %s.\",\n\t\t    sshkey_type(found->key),\n\t\t    found->host, found->file, found->line,\n\t\t    sshkey_type(found->key), fp);\n\t\tif (options.visual_host_key)\n\t\t\tlogit(\"%s\", ra);\n\t\tfree(ra);\n\t\tfree(fp);\n\t\tret = 1;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static int show_other_keys(struct hostkeys *, struct sshkey *);",
            "static void warn_changed_key(struct sshkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\nstatic int\nshow_other_keys(struct hostkeys *hostkeys, struct sshkey *key)\n{\n\tint type[] = {\n\t\tKEY_RSA,\n\t\tKEY_DSA,\n\t\tKEY_ECDSA,\n\t\tKEY_ED25519,\n\t\tKEY_XMSS,\n\t\t-1\n\t};\n\tint i, ret = 0;\n\tchar *fp, *ra;\n\tconst struct hostkey_entry *found;\n\n\tfor (i = 0; type[i] != -1; i++) {\n\t\tif (type[i] == key->type)\n\t\t\tcontinue;\n\t\tif (!lookup_key_in_hostkeys_by_type(hostkeys, type[i], &found))\n\t\t\tcontinue;\n\t\tfp = sshkey_fingerprint(found->key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\tra = sshkey_fingerprint(found->key,\n\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\tif (fp == NULL || ra == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\tlogit(\"WARNING: %s key found for host %s\\n\"\n\t\t    \"in %s:%lu\\n\"\n\t\t    \"%s key fingerprint %s.\",\n\t\t    sshkey_type(found->key),\n\t\t    found->host, found->file, found->line,\n\t\t    sshkey_type(found->key), fp);\n\t\tif (options.visual_host_key)\n\t\t\tlogit(\"%s\", ra);\n\t\tfree(ra);\n\t\tfree(fp);\n\t\tret = 1;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_host_key",
          "args": [
            "hostname",
            "hostaddr",
            "0",
            "host_key",
            "ROQUIET",
            "user_hostfiles",
            "num_user_hostfiles",
            "system_hostfiles",
            "num_system_hostfiles"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "check_host_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "838-1277",
          "snippet": "static int\ncheck_host_key(char *hostname, struct sockaddr *hostaddr, u_short port,\n    struct sshkey *host_key, int readonly,\n    char **user_hostfiles, u_int num_user_hostfiles,\n    char **system_hostfiles, u_int num_system_hostfiles)\n{\n\tHostStatus host_status;\n\tHostStatus ip_status;\n\tstruct sshkey *raw_key = NULL;\n\tchar *ip = NULL, *host = NULL;\n\tchar hostline[1000], *hostp, *fp, *ra;\n\tchar msg[1024];\n\tconst char *type;\n\tconst struct hostkey_entry *host_found, *ip_found;\n\tint len, cancelled_forwarding = 0;\n\tint local = sockaddr_is_local(hostaddr);\n\tint r, want_cert = sshkey_is_cert(host_key), host_ip_differ = 0;\n\tint hostkey_trusted = 0; /* Known or explicitly accepted by user */\n\tstruct hostkeys *host_hostkeys, *ip_hostkeys;\n\tu_int i;\n\n\t/*\n\t * Force accepting of the host key for loopback/localhost. The\n\t * problem is that if the home directory is NFS-mounted to multiple\n\t * machines, localhost will refer to a different machine in each of\n\t * them, and the user will get bogus HOST_CHANGED warnings.  This\n\t * essentially disables host authentication for localhost; however,\n\t * this is probably not a real problem.\n\t */\n\tif (options.no_host_authentication_for_localhost == 1 && local &&\n\t    options.host_key_alias == NULL) {\n\t\tdebug(\"Forcing accepting of host key for \"\n\t\t    \"loopback/localhost.\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Prepare the hostname and address strings used for hostkey lookup.\n\t * In some cases, these will have a port number appended.\n\t */\n\tget_hostfile_hostname_ipaddr(hostname, hostaddr, port, &host, &ip);\n\n\t/*\n\t * Turn off check_host_ip if the connection is to localhost, via proxy\n\t * command or if we don't have a hostname to compare with\n\t */\n\tif (options.check_host_ip && (local ||\n\t    strcmp(hostname, ip) == 0 || options.proxy_command != NULL))\n\t\toptions.check_host_ip = 0;\n\n\thost_hostkeys = init_hostkeys();\n\tfor (i = 0; i < num_user_hostfiles; i++)\n\t\tload_hostkeys(host_hostkeys, host, user_hostfiles[i]);\n\tfor (i = 0; i < num_system_hostfiles; i++)\n\t\tload_hostkeys(host_hostkeys, host, system_hostfiles[i]);\n\n\tip_hostkeys = NULL;\n\tif (!want_cert && options.check_host_ip) {\n\t\tip_hostkeys = init_hostkeys();\n\t\tfor (i = 0; i < num_user_hostfiles; i++)\n\t\t\tload_hostkeys(ip_hostkeys, ip, user_hostfiles[i]);\n\t\tfor (i = 0; i < num_system_hostfiles; i++)\n\t\t\tload_hostkeys(ip_hostkeys, ip, system_hostfiles[i]);\n\t}\n\n retry:\n\t/* Reload these as they may have changed on cert->key downgrade */\n\twant_cert = sshkey_is_cert(host_key);\n\ttype = sshkey_type(host_key);\n\n\t/*\n\t * Check if the host key is present in the user's list of known\n\t * hosts or in the systemwide list.\n\t */\n\thost_status = check_key_in_hostkeys(host_hostkeys, host_key,\n\t    &host_found);\n\n\t/*\n\t * Also perform check for the ip address, skip the check if we are\n\t * localhost, looking for a certificate, or the hostname was an ip\n\t * address to begin with.\n\t */\n\tif (!want_cert && ip_hostkeys != NULL) {\n\t\tip_status = check_key_in_hostkeys(ip_hostkeys, host_key,\n\t\t    &ip_found);\n\t\tif (host_status == HOST_CHANGED &&\n\t\t    (ip_status != HOST_CHANGED || \n\t\t    (ip_found != NULL &&\n\t\t    !sshkey_equal(ip_found->key, host_found->key))))\n\t\t\thost_ip_differ = 1;\n\t} else\n\t\tip_status = host_status;\n\n\tswitch (host_status) {\n\tcase HOST_OK:\n\t\t/* The host is known and the key matches. */\n\t\tdebug(\"Host '%.200s' is known and matches the %s host %s.\",\n\t\t    host, type, want_cert ? \"certificate\" : \"key\");\n\t\tdebug(\"Found %s in %s:%lu\", want_cert ? \"CA key\" : \"key\",\n\t\t    host_found->file, host_found->line);\n\t\tif (want_cert &&\n\t\t    !check_host_cert(options.host_key_alias == NULL ?\n\t\t    hostname : options.host_key_alias, host_key))\n\t\t\tgoto fail;\n\t\tif (options.check_host_ip && ip_status == HOST_NEW) {\n\t\t\tif (readonly || want_cert)\n\t\t\t\tlogit(\"%s host key for IP address \"\n\t\t\t\t    \"'%.128s' not in list of known hosts.\",\n\t\t\t\t    type, ip);\n\t\t\telse if (!add_host_to_hostfile(user_hostfiles[0], ip,\n\t\t\t    host_key, options.hash_known_hosts))\n\t\t\t\tlogit(\"Failed to add the %s host key for IP \"\n\t\t\t\t    \"address '%.128s' to the list of known \"\n\t\t\t\t    \"hosts (%.500s).\", type, ip,\n\t\t\t\t    user_hostfiles[0]);\n\t\t\telse\n\t\t\t\tlogit(\"Warning: Permanently added the %s host \"\n\t\t\t\t    \"key for IP address '%.128s' to the list \"\n\t\t\t\t    \"of known hosts.\", type, ip);\n\t\t} else if (options.visual_host_key) {\n\t\t\tfp = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tra = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tlogit(\"Host key fingerprint is %s\\n%s\", fp, ra);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t}\n\t\thostkey_trusted = 1;\n\t\tbreak;\n\tcase HOST_NEW:\n\t\tif (options.host_key_alias == NULL && port != 0 &&\n\t\t    port != SSH_DEFAULT_PORT) {\n\t\t\tdebug(\"checking without port identifier\");\n\t\t\tif (check_host_key(hostname, hostaddr, 0, host_key,\n\t\t\t    ROQUIET, user_hostfiles, num_user_hostfiles,\n\t\t\t    system_hostfiles, num_system_hostfiles) == 0) {\n\t\t\t\tdebug(\"found matching key w/out port\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (readonly || want_cert)\n\t\t\tgoto fail;\n\t\t/* The host is new. */\n\t\tif (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_YES) {\n\t\t\t/*\n\t\t\t * User has requested strict host key checking.  We\n\t\t\t * will not add the host key automatically.  The only\n\t\t\t * alternative left is to abort.\n\t\t\t */\n\t\t\terror(\"No %s host key is known for %.200s and you \"\n\t\t\t    \"have requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t} else if (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_ASK) {\n\t\t\tchar msg1[1024], msg2[1024];\n\n\t\t\tif (show_other_keys(host_hostkeys, host_key))\n\t\t\t\tsnprintf(msg1, sizeof(msg1),\n\t\t\t\t    \"\\nbut keys of different type are already\"\n\t\t\t\t    \" known for this host.\");\n\t\t\telse\n\t\t\t\tsnprintf(msg1, sizeof(msg1), \".\");\n\t\t\t/* The default */\n\t\t\tfp = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tra = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tmsg2[0] = '\\0';\n\t\t\tif (options.verify_host_key_dns) {\n\t\t\t\tif (matching_host_key_dns)\n\t\t\t\t\tsnprintf(msg2, sizeof(msg2),\n\t\t\t\t\t    \"Matching host key fingerprint\"\n\t\t\t\t\t    \" found in DNS.\\n\");\n\t\t\t\telse\n\t\t\t\t\tsnprintf(msg2, sizeof(msg2),\n\t\t\t\t\t    \"No matching host key fingerprint\"\n\t\t\t\t\t    \" found in DNS.\\n\");\n\t\t\t}\n\t\t\tsnprintf(msg, sizeof(msg),\n\t\t\t    \"The authenticity of host '%.200s (%s)' can't be \"\n\t\t\t    \"established%s\\n\"\n\t\t\t    \"%s key fingerprint is %s.%s%s\\n%s\"\n\t\t\t    \"Are you sure you want to continue connecting \"\n\t\t\t    \"(yes/no)? \",\n\t\t\t    host, ip, msg1, type, fp,\n\t\t\t    options.visual_host_key ? \"\\n\" : \"\",\n\t\t\t    options.visual_host_key ? ra : \"\",\n\t\t\t    msg2);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t\tif (!confirm(msg))\n\t\t\t\tgoto fail;\n\t\t\thostkey_trusted = 1; /* user explicitly confirmed */\n\t\t}\n\t\t/*\n\t\t * If in \"new\" or \"off\" strict mode, add the key automatically\n\t\t * to the local known_hosts file.\n\t\t */\n\t\tif (options.check_host_ip && ip_status == HOST_NEW) {\n\t\t\tsnprintf(hostline, sizeof(hostline), \"%s,%s\", host, ip);\n\t\t\thostp = hostline;\n\t\t\tif (options.hash_known_hosts) {\n\t\t\t\t/* Add hash of host and IP separately */\n\t\t\t\tr = add_host_to_hostfile(user_hostfiles[0],\n\t\t\t\t    host, host_key, options.hash_known_hosts) &&\n\t\t\t\t    add_host_to_hostfile(user_hostfiles[0], ip,\n\t\t\t\t    host_key, options.hash_known_hosts);\n\t\t\t} else {\n\t\t\t\t/* Add unhashed \"host,ip\" */\n\t\t\t\tr = add_host_to_hostfile(user_hostfiles[0],\n\t\t\t\t    hostline, host_key,\n\t\t\t\t    options.hash_known_hosts);\n\t\t\t}\n\t\t} else {\n\t\t\tr = add_host_to_hostfile(user_hostfiles[0], host,\n\t\t\t    host_key, options.hash_known_hosts);\n\t\t\thostp = host;\n\t\t}\n\n\t\tif (!r)\n\t\t\tlogit(\"Failed to add the host to the list of known \"\n\t\t\t    \"hosts (%.500s).\", user_hostfiles[0]);\n\t\telse\n\t\t\tlogit(\"Warning: Permanently added '%.200s' (%s) to the \"\n\t\t\t    \"list of known hosts.\", hostp, type);\n\t\tbreak;\n\tcase HOST_REVOKED:\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"@       WARNING: REVOKED HOST KEY DETECTED!               @\");\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"The %s host key for %s is marked as revoked.\", type, host);\n\t\terror(\"This could mean that a stolen key is being used to\");\n\t\terror(\"impersonate this host.\");\n\n\t\t/*\n\t\t * If strict host key checking is in use, the user will have\n\t\t * to edit the key manually and we can only abort.\n\t\t */\n\t\tif (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\terror(\"%s host key for %.200s was revoked and you have \"\n\t\t\t    \"requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t}\n\t\tgoto continue_unsafe;\n\n\tcase HOST_CHANGED:\n\t\tif (want_cert) {\n\t\t\t/*\n\t\t\t * This is only a debug() since it is valid to have\n\t\t\t * CAs with wildcard DNS matches that don't match\n\t\t\t * all hosts that one might visit.\n\t\t\t */\n\t\t\tdebug(\"Host certificate authority does not \"\n\t\t\t    \"match %s in %s:%lu\", CA_MARKER,\n\t\t\t    host_found->file, host_found->line);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (readonly == ROQUIET)\n\t\t\tgoto fail;\n\t\tif (options.check_host_ip && host_ip_differ) {\n\t\t\tchar *key_msg;\n\t\t\tif (ip_status == HOST_NEW)\n\t\t\t\tkey_msg = \"is unknown\";\n\t\t\telse if (ip_status == HOST_OK)\n\t\t\t\tkey_msg = \"is unchanged\";\n\t\t\telse\n\t\t\t\tkey_msg = \"has a different value\";\n\t\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\t\terror(\"@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @\");\n\t\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\t\terror(\"The %s host key for %s has changed,\", type, host);\n\t\t\terror(\"and the key for the corresponding IP address %s\", ip);\n\t\t\terror(\"%s. This could either mean that\", key_msg);\n\t\t\terror(\"DNS SPOOFING is happening or the IP address for the host\");\n\t\t\terror(\"and its host key have changed at the same time.\");\n\t\t\tif (ip_status != HOST_NEW)\n\t\t\t\terror(\"Offending key for IP in %s:%lu\",\n\t\t\t\t    ip_found->file, ip_found->line);\n\t\t}\n\t\t/* The host key has changed. */\n\t\twarn_changed_key(host_key);\n\t\terror(\"Add correct host key in %.100s to get rid of this message.\",\n\t\t    user_hostfiles[0]);\n\t\terror(\"Offending %s key in %s:%lu\",\n\t\t    sshkey_type(host_found->key),\n\t\t    host_found->file, host_found->line);\n\n\t\t/*\n\t\t * If strict host key checking is in use, the user will have\n\t\t * to edit the key manually and we can only abort.\n\t\t */\n\t\tif (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\terror(\"%s host key for %.200s has changed and you have \"\n\t\t\t    \"requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t}\n\n continue_unsafe:\n\t\t/*\n\t\t * If strict host key checking has not been requested, allow\n\t\t * the connection but without MITM-able authentication or\n\t\t * forwarding.\n\t\t */\n\t\tif (options.password_authentication) {\n\t\t\terror(\"Password authentication is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.password_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.kbd_interactive_authentication) {\n\t\t\terror(\"Keyboard-interactive authentication is disabled\"\n\t\t\t    \" to avoid man-in-the-middle attacks.\");\n\t\t\toptions.kbd_interactive_authentication = 0;\n\t\t\toptions.challenge_response_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.challenge_response_authentication) {\n\t\t\terror(\"Challenge/response authentication is disabled\"\n\t\t\t    \" to avoid man-in-the-middle attacks.\");\n\t\t\toptions.challenge_response_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.forward_agent) {\n\t\t\terror(\"Agent forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.forward_agent = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.forward_x11) {\n\t\t\terror(\"X11 forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.forward_x11 = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.num_local_forwards > 0 ||\n\t\t    options.num_remote_forwards > 0) {\n\t\t\terror(\"Port forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.num_local_forwards =\n\t\t\t    options.num_remote_forwards = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.tun_open != SSH_TUNMODE_NO) {\n\t\t\terror(\"Tunnel forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.tun_open = SSH_TUNMODE_NO;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.exit_on_forward_failure && cancelled_forwarding)\n\t\t\tfatal(\"Error: forwarding disabled due to host key \"\n\t\t\t    \"check failure\");\n\t\t\n\t\t/*\n\t\t * XXX Should permit the user to change to use the new id.\n\t\t * This could be done by converting the host key to an\n\t\t * identifying sentence, tell that the host identifies itself\n\t\t * by that sentence, and ask the user if he/she wishes to\n\t\t * accept the authentication.\n\t\t */\n\t\tbreak;\n\tcase HOST_FOUND:\n\t\tfatal(\"internal error\");\n\t\tbreak;\n\t}\n\n\tif (options.check_host_ip && host_status != HOST_CHANGED &&\n\t    ip_status == HOST_CHANGED) {\n\t\tsnprintf(msg, sizeof(msg),\n\t\t    \"Warning: the %s host key for '%.200s' \"\n\t\t    \"differs from the key for the IP address '%.128s'\"\n\t\t    \"\\nOffending key for IP in %s:%lu\",\n\t\t    type, host, ip, ip_found->file, ip_found->line);\n\t\tif (host_status == HOST_OK) {\n\t\t\tlen = strlen(msg);\n\t\t\tsnprintf(msg + len, sizeof(msg) - len,\n\t\t\t    \"\\nMatching host key in %s:%lu\",\n\t\t\t    host_found->file, host_found->line);\n\t\t}\n\t\tif (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_ASK) {\n\t\t\tstrlcat(msg, \"\\nAre you sure you want \"\n\t\t\t    \"to continue connecting (yes/no)? \", sizeof(msg));\n\t\t\tif (!confirm(msg))\n\t\t\t\tgoto fail;\n\t\t} else if (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\tlogit(\"%s\", msg);\n\t\t\terror(\"Exiting, you have requested strict checking.\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tlogit(\"%s\", msg);\n\t\t}\n\t}\n\n\tif (!hostkey_trusted && options.update_hostkeys) {\n\t\tdebug(\"%s: hostkey not known or explicitly trusted: \"\n\t\t    \"disabling UpdateHostkeys\", __func__);\n\t\toptions.update_hostkeys = 0;\n\t}\n\n\tfree(ip);\n\tfree(host);\n\tif (host_hostkeys != NULL)\n\t\tfree_hostkeys(host_hostkeys);\n\tif (ip_hostkeys != NULL)\n\t\tfree_hostkeys(ip_hostkeys);\n\treturn 0;\n\nfail:\n\tif (want_cert && host_status != HOST_REVOKED) {\n\t\t/*\n\t\t * No matching certificate. Downgrade cert to raw key and\n\t\t * search normally.\n\t\t */\n\t\tdebug(\"No matching CA found. Retry with plain key\");\n\t\tif ((r = sshkey_from_private(host_key, &raw_key)) != 0)\n\t\t\tfatal(\"%s: sshkey_from_private: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tif ((r = sshkey_drop_cert(raw_key)) != 0)\n\t\t\tfatal(\"Couldn't drop certificate: %s\", ssh_err(r));\n\t\thost_key = raw_key;\n\t\tgoto retry;\n\t}\n\tsshkey_free(raw_key);\n\tfree(ip);\n\tfree(host);\n\tif (host_hostkeys != NULL)\n\t\tfree_hostkeys(host_hostkeys);\n\tif (ip_hostkeys != NULL)\n\t\tfree_hostkeys(ip_hostkeys);\n\treturn -1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "check_host_cert",
          "args": [
            "options.host_key_alias == NULL ?\n\t\t    hostname : options.host_key_alias",
            "host_key"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "check_host_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "732-756",
          "snippet": "static int\ncheck_host_cert(const char *host, const struct sshkey *key)\n{\n\tconst char *reason;\n\tint r;\n\n\tif (sshkey_cert_check_authority(key, 1, 0, host, &reason) != 0) {\n\t\terror(\"%s\", reason);\n\t\treturn 0;\n\t}\n\tif (sshbuf_len(key->cert->critical) != 0) {\n\t\terror(\"Certificate for %s contains unsupported \"\n\t\t    \"critical options(s)\", host);\n\t\treturn 0;\n\t}\n\tif ((r = sshkey_check_cert_sigtype(key,\n\t    options.ca_sign_algorithms)) != 0) {\n\t\tlogit(\"%s: certificate signature algorithm %s: %s\", __func__,\n\t\t    (key->cert == NULL || key->cert->signature_type == NULL) ?\n\t\t    \"(null)\" : key->cert->signature_type, ssh_err(r));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static int show_other_keys(struct hostkeys *, struct sshkey *);",
            "static void warn_changed_key(struct sshkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\nstatic int\ncheck_host_cert(const char *host, const struct sshkey *key)\n{\n\tconst char *reason;\n\tint r;\n\n\tif (sshkey_cert_check_authority(key, 1, 0, host, &reason) != 0) {\n\t\terror(\"%s\", reason);\n\t\treturn 0;\n\t}\n\tif (sshbuf_len(key->cert->critical) != 0) {\n\t\terror(\"Certificate for %s contains unsupported \"\n\t\t    \"critical options(s)\", host);\n\t\treturn 0;\n\t}\n\tif ((r = sshkey_check_cert_sigtype(key,\n\t    options.ca_sign_algorithms)) != 0) {\n\t\tlogit(\"%s: certificate signature algorithm %s: %s\", __func__,\n\t\t    (key->cert == NULL || key->cert->signature_type == NULL) ?\n\t\t    \"(null)\" : key->cert->signature_type, ssh_err(r));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "ip_found->key",
            "host_found->key"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_key_in_hostkeys",
          "args": [
            "ip_hostkeys",
            "host_key",
            "&ip_found"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "check_key_in_hostkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "395-402",
          "snippet": "HostStatus\ncheck_key_in_hostkeys(struct hostkeys *hostkeys, struct sshkey *key,\n    const struct hostkey_entry **found)\n{\n\tif (key == NULL)\n\t\tfatal(\"no key to look up\");\n\treturn check_hostkeys_by_key_or_type(hostkeys, key, 0, found);\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nHostStatus\ncheck_key_in_hostkeys(struct hostkeys *hostkeys, struct sshkey *key,\n    const struct hostkey_entry **found)\n{\n\tif (key == NULL)\n\t\tfatal(\"no key to look up\");\n\treturn check_hostkeys_by_key_or_type(hostkeys, key, 0, found);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "host_key"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_hostkeys",
          "args": [
            "ip_hostkeys",
            "ip",
            "system_hostfiles[i]"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "load_hostkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "270-289",
          "snippet": "void\nload_hostkeys(struct hostkeys *hostkeys, const char *host, const char *path)\n{\n\tint r;\n\tstruct load_callback_ctx ctx;\n\n\tctx.host = host;\n\tctx.num_loaded = 0;\n\tctx.hostkeys = hostkeys;\n\n\tif ((r = hostkeys_foreach(path, record_hostkey, &ctx, host, NULL,\n\t    HKF_WANT_MATCH|HKF_WANT_PARSE_KEY)) != 0) {\n\t\tif (r != SSH_ERR_SYSTEM_ERROR && errno != ENOENT)\n\t\t\tdebug(\"%s: hostkeys_foreach failed for %s: %s\",\n\t\t\t    __func__, path, ssh_err(r));\n\t}\n\tif (ctx.num_loaded != 0)\n\t\tdebug3(\"%s: loaded %lu keys from %s\", __func__,\n\t\t    ctx.num_loaded, host);\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nload_hostkeys(struct hostkeys *hostkeys, const char *host, const char *path)\n{\n\tint r;\n\tstruct load_callback_ctx ctx;\n\n\tctx.host = host;\n\tctx.num_loaded = 0;\n\tctx.hostkeys = hostkeys;\n\n\tif ((r = hostkeys_foreach(path, record_hostkey, &ctx, host, NULL,\n\t    HKF_WANT_MATCH|HKF_WANT_PARSE_KEY)) != 0) {\n\t\tif (r != SSH_ERR_SYSTEM_ERROR && errno != ENOENT)\n\t\t\tdebug(\"%s: hostkeys_foreach failed for %s: %s\",\n\t\t\t    __func__, path, ssh_err(r));\n\t}\n\tif (ctx.num_loaded != 0)\n\t\tdebug3(\"%s: loaded %lu keys from %s\", __func__,\n\t\t    ctx.num_loaded, host);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_hostkeys",
          "args": [],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "init_hostkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "221-228",
          "snippet": "struct hostkeys *\ninit_hostkeys(void)\n{\n\tstruct hostkeys *ret = xcalloc(1, sizeof(*ret));\n\n\tret->entries = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct hostkeys *\ninit_hostkeys(void)\n{\n\tstruct hostkeys *ret = xcalloc(1, sizeof(*ret));\n\n\tret->entries = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "hostname",
            "ip"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hostfile_hostname_ipaddr",
          "args": [
            "hostname",
            "hostaddr",
            "port",
            "&host",
            "&ip"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "get_hostfile_hostname_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "777-829",
          "snippet": "void\nget_hostfile_hostname_ipaddr(char *hostname, struct sockaddr *hostaddr,\n    u_short port, char **hostfile_hostname, char **hostfile_ipaddr)\n{\n\tchar ntop[NI_MAXHOST];\n\tsocklen_t addrlen;\n\n\tswitch (hostaddr == NULL ? -1 : hostaddr->sa_family) {\n\tcase -1:\n\t\taddrlen = 0;\n\t\tbreak;\n\tcase AF_INET:\n\t\taddrlen = sizeof(struct sockaddr_in);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tbreak;\n\tdefault:\n\t\taddrlen = sizeof(struct sockaddr);\n\t\tbreak;\n\t}\n\n\t/*\n\t * We don't have the remote ip-address for connections\n\t * using a proxy command\n\t */\n\tif (hostfile_ipaddr != NULL) {\n\t\tif (options.proxy_command == NULL) {\n\t\t\tif (getnameinfo(hostaddr, addrlen,\n\t\t\t    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST) != 0)\n\t\t\tfatal(\"%s: getnameinfo failed\", __func__);\n\t\t\t*hostfile_ipaddr = put_host_port(ntop, port);\n\t\t} else {\n\t\t\t*hostfile_ipaddr = xstrdup(\"<no hostip for proxy \"\n\t\t\t    \"command>\");\n\t\t}\n\t}\n\n\t/*\n\t * Allow the user to record the key under a different name or\n\t * differentiate a non-standard port.  This is useful for ssh\n\t * tunneling over forwarded connections or if you run multiple\n\t * sshd's on different ports on the same machine.\n\t */\n\tif (hostfile_hostname != NULL) {\n\t\tif (options.host_key_alias != NULL) {\n\t\t\t*hostfile_hostname = xstrdup(options.host_key_alias);\n\t\t\tdebug(\"using hostkeyalias: %s\", *hostfile_hostname);\n\t\t} else {\n\t\t\t*hostfile_hostname = put_host_port(hostname, port);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nvoid\nget_hostfile_hostname_ipaddr(char *hostname, struct sockaddr *hostaddr,\n    u_short port, char **hostfile_hostname, char **hostfile_ipaddr)\n{\n\tchar ntop[NI_MAXHOST];\n\tsocklen_t addrlen;\n\n\tswitch (hostaddr == NULL ? -1 : hostaddr->sa_family) {\n\tcase -1:\n\t\taddrlen = 0;\n\t\tbreak;\n\tcase AF_INET:\n\t\taddrlen = sizeof(struct sockaddr_in);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tbreak;\n\tdefault:\n\t\taddrlen = sizeof(struct sockaddr);\n\t\tbreak;\n\t}\n\n\t/*\n\t * We don't have the remote ip-address for connections\n\t * using a proxy command\n\t */\n\tif (hostfile_ipaddr != NULL) {\n\t\tif (options.proxy_command == NULL) {\n\t\t\tif (getnameinfo(hostaddr, addrlen,\n\t\t\t    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST) != 0)\n\t\t\tfatal(\"%s: getnameinfo failed\", __func__);\n\t\t\t*hostfile_ipaddr = put_host_port(ntop, port);\n\t\t} else {\n\t\t\t*hostfile_ipaddr = xstrdup(\"<no hostip for proxy \"\n\t\t\t    \"command>\");\n\t\t}\n\t}\n\n\t/*\n\t * Allow the user to record the key under a different name or\n\t * differentiate a non-standard port.  This is useful for ssh\n\t * tunneling over forwarded connections or if you run multiple\n\t * sshd's on different ports on the same machine.\n\t */\n\tif (hostfile_hostname != NULL) {\n\t\tif (options.host_key_alias != NULL) {\n\t\t\t*hostfile_hostname = xstrdup(options.host_key_alias);\n\t\t\tdebug(\"using hostkeyalias: %s\", *hostfile_hostname);\n\t\t} else {\n\t\t\t*hostfile_hostname = put_host_port(hostname, port);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sockaddr_is_local",
          "args": [
            "hostaddr"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "sockaddr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "758-771",
          "snippet": "static int\nsockaddr_is_local(struct sockaddr *hostaddr)\n{\n\tswitch (hostaddr->sa_family) {\n\tcase AF_INET:\n\t\treturn (ntohl(((struct sockaddr_in *)hostaddr)->\n\t\t    sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;\n\tcase AF_INET6:\n\t\treturn IN6_IS_ADDR_LOOPBACK(\n\t\t    &(((struct sockaddr_in6 *)hostaddr)->sin6_addr));\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nsockaddr_is_local(struct sockaddr *hostaddr)\n{\n\tswitch (hostaddr->sa_family) {\n\tcase AF_INET:\n\t\treturn (ntohl(((struct sockaddr_in *)hostaddr)->\n\t\t    sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;\n\tcase AF_INET6:\n\t\treturn IN6_IS_ADDR_LOOPBACK(\n\t\t    &(((struct sockaddr_in6 *)hostaddr)->sin6_addr));\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define ROQUIET\t2\n\nstatic int matching_host_key_dns = 0;\nextern Options options;\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\nstatic int\ncheck_host_key(char *hostname, struct sockaddr *hostaddr, u_short port,\n    struct sshkey *host_key, int readonly,\n    char **user_hostfiles, u_int num_user_hostfiles,\n    char **system_hostfiles, u_int num_system_hostfiles)\n{\n\tHostStatus host_status;\n\tHostStatus ip_status;\n\tstruct sshkey *raw_key = NULL;\n\tchar *ip = NULL, *host = NULL;\n\tchar hostline[1000], *hostp, *fp, *ra;\n\tchar msg[1024];\n\tconst char *type;\n\tconst struct hostkey_entry *host_found, *ip_found;\n\tint len, cancelled_forwarding = 0;\n\tint local = sockaddr_is_local(hostaddr);\n\tint r, want_cert = sshkey_is_cert(host_key), host_ip_differ = 0;\n\tint hostkey_trusted = 0; /* Known or explicitly accepted by user */\n\tstruct hostkeys *host_hostkeys, *ip_hostkeys;\n\tu_int i;\n\n\t/*\n\t * Force accepting of the host key for loopback/localhost. The\n\t * problem is that if the home directory is NFS-mounted to multiple\n\t * machines, localhost will refer to a different machine in each of\n\t * them, and the user will get bogus HOST_CHANGED warnings.  This\n\t * essentially disables host authentication for localhost; however,\n\t * this is probably not a real problem.\n\t */\n\tif (options.no_host_authentication_for_localhost == 1 && local &&\n\t    options.host_key_alias == NULL) {\n\t\tdebug(\"Forcing accepting of host key for \"\n\t\t    \"loopback/localhost.\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Prepare the hostname and address strings used for hostkey lookup.\n\t * In some cases, these will have a port number appended.\n\t */\n\tget_hostfile_hostname_ipaddr(hostname, hostaddr, port, &host, &ip);\n\n\t/*\n\t * Turn off check_host_ip if the connection is to localhost, via proxy\n\t * command or if we don't have a hostname to compare with\n\t */\n\tif (options.check_host_ip && (local ||\n\t    strcmp(hostname, ip) == 0 || options.proxy_command != NULL))\n\t\toptions.check_host_ip = 0;\n\n\thost_hostkeys = init_hostkeys();\n\tfor (i = 0; i < num_user_hostfiles; i++)\n\t\tload_hostkeys(host_hostkeys, host, user_hostfiles[i]);\n\tfor (i = 0; i < num_system_hostfiles; i++)\n\t\tload_hostkeys(host_hostkeys, host, system_hostfiles[i]);\n\n\tip_hostkeys = NULL;\n\tif (!want_cert && options.check_host_ip) {\n\t\tip_hostkeys = init_hostkeys();\n\t\tfor (i = 0; i < num_user_hostfiles; i++)\n\t\t\tload_hostkeys(ip_hostkeys, ip, user_hostfiles[i]);\n\t\tfor (i = 0; i < num_system_hostfiles; i++)\n\t\t\tload_hostkeys(ip_hostkeys, ip, system_hostfiles[i]);\n\t}\n\n retry:\n\t/* Reload these as they may have changed on cert->key downgrade */\n\twant_cert = sshkey_is_cert(host_key);\n\ttype = sshkey_type(host_key);\n\n\t/*\n\t * Check if the host key is present in the user's list of known\n\t * hosts or in the systemwide list.\n\t */\n\thost_status = check_key_in_hostkeys(host_hostkeys, host_key,\n\t    &host_found);\n\n\t/*\n\t * Also perform check for the ip address, skip the check if we are\n\t * localhost, looking for a certificate, or the hostname was an ip\n\t * address to begin with.\n\t */\n\tif (!want_cert && ip_hostkeys != NULL) {\n\t\tip_status = check_key_in_hostkeys(ip_hostkeys, host_key,\n\t\t    &ip_found);\n\t\tif (host_status == HOST_CHANGED &&\n\t\t    (ip_status != HOST_CHANGED || \n\t\t    (ip_found != NULL &&\n\t\t    !sshkey_equal(ip_found->key, host_found->key))))\n\t\t\thost_ip_differ = 1;\n\t} else\n\t\tip_status = host_status;\n\n\tswitch (host_status) {\n\tcase HOST_OK:\n\t\t/* The host is known and the key matches. */\n\t\tdebug(\"Host '%.200s' is known and matches the %s host %s.\",\n\t\t    host, type, want_cert ? \"certificate\" : \"key\");\n\t\tdebug(\"Found %s in %s:%lu\", want_cert ? \"CA key\" : \"key\",\n\t\t    host_found->file, host_found->line);\n\t\tif (want_cert &&\n\t\t    !check_host_cert(options.host_key_alias == NULL ?\n\t\t    hostname : options.host_key_alias, host_key))\n\t\t\tgoto fail;\n\t\tif (options.check_host_ip && ip_status == HOST_NEW) {\n\t\t\tif (readonly || want_cert)\n\t\t\t\tlogit(\"%s host key for IP address \"\n\t\t\t\t    \"'%.128s' not in list of known hosts.\",\n\t\t\t\t    type, ip);\n\t\t\telse if (!add_host_to_hostfile(user_hostfiles[0], ip,\n\t\t\t    host_key, options.hash_known_hosts))\n\t\t\t\tlogit(\"Failed to add the %s host key for IP \"\n\t\t\t\t    \"address '%.128s' to the list of known \"\n\t\t\t\t    \"hosts (%.500s).\", type, ip,\n\t\t\t\t    user_hostfiles[0]);\n\t\t\telse\n\t\t\t\tlogit(\"Warning: Permanently added the %s host \"\n\t\t\t\t    \"key for IP address '%.128s' to the list \"\n\t\t\t\t    \"of known hosts.\", type, ip);\n\t\t} else if (options.visual_host_key) {\n\t\t\tfp = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tra = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tlogit(\"Host key fingerprint is %s\\n%s\", fp, ra);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t}\n\t\thostkey_trusted = 1;\n\t\tbreak;\n\tcase HOST_NEW:\n\t\tif (options.host_key_alias == NULL && port != 0 &&\n\t\t    port != SSH_DEFAULT_PORT) {\n\t\t\tdebug(\"checking without port identifier\");\n\t\t\tif (check_host_key(hostname, hostaddr, 0, host_key,\n\t\t\t    ROQUIET, user_hostfiles, num_user_hostfiles,\n\t\t\t    system_hostfiles, num_system_hostfiles) == 0) {\n\t\t\t\tdebug(\"found matching key w/out port\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (readonly || want_cert)\n\t\t\tgoto fail;\n\t\t/* The host is new. */\n\t\tif (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_YES) {\n\t\t\t/*\n\t\t\t * User has requested strict host key checking.  We\n\t\t\t * will not add the host key automatically.  The only\n\t\t\t * alternative left is to abort.\n\t\t\t */\n\t\t\terror(\"No %s host key is known for %.200s and you \"\n\t\t\t    \"have requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t} else if (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_ASK) {\n\t\t\tchar msg1[1024], msg2[1024];\n\n\t\t\tif (show_other_keys(host_hostkeys, host_key))\n\t\t\t\tsnprintf(msg1, sizeof(msg1),\n\t\t\t\t    \"\\nbut keys of different type are already\"\n\t\t\t\t    \" known for this host.\");\n\t\t\telse\n\t\t\t\tsnprintf(msg1, sizeof(msg1), \".\");\n\t\t\t/* The default */\n\t\t\tfp = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tra = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tmsg2[0] = '\\0';\n\t\t\tif (options.verify_host_key_dns) {\n\t\t\t\tif (matching_host_key_dns)\n\t\t\t\t\tsnprintf(msg2, sizeof(msg2),\n\t\t\t\t\t    \"Matching host key fingerprint\"\n\t\t\t\t\t    \" found in DNS.\\n\");\n\t\t\t\telse\n\t\t\t\t\tsnprintf(msg2, sizeof(msg2),\n\t\t\t\t\t    \"No matching host key fingerprint\"\n\t\t\t\t\t    \" found in DNS.\\n\");\n\t\t\t}\n\t\t\tsnprintf(msg, sizeof(msg),\n\t\t\t    \"The authenticity of host '%.200s (%s)' can't be \"\n\t\t\t    \"established%s\\n\"\n\t\t\t    \"%s key fingerprint is %s.%s%s\\n%s\"\n\t\t\t    \"Are you sure you want to continue connecting \"\n\t\t\t    \"(yes/no)? \",\n\t\t\t    host, ip, msg1, type, fp,\n\t\t\t    options.visual_host_key ? \"\\n\" : \"\",\n\t\t\t    options.visual_host_key ? ra : \"\",\n\t\t\t    msg2);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t\tif (!confirm(msg))\n\t\t\t\tgoto fail;\n\t\t\thostkey_trusted = 1; /* user explicitly confirmed */\n\t\t}\n\t\t/*\n\t\t * If in \"new\" or \"off\" strict mode, add the key automatically\n\t\t * to the local known_hosts file.\n\t\t */\n\t\tif (options.check_host_ip && ip_status == HOST_NEW) {\n\t\t\tsnprintf(hostline, sizeof(hostline), \"%s,%s\", host, ip);\n\t\t\thostp = hostline;\n\t\t\tif (options.hash_known_hosts) {\n\t\t\t\t/* Add hash of host and IP separately */\n\t\t\t\tr = add_host_to_hostfile(user_hostfiles[0],\n\t\t\t\t    host, host_key, options.hash_known_hosts) &&\n\t\t\t\t    add_host_to_hostfile(user_hostfiles[0], ip,\n\t\t\t\t    host_key, options.hash_known_hosts);\n\t\t\t} else {\n\t\t\t\t/* Add unhashed \"host,ip\" */\n\t\t\t\tr = add_host_to_hostfile(user_hostfiles[0],\n\t\t\t\t    hostline, host_key,\n\t\t\t\t    options.hash_known_hosts);\n\t\t\t}\n\t\t} else {\n\t\t\tr = add_host_to_hostfile(user_hostfiles[0], host,\n\t\t\t    host_key, options.hash_known_hosts);\n\t\t\thostp = host;\n\t\t}\n\n\t\tif (!r)\n\t\t\tlogit(\"Failed to add the host to the list of known \"\n\t\t\t    \"hosts (%.500s).\", user_hostfiles[0]);\n\t\telse\n\t\t\tlogit(\"Warning: Permanently added '%.200s' (%s) to the \"\n\t\t\t    \"list of known hosts.\", hostp, type);\n\t\tbreak;\n\tcase HOST_REVOKED:\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"@       WARNING: REVOKED HOST KEY DETECTED!               @\");\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"The %s host key for %s is marked as revoked.\", type, host);\n\t\terror(\"This could mean that a stolen key is being used to\");\n\t\terror(\"impersonate this host.\");\n\n\t\t/*\n\t\t * If strict host key checking is in use, the user will have\n\t\t * to edit the key manually and we can only abort.\n\t\t */\n\t\tif (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\terror(\"%s host key for %.200s was revoked and you have \"\n\t\t\t    \"requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t}\n\t\tgoto continue_unsafe;\n\n\tcase HOST_CHANGED:\n\t\tif (want_cert) {\n\t\t\t/*\n\t\t\t * This is only a debug() since it is valid to have\n\t\t\t * CAs with wildcard DNS matches that don't match\n\t\t\t * all hosts that one might visit.\n\t\t\t */\n\t\t\tdebug(\"Host certificate authority does not \"\n\t\t\t    \"match %s in %s:%lu\", CA_MARKER,\n\t\t\t    host_found->file, host_found->line);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (readonly == ROQUIET)\n\t\t\tgoto fail;\n\t\tif (options.check_host_ip && host_ip_differ) {\n\t\t\tchar *key_msg;\n\t\t\tif (ip_status == HOST_NEW)\n\t\t\t\tkey_msg = \"is unknown\";\n\t\t\telse if (ip_status == HOST_OK)\n\t\t\t\tkey_msg = \"is unchanged\";\n\t\t\telse\n\t\t\t\tkey_msg = \"has a different value\";\n\t\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\t\terror(\"@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @\");\n\t\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\t\terror(\"The %s host key for %s has changed,\", type, host);\n\t\t\terror(\"and the key for the corresponding IP address %s\", ip);\n\t\t\terror(\"%s. This could either mean that\", key_msg);\n\t\t\terror(\"DNS SPOOFING is happening or the IP address for the host\");\n\t\t\terror(\"and its host key have changed at the same time.\");\n\t\t\tif (ip_status != HOST_NEW)\n\t\t\t\terror(\"Offending key for IP in %s:%lu\",\n\t\t\t\t    ip_found->file, ip_found->line);\n\t\t}\n\t\t/* The host key has changed. */\n\t\twarn_changed_key(host_key);\n\t\terror(\"Add correct host key in %.100s to get rid of this message.\",\n\t\t    user_hostfiles[0]);\n\t\terror(\"Offending %s key in %s:%lu\",\n\t\t    sshkey_type(host_found->key),\n\t\t    host_found->file, host_found->line);\n\n\t\t/*\n\t\t * If strict host key checking is in use, the user will have\n\t\t * to edit the key manually and we can only abort.\n\t\t */\n\t\tif (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\terror(\"%s host key for %.200s has changed and you have \"\n\t\t\t    \"requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t}\n\n continue_unsafe:\n\t\t/*\n\t\t * If strict host key checking has not been requested, allow\n\t\t * the connection but without MITM-able authentication or\n\t\t * forwarding.\n\t\t */\n\t\tif (options.password_authentication) {\n\t\t\terror(\"Password authentication is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.password_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.kbd_interactive_authentication) {\n\t\t\terror(\"Keyboard-interactive authentication is disabled\"\n\t\t\t    \" to avoid man-in-the-middle attacks.\");\n\t\t\toptions.kbd_interactive_authentication = 0;\n\t\t\toptions.challenge_response_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.challenge_response_authentication) {\n\t\t\terror(\"Challenge/response authentication is disabled\"\n\t\t\t    \" to avoid man-in-the-middle attacks.\");\n\t\t\toptions.challenge_response_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.forward_agent) {\n\t\t\terror(\"Agent forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.forward_agent = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.forward_x11) {\n\t\t\terror(\"X11 forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.forward_x11 = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.num_local_forwards > 0 ||\n\t\t    options.num_remote_forwards > 0) {\n\t\t\terror(\"Port forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.num_local_forwards =\n\t\t\t    options.num_remote_forwards = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.tun_open != SSH_TUNMODE_NO) {\n\t\t\terror(\"Tunnel forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.tun_open = SSH_TUNMODE_NO;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.exit_on_forward_failure && cancelled_forwarding)\n\t\t\tfatal(\"Error: forwarding disabled due to host key \"\n\t\t\t    \"check failure\");\n\t\t\n\t\t/*\n\t\t * XXX Should permit the user to change to use the new id.\n\t\t * This could be done by converting the host key to an\n\t\t * identifying sentence, tell that the host identifies itself\n\t\t * by that sentence, and ask the user if he/she wishes to\n\t\t * accept the authentication.\n\t\t */\n\t\tbreak;\n\tcase HOST_FOUND:\n\t\tfatal(\"internal error\");\n\t\tbreak;\n\t}\n\n\tif (options.check_host_ip && host_status != HOST_CHANGED &&\n\t    ip_status == HOST_CHANGED) {\n\t\tsnprintf(msg, sizeof(msg),\n\t\t    \"Warning: the %s host key for '%.200s' \"\n\t\t    \"differs from the key for the IP address '%.128s'\"\n\t\t    \"\\nOffending key for IP in %s:%lu\",\n\t\t    type, host, ip, ip_found->file, ip_found->line);\n\t\tif (host_status == HOST_OK) {\n\t\t\tlen = strlen(msg);\n\t\t\tsnprintf(msg + len, sizeof(msg) - len,\n\t\t\t    \"\\nMatching host key in %s:%lu\",\n\t\t\t    host_found->file, host_found->line);\n\t\t}\n\t\tif (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_ASK) {\n\t\t\tstrlcat(msg, \"\\nAre you sure you want \"\n\t\t\t    \"to continue connecting (yes/no)? \", sizeof(msg));\n\t\t\tif (!confirm(msg))\n\t\t\t\tgoto fail;\n\t\t} else if (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\tlogit(\"%s\", msg);\n\t\t\terror(\"Exiting, you have requested strict checking.\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tlogit(\"%s\", msg);\n\t\t}\n\t}\n\n\tif (!hostkey_trusted && options.update_hostkeys) {\n\t\tdebug(\"%s: hostkey not known or explicitly trusted: \"\n\t\t    \"disabling UpdateHostkeys\", __func__);\n\t\toptions.update_hostkeys = 0;\n\t}\n\n\tfree(ip);\n\tfree(host);\n\tif (host_hostkeys != NULL)\n\t\tfree_hostkeys(host_hostkeys);\n\tif (ip_hostkeys != NULL)\n\t\tfree_hostkeys(ip_hostkeys);\n\treturn 0;\n\nfail:\n\tif (want_cert && host_status != HOST_REVOKED) {\n\t\t/*\n\t\t * No matching certificate. Downgrade cert to raw key and\n\t\t * search normally.\n\t\t */\n\t\tdebug(\"No matching CA found. Retry with plain key\");\n\t\tif ((r = sshkey_from_private(host_key, &raw_key)) != 0)\n\t\t\tfatal(\"%s: sshkey_from_private: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tif ((r = sshkey_drop_cert(raw_key)) != 0)\n\t\t\tfatal(\"Couldn't drop certificate: %s\", ssh_err(r));\n\t\thost_key = raw_key;\n\t\tgoto retry;\n\t}\n\tsshkey_free(raw_key);\n\tfree(ip);\n\tfree(host);\n\tif (host_hostkeys != NULL)\n\t\tfree_hostkeys(host_hostkeys);\n\tif (ip_hostkeys != NULL)\n\t\tfree_hostkeys(ip_hostkeys);\n\treturn -1;\n}"
  },
  {
    "function_name": "get_hostfile_hostname_ipaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "777-829",
    "snippet": "void\nget_hostfile_hostname_ipaddr(char *hostname, struct sockaddr *hostaddr,\n    u_short port, char **hostfile_hostname, char **hostfile_ipaddr)\n{\n\tchar ntop[NI_MAXHOST];\n\tsocklen_t addrlen;\n\n\tswitch (hostaddr == NULL ? -1 : hostaddr->sa_family) {\n\tcase -1:\n\t\taddrlen = 0;\n\t\tbreak;\n\tcase AF_INET:\n\t\taddrlen = sizeof(struct sockaddr_in);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tbreak;\n\tdefault:\n\t\taddrlen = sizeof(struct sockaddr);\n\t\tbreak;\n\t}\n\n\t/*\n\t * We don't have the remote ip-address for connections\n\t * using a proxy command\n\t */\n\tif (hostfile_ipaddr != NULL) {\n\t\tif (options.proxy_command == NULL) {\n\t\t\tif (getnameinfo(hostaddr, addrlen,\n\t\t\t    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST) != 0)\n\t\t\tfatal(\"%s: getnameinfo failed\", __func__);\n\t\t\t*hostfile_ipaddr = put_host_port(ntop, port);\n\t\t} else {\n\t\t\t*hostfile_ipaddr = xstrdup(\"<no hostip for proxy \"\n\t\t\t    \"command>\");\n\t\t}\n\t}\n\n\t/*\n\t * Allow the user to record the key under a different name or\n\t * differentiate a non-standard port.  This is useful for ssh\n\t * tunneling over forwarded connections or if you run multiple\n\t * sshd's on different ports on the same machine.\n\t */\n\tif (hostfile_hostname != NULL) {\n\t\tif (options.host_key_alias != NULL) {\n\t\t\t*hostfile_hostname = xstrdup(options.host_key_alias);\n\t\t\tdebug(\"using hostkeyalias: %s\", *hostfile_hostname);\n\t\t} else {\n\t\t\t*hostfile_hostname = put_host_port(hostname, port);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_host_port",
          "args": [
            "hostname",
            "port"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "put_host_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "471-482",
          "snippet": "char *\nput_host_port(const char *host, u_short port)\n{\n\tchar *hoststr;\n\n\tif (port == 0 || port == SSH_DEFAULT_PORT)\n\t\treturn(xstrdup(host));\n\tif (asprintf(&hoststr, \"[%s]:%d\", host, (int)port) < 0)\n\t\tfatal(\"put_host_port: asprintf: %s\", strerror(errno));\n\tdebug3(\"put_host_port: %s\", hoststr);\n\treturn hoststr;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nput_host_port(const char *host, u_short port)\n{\n\tchar *hoststr;\n\n\tif (port == 0 || port == SSH_DEFAULT_PORT)\n\t\treturn(xstrdup(host));\n\tif (asprintf(&hoststr, \"[%s]:%d\", host, (int)port) < 0)\n\t\tfatal(\"put_host_port: asprintf: %s\", strerror(errno));\n\tdebug3(\"put_host_port: %s\", hoststr);\n\treturn hoststr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"using hostkeyalias: %s\"",
            "*hostfile_hostname"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "options.host_key_alias"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: getnameinfo failed\"",
            "__func__"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "hostaddr",
            "addrlen",
            "ntop",
            "sizeof(ntop)",
            "NULL",
            "0",
            "NI_NUMERICHOST"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "sshaix_getnameinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "415-434",
          "snippet": "int\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nvoid\nget_hostfile_hostname_ipaddr(char *hostname, struct sockaddr *hostaddr,\n    u_short port, char **hostfile_hostname, char **hostfile_ipaddr)\n{\n\tchar ntop[NI_MAXHOST];\n\tsocklen_t addrlen;\n\n\tswitch (hostaddr == NULL ? -1 : hostaddr->sa_family) {\n\tcase -1:\n\t\taddrlen = 0;\n\t\tbreak;\n\tcase AF_INET:\n\t\taddrlen = sizeof(struct sockaddr_in);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tbreak;\n\tdefault:\n\t\taddrlen = sizeof(struct sockaddr);\n\t\tbreak;\n\t}\n\n\t/*\n\t * We don't have the remote ip-address for connections\n\t * using a proxy command\n\t */\n\tif (hostfile_ipaddr != NULL) {\n\t\tif (options.proxy_command == NULL) {\n\t\t\tif (getnameinfo(hostaddr, addrlen,\n\t\t\t    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST) != 0)\n\t\t\tfatal(\"%s: getnameinfo failed\", __func__);\n\t\t\t*hostfile_ipaddr = put_host_port(ntop, port);\n\t\t} else {\n\t\t\t*hostfile_ipaddr = xstrdup(\"<no hostip for proxy \"\n\t\t\t    \"command>\");\n\t\t}\n\t}\n\n\t/*\n\t * Allow the user to record the key under a different name or\n\t * differentiate a non-standard port.  This is useful for ssh\n\t * tunneling over forwarded connections or if you run multiple\n\t * sshd's on different ports on the same machine.\n\t */\n\tif (hostfile_hostname != NULL) {\n\t\tif (options.host_key_alias != NULL) {\n\t\t\t*hostfile_hostname = xstrdup(options.host_key_alias);\n\t\t\tdebug(\"using hostkeyalias: %s\", *hostfile_hostname);\n\t\t} else {\n\t\t\t*hostfile_hostname = put_host_port(hostname, port);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "sockaddr_is_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "758-771",
    "snippet": "static int\nsockaddr_is_local(struct sockaddr *hostaddr)\n{\n\tswitch (hostaddr->sa_family) {\n\tcase AF_INET:\n\t\treturn (ntohl(((struct sockaddr_in *)hostaddr)->\n\t\t    sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;\n\tcase AF_INET6:\n\t\treturn IN6_IS_ADDR_LOOPBACK(\n\t\t    &(((struct sockaddr_in6 *)hostaddr)->sin6_addr));\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_LOOPBACK",
          "args": [
            "&(((struct sockaddr_in6 *)hostaddr)->sin6_addr)"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "((struct sockaddr_in *)hostaddr)->\n\t\t    sin_addr.s_addr"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nsockaddr_is_local(struct sockaddr *hostaddr)\n{\n\tswitch (hostaddr->sa_family) {\n\tcase AF_INET:\n\t\treturn (ntohl(((struct sockaddr_in *)hostaddr)->\n\t\t    sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;\n\tcase AF_INET6:\n\t\treturn IN6_IS_ADDR_LOOPBACK(\n\t\t    &(((struct sockaddr_in6 *)hostaddr)->sin6_addr));\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "check_host_cert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "732-756",
    "snippet": "static int\ncheck_host_cert(const char *host, const struct sshkey *key)\n{\n\tconst char *reason;\n\tint r;\n\n\tif (sshkey_cert_check_authority(key, 1, 0, host, &reason) != 0) {\n\t\terror(\"%s\", reason);\n\t\treturn 0;\n\t}\n\tif (sshbuf_len(key->cert->critical) != 0) {\n\t\terror(\"Certificate for %s contains unsupported \"\n\t\t    \"critical options(s)\", host);\n\t\treturn 0;\n\t}\n\tif ((r = sshkey_check_cert_sigtype(key,\n\t    options.ca_sign_algorithms)) != 0) {\n\t\tlogit(\"%s: certificate signature algorithm %s: %s\", __func__,\n\t\t    (key->cert == NULL || key->cert->signature_type == NULL) ?\n\t\t    \"(null)\" : key->cert->signature_type, ssh_err(r));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "static int show_other_keys(struct hostkeys *, struct sshkey *);",
      "static void warn_changed_key(struct sshkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s: certificate signature algorithm %s: %s\"",
            "__func__",
            "(key->cert == NULL || key->cert->signature_type == NULL) ?\n\t\t    \"(null)\" : key->cert->signature_type",
            "ssh_err(r)"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_check_cert_sigtype",
          "args": [
            "key",
            "options.ca_sign_algorithms"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_check_cert_sigtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2327-2339",
          "snippet": "int\nsshkey_check_cert_sigtype(const struct sshkey *key, const char *allowed)\n{\n\tif (key == NULL || allowed == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_type_is_cert(key->type))\n\t\treturn 0;\n\tif (key->cert == NULL || key->cert->signature_type == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (match_pattern_list(key->cert->signature_type, allowed, 0) != 1)\n\t\treturn SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_check_cert_sigtype(const struct sshkey *key, const char *allowed)\n{\n\tif (key == NULL || allowed == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_type_is_cert(key->type))\n\t\treturn 0;\n\tif (key->cert == NULL || key->cert->signature_type == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (match_pattern_list(key->cert->signature_type, allowed, 0) != 1)\n\t\treturn SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Certificate for %s contains unsupported \"\n\t\t    \"critical options(s)\"",
            "host"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "key->cert->critical"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_cert_check_authority",
          "args": [
            "key",
            "1",
            "0",
            "host",
            "&reason"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_cert_check_authority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2673-2728",
          "snippet": "int\nsshkey_cert_check_authority(const struct sshkey *k,\n    int want_host, int require_principal,\n    const char *name, const char **reason)\n{\n\tu_int i, principal_matches;\n\ttime_t now = time(NULL);\n\n\tif (reason != NULL)\n\t\t*reason = NULL;\n\n\tif (want_host) {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_HOST) {\n\t\t\t*reason = \"Certificate invalid: not a host certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_USER) {\n\t\t\t*reason = \"Certificate invalid: not a user certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\tif (now < 0) {\n\t\t/* yikes - system clock before epoch! */\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now < k->cert->valid_after) {\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now >= k->cert->valid_before) {\n\t\t*reason = \"Certificate invalid: expired\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif (k->cert->nprincipals == 0) {\n\t\tif (require_principal) {\n\t\t\t*reason = \"Certificate lacks principal list\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else if (name != NULL) {\n\t\tprincipal_matches = 0;\n\t\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\t\tif (strcmp(name, k->cert->principals[i]) == 0) {\n\t\t\t\tprincipal_matches = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!principal_matches) {\n\t\t\t*reason = \"Certificate invalid: name is not a listed \"\n\t\t\t    \"principal\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_cert_check_authority(const struct sshkey *k,\n    int want_host, int require_principal,\n    const char *name, const char **reason)\n{\n\tu_int i, principal_matches;\n\ttime_t now = time(NULL);\n\n\tif (reason != NULL)\n\t\t*reason = NULL;\n\n\tif (want_host) {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_HOST) {\n\t\t\t*reason = \"Certificate invalid: not a host certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_USER) {\n\t\t\t*reason = \"Certificate invalid: not a user certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\tif (now < 0) {\n\t\t/* yikes - system clock before epoch! */\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now < k->cert->valid_after) {\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif ((u_int64_t)now >= k->cert->valid_before) {\n\t\t*reason = \"Certificate invalid: expired\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif (k->cert->nprincipals == 0) {\n\t\tif (require_principal) {\n\t\t\t*reason = \"Certificate lacks principal list\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else if (name != NULL) {\n\t\tprincipal_matches = 0;\n\t\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\t\tif (strcmp(name, k->cert->principals[i]) == 0) {\n\t\t\t\tprincipal_matches = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!principal_matches) {\n\t\t\t*reason = \"Certificate invalid: name is not a listed \"\n\t\t\t    \"principal\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\nstatic int\ncheck_host_cert(const char *host, const struct sshkey *key)\n{\n\tconst char *reason;\n\tint r;\n\n\tif (sshkey_cert_check_authority(key, 1, 0, host, &reason) != 0) {\n\t\terror(\"%s\", reason);\n\t\treturn 0;\n\t}\n\tif (sshbuf_len(key->cert->critical) != 0) {\n\t\terror(\"Certificate for %s contains unsupported \"\n\t\t    \"critical options(s)\", host);\n\t\treturn 0;\n\t}\n\tif ((r = sshkey_check_cert_sigtype(key,\n\t    options.ca_sign_algorithms)) != 0) {\n\t\tlogit(\"%s: certificate signature algorithm %s: %s\", __func__,\n\t\t    (key->cert == NULL || key->cert->signature_type == NULL) ?\n\t\t    \"(null)\" : key->cert->signature_type, ssh_err(r));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "708-730",
    "snippet": "static int\nconfirm(const char *prompt)\n{\n\tconst char *msg, *again = \"Please type 'yes' or 'no': \";\n\tchar *p;\n\tint ret = -1;\n\n\tif (options.batch_mode)\n\t\treturn 0;\n\tfor (msg = prompt;;msg = again) {\n\t\tp = read_passphrase(msg, RP_ECHO);\n\t\tif (p == NULL)\n\t\t\treturn 0;\n\t\tp[strcspn(p, \"\\n\")] = '\\0';\n\t\tif (p[0] == '\\0' || strcasecmp(p, \"no\") == 0)\n\t\t\tret = 0;\n\t\telse if (strcasecmp(p, \"yes\") == 0)\n\t\t\tret = 1;\n\t\tfree(p);\n\t\tif (ret != -1)\n\t\t\treturn ret;\n\t}\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "p",
            "\"yes\""
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "p",
            "\"no\""
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "p",
            "\"\\n\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_passphrase",
          "args": [
            "msg",
            "RP_ECHO"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "read_passphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "117-166",
          "snippet": "char *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nconfirm(const char *prompt)\n{\n\tconst char *msg, *again = \"Please type 'yes' or 'no': \";\n\tchar *p;\n\tint ret = -1;\n\n\tif (options.batch_mode)\n\t\treturn 0;\n\tfor (msg = prompt;;msg = again) {\n\t\tp = read_passphrase(msg, RP_ECHO);\n\t\tif (p == NULL)\n\t\t\treturn 0;\n\t\tp[strcspn(p, \"\\n\")] = '\\0';\n\t\tif (p[0] == '\\0' || strcasecmp(p, \"no\") == 0)\n\t\t\tret = 0;\n\t\telse if (strcasecmp(p, \"yes\") == 0)\n\t\t\tret = 1;\n\t\tfree(p);\n\t\tif (ret != -1)\n\t\t\treturn ret;\n\t}\n}"
  },
  {
    "function_name": "ssh_exchange_identification",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "620-705",
    "snippet": "void\nssh_exchange_identification(int timeout_ms)\n{\n\tchar buf[256], remote_version[256];\t/* must be same size! */\n\tint remote_major, remote_minor, mismatch;\n\tint connection_in = packet_get_connection_in();\n\tint connection_out = packet_get_connection_out();\n\tu_int i, n;\n\tsize_t len;\n\tint rc;\n\n\tsend_client_banner(connection_out, 0);\n\n\t/* Read other side's version identification. */\n\tfor (n = 0;;) {\n\t\tfor (i = 0; i < sizeof(buf) - 1; i++) {\n\t\t\tif (timeout_ms > 0) {\n\t\t\t\trc = waitrfd(connection_in, &timeout_ms);\n\t\t\t\tif (rc == -1 && errno == ETIMEDOUT) {\n\t\t\t\t\tfatal(\"Connection timed out during \"\n\t\t\t\t\t    \"banner exchange\");\n\t\t\t\t} else if (rc == -1) {\n\t\t\t\t\tfatal(\"%s: %s\",\n\t\t\t\t\t    __func__, strerror(errno));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlen = atomicio(read, connection_in, &buf[i], 1);\n\t\t\tif (len != 1 && errno == EPIPE)\n\t\t\t\tfatal(\"ssh_exchange_identification: \"\n\t\t\t\t    \"Connection closed by remote host\");\n\t\t\telse if (len != 1)\n\t\t\t\tfatal(\"ssh_exchange_identification: \"\n\t\t\t\t    \"read: %.100s\", strerror(errno));\n\t\t\tif (buf[i] == '\\r') {\n\t\t\t\tbuf[i] = '\\n';\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tcontinue;\t\t/**XXX wait for \\n */\n\t\t\t}\n\t\t\tif (buf[i] == '\\n') {\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++n > 65536)\n\t\t\t\tfatal(\"ssh_exchange_identification: \"\n\t\t\t\t    \"No banner received\");\n\t\t}\n\t\tbuf[sizeof(buf) - 1] = 0;\n\t\tif (strncmp(buf, \"SSH-\", 4) == 0)\n\t\t\tbreak;\n\t\tdebug(\"ssh_exchange_identification: %s\", buf);\n\t}\n\tserver_version_string = xstrdup(buf);\n\n\t/*\n\t * Check that the versions match.  In future this might accept\n\t * several versions and set appropriate flags to handle them.\n\t */\n\tif (sscanf(server_version_string, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3)\n\t\tfatal(\"Bad remote protocol version identification: '%.100s'\", buf);\n\tdebug(\"Remote protocol version %d.%d, remote software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\n\tactive_state->compat = compat_datafellows(remote_version);\n\tmismatch = 0;\n\n\tswitch (remote_major) {\n\tcase 2:\n\t\tbreak;\n\tcase 1:\n\t\tif (remote_minor != 99)\n\t\t\tmismatch = 1;\n\t\tbreak;\n\tdefault:\n\t\tmismatch = 1;\n\t\tbreak;\n\t}\n\tif (mismatch)\n\t\tfatal(\"Protocol major versions differ: %d vs. %d\",\n\t\t    PROTOCOL_MAJOR_2, remote_major);\n\tif ((datafellows & SSH_BUG_RSASIGMD5) != 0)\n\t\tlogit(\"Server version \\\"%.100s\\\" uses unsafe RSA signature \"\n\t\t    \"scheme; disabling use of RSA keys\", remote_version);\n\tchop(server_version_string);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *server_version_string = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chop",
          "args": [
            "server_version_string"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "chop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "76-89",
          "snippet": "char *\nchop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nchop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Server version \\\"%.100s\\\" uses unsafe RSA signature \"\n\t\t    \"scheme; disabling use of RSA keys\"",
            "remote_version"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Protocol major versions differ: %d vs. %d\"",
            "PROTOCOL_MAJOR_2",
            "remote_major"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_datafellows",
          "args": [
            "remote_version"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "compat_datafellows",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/compat.c",
          "lines": "44-158",
          "snippet": "u_int\ncompat_datafellows(const char *version)\n{\n\tint i;\n\tstatic struct {\n\t\tchar\t*pat;\n\t\tint\tbugs;\n\t} check[] = {\n\t\t{ \"OpenSSH_2.*,\"\n\t\t  \"OpenSSH_3.0*,\"\n\t\t  \"OpenSSH_3.1*\",\tSSH_BUG_EXTEOF|SSH_OLD_FORWARD_ADDR|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_3.*\",\tSSH_OLD_FORWARD_ADDR|SSH_BUG_SIGTYPE },\n\t\t{ \"Sun_SSH_1.0*\",\tSSH_BUG_NOREKEY|SSH_BUG_EXTEOF|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_2*,\"\n\t\t  \"OpenSSH_3*,\"\n\t\t  \"OpenSSH_4*\",\t\tSSH_BUG_SIGTYPE },\n\t\t{ \"OpenSSH_5*\",\t\tSSH_NEW_OPENSSH|SSH_BUG_DYNAMIC_RPORT|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_6.6.1*\",\tSSH_NEW_OPENSSH|SSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_6.5*,\"\n\t\t  \"OpenSSH_6.6*\",\tSSH_NEW_OPENSSH|SSH_BUG_CURVE25519PAD|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_7.0*,\"\n\t\t  \"OpenSSH_7.1*,\"\n\t\t  \"OpenSSH_7.2*,\"\n\t\t  \"OpenSSH_7.3*,\"\n\t\t  \"OpenSSH_7.4*,\"\n\t\t  \"OpenSSH_7.5*,\"\n\t\t  \"OpenSSH_7.6*,\"\n\t\t  \"OpenSSH_7.7*\",\tSSH_NEW_OPENSSH|SSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH*\",\t\tSSH_NEW_OPENSSH },\n\t\t{ \"*MindTerm*\",\t\t0 },\n\t\t{ \"3.0.*\",\t\tSSH_BUG_DEBUG },\n\t\t{ \"3.0 SecureCRT*\",\tSSH_OLD_SESSIONID },\n\t\t{ \"1.7 SecureFX*\",\tSSH_OLD_SESSIONID },\n\t\t{ \"1.2.18*,\"\n\t\t  \"1.2.19*,\"\n\t\t  \"1.2.20*,\"\n\t\t  \"1.2.21*,\"\n\t\t  \"1.2.22*\",\t\tSSH_BUG_IGNOREMSG },\n\t\t{ \"1.3.2*\",\t\t/* F-Secure */\n\t\t\t\t\tSSH_BUG_IGNOREMSG },\n\t\t{ \"Cisco-1.*\",\t\tSSH_BUG_DHGEX_LARGE|\n\t\t\t\t\tSSH_BUG_HOSTKEYS },\n\t\t{ \"*SSH Compatible Server*\",\t\t\t/* Netscreen */\n\t\t\t\t\tSSH_BUG_PASSWORDPAD },\n\t\t{ \"*OSU_0*,\"\n\t\t  \"OSU_1.0*,\"\n\t\t  \"OSU_1.1*,\"\n\t\t  \"OSU_1.2*,\"\n\t\t  \"OSU_1.3*,\"\n\t\t  \"OSU_1.4*,\"\n\t\t  \"OSU_1.5alpha1*,\"\n\t\t  \"OSU_1.5alpha2*,\"\n\t\t  \"OSU_1.5alpha3*\",\tSSH_BUG_PASSWORDPAD },\n\t\t{ \"*SSH_Version_Mapper*\",\n\t\t\t\t\tSSH_BUG_SCANNER },\n\t\t{ \"PuTTY_Local:*,\"\t/* dev versions < Sep 2014 */\n\t\t  \"PuTTY-Release-0.5*,\" /* 0.50-0.57, DH-GEX in >=0.52 */\n\t\t  \"PuTTY_Release_0.5*,\"\t/* 0.58-0.59 */\n\t\t  \"PuTTY_Release_0.60*,\"\n\t\t  \"PuTTY_Release_0.61*,\"\n\t\t  \"PuTTY_Release_0.62*,\"\n\t\t  \"PuTTY_Release_0.63*,\"\n\t\t  \"PuTTY_Release_0.64*\",\n\t\t\t\t\tSSH_OLD_DHGEX },\n\t\t{ \"FuTTY*\",\t\tSSH_OLD_DHGEX }, /* Putty Fork */\n\t\t{ \"Probe-*\",\n\t\t\t\t\tSSH_BUG_PROBE },\n\t\t{ \"TeraTerm SSH*,\"\n\t\t  \"TTSSH/1.5.*,\"\n\t\t  \"TTSSH/2.1*,\"\n\t\t  \"TTSSH/2.2*,\"\n\t\t  \"TTSSH/2.3*,\"\n\t\t  \"TTSSH/2.4*,\"\n\t\t  \"TTSSH/2.5*,\"\n\t\t  \"TTSSH/2.6*,\"\n\t\t  \"TTSSH/2.70*,\"\n\t\t  \"TTSSH/2.71*,\"\n\t\t  \"TTSSH/2.72*\",\tSSH_BUG_HOSTKEYS },\n\t\t{ \"WinSCP_release_4*,\"\n\t\t  \"WinSCP_release_5.0*,\"\n\t\t  \"WinSCP_release_5.1,\"\n\t\t  \"WinSCP_release_5.1.*,\"\n\t\t  \"WinSCP_release_5.5,\"\n\t\t  \"WinSCP_release_5.5.*,\"\n\t\t  \"WinSCP_release_5.6,\"\n\t\t  \"WinSCP_release_5.6.*,\"\n\t\t  \"WinSCP_release_5.7,\"\n\t\t  \"WinSCP_release_5.7.1,\"\n\t\t  \"WinSCP_release_5.7.2,\"\n\t\t  \"WinSCP_release_5.7.3,\"\n\t\t  \"WinSCP_release_5.7.4\",\n\t\t\t\t\tSSH_OLD_DHGEX },\n\t\t{ \"ConfD-*\",\n\t\t\t\t\tSSH_BUG_UTF8TTYMODE },\n\t\t{ \"Twisted_*\",\t\t0 },\n\t\t{ \"Twisted*\",\t\tSSH_BUG_DEBUG },\n\t\t{ NULL,\t\t\t0 }\n\t};\n\n\t/* process table, return first match */\n\tfor (i = 0; check[i].pat; i++) {\n\t\tif (match_pattern_list(version, check[i].pat, 0) == 1) {\n\t\t\tdebug(\"match: %s pat %s compat 0x%08x\",\n\t\t\t    version, check[i].pat, check[i].bugs);\n\t\t\tdatafellows = check[i].bugs;\t/* XXX for now */\n\t\t\treturn check[i].bugs;\n\t\t}\n\t}\n\tdebug(\"no match: %s\", version);\n\treturn 0;\n}",
          "includes": [
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int datafellows = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kex.h\"\n#include \"match.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint datafellows = 0;\n\nu_int\ncompat_datafellows(const char *version)\n{\n\tint i;\n\tstatic struct {\n\t\tchar\t*pat;\n\t\tint\tbugs;\n\t} check[] = {\n\t\t{ \"OpenSSH_2.*,\"\n\t\t  \"OpenSSH_3.0*,\"\n\t\t  \"OpenSSH_3.1*\",\tSSH_BUG_EXTEOF|SSH_OLD_FORWARD_ADDR|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_3.*\",\tSSH_OLD_FORWARD_ADDR|SSH_BUG_SIGTYPE },\n\t\t{ \"Sun_SSH_1.0*\",\tSSH_BUG_NOREKEY|SSH_BUG_EXTEOF|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_2*,\"\n\t\t  \"OpenSSH_3*,\"\n\t\t  \"OpenSSH_4*\",\t\tSSH_BUG_SIGTYPE },\n\t\t{ \"OpenSSH_5*\",\t\tSSH_NEW_OPENSSH|SSH_BUG_DYNAMIC_RPORT|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_6.6.1*\",\tSSH_NEW_OPENSSH|SSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_6.5*,\"\n\t\t  \"OpenSSH_6.6*\",\tSSH_NEW_OPENSSH|SSH_BUG_CURVE25519PAD|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_7.0*,\"\n\t\t  \"OpenSSH_7.1*,\"\n\t\t  \"OpenSSH_7.2*,\"\n\t\t  \"OpenSSH_7.3*,\"\n\t\t  \"OpenSSH_7.4*,\"\n\t\t  \"OpenSSH_7.5*,\"\n\t\t  \"OpenSSH_7.6*,\"\n\t\t  \"OpenSSH_7.7*\",\tSSH_NEW_OPENSSH|SSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH*\",\t\tSSH_NEW_OPENSSH },\n\t\t{ \"*MindTerm*\",\t\t0 },\n\t\t{ \"3.0.*\",\t\tSSH_BUG_DEBUG },\n\t\t{ \"3.0 SecureCRT*\",\tSSH_OLD_SESSIONID },\n\t\t{ \"1.7 SecureFX*\",\tSSH_OLD_SESSIONID },\n\t\t{ \"1.2.18*,\"\n\t\t  \"1.2.19*,\"\n\t\t  \"1.2.20*,\"\n\t\t  \"1.2.21*,\"\n\t\t  \"1.2.22*\",\t\tSSH_BUG_IGNOREMSG },\n\t\t{ \"1.3.2*\",\t\t/* F-Secure */\n\t\t\t\t\tSSH_BUG_IGNOREMSG },\n\t\t{ \"Cisco-1.*\",\t\tSSH_BUG_DHGEX_LARGE|\n\t\t\t\t\tSSH_BUG_HOSTKEYS },\n\t\t{ \"*SSH Compatible Server*\",\t\t\t/* Netscreen */\n\t\t\t\t\tSSH_BUG_PASSWORDPAD },\n\t\t{ \"*OSU_0*,\"\n\t\t  \"OSU_1.0*,\"\n\t\t  \"OSU_1.1*,\"\n\t\t  \"OSU_1.2*,\"\n\t\t  \"OSU_1.3*,\"\n\t\t  \"OSU_1.4*,\"\n\t\t  \"OSU_1.5alpha1*,\"\n\t\t  \"OSU_1.5alpha2*,\"\n\t\t  \"OSU_1.5alpha3*\",\tSSH_BUG_PASSWORDPAD },\n\t\t{ \"*SSH_Version_Mapper*\",\n\t\t\t\t\tSSH_BUG_SCANNER },\n\t\t{ \"PuTTY_Local:*,\"\t/* dev versions < Sep 2014 */\n\t\t  \"PuTTY-Release-0.5*,\" /* 0.50-0.57, DH-GEX in >=0.52 */\n\t\t  \"PuTTY_Release_0.5*,\"\t/* 0.58-0.59 */\n\t\t  \"PuTTY_Release_0.60*,\"\n\t\t  \"PuTTY_Release_0.61*,\"\n\t\t  \"PuTTY_Release_0.62*,\"\n\t\t  \"PuTTY_Release_0.63*,\"\n\t\t  \"PuTTY_Release_0.64*\",\n\t\t\t\t\tSSH_OLD_DHGEX },\n\t\t{ \"FuTTY*\",\t\tSSH_OLD_DHGEX }, /* Putty Fork */\n\t\t{ \"Probe-*\",\n\t\t\t\t\tSSH_BUG_PROBE },\n\t\t{ \"TeraTerm SSH*,\"\n\t\t  \"TTSSH/1.5.*,\"\n\t\t  \"TTSSH/2.1*,\"\n\t\t  \"TTSSH/2.2*,\"\n\t\t  \"TTSSH/2.3*,\"\n\t\t  \"TTSSH/2.4*,\"\n\t\t  \"TTSSH/2.5*,\"\n\t\t  \"TTSSH/2.6*,\"\n\t\t  \"TTSSH/2.70*,\"\n\t\t  \"TTSSH/2.71*,\"\n\t\t  \"TTSSH/2.72*\",\tSSH_BUG_HOSTKEYS },\n\t\t{ \"WinSCP_release_4*,\"\n\t\t  \"WinSCP_release_5.0*,\"\n\t\t  \"WinSCP_release_5.1,\"\n\t\t  \"WinSCP_release_5.1.*,\"\n\t\t  \"WinSCP_release_5.5,\"\n\t\t  \"WinSCP_release_5.5.*,\"\n\t\t  \"WinSCP_release_5.6,\"\n\t\t  \"WinSCP_release_5.6.*,\"\n\t\t  \"WinSCP_release_5.7,\"\n\t\t  \"WinSCP_release_5.7.1,\"\n\t\t  \"WinSCP_release_5.7.2,\"\n\t\t  \"WinSCP_release_5.7.3,\"\n\t\t  \"WinSCP_release_5.7.4\",\n\t\t\t\t\tSSH_OLD_DHGEX },\n\t\t{ \"ConfD-*\",\n\t\t\t\t\tSSH_BUG_UTF8TTYMODE },\n\t\t{ \"Twisted_*\",\t\t0 },\n\t\t{ \"Twisted*\",\t\tSSH_BUG_DEBUG },\n\t\t{ NULL,\t\t\t0 }\n\t};\n\n\t/* process table, return first match */\n\tfor (i = 0; check[i].pat; i++) {\n\t\tif (match_pattern_list(version, check[i].pat, 0) == 1) {\n\t\t\tdebug(\"match: %s pat %s compat 0x%08x\",\n\t\t\t    version, check[i].pat, check[i].bugs);\n\t\t\tdatafellows = check[i].bugs;\t/* XXX for now */\n\t\t\treturn check[i].bugs;\n\t\t}\n\t}\n\tdebug(\"no match: %s\", version);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Remote protocol version %d.%d, remote software version %.100s\"",
            "remote_major",
            "remote_minor",
            "remote_version"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Bad remote protocol version identification: '%.100s'\"",
            "buf"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "server_version_string",
            "\"SSH-%d.%d-%[^\\n]\\n\"",
            "&remote_major",
            "&remote_minor",
            "remote_version"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "buf"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"SSH-\"",
            "4"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "read",
            "connection_in",
            "&buf[i]",
            "1"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitrfd",
          "args": [
            "connection_in",
            "&timeout_ms"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "waitrfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "423-448",
          "snippet": "static int\nwaitrfd(int fd, int *timeoutp)\n{\n\tstruct pollfd pfd;\n\tstruct timeval t_start;\n\tint oerrno, r;\n\n\tmonotime_tv(&t_start);\n\tpfd.fd = fd;\n\tpfd.events = POLLIN;\n\tfor (; *timeoutp >= 0;) {\n\t\tr = poll(&pfd, 1, *timeoutp);\n\t\toerrno = errno;\n\t\tms_subtract_diff(&t_start, timeoutp);\n\t\terrno = oerrno;\n\t\tif (r > 0)\n\t\t\treturn 0;\n\t\telse if (r == -1 && errno != EAGAIN)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\t/* timeout */\n\terrno = ETIMEDOUT;\n\treturn -1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nwaitrfd(int fd, int *timeoutp)\n{\n\tstruct pollfd pfd;\n\tstruct timeval t_start;\n\tint oerrno, r;\n\n\tmonotime_tv(&t_start);\n\tpfd.fd = fd;\n\tpfd.events = POLLIN;\n\tfor (; *timeoutp >= 0;) {\n\t\tr = poll(&pfd, 1, *timeoutp);\n\t\toerrno = errno;\n\t\tms_subtract_diff(&t_start, timeoutp);\n\t\terrno = oerrno;\n\t\tif (r > 0)\n\t\t\treturn 0;\n\t\telse if (r == -1 && errno != EAGAIN)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\t/* timeout */\n\terrno = ETIMEDOUT;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_client_banner",
          "args": [
            "connection_out",
            "0"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "send_client_banner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "603-614",
          "snippet": "static void\nsend_client_banner(int connection_out, int minor1)\n{\n\t/* Send our own protocol version identification. */\n\txasprintf(&client_version_string, \"SSH-%d.%d-%.100s\\r\\n\",\n\t    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION);\n\tif (atomicio(vwrite, connection_out, client_version_string,\n\t    strlen(client_version_string)) != strlen(client_version_string))\n\t\tfatal(\"write: %.100s\", strerror(errno));\n\tchop(client_version_string);\n\tdebug(\"Local version string %.100s\", client_version_string);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *client_version_string = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *client_version_string = NULL;\n\nstatic void\nsend_client_banner(int connection_out, int minor1)\n{\n\t/* Send our own protocol version identification. */\n\txasprintf(&client_version_string, \"SSH-%d.%d-%.100s\\r\\n\",\n\t    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION);\n\tif (atomicio(vwrite, connection_out, client_version_string,\n\t    strlen(client_version_string)) != strlen(client_version_string))\n\t\tfatal(\"write: %.100s\", strerror(errno));\n\tchop(client_version_string);\n\tdebug(\"Local version string %.100s\", client_version_string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_connection_out",
          "args": [],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_connection_in",
          "args": [],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *server_version_string = NULL;\n\nvoid\nssh_exchange_identification(int timeout_ms)\n{\n\tchar buf[256], remote_version[256];\t/* must be same size! */\n\tint remote_major, remote_minor, mismatch;\n\tint connection_in = packet_get_connection_in();\n\tint connection_out = packet_get_connection_out();\n\tu_int i, n;\n\tsize_t len;\n\tint rc;\n\n\tsend_client_banner(connection_out, 0);\n\n\t/* Read other side's version identification. */\n\tfor (n = 0;;) {\n\t\tfor (i = 0; i < sizeof(buf) - 1; i++) {\n\t\t\tif (timeout_ms > 0) {\n\t\t\t\trc = waitrfd(connection_in, &timeout_ms);\n\t\t\t\tif (rc == -1 && errno == ETIMEDOUT) {\n\t\t\t\t\tfatal(\"Connection timed out during \"\n\t\t\t\t\t    \"banner exchange\");\n\t\t\t\t} else if (rc == -1) {\n\t\t\t\t\tfatal(\"%s: %s\",\n\t\t\t\t\t    __func__, strerror(errno));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlen = atomicio(read, connection_in, &buf[i], 1);\n\t\t\tif (len != 1 && errno == EPIPE)\n\t\t\t\tfatal(\"ssh_exchange_identification: \"\n\t\t\t\t    \"Connection closed by remote host\");\n\t\t\telse if (len != 1)\n\t\t\t\tfatal(\"ssh_exchange_identification: \"\n\t\t\t\t    \"read: %.100s\", strerror(errno));\n\t\t\tif (buf[i] == '\\r') {\n\t\t\t\tbuf[i] = '\\n';\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tcontinue;\t\t/**XXX wait for \\n */\n\t\t\t}\n\t\t\tif (buf[i] == '\\n') {\n\t\t\t\tbuf[i + 1] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++n > 65536)\n\t\t\t\tfatal(\"ssh_exchange_identification: \"\n\t\t\t\t    \"No banner received\");\n\t\t}\n\t\tbuf[sizeof(buf) - 1] = 0;\n\t\tif (strncmp(buf, \"SSH-\", 4) == 0)\n\t\t\tbreak;\n\t\tdebug(\"ssh_exchange_identification: %s\", buf);\n\t}\n\tserver_version_string = xstrdup(buf);\n\n\t/*\n\t * Check that the versions match.  In future this might accept\n\t * several versions and set appropriate flags to handle them.\n\t */\n\tif (sscanf(server_version_string, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3)\n\t\tfatal(\"Bad remote protocol version identification: '%.100s'\", buf);\n\tdebug(\"Remote protocol version %d.%d, remote software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\n\tactive_state->compat = compat_datafellows(remote_version);\n\tmismatch = 0;\n\n\tswitch (remote_major) {\n\tcase 2:\n\t\tbreak;\n\tcase 1:\n\t\tif (remote_minor != 99)\n\t\t\tmismatch = 1;\n\t\tbreak;\n\tdefault:\n\t\tmismatch = 1;\n\t\tbreak;\n\t}\n\tif (mismatch)\n\t\tfatal(\"Protocol major versions differ: %d vs. %d\",\n\t\t    PROTOCOL_MAJOR_2, remote_major);\n\tif ((datafellows & SSH_BUG_RSASIGMD5) != 0)\n\t\tlogit(\"Server version \\\"%.100s\\\" uses unsafe RSA signature \"\n\t\t    \"scheme; disabling use of RSA keys\", remote_version);\n\tchop(server_version_string);\n}"
  },
  {
    "function_name": "send_client_banner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "603-614",
    "snippet": "static void\nsend_client_banner(int connection_out, int minor1)\n{\n\t/* Send our own protocol version identification. */\n\txasprintf(&client_version_string, \"SSH-%d.%d-%.100s\\r\\n\",\n\t    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION);\n\tif (atomicio(vwrite, connection_out, client_version_string,\n\t    strlen(client_version_string)) != strlen(client_version_string))\n\t\tfatal(\"write: %.100s\", strerror(errno));\n\tchop(client_version_string);\n\tdebug(\"Local version string %.100s\", client_version_string);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *client_version_string = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Local version string %.100s\"",
            "client_version_string"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chop",
          "args": [
            "client_version_string"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "chop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "76-89",
          "snippet": "char *\nchop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nchop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"write: %.100s\"",
            "strerror(errno)"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "client_version_string"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "connection_out",
            "client_version_string",
            "strlen(client_version_string)"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "client_version_string"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&client_version_string",
            "\"SSH-%d.%d-%.100s\\r\\n\"",
            "PROTOCOL_MAJOR_2",
            "PROTOCOL_MINOR_2",
            "SSH_VERSION"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *client_version_string = NULL;\n\nstatic void\nsend_client_banner(int connection_out, int minor1)\n{\n\t/* Send our own protocol version identification. */\n\txasprintf(&client_version_string, \"SSH-%d.%d-%.100s\\r\\n\",\n\t    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION);\n\tif (atomicio(vwrite, connection_out, client_version_string,\n\t    strlen(client_version_string)) != strlen(client_version_string))\n\t\tfatal(\"write: %.100s\", strerror(errno));\n\tchop(client_version_string);\n\tdebug(\"Local version string %.100s\", client_version_string);\n}"
  },
  {
    "function_name": "ssh_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "583-601",
    "snippet": "int\nssh_connect(struct ssh *ssh, const char *host, struct addrinfo *addrs,\n    struct sockaddr_storage *hostaddr, u_short port, int family,\n    int connection_attempts, int *timeout_ms, int want_keepalive)\n{\n\tif (options.proxy_command == NULL) {\n\t\treturn ssh_connect_direct(ssh, host, addrs, hostaddr, port,\n\t\t    family, connection_attempts, timeout_ms, want_keepalive);\n\t} else if (strcmp(options.proxy_command, \"-\") == 0) {\n\t\tif ((ssh_packet_set_connection(ssh,\n\t\t    STDIN_FILENO, STDOUT_FILENO)) == NULL)\n\t\t\treturn -1; /* ssh_packet_set_connection logs error */\n\t\treturn 0;\n\t} else if (options.proxy_use_fdpass) {\n\t\treturn ssh_proxy_fdpass_connect(ssh, host, port,\n\t\t    options.proxy_command);\n\t}\n\treturn ssh_proxy_connect(ssh, host, port, options.proxy_command);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_proxy_connect",
          "args": [
            "ssh",
            "host",
            "port",
            "options.proxy_command"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_proxy_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "184-254",
          "snippet": "static int\nssh_proxy_connect(struct ssh *ssh, const char *host, u_short port,\n    const char *proxy_command)\n{\n\tchar *command_string;\n\tint pin[2], pout[2];\n\tpid_t pid;\n\tchar *shell;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\t/* Create pipes for communicating with the proxy. */\n\tif (pipe(pin) < 0 || pipe(pout) < 0)\n\t\tfatal(\"Could not create pipes to communicate with the proxy: %.100s\",\n\t\t    strerror(errno));\n\n\tcommand_string = expand_proxy_command(proxy_command, options.user,\n\t    host, port);\n\tdebug(\"Executing proxy command: %.500s\", command_string);\n\n\t/* Fork and execute the proxy command. */\n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[10];\n\n\t\t/* Redirect stdin and stdout. */\n\t\tclose(pin[1]);\n\t\tif (pin[0] != 0) {\n\t\t\tif (dup2(pin[0], 0) < 0)\n\t\t\t\tperror(\"dup2 stdin\");\n\t\t\tclose(pin[0]);\n\t\t}\n\t\tclose(pout[0]);\n\t\tif (dup2(pout[1], 1) < 0)\n\t\t\tperror(\"dup2 stdout\");\n\t\t/* Cannot be 1 because pin allocated two descriptors. */\n\t\tclose(pout[1]);\n\n\t\t/* Stderr is left as it is so that error messages get\n\t\t   printed on the user's terminal. */\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = command_string;\n\t\targv[3] = NULL;\n\n\t\t/* Execute the proxy command.  Note that we gave up any\n\t\t   extra privileges above. */\n\t\tsignal(SIGPIPE, SIG_DFL);\n\t\texecv(argv[0], argv);\n\t\tperror(argv[0]);\n\t\texit(1);\n\t}\n\t/* Parent. */\n\tif (pid < 0)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\telse\n\t\tproxy_command_pid = pid; /* save pid to clean up later */\n\n\t/* Close child side of the descriptors. */\n\tclose(pin[0]);\n\tclose(pout[1]);\n\n\t/* Free the command name. */\n\tfree(command_string);\n\n\t/* Set the connection file descriptors. */\n\tif (ssh_packet_set_connection(ssh, pout[0], pin[1]) == NULL)\n\t\treturn -1; /* ssh_packet_set_connection logs error */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static pid_t proxy_command_pid = 0;",
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic pid_t proxy_command_pid = 0;\nextern Options options;\n\nstatic int\nssh_proxy_connect(struct ssh *ssh, const char *host, u_short port,\n    const char *proxy_command)\n{\n\tchar *command_string;\n\tint pin[2], pout[2];\n\tpid_t pid;\n\tchar *shell;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\t/* Create pipes for communicating with the proxy. */\n\tif (pipe(pin) < 0 || pipe(pout) < 0)\n\t\tfatal(\"Could not create pipes to communicate with the proxy: %.100s\",\n\t\t    strerror(errno));\n\n\tcommand_string = expand_proxy_command(proxy_command, options.user,\n\t    host, port);\n\tdebug(\"Executing proxy command: %.500s\", command_string);\n\n\t/* Fork and execute the proxy command. */\n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[10];\n\n\t\t/* Redirect stdin and stdout. */\n\t\tclose(pin[1]);\n\t\tif (pin[0] != 0) {\n\t\t\tif (dup2(pin[0], 0) < 0)\n\t\t\t\tperror(\"dup2 stdin\");\n\t\t\tclose(pin[0]);\n\t\t}\n\t\tclose(pout[0]);\n\t\tif (dup2(pout[1], 1) < 0)\n\t\t\tperror(\"dup2 stdout\");\n\t\t/* Cannot be 1 because pin allocated two descriptors. */\n\t\tclose(pout[1]);\n\n\t\t/* Stderr is left as it is so that error messages get\n\t\t   printed on the user's terminal. */\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = command_string;\n\t\targv[3] = NULL;\n\n\t\t/* Execute the proxy command.  Note that we gave up any\n\t\t   extra privileges above. */\n\t\tsignal(SIGPIPE, SIG_DFL);\n\t\texecv(argv[0], argv);\n\t\tperror(argv[0]);\n\t\texit(1);\n\t}\n\t/* Parent. */\n\tif (pid < 0)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\telse\n\t\tproxy_command_pid = pid; /* save pid to clean up later */\n\n\t/* Close child side of the descriptors. */\n\tclose(pin[0]);\n\tclose(pout[1]);\n\n\t/* Free the command name. */\n\tfree(command_string);\n\n\t/* Set the connection file descriptors. */\n\tif (ssh_packet_set_connection(ssh, pout[0], pin[1]) == NULL)\n\t\treturn -1; /* ssh_packet_set_connection logs error */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_proxy_fdpass_connect",
          "args": [
            "ssh",
            "host",
            "port",
            "options.proxy_command"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_proxy_fdpass_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "106-179",
          "snippet": "static int\nssh_proxy_fdpass_connect(struct ssh *ssh, const char *host, u_short port,\n    const char *proxy_command)\n{\n\tchar *command_string;\n\tint sp[2], sock;\n\tpid_t pid;\n\tchar *shell;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL)\n\t\tshell = _PATH_BSHELL;\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) < 0)\n\t\tfatal(\"Could not create socketpair to communicate with \"\n\t\t    \"proxy dialer: %.100s\", strerror(errno));\n\n\tcommand_string = expand_proxy_command(proxy_command, options.user,\n\t    host, port);\n\tdebug(\"Executing proxy dialer command: %.500s\", command_string);\n\n\t/* Fork and execute the proxy command. */\n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[10];\n\n\t\tclose(sp[1]);\n\t\t/* Redirect stdin and stdout. */\n\t\tif (sp[0] != 0) {\n\t\t\tif (dup2(sp[0], 0) < 0)\n\t\t\t\tperror(\"dup2 stdin\");\n\t\t}\n\t\tif (sp[0] != 1) {\n\t\t\tif (dup2(sp[0], 1) < 0)\n\t\t\t\tperror(\"dup2 stdout\");\n\t\t}\n\t\tif (sp[0] >= 2)\n\t\t\tclose(sp[0]);\n\n\t\t/*\n\t\t * Stderr is left as it is so that error messages get\n\t\t * printed on the user's terminal.\n\t\t */\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = command_string;\n\t\targv[3] = NULL;\n\n\t\t/*\n\t\t * Execute the proxy command.\n\t\t * Note that we gave up any extra privileges above.\n\t\t */\n\t\texecv(argv[0], argv);\n\t\tperror(argv[0]);\n\t\texit(1);\n\t}\n\t/* Parent. */\n\tif (pid < 0)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\tclose(sp[0]);\n\tfree(command_string);\n\n\tif ((sock = mm_receive_fd(sp[1])) == -1)\n\t\tfatal(\"proxy dialer did not pass back a connection\");\n\tclose(sp[1]);\n\n\twhile (waitpid(pid, NULL, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\n\t/* Set the connection file descriptors. */\n\tif (ssh_packet_set_connection(ssh, sock, sock) == NULL)\n\t\treturn -1; /* ssh_packet_set_connection logs error */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nssh_proxy_fdpass_connect(struct ssh *ssh, const char *host, u_short port,\n    const char *proxy_command)\n{\n\tchar *command_string;\n\tint sp[2], sock;\n\tpid_t pid;\n\tchar *shell;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL)\n\t\tshell = _PATH_BSHELL;\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) < 0)\n\t\tfatal(\"Could not create socketpair to communicate with \"\n\t\t    \"proxy dialer: %.100s\", strerror(errno));\n\n\tcommand_string = expand_proxy_command(proxy_command, options.user,\n\t    host, port);\n\tdebug(\"Executing proxy dialer command: %.500s\", command_string);\n\n\t/* Fork and execute the proxy command. */\n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[10];\n\n\t\tclose(sp[1]);\n\t\t/* Redirect stdin and stdout. */\n\t\tif (sp[0] != 0) {\n\t\t\tif (dup2(sp[0], 0) < 0)\n\t\t\t\tperror(\"dup2 stdin\");\n\t\t}\n\t\tif (sp[0] != 1) {\n\t\t\tif (dup2(sp[0], 1) < 0)\n\t\t\t\tperror(\"dup2 stdout\");\n\t\t}\n\t\tif (sp[0] >= 2)\n\t\t\tclose(sp[0]);\n\n\t\t/*\n\t\t * Stderr is left as it is so that error messages get\n\t\t * printed on the user's terminal.\n\t\t */\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = command_string;\n\t\targv[3] = NULL;\n\n\t\t/*\n\t\t * Execute the proxy command.\n\t\t * Note that we gave up any extra privileges above.\n\t\t */\n\t\texecv(argv[0], argv);\n\t\tperror(argv[0]);\n\t\texit(1);\n\t}\n\t/* Parent. */\n\tif (pid < 0)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\tclose(sp[0]);\n\tfree(command_string);\n\n\tif ((sock = mm_receive_fd(sp[1])) == -1)\n\t\tfatal(\"proxy dialer did not pass back a connection\");\n\tclose(sp[1]);\n\n\twhile (waitpid(pid, NULL, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\n\t/* Set the connection file descriptors. */\n\tif (ssh_packet_set_connection(ssh, sock, sock) == NULL)\n\t\treturn -1; /* ssh_packet_set_connection logs error */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_set_connection",
          "args": [
            "ssh",
            "STDIN_FILENO",
            "STDOUT_FILENO"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_set_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "282-317",
          "snippet": "struct ssh *\nssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)\n{\n\tstruct session_state *state;\n\tconst struct sshcipher *none = cipher_by_name(\"none\");\n\tint r;\n\n\tif (none == NULL) {\n\t\terror(\"%s: cannot load cipher 'none'\", __func__);\n\t\treturn NULL;\n\t}\n\tif (ssh == NULL)\n\t\tssh = ssh_alloc_session_state();\n\tif (ssh == NULL) {\n\t\terror(\"%s: cound not allocate state\", __func__);\n\t\treturn NULL;\n\t}\n\tstate = ssh->state;\n\tstate->connection_in = fd_in;\n\tstate->connection_out = fd_out;\n\tif ((r = cipher_init(&state->send_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||\n\t    (r = cipher_init(&state->receive_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {\n\t\terror(\"%s: cipher_init failed: %s\", __func__, ssh_err(r));\n\t\tfree(ssh); /* XXX need ssh_free_session_state? */\n\t\treturn NULL;\n\t}\n\tstate->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;\n\t/*\n\t * Cache the IP address of the remote connection for use in error\n\t * messages that might be generated after the connection has closed.\n\t */\n\t(void)ssh_remote_ipaddr(ssh);\n\treturn ssh;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct ssh *\nssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)\n{\n\tstruct session_state *state;\n\tconst struct sshcipher *none = cipher_by_name(\"none\");\n\tint r;\n\n\tif (none == NULL) {\n\t\terror(\"%s: cannot load cipher 'none'\", __func__);\n\t\treturn NULL;\n\t}\n\tif (ssh == NULL)\n\t\tssh = ssh_alloc_session_state();\n\tif (ssh == NULL) {\n\t\terror(\"%s: cound not allocate state\", __func__);\n\t\treturn NULL;\n\t}\n\tstate = ssh->state;\n\tstate->connection_in = fd_in;\n\tstate->connection_out = fd_out;\n\tif ((r = cipher_init(&state->send_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||\n\t    (r = cipher_init(&state->receive_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {\n\t\terror(\"%s: cipher_init failed: %s\", __func__, ssh_err(r));\n\t\tfree(ssh); /* XXX need ssh_free_session_state? */\n\t\treturn NULL;\n\t}\n\tstate->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;\n\t/*\n\t * Cache the IP address of the remote connection for use in error\n\t * messages that might be generated after the connection has closed.\n\t */\n\t(void)ssh_remote_ipaddr(ssh);\n\treturn ssh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "options.proxy_command",
            "\"-\""
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_connect_direct",
          "args": [
            "ssh",
            "host",
            "addrs",
            "hostaddr",
            "port",
            "family",
            "connection_attempts",
            "timeout_ms",
            "want_keepalive"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_connect_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "494-581",
          "snippet": "static int\nssh_connect_direct(struct ssh *ssh, const char *host, struct addrinfo *aitop,\n    struct sockaddr_storage *hostaddr, u_short port, int family,\n    int connection_attempts, int *timeout_ms, int want_keepalive)\n{\n\tint on = 1;\n\tint oerrno, sock = -1, attempt;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tstruct addrinfo *ai;\n\n\tdebug2(\"%s\", __func__);\n\tmemset(ntop, 0, sizeof(ntop));\n\tmemset(strport, 0, sizeof(strport));\n\n\tfor (attempt = 0; attempt < connection_attempts; attempt++) {\n\t\tif (attempt > 0) {\n\t\t\t/* Sleep a moment before retrying. */\n\t\t\tsleep(1);\n\t\t\tdebug(\"Trying again...\");\n\t\t}\n\t\t/*\n\t\t * Loop through addresses for this host, and try each one in\n\t\t * sequence until the connection succeeds.\n\t\t */\n\t\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t\tif (ai->ai_family != AF_INET &&\n\t\t\t    ai->ai_family != AF_INET6) {\n\t\t\t\terrno = EAFNOSUPPORT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen,\n\t\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\t\toerrno = errno;\n\t\t\t\terror(\"%s: getnameinfo failed\", __func__);\n\t\t\t\terrno = oerrno;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdebug(\"Connecting to %.200s [%.100s] port %s.\",\n\t\t\t\thost, ntop, strport);\n\n\t\t\t/* Create a socket for connecting. */\n\t\t\tsock = ssh_create_socket(ai);\n\t\t\tif (sock < 0) {\n\t\t\t\t/* Any error is already output */\n\t\t\t\terrno = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (timeout_connect(sock, ai->ai_addr, ai->ai_addrlen,\n\t\t\t    timeout_ms) >= 0) {\n\t\t\t\t/* Successful connection. */\n\t\t\t\tmemcpy(hostaddr, ai->ai_addr, ai->ai_addrlen);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\toerrno = errno;\n\t\t\t\tdebug(\"connect to address %s port %s: %s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\t\t\t\tclose(sock);\n\t\t\t\tsock = -1;\n\t\t\t\terrno = oerrno;\n\t\t\t}\n\t\t}\n\t\tif (sock != -1)\n\t\t\tbreak;\t/* Successful connection. */\n\t}\n\n\t/* Return failure if we didn't get a successful connection. */\n\tif (sock == -1) {\n\t\terror(\"ssh: connect to host %s port %s: %s\",\n\t\t    host, strport, errno == 0 ? \"failure\" : strerror(errno));\n\t\treturn -1;\n\t}\n\n\tdebug(\"Connection established.\");\n\n\t/* Set SO_KEEPALIVE if requested. */\n\tif (want_keepalive &&\n\t    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (void *)&on,\n\t    sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_KEEPALIVE: %.100s\", strerror(errno));\n\n\t/* Set the connection. */\n\tif (ssh_packet_set_connection(ssh, sock, sock) == NULL)\n\t\treturn -1; /* ssh_packet_set_connection logs error */\n\n        return 0;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nssh_connect_direct(struct ssh *ssh, const char *host, struct addrinfo *aitop,\n    struct sockaddr_storage *hostaddr, u_short port, int family,\n    int connection_attempts, int *timeout_ms, int want_keepalive)\n{\n\tint on = 1;\n\tint oerrno, sock = -1, attempt;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tstruct addrinfo *ai;\n\n\tdebug2(\"%s\", __func__);\n\tmemset(ntop, 0, sizeof(ntop));\n\tmemset(strport, 0, sizeof(strport));\n\n\tfor (attempt = 0; attempt < connection_attempts; attempt++) {\n\t\tif (attempt > 0) {\n\t\t\t/* Sleep a moment before retrying. */\n\t\t\tsleep(1);\n\t\t\tdebug(\"Trying again...\");\n\t\t}\n\t\t/*\n\t\t * Loop through addresses for this host, and try each one in\n\t\t * sequence until the connection succeeds.\n\t\t */\n\t\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t\tif (ai->ai_family != AF_INET &&\n\t\t\t    ai->ai_family != AF_INET6) {\n\t\t\t\terrno = EAFNOSUPPORT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen,\n\t\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\t\toerrno = errno;\n\t\t\t\terror(\"%s: getnameinfo failed\", __func__);\n\t\t\t\terrno = oerrno;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdebug(\"Connecting to %.200s [%.100s] port %s.\",\n\t\t\t\thost, ntop, strport);\n\n\t\t\t/* Create a socket for connecting. */\n\t\t\tsock = ssh_create_socket(ai);\n\t\t\tif (sock < 0) {\n\t\t\t\t/* Any error is already output */\n\t\t\t\terrno = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (timeout_connect(sock, ai->ai_addr, ai->ai_addrlen,\n\t\t\t    timeout_ms) >= 0) {\n\t\t\t\t/* Successful connection. */\n\t\t\t\tmemcpy(hostaddr, ai->ai_addr, ai->ai_addrlen);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\toerrno = errno;\n\t\t\t\tdebug(\"connect to address %s port %s: %s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\t\t\t\tclose(sock);\n\t\t\t\tsock = -1;\n\t\t\t\terrno = oerrno;\n\t\t\t}\n\t\t}\n\t\tif (sock != -1)\n\t\t\tbreak;\t/* Successful connection. */\n\t}\n\n\t/* Return failure if we didn't get a successful connection. */\n\tif (sock == -1) {\n\t\terror(\"ssh: connect to host %s port %s: %s\",\n\t\t    host, strport, errno == 0 ? \"failure\" : strerror(errno));\n\t\treturn -1;\n\t}\n\n\tdebug(\"Connection established.\");\n\n\t/* Set SO_KEEPALIVE if requested. */\n\tif (want_keepalive &&\n\t    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (void *)&on,\n\t    sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_KEEPALIVE: %.100s\", strerror(errno));\n\n\t/* Set the connection. */\n\tif (ssh_packet_set_connection(ssh, sock, sock) == NULL)\n\t\treturn -1; /* ssh_packet_set_connection logs error */\n\n        return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nint\nssh_connect(struct ssh *ssh, const char *host, struct addrinfo *addrs,\n    struct sockaddr_storage *hostaddr, u_short port, int family,\n    int connection_attempts, int *timeout_ms, int want_keepalive)\n{\n\tif (options.proxy_command == NULL) {\n\t\treturn ssh_connect_direct(ssh, host, addrs, hostaddr, port,\n\t\t    family, connection_attempts, timeout_ms, want_keepalive);\n\t} else if (strcmp(options.proxy_command, \"-\") == 0) {\n\t\tif ((ssh_packet_set_connection(ssh,\n\t\t    STDIN_FILENO, STDOUT_FILENO)) == NULL)\n\t\t\treturn -1; /* ssh_packet_set_connection logs error */\n\t\treturn 0;\n\t} else if (options.proxy_use_fdpass) {\n\t\treturn ssh_proxy_fdpass_connect(ssh, host, port,\n\t\t    options.proxy_command);\n\t}\n\treturn ssh_proxy_connect(ssh, host, port, options.proxy_command);\n}"
  },
  {
    "function_name": "ssh_connect_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "494-581",
    "snippet": "static int\nssh_connect_direct(struct ssh *ssh, const char *host, struct addrinfo *aitop,\n    struct sockaddr_storage *hostaddr, u_short port, int family,\n    int connection_attempts, int *timeout_ms, int want_keepalive)\n{\n\tint on = 1;\n\tint oerrno, sock = -1, attempt;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tstruct addrinfo *ai;\n\n\tdebug2(\"%s\", __func__);\n\tmemset(ntop, 0, sizeof(ntop));\n\tmemset(strport, 0, sizeof(strport));\n\n\tfor (attempt = 0; attempt < connection_attempts; attempt++) {\n\t\tif (attempt > 0) {\n\t\t\t/* Sleep a moment before retrying. */\n\t\t\tsleep(1);\n\t\t\tdebug(\"Trying again...\");\n\t\t}\n\t\t/*\n\t\t * Loop through addresses for this host, and try each one in\n\t\t * sequence until the connection succeeds.\n\t\t */\n\t\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t\tif (ai->ai_family != AF_INET &&\n\t\t\t    ai->ai_family != AF_INET6) {\n\t\t\t\terrno = EAFNOSUPPORT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen,\n\t\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\t\toerrno = errno;\n\t\t\t\terror(\"%s: getnameinfo failed\", __func__);\n\t\t\t\terrno = oerrno;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdebug(\"Connecting to %.200s [%.100s] port %s.\",\n\t\t\t\thost, ntop, strport);\n\n\t\t\t/* Create a socket for connecting. */\n\t\t\tsock = ssh_create_socket(ai);\n\t\t\tif (sock < 0) {\n\t\t\t\t/* Any error is already output */\n\t\t\t\terrno = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (timeout_connect(sock, ai->ai_addr, ai->ai_addrlen,\n\t\t\t    timeout_ms) >= 0) {\n\t\t\t\t/* Successful connection. */\n\t\t\t\tmemcpy(hostaddr, ai->ai_addr, ai->ai_addrlen);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\toerrno = errno;\n\t\t\t\tdebug(\"connect to address %s port %s: %s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\t\t\t\tclose(sock);\n\t\t\t\tsock = -1;\n\t\t\t\terrno = oerrno;\n\t\t\t}\n\t\t}\n\t\tif (sock != -1)\n\t\t\tbreak;\t/* Successful connection. */\n\t}\n\n\t/* Return failure if we didn't get a successful connection. */\n\tif (sock == -1) {\n\t\terror(\"ssh: connect to host %s port %s: %s\",\n\t\t    host, strport, errno == 0 ? \"failure\" : strerror(errno));\n\t\treturn -1;\n\t}\n\n\tdebug(\"Connection established.\");\n\n\t/* Set SO_KEEPALIVE if requested. */\n\tif (want_keepalive &&\n\t    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (void *)&on,\n\t    sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_KEEPALIVE: %.100s\", strerror(errno));\n\n\t/* Set the connection. */\n\tif (ssh_packet_set_connection(ssh, sock, sock) == NULL)\n\t\treturn -1; /* ssh_packet_set_connection logs error */\n\n        return 0;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_packet_set_connection",
          "args": [
            "ssh",
            "sock",
            "sock"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_set_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "282-317",
          "snippet": "struct ssh *\nssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)\n{\n\tstruct session_state *state;\n\tconst struct sshcipher *none = cipher_by_name(\"none\");\n\tint r;\n\n\tif (none == NULL) {\n\t\terror(\"%s: cannot load cipher 'none'\", __func__);\n\t\treturn NULL;\n\t}\n\tif (ssh == NULL)\n\t\tssh = ssh_alloc_session_state();\n\tif (ssh == NULL) {\n\t\terror(\"%s: cound not allocate state\", __func__);\n\t\treturn NULL;\n\t}\n\tstate = ssh->state;\n\tstate->connection_in = fd_in;\n\tstate->connection_out = fd_out;\n\tif ((r = cipher_init(&state->send_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||\n\t    (r = cipher_init(&state->receive_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {\n\t\terror(\"%s: cipher_init failed: %s\", __func__, ssh_err(r));\n\t\tfree(ssh); /* XXX need ssh_free_session_state? */\n\t\treturn NULL;\n\t}\n\tstate->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;\n\t/*\n\t * Cache the IP address of the remote connection for use in error\n\t * messages that might be generated after the connection has closed.\n\t */\n\t(void)ssh_remote_ipaddr(ssh);\n\treturn ssh;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct ssh *\nssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)\n{\n\tstruct session_state *state;\n\tconst struct sshcipher *none = cipher_by_name(\"none\");\n\tint r;\n\n\tif (none == NULL) {\n\t\terror(\"%s: cannot load cipher 'none'\", __func__);\n\t\treturn NULL;\n\t}\n\tif (ssh == NULL)\n\t\tssh = ssh_alloc_session_state();\n\tif (ssh == NULL) {\n\t\terror(\"%s: cound not allocate state\", __func__);\n\t\treturn NULL;\n\t}\n\tstate = ssh->state;\n\tstate->connection_in = fd_in;\n\tstate->connection_out = fd_out;\n\tif ((r = cipher_init(&state->send_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||\n\t    (r = cipher_init(&state->receive_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {\n\t\terror(\"%s: cipher_init failed: %s\", __func__, ssh_err(r));\n\t\tfree(ssh); /* XXX need ssh_free_session_state? */\n\t\treturn NULL;\n\t}\n\tstate->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;\n\t/*\n\t * Cache the IP address of the remote connection for use in error\n\t * messages that might be generated after the connection has closed.\n\t */\n\t(void)ssh_remote_ipaddr(ssh);\n\treturn ssh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"setsockopt SO_KEEPALIVE: %.100s\"",
            "strerror(errno)"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "sock",
            "SOL_SOCKET",
            "SO_KEEPALIVE",
            "(void *)&on",
            "sizeof(on)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Connection established.\""
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hostaddr",
            "ai->ai_addr",
            "ai->ai_addrlen"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_connect",
          "args": [
            "sock",
            "ai->ai_addr",
            "ai->ai_addrlen",
            "timeout_ms"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "timeout_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "450-483",
          "snippet": "static int\ntimeout_connect(int sockfd, const struct sockaddr *serv_addr,\n    socklen_t addrlen, int *timeoutp)\n{\n\tint optval = 0;\n\tsocklen_t optlen = sizeof(optval);\n\n\t/* No timeout: just do a blocking connect() */\n\tif (*timeoutp <= 0)\n\t\treturn connect(sockfd, serv_addr, addrlen);\n\n\tset_nonblock(sockfd);\n\tif (connect(sockfd, serv_addr, addrlen) == 0) {\n\t\t/* Succeeded already? */\n\t\tunset_nonblock(sockfd);\n\t\treturn 0;\n\t} else if (errno != EINPROGRESS)\n\t\treturn -1;\n\n\tif (waitrfd(sockfd, timeoutp) == -1)\n\t\treturn -1;\n\n\t/* Completed or failed */\n\tif (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &optval, &optlen) == -1) {\n\t\tdebug(\"getsockopt: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (optval != 0) {\n\t\terrno = optval;\n\t\treturn -1;\n\t}\n\tunset_nonblock(sockfd);\n\treturn 0;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ntimeout_connect(int sockfd, const struct sockaddr *serv_addr,\n    socklen_t addrlen, int *timeoutp)\n{\n\tint optval = 0;\n\tsocklen_t optlen = sizeof(optval);\n\n\t/* No timeout: just do a blocking connect() */\n\tif (*timeoutp <= 0)\n\t\treturn connect(sockfd, serv_addr, addrlen);\n\n\tset_nonblock(sockfd);\n\tif (connect(sockfd, serv_addr, addrlen) == 0) {\n\t\t/* Succeeded already? */\n\t\tunset_nonblock(sockfd);\n\t\treturn 0;\n\t} else if (errno != EINPROGRESS)\n\t\treturn -1;\n\n\tif (waitrfd(sockfd, timeoutp) == -1)\n\t\treturn -1;\n\n\t/* Completed or failed */\n\tif (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &optval, &optlen) == -1) {\n\t\tdebug(\"getsockopt: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (optval != 0) {\n\t\terrno = optval;\n\t\treturn -1;\n\t}\n\tunset_nonblock(sockfd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_create_socket",
          "args": [
            "ai"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_create_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "333-416",
          "snippet": "static int\nssh_create_socket(struct addrinfo *ai)\n{\n\tint sock, r;\n\tstruct sockaddr_storage bindaddr;\n\tsocklen_t bindaddrlen = 0;\n\tstruct addrinfo hints, *res = NULL;\n#ifdef HAVE_IFADDRS_H\n\tstruct ifaddrs *ifaddrs = NULL;\n#endif\n\tchar ntop[NI_MAXHOST];\n\n\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\tif (sock < 0) {\n\t\terror(\"socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tfcntl(sock, F_SETFD, FD_CLOEXEC);\n\n\t/* Bind the socket to an alternative local IP address */\n\tif (options.bind_address == NULL && options.bind_interface == NULL)\n\t\treturn sock;\n\n\tif (options.bind_address != NULL) {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ai->ai_family;\n\t\thints.ai_socktype = ai->ai_socktype;\n\t\thints.ai_protocol = ai->ai_protocol;\n\t\thints.ai_flags = AI_PASSIVE;\n\t\tif ((r = getaddrinfo(options.bind_address, NULL,\n\t\t    &hints, &res)) != 0) {\n\t\t\terror(\"getaddrinfo: %s: %s\", options.bind_address,\n\t\t\t    ssh_gai_strerror(r));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (res == NULL) {\n\t\t\terror(\"getaddrinfo: no addrs\");\n\t\t\tgoto fail;\n\t\t}\n\t\tmemcpy(&bindaddr, res->ai_addr, res->ai_addrlen);\n\t\tbindaddrlen = res->ai_addrlen;\n\t} else if (options.bind_interface != NULL) {\n#ifdef HAVE_IFADDRS_H\n\t\tif ((r = getifaddrs(&ifaddrs)) != 0) {\n\t\t\terror(\"getifaddrs: %s: %s\", options.bind_interface,\n\t\t\t      strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t\tbindaddrlen = sizeof(bindaddr);\n\t\tif (check_ifaddrs(options.bind_interface, ai->ai_family,\n\t\t    ifaddrs, &bindaddr, &bindaddrlen) != 0) {\n\t\t\tlogit(\"getifaddrs: %s: no suitable addresses\",\n\t\t\t      options.bind_interface);\n\t\t\tgoto fail;\n\t\t}\n#else\n\t\terror(\"BindInterface not supported on this platform.\");\n#endif\n\t}\n\tif ((r = getnameinfo((struct sockaddr *)&bindaddr, bindaddrlen,\n\t    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST)) != 0) {\n\t\terror(\"%s: getnameinfo failed: %s\", __func__,\n\t\t    ssh_gai_strerror(r));\n\t\tgoto fail;\n\t}\n\tif (bind(sock, (struct sockaddr *)&bindaddr, bindaddrlen) != 0) {\n\t\terror(\"bind %s: %s\", ntop, strerror(errno));\n\t\tgoto fail;\n\t}\n\tdebug(\"%s: bound to %s\", __func__, ntop);\n\t/* success */\n\tgoto out;\nfail:\n\tclose(sock);\n\tsock = -1;\n out:\n\tif (res != NULL)\n\t\tfreeaddrinfo(res);\n#ifdef HAVE_IFADDRS_H\n\tif (ifaddrs != NULL)\n\t\tfreeifaddrs(ifaddrs);\n#endif\n\treturn sock;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nssh_create_socket(struct addrinfo *ai)\n{\n\tint sock, r;\n\tstruct sockaddr_storage bindaddr;\n\tsocklen_t bindaddrlen = 0;\n\tstruct addrinfo hints, *res = NULL;\n#ifdef HAVE_IFADDRS_H\n\tstruct ifaddrs *ifaddrs = NULL;\n#endif\n\tchar ntop[NI_MAXHOST];\n\n\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\tif (sock < 0) {\n\t\terror(\"socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tfcntl(sock, F_SETFD, FD_CLOEXEC);\n\n\t/* Bind the socket to an alternative local IP address */\n\tif (options.bind_address == NULL && options.bind_interface == NULL)\n\t\treturn sock;\n\n\tif (options.bind_address != NULL) {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ai->ai_family;\n\t\thints.ai_socktype = ai->ai_socktype;\n\t\thints.ai_protocol = ai->ai_protocol;\n\t\thints.ai_flags = AI_PASSIVE;\n\t\tif ((r = getaddrinfo(options.bind_address, NULL,\n\t\t    &hints, &res)) != 0) {\n\t\t\terror(\"getaddrinfo: %s: %s\", options.bind_address,\n\t\t\t    ssh_gai_strerror(r));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (res == NULL) {\n\t\t\terror(\"getaddrinfo: no addrs\");\n\t\t\tgoto fail;\n\t\t}\n\t\tmemcpy(&bindaddr, res->ai_addr, res->ai_addrlen);\n\t\tbindaddrlen = res->ai_addrlen;\n\t} else if (options.bind_interface != NULL) {\n#ifdef HAVE_IFADDRS_H\n\t\tif ((r = getifaddrs(&ifaddrs)) != 0) {\n\t\t\terror(\"getifaddrs: %s: %s\", options.bind_interface,\n\t\t\t      strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t\tbindaddrlen = sizeof(bindaddr);\n\t\tif (check_ifaddrs(options.bind_interface, ai->ai_family,\n\t\t    ifaddrs, &bindaddr, &bindaddrlen) != 0) {\n\t\t\tlogit(\"getifaddrs: %s: no suitable addresses\",\n\t\t\t      options.bind_interface);\n\t\t\tgoto fail;\n\t\t}\n#else\n\t\terror(\"BindInterface not supported on this platform.\");\n#endif\n\t}\n\tif ((r = getnameinfo((struct sockaddr *)&bindaddr, bindaddrlen,\n\t    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST)) != 0) {\n\t\terror(\"%s: getnameinfo failed: %s\", __func__,\n\t\t    ssh_gai_strerror(r));\n\t\tgoto fail;\n\t}\n\tif (bind(sock, (struct sockaddr *)&bindaddr, bindaddrlen) != 0) {\n\t\terror(\"bind %s: %s\", ntop, strerror(errno));\n\t\tgoto fail;\n\t}\n\tdebug(\"%s: bound to %s\", __func__, ntop);\n\t/* success */\n\tgoto out;\nfail:\n\tclose(sock);\n\tsock = -1;\n out:\n\tif (res != NULL)\n\t\tfreeaddrinfo(res);\n#ifdef HAVE_IFADDRS_H\n\tif (ifaddrs != NULL)\n\t\tfreeifaddrs(ifaddrs);\n#endif\n\treturn sock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "ai->ai_addr",
            "ai->ai_addrlen",
            "ntop",
            "sizeof(ntop)",
            "strport",
            "sizeof(strport)",
            "NI_NUMERICHOST|NI_NUMERICSERV"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "sshaix_getnameinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "415-434",
          "snippet": "int\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "usleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "171-178",
          "snippet": "int usleep(unsigned int useconds)\n{\n\tstruct timespec ts;\n\n\tts.tv_sec = useconds / 1000000;\n\tts.tv_nsec = (useconds % 1000000) * 1000;\n\treturn nanosleep(&ts, NULL);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint usleep(unsigned int useconds)\n{\n\tstruct timespec ts;\n\n\tts.tv_sec = useconds / 1000000;\n\tts.tv_nsec = (useconds % 1000000) * 1000;\n\treturn nanosleep(&ts, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "strport",
            "0",
            "sizeof(strport)"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ntop",
            "0",
            "sizeof(ntop)"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s\"",
            "__func__"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nssh_connect_direct(struct ssh *ssh, const char *host, struct addrinfo *aitop,\n    struct sockaddr_storage *hostaddr, u_short port, int family,\n    int connection_attempts, int *timeout_ms, int want_keepalive)\n{\n\tint on = 1;\n\tint oerrno, sock = -1, attempt;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tstruct addrinfo *ai;\n\n\tdebug2(\"%s\", __func__);\n\tmemset(ntop, 0, sizeof(ntop));\n\tmemset(strport, 0, sizeof(strport));\n\n\tfor (attempt = 0; attempt < connection_attempts; attempt++) {\n\t\tif (attempt > 0) {\n\t\t\t/* Sleep a moment before retrying. */\n\t\t\tsleep(1);\n\t\t\tdebug(\"Trying again...\");\n\t\t}\n\t\t/*\n\t\t * Loop through addresses for this host, and try each one in\n\t\t * sequence until the connection succeeds.\n\t\t */\n\t\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t\tif (ai->ai_family != AF_INET &&\n\t\t\t    ai->ai_family != AF_INET6) {\n\t\t\t\terrno = EAFNOSUPPORT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen,\n\t\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\t\toerrno = errno;\n\t\t\t\terror(\"%s: getnameinfo failed\", __func__);\n\t\t\t\terrno = oerrno;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdebug(\"Connecting to %.200s [%.100s] port %s.\",\n\t\t\t\thost, ntop, strport);\n\n\t\t\t/* Create a socket for connecting. */\n\t\t\tsock = ssh_create_socket(ai);\n\t\t\tif (sock < 0) {\n\t\t\t\t/* Any error is already output */\n\t\t\t\terrno = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (timeout_connect(sock, ai->ai_addr, ai->ai_addrlen,\n\t\t\t    timeout_ms) >= 0) {\n\t\t\t\t/* Successful connection. */\n\t\t\t\tmemcpy(hostaddr, ai->ai_addr, ai->ai_addrlen);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\toerrno = errno;\n\t\t\t\tdebug(\"connect to address %s port %s: %s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\t\t\t\tclose(sock);\n\t\t\t\tsock = -1;\n\t\t\t\terrno = oerrno;\n\t\t\t}\n\t\t}\n\t\tif (sock != -1)\n\t\t\tbreak;\t/* Successful connection. */\n\t}\n\n\t/* Return failure if we didn't get a successful connection. */\n\tif (sock == -1) {\n\t\terror(\"ssh: connect to host %s port %s: %s\",\n\t\t    host, strport, errno == 0 ? \"failure\" : strerror(errno));\n\t\treturn -1;\n\t}\n\n\tdebug(\"Connection established.\");\n\n\t/* Set SO_KEEPALIVE if requested. */\n\tif (want_keepalive &&\n\t    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (void *)&on,\n\t    sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_KEEPALIVE: %.100s\", strerror(errno));\n\n\t/* Set the connection. */\n\tif (ssh_packet_set_connection(ssh, sock, sock) == NULL)\n\t\treturn -1; /* ssh_packet_set_connection logs error */\n\n        return 0;\n}"
  },
  {
    "function_name": "timeout_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "450-483",
    "snippet": "static int\ntimeout_connect(int sockfd, const struct sockaddr *serv_addr,\n    socklen_t addrlen, int *timeoutp)\n{\n\tint optval = 0;\n\tsocklen_t optlen = sizeof(optval);\n\n\t/* No timeout: just do a blocking connect() */\n\tif (*timeoutp <= 0)\n\t\treturn connect(sockfd, serv_addr, addrlen);\n\n\tset_nonblock(sockfd);\n\tif (connect(sockfd, serv_addr, addrlen) == 0) {\n\t\t/* Succeeded already? */\n\t\tunset_nonblock(sockfd);\n\t\treturn 0;\n\t} else if (errno != EINPROGRESS)\n\t\treturn -1;\n\n\tif (waitrfd(sockfd, timeoutp) == -1)\n\t\treturn -1;\n\n\t/* Completed or failed */\n\tif (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &optval, &optlen) == -1) {\n\t\tdebug(\"getsockopt: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (optval != 0) {\n\t\terrno = optval;\n\t\treturn -1;\n\t}\n\tunset_nonblock(sockfd);\n\treturn 0;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unset_nonblock",
          "args": [
            "sockfd"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"getsockopt: %s\"",
            "strerror(errno)"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "sockfd",
            "SOL_SOCKET",
            "SO_ERROR",
            "&optval",
            "&optlen"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitrfd",
          "args": [
            "sockfd",
            "timeoutp"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "waitrfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "423-448",
          "snippet": "static int\nwaitrfd(int fd, int *timeoutp)\n{\n\tstruct pollfd pfd;\n\tstruct timeval t_start;\n\tint oerrno, r;\n\n\tmonotime_tv(&t_start);\n\tpfd.fd = fd;\n\tpfd.events = POLLIN;\n\tfor (; *timeoutp >= 0;) {\n\t\tr = poll(&pfd, 1, *timeoutp);\n\t\toerrno = errno;\n\t\tms_subtract_diff(&t_start, timeoutp);\n\t\terrno = oerrno;\n\t\tif (r > 0)\n\t\t\treturn 0;\n\t\telse if (r == -1 && errno != EAGAIN)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\t/* timeout */\n\terrno = ETIMEDOUT;\n\treturn -1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nwaitrfd(int fd, int *timeoutp)\n{\n\tstruct pollfd pfd;\n\tstruct timeval t_start;\n\tint oerrno, r;\n\n\tmonotime_tv(&t_start);\n\tpfd.fd = fd;\n\tpfd.events = POLLIN;\n\tfor (; *timeoutp >= 0;) {\n\t\tr = poll(&pfd, 1, *timeoutp);\n\t\toerrno = errno;\n\t\tms_subtract_diff(&t_start, timeoutp);\n\t\terrno = oerrno;\n\t\tif (r > 0)\n\t\t\treturn 0;\n\t\telse if (r == -1 && errno != EAGAIN)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\t/* timeout */\n\terrno = ETIMEDOUT;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sockfd",
            "serv_addr",
            "addrlen"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "298-308",
          "snippet": "void\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ntimeout_connect(int sockfd, const struct sockaddr *serv_addr,\n    socklen_t addrlen, int *timeoutp)\n{\n\tint optval = 0;\n\tsocklen_t optlen = sizeof(optval);\n\n\t/* No timeout: just do a blocking connect() */\n\tif (*timeoutp <= 0)\n\t\treturn connect(sockfd, serv_addr, addrlen);\n\n\tset_nonblock(sockfd);\n\tif (connect(sockfd, serv_addr, addrlen) == 0) {\n\t\t/* Succeeded already? */\n\t\tunset_nonblock(sockfd);\n\t\treturn 0;\n\t} else if (errno != EINPROGRESS)\n\t\treturn -1;\n\n\tif (waitrfd(sockfd, timeoutp) == -1)\n\t\treturn -1;\n\n\t/* Completed or failed */\n\tif (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &optval, &optlen) == -1) {\n\t\tdebug(\"getsockopt: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (optval != 0) {\n\t\terrno = optval;\n\t\treturn -1;\n\t}\n\tunset_nonblock(sockfd);\n\treturn 0;\n}"
  },
  {
    "function_name": "waitrfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "423-448",
    "snippet": "static int\nwaitrfd(int fd, int *timeoutp)\n{\n\tstruct pollfd pfd;\n\tstruct timeval t_start;\n\tint oerrno, r;\n\n\tmonotime_tv(&t_start);\n\tpfd.fd = fd;\n\tpfd.events = POLLIN;\n\tfor (; *timeoutp >= 0;) {\n\t\tr = poll(&pfd, 1, *timeoutp);\n\t\toerrno = errno;\n\t\tms_subtract_diff(&t_start, timeoutp);\n\t\terrno = oerrno;\n\t\tif (r > 0)\n\t\t\treturn 0;\n\t\telse if (r == -1 && errno != EAGAIN)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\t/* timeout */\n\terrno = ETIMEDOUT;\n\treturn -1;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ms_subtract_diff",
          "args": [
            "&t_start",
            "timeoutp"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "ms_subtract_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1255-1263",
          "snippet": "void\nms_subtract_diff(struct timeval *start, int *ms)\n{\n\tstruct timeval diff, finish;\n\n\tmonotime_tv(&finish);\n\ttimersub(&finish, start, &diff);\n\t*ms -= (diff.tv_sec * 1000) + (diff.tv_usec / 1000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nms_subtract_diff(struct timeval *start, int *ms)\n{\n\tstruct timeval diff, finish;\n\n\tmonotime_tv(&finish);\n\ttimersub(&finish, start, &diff);\n\t*ms -= (diff.tv_sec * 1000) + (diff.tv_usec / 1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "&pfd",
            "1",
            "*timeoutp"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "after_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "888-941",
          "snippet": "static void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int sockets_alloc = 0;",
            "SocketEntry *sockets = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "monotime_tv",
          "args": [
            "&t_start"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_tv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1305-1313",
          "snippet": "void\nmonotime_tv(struct timeval *tv)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\ttv->tv_sec = ts.tv_sec;\n\ttv->tv_usec = ts.tv_nsec / 1000;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmonotime_tv(struct timeval *tv)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\ttv->tv_sec = ts.tv_sec;\n\ttv->tv_usec = ts.tv_nsec / 1000;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nwaitrfd(int fd, int *timeoutp)\n{\n\tstruct pollfd pfd;\n\tstruct timeval t_start;\n\tint oerrno, r;\n\n\tmonotime_tv(&t_start);\n\tpfd.fd = fd;\n\tpfd.events = POLLIN;\n\tfor (; *timeoutp >= 0;) {\n\t\tr = poll(&pfd, 1, *timeoutp);\n\t\toerrno = errno;\n\t\tms_subtract_diff(&t_start, timeoutp);\n\t\terrno = oerrno;\n\t\tif (r > 0)\n\t\t\treturn 0;\n\t\telse if (r == -1 && errno != EAGAIN)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\t/* timeout */\n\terrno = ETIMEDOUT;\n\treturn -1;\n}"
  },
  {
    "function_name": "ssh_create_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "333-416",
    "snippet": "static int\nssh_create_socket(struct addrinfo *ai)\n{\n\tint sock, r;\n\tstruct sockaddr_storage bindaddr;\n\tsocklen_t bindaddrlen = 0;\n\tstruct addrinfo hints, *res = NULL;\n#ifdef HAVE_IFADDRS_H\n\tstruct ifaddrs *ifaddrs = NULL;\n#endif\n\tchar ntop[NI_MAXHOST];\n\n\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\tif (sock < 0) {\n\t\terror(\"socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tfcntl(sock, F_SETFD, FD_CLOEXEC);\n\n\t/* Bind the socket to an alternative local IP address */\n\tif (options.bind_address == NULL && options.bind_interface == NULL)\n\t\treturn sock;\n\n\tif (options.bind_address != NULL) {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ai->ai_family;\n\t\thints.ai_socktype = ai->ai_socktype;\n\t\thints.ai_protocol = ai->ai_protocol;\n\t\thints.ai_flags = AI_PASSIVE;\n\t\tif ((r = getaddrinfo(options.bind_address, NULL,\n\t\t    &hints, &res)) != 0) {\n\t\t\terror(\"getaddrinfo: %s: %s\", options.bind_address,\n\t\t\t    ssh_gai_strerror(r));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (res == NULL) {\n\t\t\terror(\"getaddrinfo: no addrs\");\n\t\t\tgoto fail;\n\t\t}\n\t\tmemcpy(&bindaddr, res->ai_addr, res->ai_addrlen);\n\t\tbindaddrlen = res->ai_addrlen;\n\t} else if (options.bind_interface != NULL) {\n#ifdef HAVE_IFADDRS_H\n\t\tif ((r = getifaddrs(&ifaddrs)) != 0) {\n\t\t\terror(\"getifaddrs: %s: %s\", options.bind_interface,\n\t\t\t      strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t\tbindaddrlen = sizeof(bindaddr);\n\t\tif (check_ifaddrs(options.bind_interface, ai->ai_family,\n\t\t    ifaddrs, &bindaddr, &bindaddrlen) != 0) {\n\t\t\tlogit(\"getifaddrs: %s: no suitable addresses\",\n\t\t\t      options.bind_interface);\n\t\t\tgoto fail;\n\t\t}\n#else\n\t\terror(\"BindInterface not supported on this platform.\");\n#endif\n\t}\n\tif ((r = getnameinfo((struct sockaddr *)&bindaddr, bindaddrlen,\n\t    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST)) != 0) {\n\t\terror(\"%s: getnameinfo failed: %s\", __func__,\n\t\t    ssh_gai_strerror(r));\n\t\tgoto fail;\n\t}\n\tif (bind(sock, (struct sockaddr *)&bindaddr, bindaddrlen) != 0) {\n\t\terror(\"bind %s: %s\", ntop, strerror(errno));\n\t\tgoto fail;\n\t}\n\tdebug(\"%s: bound to %s\", __func__, ntop);\n\t/* success */\n\tgoto out;\nfail:\n\tclose(sock);\n\tsock = -1;\n out:\n\tif (res != NULL)\n\t\tfreeaddrinfo(res);\n#ifdef HAVE_IFADDRS_H\n\tif (ifaddrs != NULL)\n\t\tfreeifaddrs(ifaddrs);\n#endif\n\treturn sock;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeifaddrs",
          "args": [
            "ifaddrs"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "res"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: bound to %s\"",
            "__func__",
            "ntop"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"bind %s: %s\"",
            "ntop",
            "strerror(errno)"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "sock",
            "(struct sockaddr *)&bindaddr",
            "bindaddrlen"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "(struct sockaddr *)&bindaddr",
            "bindaddrlen",
            "ntop",
            "sizeof(ntop)",
            "NULL",
            "0",
            "NI_NUMERICHOST"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "sshaix_getnameinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "415-434",
          "snippet": "int\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"getifaddrs: %s: no suitable addresses\"",
            "options.bind_interface"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_ifaddrs",
          "args": [
            "options.bind_interface",
            "ai->ai_family",
            "ifaddrs",
            "&bindaddr",
            "&bindaddrlen"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "check_ifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "273-327",
          "snippet": "static int\ncheck_ifaddrs(const char *ifname, int af, const struct ifaddrs *ifaddrs,\n    struct sockaddr_storage *resultp, socklen_t *rlenp)\n{\n\tstruct sockaddr_in6 *sa6;\n\tstruct sockaddr_in *sa;\n\tstruct in6_addr *v6addr;\n\tconst struct ifaddrs *ifa;\n\tint allow_local;\n\n\t/*\n\t * Prefer addresses that are not loopback or linklocal, but use them\n\t * if nothing else matches.\n\t */\n\tfor (allow_local = 0; allow_local < 2; allow_local++) {\n\t\tfor (ifa = ifaddrs; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (ifa->ifa_addr == NULL || ifa->ifa_name == NULL ||\n\t\t\t    (ifa->ifa_flags & IFF_UP) == 0 ||\n\t\t\t    ifa->ifa_addr->sa_family != af ||\n\t\t\t    strcmp(ifa->ifa_name, options.bind_interface) != 0)\n\t\t\t\tcontinue;\n\t\t\tswitch (ifa->ifa_addr->sa_family) {\n\t\t\tcase AF_INET:\n\t\t\t\tsa = (struct sockaddr_in *)ifa->ifa_addr;\n\t\t\t\tif (!allow_local && sa->sin_addr.s_addr ==\n\t\t\t\t    htonl(INADDR_LOOPBACK))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (*rlenp < sizeof(struct sockaddr_in)) {\n\t\t\t\t\terror(\"%s: v4 addr doesn't fit\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*rlenp = sizeof(struct sockaddr_in);\n\t\t\t\tmemcpy(resultp, sa, *rlenp);\n\t\t\t\treturn 0;\n\t\t\tcase AF_INET6:\n\t\t\t\tsa6 = (struct sockaddr_in6 *)ifa->ifa_addr;\n\t\t\t\tv6addr = &sa6->sin6_addr;\n\t\t\t\tif (!allow_local &&\n\t\t\t\t    (IN6_IS_ADDR_LINKLOCAL(v6addr) ||\n\t\t\t\t    IN6_IS_ADDR_LOOPBACK(v6addr)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (*rlenp < sizeof(struct sockaddr_in6)) {\n\t\t\t\t\terror(\"%s: v6 addr doesn't fit\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*rlenp = sizeof(struct sockaddr_in6);\n\t\t\t\tmemcpy(resultp, sa6, *rlenp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\ncheck_ifaddrs(const char *ifname, int af, const struct ifaddrs *ifaddrs,\n    struct sockaddr_storage *resultp, socklen_t *rlenp)\n{\n\tstruct sockaddr_in6 *sa6;\n\tstruct sockaddr_in *sa;\n\tstruct in6_addr *v6addr;\n\tconst struct ifaddrs *ifa;\n\tint allow_local;\n\n\t/*\n\t * Prefer addresses that are not loopback or linklocal, but use them\n\t * if nothing else matches.\n\t */\n\tfor (allow_local = 0; allow_local < 2; allow_local++) {\n\t\tfor (ifa = ifaddrs; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (ifa->ifa_addr == NULL || ifa->ifa_name == NULL ||\n\t\t\t    (ifa->ifa_flags & IFF_UP) == 0 ||\n\t\t\t    ifa->ifa_addr->sa_family != af ||\n\t\t\t    strcmp(ifa->ifa_name, options.bind_interface) != 0)\n\t\t\t\tcontinue;\n\t\t\tswitch (ifa->ifa_addr->sa_family) {\n\t\t\tcase AF_INET:\n\t\t\t\tsa = (struct sockaddr_in *)ifa->ifa_addr;\n\t\t\t\tif (!allow_local && sa->sin_addr.s_addr ==\n\t\t\t\t    htonl(INADDR_LOOPBACK))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (*rlenp < sizeof(struct sockaddr_in)) {\n\t\t\t\t\terror(\"%s: v4 addr doesn't fit\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*rlenp = sizeof(struct sockaddr_in);\n\t\t\t\tmemcpy(resultp, sa, *rlenp);\n\t\t\t\treturn 0;\n\t\t\tcase AF_INET6:\n\t\t\t\tsa6 = (struct sockaddr_in6 *)ifa->ifa_addr;\n\t\t\t\tv6addr = &sa6->sin6_addr;\n\t\t\t\tif (!allow_local &&\n\t\t\t\t    (IN6_IS_ADDR_LINKLOCAL(v6addr) ||\n\t\t\t\t    IN6_IS_ADDR_LOOPBACK(v6addr)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (*rlenp < sizeof(struct sockaddr_in6)) {\n\t\t\t\t\terror(\"%s: v6 addr doesn't fit\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*rlenp = sizeof(struct sockaddr_in6);\n\t\t\t\tmemcpy(resultp, sa6, *rlenp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getifaddrs",
          "args": [
            "&ifaddrs"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&bindaddr",
            "res->ai_addr",
            "res->ai_addrlen"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "options.bind_address",
            "NULL",
            "&hints",
            "&res"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "sock",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "ai->ai_family",
            "ai->ai_socktype",
            "ai->ai_protocol"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "67-111",
          "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nssh_create_socket(struct addrinfo *ai)\n{\n\tint sock, r;\n\tstruct sockaddr_storage bindaddr;\n\tsocklen_t bindaddrlen = 0;\n\tstruct addrinfo hints, *res = NULL;\n#ifdef HAVE_IFADDRS_H\n\tstruct ifaddrs *ifaddrs = NULL;\n#endif\n\tchar ntop[NI_MAXHOST];\n\n\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\tif (sock < 0) {\n\t\terror(\"socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tfcntl(sock, F_SETFD, FD_CLOEXEC);\n\n\t/* Bind the socket to an alternative local IP address */\n\tif (options.bind_address == NULL && options.bind_interface == NULL)\n\t\treturn sock;\n\n\tif (options.bind_address != NULL) {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ai->ai_family;\n\t\thints.ai_socktype = ai->ai_socktype;\n\t\thints.ai_protocol = ai->ai_protocol;\n\t\thints.ai_flags = AI_PASSIVE;\n\t\tif ((r = getaddrinfo(options.bind_address, NULL,\n\t\t    &hints, &res)) != 0) {\n\t\t\terror(\"getaddrinfo: %s: %s\", options.bind_address,\n\t\t\t    ssh_gai_strerror(r));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (res == NULL) {\n\t\t\terror(\"getaddrinfo: no addrs\");\n\t\t\tgoto fail;\n\t\t}\n\t\tmemcpy(&bindaddr, res->ai_addr, res->ai_addrlen);\n\t\tbindaddrlen = res->ai_addrlen;\n\t} else if (options.bind_interface != NULL) {\n#ifdef HAVE_IFADDRS_H\n\t\tif ((r = getifaddrs(&ifaddrs)) != 0) {\n\t\t\terror(\"getifaddrs: %s: %s\", options.bind_interface,\n\t\t\t      strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t\tbindaddrlen = sizeof(bindaddr);\n\t\tif (check_ifaddrs(options.bind_interface, ai->ai_family,\n\t\t    ifaddrs, &bindaddr, &bindaddrlen) != 0) {\n\t\t\tlogit(\"getifaddrs: %s: no suitable addresses\",\n\t\t\t      options.bind_interface);\n\t\t\tgoto fail;\n\t\t}\n#else\n\t\terror(\"BindInterface not supported on this platform.\");\n#endif\n\t}\n\tif ((r = getnameinfo((struct sockaddr *)&bindaddr, bindaddrlen,\n\t    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST)) != 0) {\n\t\terror(\"%s: getnameinfo failed: %s\", __func__,\n\t\t    ssh_gai_strerror(r));\n\t\tgoto fail;\n\t}\n\tif (bind(sock, (struct sockaddr *)&bindaddr, bindaddrlen) != 0) {\n\t\terror(\"bind %s: %s\", ntop, strerror(errno));\n\t\tgoto fail;\n\t}\n\tdebug(\"%s: bound to %s\", __func__, ntop);\n\t/* success */\n\tgoto out;\nfail:\n\tclose(sock);\n\tsock = -1;\n out:\n\tif (res != NULL)\n\t\tfreeaddrinfo(res);\n#ifdef HAVE_IFADDRS_H\n\tif (ifaddrs != NULL)\n\t\tfreeifaddrs(ifaddrs);\n#endif\n\treturn sock;\n}"
  },
  {
    "function_name": "check_ifaddrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "273-327",
    "snippet": "static int\ncheck_ifaddrs(const char *ifname, int af, const struct ifaddrs *ifaddrs,\n    struct sockaddr_storage *resultp, socklen_t *rlenp)\n{\n\tstruct sockaddr_in6 *sa6;\n\tstruct sockaddr_in *sa;\n\tstruct in6_addr *v6addr;\n\tconst struct ifaddrs *ifa;\n\tint allow_local;\n\n\t/*\n\t * Prefer addresses that are not loopback or linklocal, but use them\n\t * if nothing else matches.\n\t */\n\tfor (allow_local = 0; allow_local < 2; allow_local++) {\n\t\tfor (ifa = ifaddrs; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (ifa->ifa_addr == NULL || ifa->ifa_name == NULL ||\n\t\t\t    (ifa->ifa_flags & IFF_UP) == 0 ||\n\t\t\t    ifa->ifa_addr->sa_family != af ||\n\t\t\t    strcmp(ifa->ifa_name, options.bind_interface) != 0)\n\t\t\t\tcontinue;\n\t\t\tswitch (ifa->ifa_addr->sa_family) {\n\t\t\tcase AF_INET:\n\t\t\t\tsa = (struct sockaddr_in *)ifa->ifa_addr;\n\t\t\t\tif (!allow_local && sa->sin_addr.s_addr ==\n\t\t\t\t    htonl(INADDR_LOOPBACK))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (*rlenp < sizeof(struct sockaddr_in)) {\n\t\t\t\t\terror(\"%s: v4 addr doesn't fit\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*rlenp = sizeof(struct sockaddr_in);\n\t\t\t\tmemcpy(resultp, sa, *rlenp);\n\t\t\t\treturn 0;\n\t\t\tcase AF_INET6:\n\t\t\t\tsa6 = (struct sockaddr_in6 *)ifa->ifa_addr;\n\t\t\t\tv6addr = &sa6->sin6_addr;\n\t\t\t\tif (!allow_local &&\n\t\t\t\t    (IN6_IS_ADDR_LINKLOCAL(v6addr) ||\n\t\t\t\t    IN6_IS_ADDR_LOOPBACK(v6addr)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (*rlenp < sizeof(struct sockaddr_in6)) {\n\t\t\t\t\terror(\"%s: v6 addr doesn't fit\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*rlenp = sizeof(struct sockaddr_in6);\n\t\t\t\tmemcpy(resultp, sa6, *rlenp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "resultp",
            "sa6",
            "*rlenp"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: v6 addr doesn't fit\"",
            "__func__"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_LOOPBACK",
          "args": [
            "v6addr"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_LINKLOCAL",
          "args": [
            "v6addr"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "resultp",
            "sa",
            "*rlenp"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_LOOPBACK"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ifa->ifa_name",
            "options.bind_interface"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\ncheck_ifaddrs(const char *ifname, int af, const struct ifaddrs *ifaddrs,\n    struct sockaddr_storage *resultp, socklen_t *rlenp)\n{\n\tstruct sockaddr_in6 *sa6;\n\tstruct sockaddr_in *sa;\n\tstruct in6_addr *v6addr;\n\tconst struct ifaddrs *ifa;\n\tint allow_local;\n\n\t/*\n\t * Prefer addresses that are not loopback or linklocal, but use them\n\t * if nothing else matches.\n\t */\n\tfor (allow_local = 0; allow_local < 2; allow_local++) {\n\t\tfor (ifa = ifaddrs; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (ifa->ifa_addr == NULL || ifa->ifa_name == NULL ||\n\t\t\t    (ifa->ifa_flags & IFF_UP) == 0 ||\n\t\t\t    ifa->ifa_addr->sa_family != af ||\n\t\t\t    strcmp(ifa->ifa_name, options.bind_interface) != 0)\n\t\t\t\tcontinue;\n\t\t\tswitch (ifa->ifa_addr->sa_family) {\n\t\t\tcase AF_INET:\n\t\t\t\tsa = (struct sockaddr_in *)ifa->ifa_addr;\n\t\t\t\tif (!allow_local && sa->sin_addr.s_addr ==\n\t\t\t\t    htonl(INADDR_LOOPBACK))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (*rlenp < sizeof(struct sockaddr_in)) {\n\t\t\t\t\terror(\"%s: v4 addr doesn't fit\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*rlenp = sizeof(struct sockaddr_in);\n\t\t\t\tmemcpy(resultp, sa, *rlenp);\n\t\t\t\treturn 0;\n\t\t\tcase AF_INET6:\n\t\t\t\tsa6 = (struct sockaddr_in6 *)ifa->ifa_addr;\n\t\t\t\tv6addr = &sa6->sin6_addr;\n\t\t\t\tif (!allow_local &&\n\t\t\t\t    (IN6_IS_ADDR_LINKLOCAL(v6addr) ||\n\t\t\t\t    IN6_IS_ADDR_LOOPBACK(v6addr)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (*rlenp < sizeof(struct sockaddr_in6)) {\n\t\t\t\t\terror(\"%s: v6 addr doesn't fit\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*rlenp = sizeof(struct sockaddr_in6);\n\t\t\t\tmemcpy(resultp, sa6, *rlenp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "ssh_kill_proxy_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "256-265",
    "snippet": "void\nssh_kill_proxy_command(void)\n{\n\t/*\n\t * Send SIGHUP to proxy command if used. We don't wait() in\n\t * case it hangs and instead rely on init to reap the child\n\t */\n\tif (proxy_command_pid > 1)\n\t\tkill(proxy_command_pid, SIGHUP);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static pid_t proxy_command_pid = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "proxy_command_pid",
            "SIGHUP"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic pid_t proxy_command_pid = 0;\n\nvoid\nssh_kill_proxy_command(void)\n{\n\t/*\n\t * Send SIGHUP to proxy command if used. We don't wait() in\n\t * case it hangs and instead rely on init to reap the child\n\t */\n\tif (proxy_command_pid > 1)\n\t\tkill(proxy_command_pid, SIGHUP);\n}"
  },
  {
    "function_name": "ssh_proxy_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "184-254",
    "snippet": "static int\nssh_proxy_connect(struct ssh *ssh, const char *host, u_short port,\n    const char *proxy_command)\n{\n\tchar *command_string;\n\tint pin[2], pout[2];\n\tpid_t pid;\n\tchar *shell;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\t/* Create pipes for communicating with the proxy. */\n\tif (pipe(pin) < 0 || pipe(pout) < 0)\n\t\tfatal(\"Could not create pipes to communicate with the proxy: %.100s\",\n\t\t    strerror(errno));\n\n\tcommand_string = expand_proxy_command(proxy_command, options.user,\n\t    host, port);\n\tdebug(\"Executing proxy command: %.500s\", command_string);\n\n\t/* Fork and execute the proxy command. */\n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[10];\n\n\t\t/* Redirect stdin and stdout. */\n\t\tclose(pin[1]);\n\t\tif (pin[0] != 0) {\n\t\t\tif (dup2(pin[0], 0) < 0)\n\t\t\t\tperror(\"dup2 stdin\");\n\t\t\tclose(pin[0]);\n\t\t}\n\t\tclose(pout[0]);\n\t\tif (dup2(pout[1], 1) < 0)\n\t\t\tperror(\"dup2 stdout\");\n\t\t/* Cannot be 1 because pin allocated two descriptors. */\n\t\tclose(pout[1]);\n\n\t\t/* Stderr is left as it is so that error messages get\n\t\t   printed on the user's terminal. */\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = command_string;\n\t\targv[3] = NULL;\n\n\t\t/* Execute the proxy command.  Note that we gave up any\n\t\t   extra privileges above. */\n\t\tsignal(SIGPIPE, SIG_DFL);\n\t\texecv(argv[0], argv);\n\t\tperror(argv[0]);\n\t\texit(1);\n\t}\n\t/* Parent. */\n\tif (pid < 0)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\telse\n\t\tproxy_command_pid = pid; /* save pid to clean up later */\n\n\t/* Close child side of the descriptors. */\n\tclose(pin[0]);\n\tclose(pout[1]);\n\n\t/* Free the command name. */\n\tfree(command_string);\n\n\t/* Set the connection file descriptors. */\n\tif (ssh_packet_set_connection(ssh, pout[0], pin[1]) == NULL)\n\t\treturn -1; /* ssh_packet_set_connection logs error */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static pid_t proxy_command_pid = 0;",
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_packet_set_connection",
          "args": [
            "ssh",
            "pout[0]",
            "pin[1]"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_set_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "282-317",
          "snippet": "struct ssh *\nssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)\n{\n\tstruct session_state *state;\n\tconst struct sshcipher *none = cipher_by_name(\"none\");\n\tint r;\n\n\tif (none == NULL) {\n\t\terror(\"%s: cannot load cipher 'none'\", __func__);\n\t\treturn NULL;\n\t}\n\tif (ssh == NULL)\n\t\tssh = ssh_alloc_session_state();\n\tif (ssh == NULL) {\n\t\terror(\"%s: cound not allocate state\", __func__);\n\t\treturn NULL;\n\t}\n\tstate = ssh->state;\n\tstate->connection_in = fd_in;\n\tstate->connection_out = fd_out;\n\tif ((r = cipher_init(&state->send_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||\n\t    (r = cipher_init(&state->receive_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {\n\t\terror(\"%s: cipher_init failed: %s\", __func__, ssh_err(r));\n\t\tfree(ssh); /* XXX need ssh_free_session_state? */\n\t\treturn NULL;\n\t}\n\tstate->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;\n\t/*\n\t * Cache the IP address of the remote connection for use in error\n\t * messages that might be generated after the connection has closed.\n\t */\n\t(void)ssh_remote_ipaddr(ssh);\n\treturn ssh;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct ssh *\nssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)\n{\n\tstruct session_state *state;\n\tconst struct sshcipher *none = cipher_by_name(\"none\");\n\tint r;\n\n\tif (none == NULL) {\n\t\terror(\"%s: cannot load cipher 'none'\", __func__);\n\t\treturn NULL;\n\t}\n\tif (ssh == NULL)\n\t\tssh = ssh_alloc_session_state();\n\tif (ssh == NULL) {\n\t\terror(\"%s: cound not allocate state\", __func__);\n\t\treturn NULL;\n\t}\n\tstate = ssh->state;\n\tstate->connection_in = fd_in;\n\tstate->connection_out = fd_out;\n\tif ((r = cipher_init(&state->send_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||\n\t    (r = cipher_init(&state->receive_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {\n\t\terror(\"%s: cipher_init failed: %s\", __func__, ssh_err(r));\n\t\tfree(ssh); /* XXX need ssh_free_session_state? */\n\t\treturn NULL;\n\t}\n\tstate->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;\n\t/*\n\t * Cache the IP address of the remote connection for use in error\n\t * messages that might be generated after the connection has closed.\n\t */\n\t(void)ssh_remote_ipaddr(ssh);\n\treturn ssh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "command_string"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pout[1]"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"fork failed: %.100s\"",
            "strerror(errno)"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "argv[0]"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execv",
          "args": [
            "argv[0]",
            "argv"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGPIPE",
            "SIG_DFL"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"dup2 stdout\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "pout[1]",
            "1"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"dup2 stdin\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "pin[0]",
            "0"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Executing proxy command: %.500s\"",
            "command_string"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "expand_proxy_command",
          "args": [
            "proxy_command",
            "options.user",
            "host",
            "port"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "expand_proxy_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "88-100",
          "snippet": "static char *\nexpand_proxy_command(const char *proxy_command, const char *user,\n    const char *host, int port)\n{\n\tchar *tmp, *ret, strport[NI_MAXSERV];\n\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\txasprintf(&tmp, \"exec %s\", proxy_command);\n\tret = percent_expand(tmp, \"h\", host, \"p\", strport,\n\t    \"r\", options.user, (char *)NULL);\n\tfree(tmp);\n\treturn ret;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic char *\nexpand_proxy_command(const char *proxy_command, const char *user,\n    const char *host, int port)\n{\n\tchar *tmp, *ret, strport[NI_MAXSERV];\n\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\txasprintf(&tmp, \"exec %s\", proxy_command);\n\tret = percent_expand(tmp, \"h\", host, \"p\", strport,\n\t    \"r\", options.user, (char *)NULL);\n\tfree(tmp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pout"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pin"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SHELL\""
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic pid_t proxy_command_pid = 0;\nextern Options options;\n\nstatic int\nssh_proxy_connect(struct ssh *ssh, const char *host, u_short port,\n    const char *proxy_command)\n{\n\tchar *command_string;\n\tint pin[2], pout[2];\n\tpid_t pid;\n\tchar *shell;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\t/* Create pipes for communicating with the proxy. */\n\tif (pipe(pin) < 0 || pipe(pout) < 0)\n\t\tfatal(\"Could not create pipes to communicate with the proxy: %.100s\",\n\t\t    strerror(errno));\n\n\tcommand_string = expand_proxy_command(proxy_command, options.user,\n\t    host, port);\n\tdebug(\"Executing proxy command: %.500s\", command_string);\n\n\t/* Fork and execute the proxy command. */\n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[10];\n\n\t\t/* Redirect stdin and stdout. */\n\t\tclose(pin[1]);\n\t\tif (pin[0] != 0) {\n\t\t\tif (dup2(pin[0], 0) < 0)\n\t\t\t\tperror(\"dup2 stdin\");\n\t\t\tclose(pin[0]);\n\t\t}\n\t\tclose(pout[0]);\n\t\tif (dup2(pout[1], 1) < 0)\n\t\t\tperror(\"dup2 stdout\");\n\t\t/* Cannot be 1 because pin allocated two descriptors. */\n\t\tclose(pout[1]);\n\n\t\t/* Stderr is left as it is so that error messages get\n\t\t   printed on the user's terminal. */\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = command_string;\n\t\targv[3] = NULL;\n\n\t\t/* Execute the proxy command.  Note that we gave up any\n\t\t   extra privileges above. */\n\t\tsignal(SIGPIPE, SIG_DFL);\n\t\texecv(argv[0], argv);\n\t\tperror(argv[0]);\n\t\texit(1);\n\t}\n\t/* Parent. */\n\tif (pid < 0)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\telse\n\t\tproxy_command_pid = pid; /* save pid to clean up later */\n\n\t/* Close child side of the descriptors. */\n\tclose(pin[0]);\n\tclose(pout[1]);\n\n\t/* Free the command name. */\n\tfree(command_string);\n\n\t/* Set the connection file descriptors. */\n\tif (ssh_packet_set_connection(ssh, pout[0], pin[1]) == NULL)\n\t\treturn -1; /* ssh_packet_set_connection logs error */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_proxy_fdpass_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "106-179",
    "snippet": "static int\nssh_proxy_fdpass_connect(struct ssh *ssh, const char *host, u_short port,\n    const char *proxy_command)\n{\n\tchar *command_string;\n\tint sp[2], sock;\n\tpid_t pid;\n\tchar *shell;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL)\n\t\tshell = _PATH_BSHELL;\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) < 0)\n\t\tfatal(\"Could not create socketpair to communicate with \"\n\t\t    \"proxy dialer: %.100s\", strerror(errno));\n\n\tcommand_string = expand_proxy_command(proxy_command, options.user,\n\t    host, port);\n\tdebug(\"Executing proxy dialer command: %.500s\", command_string);\n\n\t/* Fork and execute the proxy command. */\n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[10];\n\n\t\tclose(sp[1]);\n\t\t/* Redirect stdin and stdout. */\n\t\tif (sp[0] != 0) {\n\t\t\tif (dup2(sp[0], 0) < 0)\n\t\t\t\tperror(\"dup2 stdin\");\n\t\t}\n\t\tif (sp[0] != 1) {\n\t\t\tif (dup2(sp[0], 1) < 0)\n\t\t\t\tperror(\"dup2 stdout\");\n\t\t}\n\t\tif (sp[0] >= 2)\n\t\t\tclose(sp[0]);\n\n\t\t/*\n\t\t * Stderr is left as it is so that error messages get\n\t\t * printed on the user's terminal.\n\t\t */\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = command_string;\n\t\targv[3] = NULL;\n\n\t\t/*\n\t\t * Execute the proxy command.\n\t\t * Note that we gave up any extra privileges above.\n\t\t */\n\t\texecv(argv[0], argv);\n\t\tperror(argv[0]);\n\t\texit(1);\n\t}\n\t/* Parent. */\n\tif (pid < 0)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\tclose(sp[0]);\n\tfree(command_string);\n\n\tif ((sock = mm_receive_fd(sp[1])) == -1)\n\t\tfatal(\"proxy dialer did not pass back a connection\");\n\tclose(sp[1]);\n\n\twhile (waitpid(pid, NULL, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\n\t/* Set the connection file descriptors. */\n\tif (ssh_packet_set_connection(ssh, sock, sock) == NULL)\n\t\treturn -1; /* ssh_packet_set_connection logs error */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_packet_set_connection",
          "args": [
            "ssh",
            "sock",
            "sock"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_set_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "282-317",
          "snippet": "struct ssh *\nssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)\n{\n\tstruct session_state *state;\n\tconst struct sshcipher *none = cipher_by_name(\"none\");\n\tint r;\n\n\tif (none == NULL) {\n\t\terror(\"%s: cannot load cipher 'none'\", __func__);\n\t\treturn NULL;\n\t}\n\tif (ssh == NULL)\n\t\tssh = ssh_alloc_session_state();\n\tif (ssh == NULL) {\n\t\terror(\"%s: cound not allocate state\", __func__);\n\t\treturn NULL;\n\t}\n\tstate = ssh->state;\n\tstate->connection_in = fd_in;\n\tstate->connection_out = fd_out;\n\tif ((r = cipher_init(&state->send_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||\n\t    (r = cipher_init(&state->receive_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {\n\t\terror(\"%s: cipher_init failed: %s\", __func__, ssh_err(r));\n\t\tfree(ssh); /* XXX need ssh_free_session_state? */\n\t\treturn NULL;\n\t}\n\tstate->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;\n\t/*\n\t * Cache the IP address of the remote connection for use in error\n\t * messages that might be generated after the connection has closed.\n\t */\n\t(void)ssh_remote_ipaddr(ssh);\n\treturn ssh;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct ssh *\nssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)\n{\n\tstruct session_state *state;\n\tconst struct sshcipher *none = cipher_by_name(\"none\");\n\tint r;\n\n\tif (none == NULL) {\n\t\terror(\"%s: cannot load cipher 'none'\", __func__);\n\t\treturn NULL;\n\t}\n\tif (ssh == NULL)\n\t\tssh = ssh_alloc_session_state();\n\tif (ssh == NULL) {\n\t\terror(\"%s: cound not allocate state\", __func__);\n\t\treturn NULL;\n\t}\n\tstate = ssh->state;\n\tstate->connection_in = fd_in;\n\tstate->connection_out = fd_out;\n\tif ((r = cipher_init(&state->send_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||\n\t    (r = cipher_init(&state->receive_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {\n\t\terror(\"%s: cipher_init failed: %s\", __func__, ssh_err(r));\n\t\tfree(ssh); /* XXX need ssh_free_session_state? */\n\t\treturn NULL;\n\t}\n\tstate->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;\n\t/*\n\t * Cache the IP address of the remote connection for use in error\n\t * messages that might be generated after the connection has closed.\n\t */\n\t(void)ssh_remote_ipaddr(ssh);\n\treturn ssh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Couldn't wait for child: %s\"",
            "strerror(errno)"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "NULL",
            "0"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sp[1]"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"proxy dialer did not pass back a connection\""
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_receive_fd",
          "args": [
            "sp[1]"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "mm_receive_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_fdpass.c",
          "lines": "112-187",
          "snippet": "int\nmm_receive_fd(int sock)\n{\n#if defined(HAVE_RECVMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tssize_t n;\n\tchar ch;\n\tint fd;\n\tstruct pollfd pfd;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&fd;\n\tmsg.msg_accrightslen = sizeof(fd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = &cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n#endif\n\n\tpfd.fd = sock;\n\tpfd.events = POLLIN;\n\twhile ((n = recvmsg(sock, &msg, 0)) == -1 &&\n\t    (errno == EAGAIN || errno == EINTR)) {\n\t\tdebug3(\"%s: recvmsg: %s\", __func__, strerror(errno));\n\t\t(void)poll(&pfd, 1, -1);\n\t}\n\tif (n == -1) {\n\t\terror(\"%s: recvmsg: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (n != 1) {\n\t\terror(\"%s: recvmsg: expected received 1 got %zd\", __func__, n);\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tif (msg.msg_accrightslen != sizeof(fd)) {\n\t\terror(\"%s: no fd\", __func__);\n\t\treturn -1;\n\t}\n#else\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tif (cmsg == NULL) {\n\t\terror(\"%s: no message header\", __func__);\n\t\treturn -1;\n\t}\n\n#ifndef BROKEN_CMSG_TYPE\n\tif (cmsg->cmsg_type != SCM_RIGHTS) {\n\t\terror(\"%s: expected type %d got %d\", __func__,\n\t\t    SCM_RIGHTS, cmsg->cmsg_type);\n\t\treturn -1;\n\t}\n#endif\n\tfd = (*(int *)CMSG_DATA(cmsg));\n#endif\n\treturn fd;\n#else\n\terror(\"%s: file descriptor passing not supported\", __func__);\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include \"monitor_fdpass.h\"",
            "#include \"log.h\"",
            "#  include <sys/poll.h>",
            "# include <poll.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"monitor_fdpass.h\"\n#include \"log.h\"\n#  include <sys/poll.h>\n# include <poll.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmm_receive_fd(int sock)\n{\n#if defined(HAVE_RECVMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tssize_t n;\n\tchar ch;\n\tint fd;\n\tstruct pollfd pfd;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&fd;\n\tmsg.msg_accrightslen = sizeof(fd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = &cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n#endif\n\n\tpfd.fd = sock;\n\tpfd.events = POLLIN;\n\twhile ((n = recvmsg(sock, &msg, 0)) == -1 &&\n\t    (errno == EAGAIN || errno == EINTR)) {\n\t\tdebug3(\"%s: recvmsg: %s\", __func__, strerror(errno));\n\t\t(void)poll(&pfd, 1, -1);\n\t}\n\tif (n == -1) {\n\t\terror(\"%s: recvmsg: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (n != 1) {\n\t\terror(\"%s: recvmsg: expected received 1 got %zd\", __func__, n);\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tif (msg.msg_accrightslen != sizeof(fd)) {\n\t\terror(\"%s: no fd\", __func__);\n\t\treturn -1;\n\t}\n#else\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tif (cmsg == NULL) {\n\t\terror(\"%s: no message header\", __func__);\n\t\treturn -1;\n\t}\n\n#ifndef BROKEN_CMSG_TYPE\n\tif (cmsg->cmsg_type != SCM_RIGHTS) {\n\t\terror(\"%s: expected type %d got %d\", __func__,\n\t\t    SCM_RIGHTS, cmsg->cmsg_type);\n\t\treturn -1;\n\t}\n#endif\n\tfd = (*(int *)CMSG_DATA(cmsg));\n#endif\n\treturn fd;\n#else\n\terror(\"%s: file descriptor passing not supported\", __func__);\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "command_string"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "argv[0]"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execv",
          "args": [
            "argv[0]",
            "argv"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"dup2 stdout\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "sp[0]",
            "1"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"dup2 stdin\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "sp[0]",
            "0"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Executing proxy dialer command: %.500s\"",
            "command_string"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "expand_proxy_command",
          "args": [
            "proxy_command",
            "options.user",
            "host",
            "port"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "expand_proxy_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "88-100",
          "snippet": "static char *\nexpand_proxy_command(const char *proxy_command, const char *user,\n    const char *host, int port)\n{\n\tchar *tmp, *ret, strport[NI_MAXSERV];\n\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\txasprintf(&tmp, \"exec %s\", proxy_command);\n\tret = percent_expand(tmp, \"h\", host, \"p\", strport,\n\t    \"r\", options.user, (char *)NULL);\n\tfree(tmp);\n\treturn ret;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic char *\nexpand_proxy_command(const char *proxy_command, const char *user,\n    const char *host, int port)\n{\n\tchar *tmp, *ret, strport[NI_MAXSERV];\n\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\txasprintf(&tmp, \"exec %s\", proxy_command);\n\tret = percent_expand(tmp, \"h\", host, \"p\", strport,\n\t    \"r\", options.user, (char *)NULL);\n\tfree(tmp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0",
            "sp"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SHELL\""
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nssh_proxy_fdpass_connect(struct ssh *ssh, const char *host, u_short port,\n    const char *proxy_command)\n{\n\tchar *command_string;\n\tint sp[2], sock;\n\tpid_t pid;\n\tchar *shell;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL)\n\t\tshell = _PATH_BSHELL;\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) < 0)\n\t\tfatal(\"Could not create socketpair to communicate with \"\n\t\t    \"proxy dialer: %.100s\", strerror(errno));\n\n\tcommand_string = expand_proxy_command(proxy_command, options.user,\n\t    host, port);\n\tdebug(\"Executing proxy dialer command: %.500s\", command_string);\n\n\t/* Fork and execute the proxy command. */\n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[10];\n\n\t\tclose(sp[1]);\n\t\t/* Redirect stdin and stdout. */\n\t\tif (sp[0] != 0) {\n\t\t\tif (dup2(sp[0], 0) < 0)\n\t\t\t\tperror(\"dup2 stdin\");\n\t\t}\n\t\tif (sp[0] != 1) {\n\t\t\tif (dup2(sp[0], 1) < 0)\n\t\t\t\tperror(\"dup2 stdout\");\n\t\t}\n\t\tif (sp[0] >= 2)\n\t\t\tclose(sp[0]);\n\n\t\t/*\n\t\t * Stderr is left as it is so that error messages get\n\t\t * printed on the user's terminal.\n\t\t */\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = command_string;\n\t\targv[3] = NULL;\n\n\t\t/*\n\t\t * Execute the proxy command.\n\t\t * Note that we gave up any extra privileges above.\n\t\t */\n\t\texecv(argv[0], argv);\n\t\tperror(argv[0]);\n\t\texit(1);\n\t}\n\t/* Parent. */\n\tif (pid < 0)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\tclose(sp[0]);\n\tfree(command_string);\n\n\tif ((sock = mm_receive_fd(sp[1])) == -1)\n\t\tfatal(\"proxy dialer did not pass back a connection\");\n\tclose(sp[1]);\n\n\twhile (waitpid(pid, NULL, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\n\t/* Set the connection file descriptors. */\n\tif (ssh_packet_set_connection(ssh, sock, sock) == NULL)\n\t\treturn -1; /* ssh_packet_set_connection logs error */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "expand_proxy_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
    "lines": "88-100",
    "snippet": "static char *\nexpand_proxy_command(const char *proxy_command, const char *user,\n    const char *host, int port)\n{\n\tchar *tmp, *ret, strport[NI_MAXSERV];\n\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\txasprintf(&tmp, \"exec %s\", proxy_command);\n\tret = percent_expand(tmp, \"h\", host, \"p\", strport,\n\t    \"r\", options.user, (char *)NULL);\n\tfree(tmp);\n\treturn ret;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"version.h\"",
      "#include \"ssh2.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"dns.h\"",
      "#include \"atomicio.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"sshkey.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"hostfile.h\"",
      "#include \"xmalloc.h\"",
      "# include <ifaddrs.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percent_expand",
          "args": [
            "tmp",
            "\"h\"",
            "host",
            "\"p\"",
            "strport",
            "\"r\"",
            "options.user",
            "(char *)NULL"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "percent_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "973-1029",
          "snippet": "char *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define EXPAND_MAX_KEYS\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define EXPAND_MAX_KEYS\t16\n\nchar *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&tmp",
            "\"exec %s\"",
            "proxy_command"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strport",
            "sizeof strport",
            "\"%d\"",
            "port"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic char *\nexpand_proxy_command(const char *proxy_command, const char *user,\n    const char *host, int port)\n{\n\tchar *tmp, *ret, strport[NI_MAXSERV];\n\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\txasprintf(&tmp, \"exec %s\", proxy_command);\n\tret = percent_expand(tmp, \"h\", host, \"p\", strport,\n\t    \"r\", options.user, (char *)NULL);\n\tfree(tmp);\n\treturn ret;\n}"
  }
]