[
  {
    "function_name": "chachapoly_get_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher-chachapoly.c",
    "lines": "106-119",
    "snippet": "int\nchachapoly_get_length(struct chachapoly_ctx *ctx,\n    u_int *plenp, u_int seqnr, const u_char *cp, u_int len)\n{\n\tu_char buf[4], seqbuf[8];\n\n\tif (len < 4)\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tPOKE_U64(seqbuf, seqnr);\n\tchacha_ivsetup(&ctx->header_ctx, seqbuf, NULL);\n\tchacha_encrypt_bytes(&ctx->header_ctx, cp, buf, 4);\n\t*plenp = PEEK_U32(buf);\n\treturn 0;\n}",
    "includes": [
      "#include \"cipher-chachapoly.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include <stdio.h>  /* needed for misc.h */",
      "#include <string.h>",
      "#include <stdarg.h> /* needed for log.h */",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "buf"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chacha_encrypt_bytes",
          "args": [
            "&ctx->header_ctx",
            "cp",
            "buf",
            "4"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "chacha_encrypt_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/chacha.c",
          "lines": "89-219",
          "snippet": "void\nchacha_encrypt_bytes(chacha_ctx *x,const u8 *m,u8 *c,u32 bytes)\n{\n  u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n  u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n  u8 *ctarget = NULL;\n  u8 tmp[64];\n  u_int i;\n\n  if (!bytes) return;\n\n  j0 = x->input[0];\n  j1 = x->input[1];\n  j2 = x->input[2];\n  j3 = x->input[3];\n  j4 = x->input[4];\n  j5 = x->input[5];\n  j6 = x->input[6];\n  j7 = x->input[7];\n  j8 = x->input[8];\n  j9 = x->input[9];\n  j10 = x->input[10];\n  j11 = x->input[11];\n  j12 = x->input[12];\n  j13 = x->input[13];\n  j14 = x->input[14];\n  j15 = x->input[15];\n\n  for (;;) {\n    if (bytes < 64) {\n      for (i = 0;i < bytes;++i) tmp[i] = m[i];\n      m = tmp;\n      ctarget = c;\n      c = tmp;\n    }\n    x0 = j0;\n    x1 = j1;\n    x2 = j2;\n    x3 = j3;\n    x4 = j4;\n    x5 = j5;\n    x6 = j6;\n    x7 = j7;\n    x8 = j8;\n    x9 = j9;\n    x10 = j10;\n    x11 = j11;\n    x12 = j12;\n    x13 = j13;\n    x14 = j14;\n    x15 = j15;\n    for (i = 20;i > 0;i -= 2) {\n      QUARTERROUND( x0, x4, x8,x12)\n      QUARTERROUND( x1, x5, x9,x13)\n      QUARTERROUND( x2, x6,x10,x14)\n      QUARTERROUND( x3, x7,x11,x15)\n      QUARTERROUND( x0, x5,x10,x15)\n      QUARTERROUND( x1, x6,x11,x12)\n      QUARTERROUND( x2, x7, x8,x13)\n      QUARTERROUND( x3, x4, x9,x14)\n    }\n    x0 = PLUS(x0,j0);\n    x1 = PLUS(x1,j1);\n    x2 = PLUS(x2,j2);\n    x3 = PLUS(x3,j3);\n    x4 = PLUS(x4,j4);\n    x5 = PLUS(x5,j5);\n    x6 = PLUS(x6,j6);\n    x7 = PLUS(x7,j7);\n    x8 = PLUS(x8,j8);\n    x9 = PLUS(x9,j9);\n    x10 = PLUS(x10,j10);\n    x11 = PLUS(x11,j11);\n    x12 = PLUS(x12,j12);\n    x13 = PLUS(x13,j13);\n    x14 = PLUS(x14,j14);\n    x15 = PLUS(x15,j15);\n\n    x0 = XOR(x0,U8TO32_LITTLE(m + 0));\n    x1 = XOR(x1,U8TO32_LITTLE(m + 4));\n    x2 = XOR(x2,U8TO32_LITTLE(m + 8));\n    x3 = XOR(x3,U8TO32_LITTLE(m + 12));\n    x4 = XOR(x4,U8TO32_LITTLE(m + 16));\n    x5 = XOR(x5,U8TO32_LITTLE(m + 20));\n    x6 = XOR(x6,U8TO32_LITTLE(m + 24));\n    x7 = XOR(x7,U8TO32_LITTLE(m + 28));\n    x8 = XOR(x8,U8TO32_LITTLE(m + 32));\n    x9 = XOR(x9,U8TO32_LITTLE(m + 36));\n    x10 = XOR(x10,U8TO32_LITTLE(m + 40));\n    x11 = XOR(x11,U8TO32_LITTLE(m + 44));\n    x12 = XOR(x12,U8TO32_LITTLE(m + 48));\n    x13 = XOR(x13,U8TO32_LITTLE(m + 52));\n    x14 = XOR(x14,U8TO32_LITTLE(m + 56));\n    x15 = XOR(x15,U8TO32_LITTLE(m + 60));\n\n    j12 = PLUSONE(j12);\n    if (!j12) {\n      j13 = PLUSONE(j13);\n      /* stopping at 2^70 bytes per nonce is user's responsibility */\n    }\n\n    U32TO8_LITTLE(c + 0,x0);\n    U32TO8_LITTLE(c + 4,x1);\n    U32TO8_LITTLE(c + 8,x2);\n    U32TO8_LITTLE(c + 12,x3);\n    U32TO8_LITTLE(c + 16,x4);\n    U32TO8_LITTLE(c + 20,x5);\n    U32TO8_LITTLE(c + 24,x6);\n    U32TO8_LITTLE(c + 28,x7);\n    U32TO8_LITTLE(c + 32,x8);\n    U32TO8_LITTLE(c + 36,x9);\n    U32TO8_LITTLE(c + 40,x10);\n    U32TO8_LITTLE(c + 44,x11);\n    U32TO8_LITTLE(c + 48,x12);\n    U32TO8_LITTLE(c + 52,x13);\n    U32TO8_LITTLE(c + 56,x14);\n    U32TO8_LITTLE(c + 60,x15);\n\n    if (bytes <= 64) {\n      if (bytes < 64) {\n        for (i = 0;i < bytes;++i) ctarget[i] = c[i];\n      }\n      x->input[12] = j12;\n      x->input[13] = j13;\n      return;\n    }\n    bytes -= 64;\n    c += 64;\n    m += 64;\n  }\n}",
          "includes": [
            "#include \"chacha.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"chacha.h\"\n#include \"includes.h\"\n\nvoid\nchacha_encrypt_bytes(chacha_ctx *x,const u8 *m,u8 *c,u32 bytes)\n{\n  u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n  u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n  u8 *ctarget = NULL;\n  u8 tmp[64];\n  u_int i;\n\n  if (!bytes) return;\n\n  j0 = x->input[0];\n  j1 = x->input[1];\n  j2 = x->input[2];\n  j3 = x->input[3];\n  j4 = x->input[4];\n  j5 = x->input[5];\n  j6 = x->input[6];\n  j7 = x->input[7];\n  j8 = x->input[8];\n  j9 = x->input[9];\n  j10 = x->input[10];\n  j11 = x->input[11];\n  j12 = x->input[12];\n  j13 = x->input[13];\n  j14 = x->input[14];\n  j15 = x->input[15];\n\n  for (;;) {\n    if (bytes < 64) {\n      for (i = 0;i < bytes;++i) tmp[i] = m[i];\n      m = tmp;\n      ctarget = c;\n      c = tmp;\n    }\n    x0 = j0;\n    x1 = j1;\n    x2 = j2;\n    x3 = j3;\n    x4 = j4;\n    x5 = j5;\n    x6 = j6;\n    x7 = j7;\n    x8 = j8;\n    x9 = j9;\n    x10 = j10;\n    x11 = j11;\n    x12 = j12;\n    x13 = j13;\n    x14 = j14;\n    x15 = j15;\n    for (i = 20;i > 0;i -= 2) {\n      QUARTERROUND( x0, x4, x8,x12)\n      QUARTERROUND( x1, x5, x9,x13)\n      QUARTERROUND( x2, x6,x10,x14)\n      QUARTERROUND( x3, x7,x11,x15)\n      QUARTERROUND( x0, x5,x10,x15)\n      QUARTERROUND( x1, x6,x11,x12)\n      QUARTERROUND( x2, x7, x8,x13)\n      QUARTERROUND( x3, x4, x9,x14)\n    }\n    x0 = PLUS(x0,j0);\n    x1 = PLUS(x1,j1);\n    x2 = PLUS(x2,j2);\n    x3 = PLUS(x3,j3);\n    x4 = PLUS(x4,j4);\n    x5 = PLUS(x5,j5);\n    x6 = PLUS(x6,j6);\n    x7 = PLUS(x7,j7);\n    x8 = PLUS(x8,j8);\n    x9 = PLUS(x9,j9);\n    x10 = PLUS(x10,j10);\n    x11 = PLUS(x11,j11);\n    x12 = PLUS(x12,j12);\n    x13 = PLUS(x13,j13);\n    x14 = PLUS(x14,j14);\n    x15 = PLUS(x15,j15);\n\n    x0 = XOR(x0,U8TO32_LITTLE(m + 0));\n    x1 = XOR(x1,U8TO32_LITTLE(m + 4));\n    x2 = XOR(x2,U8TO32_LITTLE(m + 8));\n    x3 = XOR(x3,U8TO32_LITTLE(m + 12));\n    x4 = XOR(x4,U8TO32_LITTLE(m + 16));\n    x5 = XOR(x5,U8TO32_LITTLE(m + 20));\n    x6 = XOR(x6,U8TO32_LITTLE(m + 24));\n    x7 = XOR(x7,U8TO32_LITTLE(m + 28));\n    x8 = XOR(x8,U8TO32_LITTLE(m + 32));\n    x9 = XOR(x9,U8TO32_LITTLE(m + 36));\n    x10 = XOR(x10,U8TO32_LITTLE(m + 40));\n    x11 = XOR(x11,U8TO32_LITTLE(m + 44));\n    x12 = XOR(x12,U8TO32_LITTLE(m + 48));\n    x13 = XOR(x13,U8TO32_LITTLE(m + 52));\n    x14 = XOR(x14,U8TO32_LITTLE(m + 56));\n    x15 = XOR(x15,U8TO32_LITTLE(m + 60));\n\n    j12 = PLUSONE(j12);\n    if (!j12) {\n      j13 = PLUSONE(j13);\n      /* stopping at 2^70 bytes per nonce is user's responsibility */\n    }\n\n    U32TO8_LITTLE(c + 0,x0);\n    U32TO8_LITTLE(c + 4,x1);\n    U32TO8_LITTLE(c + 8,x2);\n    U32TO8_LITTLE(c + 12,x3);\n    U32TO8_LITTLE(c + 16,x4);\n    U32TO8_LITTLE(c + 20,x5);\n    U32TO8_LITTLE(c + 24,x6);\n    U32TO8_LITTLE(c + 28,x7);\n    U32TO8_LITTLE(c + 32,x8);\n    U32TO8_LITTLE(c + 36,x9);\n    U32TO8_LITTLE(c + 40,x10);\n    U32TO8_LITTLE(c + 44,x11);\n    U32TO8_LITTLE(c + 48,x12);\n    U32TO8_LITTLE(c + 52,x13);\n    U32TO8_LITTLE(c + 56,x14);\n    U32TO8_LITTLE(c + 60,x15);\n\n    if (bytes <= 64) {\n      if (bytes < 64) {\n        for (i = 0;i < bytes;++i) ctarget[i] = c[i];\n      }\n      x->input[12] = j12;\n      x->input[13] = j13;\n      return;\n    }\n    bytes -= 64;\n    c += 64;\n    m += 64;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "chacha_ivsetup",
          "args": [
            "&ctx->header_ctx",
            "seqbuf",
            "NULL"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "chacha_ivsetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/chacha.c",
          "lines": "80-87",
          "snippet": "void\nchacha_ivsetup(chacha_ctx *x, const u8 *iv, const u8 *counter)\n{\n  x->input[12] = counter == NULL ? 0 : U8TO32_LITTLE(counter + 0);\n  x->input[13] = counter == NULL ? 0 : U8TO32_LITTLE(counter + 4);\n  x->input[14] = U8TO32_LITTLE(iv + 0);\n  x->input[15] = U8TO32_LITTLE(iv + 4);\n}",
          "includes": [
            "#include \"chacha.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"chacha.h\"\n#include \"includes.h\"\n\nvoid\nchacha_ivsetup(chacha_ctx *x, const u8 *iv, const u8 *counter)\n{\n  x->input[12] = counter == NULL ? 0 : U8TO32_LITTLE(counter + 0);\n  x->input[13] = counter == NULL ? 0 : U8TO32_LITTLE(counter + 4);\n  x->input[14] = U8TO32_LITTLE(iv + 0);\n  x->input[15] = U8TO32_LITTLE(iv + 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "POKE_U64",
          "args": [
            "seqbuf",
            "seqnr"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cipher-chachapoly.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include <stdio.h>  /* needed for misc.h */\n#include <string.h>\n#include <stdarg.h> /* needed for log.h */\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nchachapoly_get_length(struct chachapoly_ctx *ctx,\n    u_int *plenp, u_int seqnr, const u_char *cp, u_int len)\n{\n\tu_char buf[4], seqbuf[8];\n\n\tif (len < 4)\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tPOKE_U64(seqbuf, seqnr);\n\tchacha_ivsetup(&ctx->header_ctx, seqbuf, NULL);\n\tchacha_encrypt_bytes(&ctx->header_ctx, cp, buf, 4);\n\t*plenp = PEEK_U32(buf);\n\treturn 0;\n}"
  },
  {
    "function_name": "chachapoly_crypt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher-chachapoly.c",
    "lines": "51-103",
    "snippet": "int\nchachapoly_crypt(struct chachapoly_ctx *ctx, u_int seqnr, u_char *dest,\n    const u_char *src, u_int len, u_int aadlen, u_int authlen, int do_encrypt)\n{\n\tu_char seqbuf[8];\n\tconst u_char one[8] = { 1, 0, 0, 0, 0, 0, 0, 0 }; /* NB little-endian */\n\tu_char expected_tag[POLY1305_TAGLEN], poly_key[POLY1305_KEYLEN];\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t/*\n\t * Run ChaCha20 once to generate the Poly1305 key. The IV is the\n\t * packet sequence number.\n\t */\n\tmemset(poly_key, 0, sizeof(poly_key));\n\tPOKE_U64(seqbuf, seqnr);\n\tchacha_ivsetup(&ctx->main_ctx, seqbuf, NULL);\n\tchacha_encrypt_bytes(&ctx->main_ctx,\n\t    poly_key, poly_key, sizeof(poly_key));\n\n\t/* If decrypting, check tag before anything else */\n\tif (!do_encrypt) {\n\t\tconst u_char *tag = src + aadlen + len;\n\n\t\tpoly1305_auth(expected_tag, src, aadlen + len, poly_key);\n\t\tif (timingsafe_bcmp(expected_tag, tag, POLY1305_TAGLEN) != 0) {\n\t\t\tr = SSH_ERR_MAC_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Crypt additional data */\n\tif (aadlen) {\n\t\tchacha_ivsetup(&ctx->header_ctx, seqbuf, NULL);\n\t\tchacha_encrypt_bytes(&ctx->header_ctx, src, dest, aadlen);\n\t}\n\n\t/* Set Chacha's block counter to 1 */\n\tchacha_ivsetup(&ctx->main_ctx, seqbuf, one);\n\tchacha_encrypt_bytes(&ctx->main_ctx, src + aadlen,\n\t    dest + aadlen, len);\n\n\t/* If encrypting, calculate and append tag */\n\tif (do_encrypt) {\n\t\tpoly1305_auth(dest + aadlen + len, dest, aadlen + len,\n\t\t    poly_key);\n\t}\n\tr = 0;\n out:\n\texplicit_bzero(expected_tag, sizeof(expected_tag));\n\texplicit_bzero(seqbuf, sizeof(seqbuf));\n\texplicit_bzero(poly_key, sizeof(poly_key));\n\treturn r;\n}",
    "includes": [
      "#include \"cipher-chachapoly.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include <stdio.h>  /* needed for misc.h */",
      "#include <string.h>",
      "#include <stdarg.h> /* needed for log.h */",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "poly_key",
            "sizeof(poly_key)"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poly1305_auth",
          "args": [
            "dest + aadlen + len",
            "dest",
            "aadlen + len",
            "poly_key"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "poly1305_auth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/poly1305.c",
          "lines": "33-160",
          "snippet": "void\npoly1305_auth(unsigned char out[POLY1305_TAGLEN], const unsigned char *m, size_t inlen, const unsigned char key[POLY1305_KEYLEN]) {\n\tuint32_t t0,t1,t2,t3;\n\tuint32_t h0,h1,h2,h3,h4;\n\tuint32_t r0,r1,r2,r3,r4;\n\tuint32_t s1,s2,s3,s4;\n\tuint32_t b, nb;\n\tsize_t j;\n\tuint64_t t[5];\n\tuint64_t f0,f1,f2,f3;\n\tuint32_t g0,g1,g2,g3,g4;\n\tuint64_t c;\n\tunsigned char mp[16];\n\n\t/* clamp key */\n\tt0 = U8TO32_LE(key+0);\n\tt1 = U8TO32_LE(key+4);\n\tt2 = U8TO32_LE(key+8);\n\tt3 = U8TO32_LE(key+12);\n\n\t/* precompute multipliers */\n\tr0 = t0 & 0x3ffffff; t0 >>= 26; t0 |= t1 << 6;\n\tr1 = t0 & 0x3ffff03; t1 >>= 20; t1 |= t2 << 12;\n\tr2 = t1 & 0x3ffc0ff; t2 >>= 14; t2 |= t3 << 18;\n\tr3 = t2 & 0x3f03fff; t3 >>= 8;\n\tr4 = t3 & 0x00fffff;\n\n\ts1 = r1 * 5;\n\ts2 = r2 * 5;\n\ts3 = r3 * 5;\n\ts4 = r4 * 5;\n\n\t/* init state */\n\th0 = 0;\n\th1 = 0;\n\th2 = 0;\n\th3 = 0;\n\th4 = 0;\n\n\t/* full blocks */\n\tif (inlen < 16) goto poly1305_donna_atmost15bytes;\npoly1305_donna_16bytes:\n\tm += 16;\n\tinlen -= 16;\n\n\tt0 = U8TO32_LE(m-16);\n\tt1 = U8TO32_LE(m-12);\n\tt2 = U8TO32_LE(m-8);\n\tt3 = U8TO32_LE(m-4);\n\n\th0 += t0 & 0x3ffffff;\n\th1 += ((((uint64_t)t1 << 32) | t0) >> 26) & 0x3ffffff;\n\th2 += ((((uint64_t)t2 << 32) | t1) >> 20) & 0x3ffffff;\n\th3 += ((((uint64_t)t3 << 32) | t2) >> 14) & 0x3ffffff;\n\th4 += (t3 >> 8) | (1 << 24);\n\n\npoly1305_donna_mul:\n\tt[0]  = mul32x32_64(h0,r0) + mul32x32_64(h1,s4) + mul32x32_64(h2,s3) + mul32x32_64(h3,s2) + mul32x32_64(h4,s1);\n\tt[1]  = mul32x32_64(h0,r1) + mul32x32_64(h1,r0) + mul32x32_64(h2,s4) + mul32x32_64(h3,s3) + mul32x32_64(h4,s2);\n\tt[2]  = mul32x32_64(h0,r2) + mul32x32_64(h1,r1) + mul32x32_64(h2,r0) + mul32x32_64(h3,s4) + mul32x32_64(h4,s3);\n\tt[3]  = mul32x32_64(h0,r3) + mul32x32_64(h1,r2) + mul32x32_64(h2,r1) + mul32x32_64(h3,r0) + mul32x32_64(h4,s4);\n\tt[4]  = mul32x32_64(h0,r4) + mul32x32_64(h1,r3) + mul32x32_64(h2,r2) + mul32x32_64(h3,r1) + mul32x32_64(h4,r0);\n\n\t                h0 = (uint32_t)t[0] & 0x3ffffff; c =           (t[0] >> 26);\n\tt[1] += c;      h1 = (uint32_t)t[1] & 0x3ffffff; b = (uint32_t)(t[1] >> 26);\n\tt[2] += b;      h2 = (uint32_t)t[2] & 0x3ffffff; b = (uint32_t)(t[2] >> 26);\n\tt[3] += b;      h3 = (uint32_t)t[3] & 0x3ffffff; b = (uint32_t)(t[3] >> 26);\n\tt[4] += b;      h4 = (uint32_t)t[4] & 0x3ffffff; b = (uint32_t)(t[4] >> 26);\n\th0 += b * 5;\n\n\tif (inlen >= 16) goto poly1305_donna_16bytes;\n\n\t/* final bytes */\npoly1305_donna_atmost15bytes:\n\tif (!inlen) goto poly1305_donna_finish;\n\n\tfor (j = 0; j < inlen; j++) mp[j] = m[j];\n\tmp[j++] = 1;\n\tfor (; j < 16; j++)\tmp[j] = 0;\n\tinlen = 0;\n\n\tt0 = U8TO32_LE(mp+0);\n\tt1 = U8TO32_LE(mp+4);\n\tt2 = U8TO32_LE(mp+8);\n\tt3 = U8TO32_LE(mp+12);\n\n\th0 += t0 & 0x3ffffff;\n\th1 += ((((uint64_t)t1 << 32) | t0) >> 26) & 0x3ffffff;\n\th2 += ((((uint64_t)t2 << 32) | t1) >> 20) & 0x3ffffff;\n\th3 += ((((uint64_t)t3 << 32) | t2) >> 14) & 0x3ffffff;\n\th4 += (t3 >> 8);\n\n\tgoto poly1305_donna_mul;\n\npoly1305_donna_finish:\n\t             b = h0 >> 26; h0 = h0 & 0x3ffffff;\n\th1 +=     b; b = h1 >> 26; h1 = h1 & 0x3ffffff;\n\th2 +=     b; b = h2 >> 26; h2 = h2 & 0x3ffffff;\n\th3 +=     b; b = h3 >> 26; h3 = h3 & 0x3ffffff;\n\th4 +=     b; b = h4 >> 26; h4 = h4 & 0x3ffffff;\n\th0 += b * 5; b = h0 >> 26; h0 = h0 & 0x3ffffff;\n\th1 +=     b;\n\n\tg0 = h0 + 5; b = g0 >> 26; g0 &= 0x3ffffff;\n\tg1 = h1 + b; b = g1 >> 26; g1 &= 0x3ffffff;\n\tg2 = h2 + b; b = g2 >> 26; g2 &= 0x3ffffff;\n\tg3 = h3 + b; b = g3 >> 26; g3 &= 0x3ffffff;\n\tg4 = h4 + b - (1 << 26);\n\n\tb = (g4 >> 31) - 1;\n\tnb = ~b;\n\th0 = (h0 & nb) | (g0 & b);\n\th1 = (h1 & nb) | (g1 & b);\n\th2 = (h2 & nb) | (g2 & b);\n\th3 = (h3 & nb) | (g3 & b);\n\th4 = (h4 & nb) | (g4 & b);\n\n\tf0 = ((h0      ) | (h1 << 26)) + (uint64_t)U8TO32_LE(&key[16]);\n\tf1 = ((h1 >>  6) | (h2 << 20)) + (uint64_t)U8TO32_LE(&key[20]);\n\tf2 = ((h2 >> 12) | (h3 << 14)) + (uint64_t)U8TO32_LE(&key[24]);\n\tf3 = ((h3 >> 18) | (h4 <<  8)) + (uint64_t)U8TO32_LE(&key[28]);\n\n\tU32TO8_LE(&out[ 0], f0); f1 += (f0 >> 32);\n\tU32TO8_LE(&out[ 4], f1); f2 += (f1 >> 32);\n\tU32TO8_LE(&out[ 8], f2); f3 += (f2 >> 32);\n\tU32TO8_LE(&out[12], f3);\n}",
          "includes": [
            "#include \"poly1305.h\"",
            "# include <stdint.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"poly1305.h\"\n# include <stdint.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\npoly1305_auth(unsigned char out[POLY1305_TAGLEN], const unsigned char *m, size_t inlen, const unsigned char key[POLY1305_KEYLEN]) {\n\tuint32_t t0,t1,t2,t3;\n\tuint32_t h0,h1,h2,h3,h4;\n\tuint32_t r0,r1,r2,r3,r4;\n\tuint32_t s1,s2,s3,s4;\n\tuint32_t b, nb;\n\tsize_t j;\n\tuint64_t t[5];\n\tuint64_t f0,f1,f2,f3;\n\tuint32_t g0,g1,g2,g3,g4;\n\tuint64_t c;\n\tunsigned char mp[16];\n\n\t/* clamp key */\n\tt0 = U8TO32_LE(key+0);\n\tt1 = U8TO32_LE(key+4);\n\tt2 = U8TO32_LE(key+8);\n\tt3 = U8TO32_LE(key+12);\n\n\t/* precompute multipliers */\n\tr0 = t0 & 0x3ffffff; t0 >>= 26; t0 |= t1 << 6;\n\tr1 = t0 & 0x3ffff03; t1 >>= 20; t1 |= t2 << 12;\n\tr2 = t1 & 0x3ffc0ff; t2 >>= 14; t2 |= t3 << 18;\n\tr3 = t2 & 0x3f03fff; t3 >>= 8;\n\tr4 = t3 & 0x00fffff;\n\n\ts1 = r1 * 5;\n\ts2 = r2 * 5;\n\ts3 = r3 * 5;\n\ts4 = r4 * 5;\n\n\t/* init state */\n\th0 = 0;\n\th1 = 0;\n\th2 = 0;\n\th3 = 0;\n\th4 = 0;\n\n\t/* full blocks */\n\tif (inlen < 16) goto poly1305_donna_atmost15bytes;\npoly1305_donna_16bytes:\n\tm += 16;\n\tinlen -= 16;\n\n\tt0 = U8TO32_LE(m-16);\n\tt1 = U8TO32_LE(m-12);\n\tt2 = U8TO32_LE(m-8);\n\tt3 = U8TO32_LE(m-4);\n\n\th0 += t0 & 0x3ffffff;\n\th1 += ((((uint64_t)t1 << 32) | t0) >> 26) & 0x3ffffff;\n\th2 += ((((uint64_t)t2 << 32) | t1) >> 20) & 0x3ffffff;\n\th3 += ((((uint64_t)t3 << 32) | t2) >> 14) & 0x3ffffff;\n\th4 += (t3 >> 8) | (1 << 24);\n\n\npoly1305_donna_mul:\n\tt[0]  = mul32x32_64(h0,r0) + mul32x32_64(h1,s4) + mul32x32_64(h2,s3) + mul32x32_64(h3,s2) + mul32x32_64(h4,s1);\n\tt[1]  = mul32x32_64(h0,r1) + mul32x32_64(h1,r0) + mul32x32_64(h2,s4) + mul32x32_64(h3,s3) + mul32x32_64(h4,s2);\n\tt[2]  = mul32x32_64(h0,r2) + mul32x32_64(h1,r1) + mul32x32_64(h2,r0) + mul32x32_64(h3,s4) + mul32x32_64(h4,s3);\n\tt[3]  = mul32x32_64(h0,r3) + mul32x32_64(h1,r2) + mul32x32_64(h2,r1) + mul32x32_64(h3,r0) + mul32x32_64(h4,s4);\n\tt[4]  = mul32x32_64(h0,r4) + mul32x32_64(h1,r3) + mul32x32_64(h2,r2) + mul32x32_64(h3,r1) + mul32x32_64(h4,r0);\n\n\t                h0 = (uint32_t)t[0] & 0x3ffffff; c =           (t[0] >> 26);\n\tt[1] += c;      h1 = (uint32_t)t[1] & 0x3ffffff; b = (uint32_t)(t[1] >> 26);\n\tt[2] += b;      h2 = (uint32_t)t[2] & 0x3ffffff; b = (uint32_t)(t[2] >> 26);\n\tt[3] += b;      h3 = (uint32_t)t[3] & 0x3ffffff; b = (uint32_t)(t[3] >> 26);\n\tt[4] += b;      h4 = (uint32_t)t[4] & 0x3ffffff; b = (uint32_t)(t[4] >> 26);\n\th0 += b * 5;\n\n\tif (inlen >= 16) goto poly1305_donna_16bytes;\n\n\t/* final bytes */\npoly1305_donna_atmost15bytes:\n\tif (!inlen) goto poly1305_donna_finish;\n\n\tfor (j = 0; j < inlen; j++) mp[j] = m[j];\n\tmp[j++] = 1;\n\tfor (; j < 16; j++)\tmp[j] = 0;\n\tinlen = 0;\n\n\tt0 = U8TO32_LE(mp+0);\n\tt1 = U8TO32_LE(mp+4);\n\tt2 = U8TO32_LE(mp+8);\n\tt3 = U8TO32_LE(mp+12);\n\n\th0 += t0 & 0x3ffffff;\n\th1 += ((((uint64_t)t1 << 32) | t0) >> 26) & 0x3ffffff;\n\th2 += ((((uint64_t)t2 << 32) | t1) >> 20) & 0x3ffffff;\n\th3 += ((((uint64_t)t3 << 32) | t2) >> 14) & 0x3ffffff;\n\th4 += (t3 >> 8);\n\n\tgoto poly1305_donna_mul;\n\npoly1305_donna_finish:\n\t             b = h0 >> 26; h0 = h0 & 0x3ffffff;\n\th1 +=     b; b = h1 >> 26; h1 = h1 & 0x3ffffff;\n\th2 +=     b; b = h2 >> 26; h2 = h2 & 0x3ffffff;\n\th3 +=     b; b = h3 >> 26; h3 = h3 & 0x3ffffff;\n\th4 +=     b; b = h4 >> 26; h4 = h4 & 0x3ffffff;\n\th0 += b * 5; b = h0 >> 26; h0 = h0 & 0x3ffffff;\n\th1 +=     b;\n\n\tg0 = h0 + 5; b = g0 >> 26; g0 &= 0x3ffffff;\n\tg1 = h1 + b; b = g1 >> 26; g1 &= 0x3ffffff;\n\tg2 = h2 + b; b = g2 >> 26; g2 &= 0x3ffffff;\n\tg3 = h3 + b; b = g3 >> 26; g3 &= 0x3ffffff;\n\tg4 = h4 + b - (1 << 26);\n\n\tb = (g4 >> 31) - 1;\n\tnb = ~b;\n\th0 = (h0 & nb) | (g0 & b);\n\th1 = (h1 & nb) | (g1 & b);\n\th2 = (h2 & nb) | (g2 & b);\n\th3 = (h3 & nb) | (g3 & b);\n\th4 = (h4 & nb) | (g4 & b);\n\n\tf0 = ((h0      ) | (h1 << 26)) + (uint64_t)U8TO32_LE(&key[16]);\n\tf1 = ((h1 >>  6) | (h2 << 20)) + (uint64_t)U8TO32_LE(&key[20]);\n\tf2 = ((h2 >> 12) | (h3 << 14)) + (uint64_t)U8TO32_LE(&key[24]);\n\tf3 = ((h3 >> 18) | (h4 <<  8)) + (uint64_t)U8TO32_LE(&key[28]);\n\n\tU32TO8_LE(&out[ 0], f0); f1 += (f0 >> 32);\n\tU32TO8_LE(&out[ 4], f1); f2 += (f1 >> 32);\n\tU32TO8_LE(&out[ 8], f2); f3 += (f2 >> 32);\n\tU32TO8_LE(&out[12], f3);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chacha_encrypt_bytes",
          "args": [
            "&ctx->main_ctx",
            "src + aadlen",
            "dest + aadlen",
            "len"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "chacha_encrypt_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/chacha.c",
          "lines": "89-219",
          "snippet": "void\nchacha_encrypt_bytes(chacha_ctx *x,const u8 *m,u8 *c,u32 bytes)\n{\n  u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n  u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n  u8 *ctarget = NULL;\n  u8 tmp[64];\n  u_int i;\n\n  if (!bytes) return;\n\n  j0 = x->input[0];\n  j1 = x->input[1];\n  j2 = x->input[2];\n  j3 = x->input[3];\n  j4 = x->input[4];\n  j5 = x->input[5];\n  j6 = x->input[6];\n  j7 = x->input[7];\n  j8 = x->input[8];\n  j9 = x->input[9];\n  j10 = x->input[10];\n  j11 = x->input[11];\n  j12 = x->input[12];\n  j13 = x->input[13];\n  j14 = x->input[14];\n  j15 = x->input[15];\n\n  for (;;) {\n    if (bytes < 64) {\n      for (i = 0;i < bytes;++i) tmp[i] = m[i];\n      m = tmp;\n      ctarget = c;\n      c = tmp;\n    }\n    x0 = j0;\n    x1 = j1;\n    x2 = j2;\n    x3 = j3;\n    x4 = j4;\n    x5 = j5;\n    x6 = j6;\n    x7 = j7;\n    x8 = j8;\n    x9 = j9;\n    x10 = j10;\n    x11 = j11;\n    x12 = j12;\n    x13 = j13;\n    x14 = j14;\n    x15 = j15;\n    for (i = 20;i > 0;i -= 2) {\n      QUARTERROUND( x0, x4, x8,x12)\n      QUARTERROUND( x1, x5, x9,x13)\n      QUARTERROUND( x2, x6,x10,x14)\n      QUARTERROUND( x3, x7,x11,x15)\n      QUARTERROUND( x0, x5,x10,x15)\n      QUARTERROUND( x1, x6,x11,x12)\n      QUARTERROUND( x2, x7, x8,x13)\n      QUARTERROUND( x3, x4, x9,x14)\n    }\n    x0 = PLUS(x0,j0);\n    x1 = PLUS(x1,j1);\n    x2 = PLUS(x2,j2);\n    x3 = PLUS(x3,j3);\n    x4 = PLUS(x4,j4);\n    x5 = PLUS(x5,j5);\n    x6 = PLUS(x6,j6);\n    x7 = PLUS(x7,j7);\n    x8 = PLUS(x8,j8);\n    x9 = PLUS(x9,j9);\n    x10 = PLUS(x10,j10);\n    x11 = PLUS(x11,j11);\n    x12 = PLUS(x12,j12);\n    x13 = PLUS(x13,j13);\n    x14 = PLUS(x14,j14);\n    x15 = PLUS(x15,j15);\n\n    x0 = XOR(x0,U8TO32_LITTLE(m + 0));\n    x1 = XOR(x1,U8TO32_LITTLE(m + 4));\n    x2 = XOR(x2,U8TO32_LITTLE(m + 8));\n    x3 = XOR(x3,U8TO32_LITTLE(m + 12));\n    x4 = XOR(x4,U8TO32_LITTLE(m + 16));\n    x5 = XOR(x5,U8TO32_LITTLE(m + 20));\n    x6 = XOR(x6,U8TO32_LITTLE(m + 24));\n    x7 = XOR(x7,U8TO32_LITTLE(m + 28));\n    x8 = XOR(x8,U8TO32_LITTLE(m + 32));\n    x9 = XOR(x9,U8TO32_LITTLE(m + 36));\n    x10 = XOR(x10,U8TO32_LITTLE(m + 40));\n    x11 = XOR(x11,U8TO32_LITTLE(m + 44));\n    x12 = XOR(x12,U8TO32_LITTLE(m + 48));\n    x13 = XOR(x13,U8TO32_LITTLE(m + 52));\n    x14 = XOR(x14,U8TO32_LITTLE(m + 56));\n    x15 = XOR(x15,U8TO32_LITTLE(m + 60));\n\n    j12 = PLUSONE(j12);\n    if (!j12) {\n      j13 = PLUSONE(j13);\n      /* stopping at 2^70 bytes per nonce is user's responsibility */\n    }\n\n    U32TO8_LITTLE(c + 0,x0);\n    U32TO8_LITTLE(c + 4,x1);\n    U32TO8_LITTLE(c + 8,x2);\n    U32TO8_LITTLE(c + 12,x3);\n    U32TO8_LITTLE(c + 16,x4);\n    U32TO8_LITTLE(c + 20,x5);\n    U32TO8_LITTLE(c + 24,x6);\n    U32TO8_LITTLE(c + 28,x7);\n    U32TO8_LITTLE(c + 32,x8);\n    U32TO8_LITTLE(c + 36,x9);\n    U32TO8_LITTLE(c + 40,x10);\n    U32TO8_LITTLE(c + 44,x11);\n    U32TO8_LITTLE(c + 48,x12);\n    U32TO8_LITTLE(c + 52,x13);\n    U32TO8_LITTLE(c + 56,x14);\n    U32TO8_LITTLE(c + 60,x15);\n\n    if (bytes <= 64) {\n      if (bytes < 64) {\n        for (i = 0;i < bytes;++i) ctarget[i] = c[i];\n      }\n      x->input[12] = j12;\n      x->input[13] = j13;\n      return;\n    }\n    bytes -= 64;\n    c += 64;\n    m += 64;\n  }\n}",
          "includes": [
            "#include \"chacha.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"chacha.h\"\n#include \"includes.h\"\n\nvoid\nchacha_encrypt_bytes(chacha_ctx *x,const u8 *m,u8 *c,u32 bytes)\n{\n  u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n  u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n  u8 *ctarget = NULL;\n  u8 tmp[64];\n  u_int i;\n\n  if (!bytes) return;\n\n  j0 = x->input[0];\n  j1 = x->input[1];\n  j2 = x->input[2];\n  j3 = x->input[3];\n  j4 = x->input[4];\n  j5 = x->input[5];\n  j6 = x->input[6];\n  j7 = x->input[7];\n  j8 = x->input[8];\n  j9 = x->input[9];\n  j10 = x->input[10];\n  j11 = x->input[11];\n  j12 = x->input[12];\n  j13 = x->input[13];\n  j14 = x->input[14];\n  j15 = x->input[15];\n\n  for (;;) {\n    if (bytes < 64) {\n      for (i = 0;i < bytes;++i) tmp[i] = m[i];\n      m = tmp;\n      ctarget = c;\n      c = tmp;\n    }\n    x0 = j0;\n    x1 = j1;\n    x2 = j2;\n    x3 = j3;\n    x4 = j4;\n    x5 = j5;\n    x6 = j6;\n    x7 = j7;\n    x8 = j8;\n    x9 = j9;\n    x10 = j10;\n    x11 = j11;\n    x12 = j12;\n    x13 = j13;\n    x14 = j14;\n    x15 = j15;\n    for (i = 20;i > 0;i -= 2) {\n      QUARTERROUND( x0, x4, x8,x12)\n      QUARTERROUND( x1, x5, x9,x13)\n      QUARTERROUND( x2, x6,x10,x14)\n      QUARTERROUND( x3, x7,x11,x15)\n      QUARTERROUND( x0, x5,x10,x15)\n      QUARTERROUND( x1, x6,x11,x12)\n      QUARTERROUND( x2, x7, x8,x13)\n      QUARTERROUND( x3, x4, x9,x14)\n    }\n    x0 = PLUS(x0,j0);\n    x1 = PLUS(x1,j1);\n    x2 = PLUS(x2,j2);\n    x3 = PLUS(x3,j3);\n    x4 = PLUS(x4,j4);\n    x5 = PLUS(x5,j5);\n    x6 = PLUS(x6,j6);\n    x7 = PLUS(x7,j7);\n    x8 = PLUS(x8,j8);\n    x9 = PLUS(x9,j9);\n    x10 = PLUS(x10,j10);\n    x11 = PLUS(x11,j11);\n    x12 = PLUS(x12,j12);\n    x13 = PLUS(x13,j13);\n    x14 = PLUS(x14,j14);\n    x15 = PLUS(x15,j15);\n\n    x0 = XOR(x0,U8TO32_LITTLE(m + 0));\n    x1 = XOR(x1,U8TO32_LITTLE(m + 4));\n    x2 = XOR(x2,U8TO32_LITTLE(m + 8));\n    x3 = XOR(x3,U8TO32_LITTLE(m + 12));\n    x4 = XOR(x4,U8TO32_LITTLE(m + 16));\n    x5 = XOR(x5,U8TO32_LITTLE(m + 20));\n    x6 = XOR(x6,U8TO32_LITTLE(m + 24));\n    x7 = XOR(x7,U8TO32_LITTLE(m + 28));\n    x8 = XOR(x8,U8TO32_LITTLE(m + 32));\n    x9 = XOR(x9,U8TO32_LITTLE(m + 36));\n    x10 = XOR(x10,U8TO32_LITTLE(m + 40));\n    x11 = XOR(x11,U8TO32_LITTLE(m + 44));\n    x12 = XOR(x12,U8TO32_LITTLE(m + 48));\n    x13 = XOR(x13,U8TO32_LITTLE(m + 52));\n    x14 = XOR(x14,U8TO32_LITTLE(m + 56));\n    x15 = XOR(x15,U8TO32_LITTLE(m + 60));\n\n    j12 = PLUSONE(j12);\n    if (!j12) {\n      j13 = PLUSONE(j13);\n      /* stopping at 2^70 bytes per nonce is user's responsibility */\n    }\n\n    U32TO8_LITTLE(c + 0,x0);\n    U32TO8_LITTLE(c + 4,x1);\n    U32TO8_LITTLE(c + 8,x2);\n    U32TO8_LITTLE(c + 12,x3);\n    U32TO8_LITTLE(c + 16,x4);\n    U32TO8_LITTLE(c + 20,x5);\n    U32TO8_LITTLE(c + 24,x6);\n    U32TO8_LITTLE(c + 28,x7);\n    U32TO8_LITTLE(c + 32,x8);\n    U32TO8_LITTLE(c + 36,x9);\n    U32TO8_LITTLE(c + 40,x10);\n    U32TO8_LITTLE(c + 44,x11);\n    U32TO8_LITTLE(c + 48,x12);\n    U32TO8_LITTLE(c + 52,x13);\n    U32TO8_LITTLE(c + 56,x14);\n    U32TO8_LITTLE(c + 60,x15);\n\n    if (bytes <= 64) {\n      if (bytes < 64) {\n        for (i = 0;i < bytes;++i) ctarget[i] = c[i];\n      }\n      x->input[12] = j12;\n      x->input[13] = j13;\n      return;\n    }\n    bytes -= 64;\n    c += 64;\n    m += 64;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "chacha_ivsetup",
          "args": [
            "&ctx->main_ctx",
            "seqbuf",
            "one"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "chacha_ivsetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/chacha.c",
          "lines": "80-87",
          "snippet": "void\nchacha_ivsetup(chacha_ctx *x, const u8 *iv, const u8 *counter)\n{\n  x->input[12] = counter == NULL ? 0 : U8TO32_LITTLE(counter + 0);\n  x->input[13] = counter == NULL ? 0 : U8TO32_LITTLE(counter + 4);\n  x->input[14] = U8TO32_LITTLE(iv + 0);\n  x->input[15] = U8TO32_LITTLE(iv + 4);\n}",
          "includes": [
            "#include \"chacha.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"chacha.h\"\n#include \"includes.h\"\n\nvoid\nchacha_ivsetup(chacha_ctx *x, const u8 *iv, const u8 *counter)\n{\n  x->input[12] = counter == NULL ? 0 : U8TO32_LITTLE(counter + 0);\n  x->input[13] = counter == NULL ? 0 : U8TO32_LITTLE(counter + 4);\n  x->input[14] = U8TO32_LITTLE(iv + 0);\n  x->input[15] = U8TO32_LITTLE(iv + 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timingsafe_bcmp",
          "args": [
            "expected_tag",
            "tag",
            "POLY1305_TAGLEN"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "timingsafe_bcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/timingsafe_bcmp.c",
          "lines": "23-32",
          "snippet": "int\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}",
          "includes": [
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"includes.h\"\n\nint\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "POKE_U64",
          "args": [
            "seqbuf",
            "seqnr"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "poly_key",
            "0",
            "sizeof(poly_key)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cipher-chachapoly.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include <stdio.h>  /* needed for misc.h */\n#include <string.h>\n#include <stdarg.h> /* needed for log.h */\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nchachapoly_crypt(struct chachapoly_ctx *ctx, u_int seqnr, u_char *dest,\n    const u_char *src, u_int len, u_int aadlen, u_int authlen, int do_encrypt)\n{\n\tu_char seqbuf[8];\n\tconst u_char one[8] = { 1, 0, 0, 0, 0, 0, 0, 0 }; /* NB little-endian */\n\tu_char expected_tag[POLY1305_TAGLEN], poly_key[POLY1305_KEYLEN];\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t/*\n\t * Run ChaCha20 once to generate the Poly1305 key. The IV is the\n\t * packet sequence number.\n\t */\n\tmemset(poly_key, 0, sizeof(poly_key));\n\tPOKE_U64(seqbuf, seqnr);\n\tchacha_ivsetup(&ctx->main_ctx, seqbuf, NULL);\n\tchacha_encrypt_bytes(&ctx->main_ctx,\n\t    poly_key, poly_key, sizeof(poly_key));\n\n\t/* If decrypting, check tag before anything else */\n\tif (!do_encrypt) {\n\t\tconst u_char *tag = src + aadlen + len;\n\n\t\tpoly1305_auth(expected_tag, src, aadlen + len, poly_key);\n\t\tif (timingsafe_bcmp(expected_tag, tag, POLY1305_TAGLEN) != 0) {\n\t\t\tr = SSH_ERR_MAC_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Crypt additional data */\n\tif (aadlen) {\n\t\tchacha_ivsetup(&ctx->header_ctx, seqbuf, NULL);\n\t\tchacha_encrypt_bytes(&ctx->header_ctx, src, dest, aadlen);\n\t}\n\n\t/* Set Chacha's block counter to 1 */\n\tchacha_ivsetup(&ctx->main_ctx, seqbuf, one);\n\tchacha_encrypt_bytes(&ctx->main_ctx, src + aadlen,\n\t    dest + aadlen, len);\n\n\t/* If encrypting, calculate and append tag */\n\tif (do_encrypt) {\n\t\tpoly1305_auth(dest + aadlen + len, dest, aadlen + len,\n\t\t    poly_key);\n\t}\n\tr = 0;\n out:\n\texplicit_bzero(expected_tag, sizeof(expected_tag));\n\texplicit_bzero(seqbuf, sizeof(seqbuf));\n\texplicit_bzero(poly_key, sizeof(poly_key));\n\treturn r;\n}"
  },
  {
    "function_name": "chachapoly_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher-chachapoly.c",
    "lines": "31-40",
    "snippet": "int\nchachapoly_init(struct chachapoly_ctx *ctx,\n    const u_char *key, u_int keylen)\n{\n\tif (keylen != (32 + 32)) /* 2 x 256 bit keys */\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tchacha_keysetup(&ctx->main_ctx, key, 256);\n\tchacha_keysetup(&ctx->header_ctx, key + 32, 256);\n\treturn 0;\n}",
    "includes": [
      "#include \"cipher-chachapoly.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include <stdio.h>  /* needed for misc.h */",
      "#include <string.h>",
      "#include <stdarg.h> /* needed for log.h */",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chacha_keysetup",
          "args": [
            "&ctx->header_ctx",
            "key + 32",
            "256"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "chacha_keysetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/chacha.c",
          "lines": "55-78",
          "snippet": "void\nchacha_keysetup(chacha_ctx *x,const u8 *k,u32 kbits)\n{\n  const char *constants;\n\n  x->input[4] = U8TO32_LITTLE(k + 0);\n  x->input[5] = U8TO32_LITTLE(k + 4);\n  x->input[6] = U8TO32_LITTLE(k + 8);\n  x->input[7] = U8TO32_LITTLE(k + 12);\n  if (kbits == 256) { /* recommended */\n    k += 16;\n    constants = sigma;\n  } else { /* kbits == 128 */\n    constants = tau;\n  }\n  x->input[8] = U8TO32_LITTLE(k + 0);\n  x->input[9] = U8TO32_LITTLE(k + 4);\n  x->input[10] = U8TO32_LITTLE(k + 8);\n  x->input[11] = U8TO32_LITTLE(k + 12);\n  x->input[0] = U8TO32_LITTLE(constants + 0);\n  x->input[1] = U8TO32_LITTLE(constants + 4);\n  x->input[2] = U8TO32_LITTLE(constants + 8);\n  x->input[3] = U8TO32_LITTLE(constants + 12);\n}",
          "includes": [
            "#include \"chacha.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char sigma[16] = \"expand 32-byte k\";",
            "static const char tau[16] = \"expand 16-byte k\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chacha.h\"\n#include \"includes.h\"\n\nstatic const char sigma[16] = \"expand 32-byte k\";\nstatic const char tau[16] = \"expand 16-byte k\";\n\nvoid\nchacha_keysetup(chacha_ctx *x,const u8 *k,u32 kbits)\n{\n  const char *constants;\n\n  x->input[4] = U8TO32_LITTLE(k + 0);\n  x->input[5] = U8TO32_LITTLE(k + 4);\n  x->input[6] = U8TO32_LITTLE(k + 8);\n  x->input[7] = U8TO32_LITTLE(k + 12);\n  if (kbits == 256) { /* recommended */\n    k += 16;\n    constants = sigma;\n  } else { /* kbits == 128 */\n    constants = tau;\n  }\n  x->input[8] = U8TO32_LITTLE(k + 0);\n  x->input[9] = U8TO32_LITTLE(k + 4);\n  x->input[10] = U8TO32_LITTLE(k + 8);\n  x->input[11] = U8TO32_LITTLE(k + 12);\n  x->input[0] = U8TO32_LITTLE(constants + 0);\n  x->input[1] = U8TO32_LITTLE(constants + 4);\n  x->input[2] = U8TO32_LITTLE(constants + 8);\n  x->input[3] = U8TO32_LITTLE(constants + 12);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cipher-chachapoly.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include <stdio.h>  /* needed for misc.h */\n#include <string.h>\n#include <stdarg.h> /* needed for log.h */\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nchachapoly_init(struct chachapoly_ctx *ctx,\n    const u_char *key, u_int keylen)\n{\n\tif (keylen != (32 + 32)) /* 2 x 256 bit keys */\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tchacha_keysetup(&ctx->main_ctx, key, 256);\n\tchacha_keysetup(&ctx->header_ctx, key + 32, 256);\n\treturn 0;\n}"
  }
]