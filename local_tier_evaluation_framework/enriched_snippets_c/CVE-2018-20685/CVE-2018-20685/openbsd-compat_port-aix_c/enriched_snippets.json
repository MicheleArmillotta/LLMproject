[
  {
    "function_name": "getgrouplist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
    "lines": "439-477",
    "snippet": "int\ngetgrouplist(const char *user, gid_t pgid, gid_t *groups, int *grpcnt)\n{\n\tchar *cp, *grplist, *grp;\n\tgid_t gid;\n\tint ret = 0, ngroups = 0, maxgroups;\n\tlong l;\n\n\tmaxgroups = *grpcnt;\n\n\tif ((cp = grplist = getgrset(user)) == NULL)\n\t\treturn -1;\n\n\t/* handle zero-length case */\n\tif (maxgroups <= 0) {\n\t\t*grpcnt = 0;\n\t\treturn -1;\n\t}\n\n\t/* copy primary group */\n\tgroups[ngroups++] = pgid;\n\n\t/* copy each entry from getgrset into group list */\n\twhile ((grp = strsep(&grplist, \",\")) != NULL) {\n\t\tl = strtol(grp, NULL, 10);\n\t\tif (ngroups >= maxgroups || l == LONG_MIN || l == LONG_MAX) {\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tgid = (gid_t)l;\n\t\tif (gid == pgid)\n\t\t\tcontinue;\t/* we have already added primary gid */\n\t\tgroups[ngroups++] = gid;\n\t}\nout:\n\tfree(cp);\n\t*grpcnt = ngroups;\n\treturn ret;\n}",
    "includes": [
      "#  include <stdlib.h>",
      "#include \"port-aix.h\"",
      "# include <usersec.h>",
      "#  include <sys/audit.h>",
      "# include <userpw.h>",
      "# include <login.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <uinfo.h>",
      "# include <netdb.h>",
      "#include <errno.h>",
      "#include \"log.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cp"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "grp",
            "NULL",
            "10"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "strtoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtoll.c",
          "lines": "49-147",
          "snippet": "long long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nlong long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&grplist",
            "\",\""
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "strsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strsep.c",
          "lines": "52-77",
          "snippet": "char *\nstrsep(char **stringp, const char *delim)\n{\n\tchar *s;\n\tconst char *spanp;\n\tint c, sc;\n\tchar *tok;\n\n\tif ((s = *stringp) == NULL)\n\t\treturn (NULL);\n\tfor (tok = s;;) {\n\t\tc = *s++;\n\t\tspanp = delim;\n\t\tdo {\n\t\t\tif ((sc = *spanp++) == c) {\n\t\t\t\tif (c == 0)\n\t\t\t\t\ts = NULL;\n\t\t\t\telse\n\t\t\t\t\ts[-1] = 0;\n\t\t\t\t*stringp = s;\n\t\t\t\treturn (tok);\n\t\t\t}\n\t\t} while (sc != 0);\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <string.h>\n#include \"includes.h\"\n\nchar *\nstrsep(char **stringp, const char *delim)\n{\n\tchar *s;\n\tconst char *spanp;\n\tint c, sc;\n\tchar *tok;\n\n\tif ((s = *stringp) == NULL)\n\t\treturn (NULL);\n\tfor (tok = s;;) {\n\t\tc = *s++;\n\t\tspanp = delim;\n\t\tdo {\n\t\t\tif ((sc = *spanp++) == c) {\n\t\t\t\tif (c == 0)\n\t\t\t\t\ts = NULL;\n\t\t\t\telse\n\t\t\t\t\ts[-1] = 0;\n\t\t\t\t*stringp = s;\n\t\t\t\treturn (tok);\n\t\t\t}\n\t\t} while (sc != 0);\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgrset",
          "args": [
            "user"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\ngetgrouplist(const char *user, gid_t pgid, gid_t *groups, int *grpcnt)\n{\n\tchar *cp, *grplist, *grp;\n\tgid_t gid;\n\tint ret = 0, ngroups = 0, maxgroups;\n\tlong l;\n\n\tmaxgroups = *grpcnt;\n\n\tif ((cp = grplist = getgrset(user)) == NULL)\n\t\treturn -1;\n\n\t/* handle zero-length case */\n\tif (maxgroups <= 0) {\n\t\t*grpcnt = 0;\n\t\treturn -1;\n\t}\n\n\t/* copy primary group */\n\tgroups[ngroups++] = pgid;\n\n\t/* copy each entry from getgrset into group list */\n\twhile ((grp = strsep(&grplist, \",\")) != NULL) {\n\t\tl = strtol(grp, NULL, 10);\n\t\tif (ngroups >= maxgroups || l == LONG_MIN || l == LONG_MAX) {\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tgid = (gid_t)l;\n\t\tif (gid == pgid)\n\t\t\tcontinue;\t/* we have already added primary gid */\n\t\tgroups[ngroups++] = gid;\n\t}\nout:\n\tfree(cp);\n\t*grpcnt = ngroups;\n\treturn ret;\n}"
  },
  {
    "function_name": "sshaix_getnameinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
    "lines": "415-434",
    "snippet": "int\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}",
    "includes": [
      "#  include <stdlib.h>",
      "#include \"port-aix.h\"",
      "# include <usersec.h>",
      "#  include <sys/audit.h>",
      "# include <userpw.h>",
      "# include <login.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <uinfo.h>",
      "# include <netdb.h>",
      "#include <errno.h>",
      "#include \"log.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "sa",
            "salen",
            "host",
            "hostlen",
            "serv",
            "servlen",
            "flags"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "sshaix_getnameinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "415-434",
          "snippet": "int\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "serv",
            "servlen",
            "\"%d\"",
            "sa6->sin6_port"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "host",
            "\"::\"",
            "hostlen"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      }
    ],
    "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}"
  },
  {
    "function_name": "aix_krb5_get_principal_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
    "lines": "388-405",
    "snippet": "char *\naix_krb5_get_principal_name(char *pw_name)\n{\n\tchar *authname = NULL, *authdomain = NULL, *principal = NULL;\n\n\tsetuserdb(S_READ);\n\tif (getuserattr(pw_name, S_AUTHDOMAIN, &authdomain, SEC_CHAR) != 0)\n\t\tdebug(\"AIX getuserattr S_AUTHDOMAIN: %s\", strerror(errno));\n\tif (getuserattr(pw_name, S_AUTHNAME, &authname, SEC_CHAR) != 0)\n\t\tdebug(\"AIX getuserattr S_AUTHNAME: %s\", strerror(errno));\n\n\tif (authdomain != NULL)\n\t\txasprintf(&principal, \"%s@%s\", authname ? authname : pw_name, authdomain);\n\telse if (authname != NULL)\n\t\tprincipal = xstrdup(authname);\n\tenduserdb();\n\treturn principal;\n}",
    "includes": [
      "#  include <stdlib.h>",
      "#include \"port-aix.h\"",
      "# include <usersec.h>",
      "#  include <sys/audit.h>",
      "# include <userpw.h>",
      "# include <login.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <uinfo.h>",
      "# include <netdb.h>",
      "#include <errno.h>",
      "#include \"log.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enduserdb",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "authname"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&principal",
            "\"%s@%s\"",
            "authname ? authname : pw_name",
            "authdomain"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"AIX getuserattr S_AUTHNAME: %s\"",
            "strerror(errno)"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuserattr",
          "args": [
            "pw_name",
            "S_AUTHNAME",
            "&authname",
            "SEC_CHAR"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuserattr",
          "args": [
            "pw_name",
            "S_AUTHDOMAIN",
            "&authdomain",
            "SEC_CHAR"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuserdb",
          "args": [
            "S_READ"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nchar *\naix_krb5_get_principal_name(char *pw_name)\n{\n\tchar *authname = NULL, *authdomain = NULL, *principal = NULL;\n\n\tsetuserdb(S_READ);\n\tif (getuserattr(pw_name, S_AUTHDOMAIN, &authdomain, SEC_CHAR) != 0)\n\t\tdebug(\"AIX getuserattr S_AUTHDOMAIN: %s\", strerror(errno));\n\tif (getuserattr(pw_name, S_AUTHNAME, &authname, SEC_CHAR) != 0)\n\t\tdebug(\"AIX getuserattr S_AUTHNAME: %s\", strerror(errno));\n\n\tif (authdomain != NULL)\n\t\txasprintf(&principal, \"%s@%s\", authname ? authname : pw_name, authdomain);\n\telse if (authname != NULL)\n\t\tprincipal = xstrdup(authname);\n\tenduserdb();\n\treturn principal;\n}"
  },
  {
    "function_name": "aix_restoreauthdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
    "lines": "368-379",
    "snippet": "void\naix_restoreauthdb(void)\n{\n#  ifdef HAVE_SETAUTHDB\n\tif (setauthdb(old_registry, NULL) == 0)\n\t\tdebug3(\"%s: restoring old registry '%s'\", __func__,\n\t\t    old_registry);\n\telse\n\t\tdebug3(\"%s: failed to restore old registry %s\", __func__,\n\t\t    old_registry);\n#  endif /* HAVE_SETAUTHDB */\n}",
    "includes": [
      "#  include <stdlib.h>",
      "#include \"port-aix.h\"",
      "# include <usersec.h>",
      "#  include <sys/audit.h>",
      "# include <userpw.h>",
      "# include <login.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <uinfo.h>",
      "# include <netdb.h>",
      "#include <errno.h>",
      "#include \"log.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: failed to restore old registry %s\"",
            "__func__",
            "old_registry"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setauthdb",
          "args": [
            "old_registry",
            "NULL"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_restoreauthdb(void)\n{\n#  ifdef HAVE_SETAUTHDB\n\tif (setauthdb(old_registry, NULL) == 0)\n\t\tdebug3(\"%s: restoring old registry '%s'\", __func__,\n\t\t    old_registry);\n\telse\n\t\tdebug3(\"%s: failed to restore old registry %s\", __func__,\n\t\t    old_registry);\n#  endif /* HAVE_SETAUTHDB */\n}"
  },
  {
    "function_name": "aix_setauthdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
    "lines": "338-360",
    "snippet": "void\naix_setauthdb(const char *user)\n{\n#  ifdef HAVE_SETAUTHDB\n\tchar *registry;\n\n\tif (setuserdb(S_READ) == -1) {\n\t\tdebug3(\"%s: Could not open userdb to read\", __func__);\n\t\treturn;\n\t}\n\n\tif (getuserattr((char *)user, S_REGISTRY, &registry, SEC_CHAR) == 0) {\n\t\tif (setauthdb(registry, old_registry) == 0)\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s'\", registry);\n\t\telse\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s' failed: %s\",\n\t\t\t    registry, strerror(errno));\n\t} else\n\t\tdebug3(\"%s: Could not read S_REGISTRY for user: %s\", __func__,\n\t\t    strerror(errno));\n\tenduserdb();\n#  endif /* HAVE_SETAUTHDB */\n}",
    "includes": [
      "#  include <stdlib.h>",
      "#include \"port-aix.h\"",
      "# include <usersec.h>",
      "#  include <sys/audit.h>",
      "# include <userpw.h>",
      "# include <login.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <uinfo.h>",
      "# include <netdb.h>",
      "#include <errno.h>",
      "#include \"log.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enduserdb",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: Could not read S_REGISTRY for user: %s\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setauthdb",
          "args": [
            "registry",
            "old_registry"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuserattr",
          "args": [
            "(char *)user",
            "S_REGISTRY",
            "&registry",
            "SEC_CHAR"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuserdb",
          "args": [
            "S_READ"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_setauthdb(const char *user)\n{\n#  ifdef HAVE_SETAUTHDB\n\tchar *registry;\n\n\tif (setuserdb(S_READ) == -1) {\n\t\tdebug3(\"%s: Could not open userdb to read\", __func__);\n\t\treturn;\n\t}\n\n\tif (getuserattr((char *)user, S_REGISTRY, &registry, SEC_CHAR) == 0) {\n\t\tif (setauthdb(registry, old_registry) == 0)\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s'\", registry);\n\t\telse\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s' failed: %s\",\n\t\t\t    registry, strerror(errno));\n\t} else\n\t\tdebug3(\"%s: Could not read S_REGISTRY for user: %s\", __func__,\n\t\t    strerror(errno));\n\tenduserdb();\n#  endif /* HAVE_SETAUTHDB */\n}"
  },
  {
    "function_name": "record_failed_login",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
    "lines": "315-329",
    "snippet": "void\nrecord_failed_login(const char *user, const char *hostname, const char *ttyname)\n{\n\tif (geteuid() != 0)\n\t\treturn;\n\n\taix_setauthdb(user);\n#   ifdef AIX_LOGINFAILED_4ARG\n\tloginfailed((char *)user, (char *)hostname, (char *)ttyname,\n\t    AUDIT_FAIL_AUTH);\n#   else\n\tloginfailed((char *)user, (char *)hostname, (char *)ttyname);\n#   endif\n\taix_restoreauthdb();\n}",
    "includes": [
      "#  include <stdlib.h>",
      "#include \"port-aix.h\"",
      "# include <usersec.h>",
      "#  include <sys/audit.h>",
      "# include <userpw.h>",
      "# include <login.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <uinfo.h>",
      "# include <netdb.h>",
      "#include <errno.h>",
      "#include \"log.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aix_restoreauthdb",
          "args": [],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "aix_restoreauthdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "368-379",
          "snippet": "void\naix_restoreauthdb(void)\n{\n#  ifdef HAVE_SETAUTHDB\n\tif (setauthdb(old_registry, NULL) == 0)\n\t\tdebug3(\"%s: restoring old registry '%s'\", __func__,\n\t\t    old_registry);\n\telse\n\t\tdebug3(\"%s: failed to restore old registry %s\", __func__,\n\t\t    old_registry);\n#  endif /* HAVE_SETAUTHDB */\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_restoreauthdb(void)\n{\n#  ifdef HAVE_SETAUTHDB\n\tif (setauthdb(old_registry, NULL) == 0)\n\t\tdebug3(\"%s: restoring old registry '%s'\", __func__,\n\t\t    old_registry);\n\telse\n\t\tdebug3(\"%s: failed to restore old registry %s\", __func__,\n\t\t    old_registry);\n#  endif /* HAVE_SETAUTHDB */\n}"
        }
      },
      {
        "call_info": {
          "callee": "loginfailed",
          "args": [
            "(char *)user",
            "(char *)hostname",
            "(char *)ttyname"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loginfailed",
          "args": [
            "(char *)user",
            "(char *)hostname",
            "(char *)ttyname",
            "AUDIT_FAIL_AUTH"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aix_setauthdb",
          "args": [
            "user"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "aix_setauthdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "338-360",
          "snippet": "void\naix_setauthdb(const char *user)\n{\n#  ifdef HAVE_SETAUTHDB\n\tchar *registry;\n\n\tif (setuserdb(S_READ) == -1) {\n\t\tdebug3(\"%s: Could not open userdb to read\", __func__);\n\t\treturn;\n\t}\n\n\tif (getuserattr((char *)user, S_REGISTRY, &registry, SEC_CHAR) == 0) {\n\t\tif (setauthdb(registry, old_registry) == 0)\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s'\", registry);\n\t\telse\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s' failed: %s\",\n\t\t\t    registry, strerror(errno));\n\t} else\n\t\tdebug3(\"%s: Could not read S_REGISTRY for user: %s\", __func__,\n\t\t    strerror(errno));\n\tenduserdb();\n#  endif /* HAVE_SETAUTHDB */\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_setauthdb(const char *user)\n{\n#  ifdef HAVE_SETAUTHDB\n\tchar *registry;\n\n\tif (setuserdb(S_READ) == -1) {\n\t\tdebug3(\"%s: Could not open userdb to read\", __func__);\n\t\treturn;\n\t}\n\n\tif (getuserattr((char *)user, S_REGISTRY, &registry, SEC_CHAR) == 0) {\n\t\tif (setauthdb(registry, old_registry) == 0)\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s'\", registry);\n\t\telse\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s' failed: %s\",\n\t\t\t    registry, strerror(errno));\n\t} else\n\t\tdebug3(\"%s: Could not read S_REGISTRY for user: %s\", __func__,\n\t\t    strerror(errno));\n\tenduserdb();\n#  endif /* HAVE_SETAUTHDB */\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\nrecord_failed_login(const char *user, const char *hostname, const char *ttyname)\n{\n\tif (geteuid() != 0)\n\t\treturn;\n\n\taix_setauthdb(user);\n#   ifdef AIX_LOGINFAILED_4ARG\n\tloginfailed((char *)user, (char *)hostname, (char *)ttyname,\n\t    AUDIT_FAIL_AUTH);\n#   else\n\tloginfailed((char *)user, (char *)hostname, (char *)ttyname);\n#   endif\n\taix_restoreauthdb();\n}"
  },
  {
    "function_name": "sys_auth_get_lastlogin_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
    "lines": "302-309",
    "snippet": "char *\nsys_auth_get_lastlogin_msg(const char *user, uid_t uid)\n{\n\tchar *msg = lastlogin_msg;\n\n\tlastlogin_msg = NULL;\n\treturn msg;\n}",
    "includes": [
      "#  include <stdlib.h>",
      "#include \"port-aix.h\"",
      "# include <usersec.h>",
      "#  include <sys/audit.h>",
      "# include <userpw.h>",
      "# include <login.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <uinfo.h>",
      "# include <netdb.h>",
      "#include <errno.h>",
      "#include \"log.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nchar *\nsys_auth_get_lastlogin_msg(const char *user, uid_t uid)\n{\n\tchar *msg = lastlogin_msg;\n\n\tlastlogin_msg = NULL;\n\treturn msg;\n}"
  },
  {
    "function_name": "sys_auth_record_login",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
    "lines": "282-300",
    "snippet": "int\nsys_auth_record_login(const char *user, const char *host, const char *ttynm,\n    struct sshbuf *loginmsg)\n{\n\tchar *msg = NULL;\n\tint success = 0;\n\n\taix_setauthdb(user);\n\tif (loginsuccess((char *)user, (char *)host, (char *)ttynm, &msg) == 0) {\n\t\tsuccess = 1;\n\t\tif (msg != NULL) {\n\t\t\tdebug(\"AIX/loginsuccess: msg %s\", msg);\n\t\t\tif (lastlogin_msg == NULL)\n\t\t\t\tlastlogin_msg = msg;\n\t\t}\n\t}\n\taix_restoreauthdb();\n\treturn (success);\n}",
    "includes": [
      "#  include <stdlib.h>",
      "#include \"port-aix.h\"",
      "# include <usersec.h>",
      "#  include <sys/audit.h>",
      "# include <userpw.h>",
      "# include <login.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <uinfo.h>",
      "# include <netdb.h>",
      "#include <errno.h>",
      "#include \"log.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aix_restoreauthdb",
          "args": [],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "aix_restoreauthdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "368-379",
          "snippet": "void\naix_restoreauthdb(void)\n{\n#  ifdef HAVE_SETAUTHDB\n\tif (setauthdb(old_registry, NULL) == 0)\n\t\tdebug3(\"%s: restoring old registry '%s'\", __func__,\n\t\t    old_registry);\n\telse\n\t\tdebug3(\"%s: failed to restore old registry %s\", __func__,\n\t\t    old_registry);\n#  endif /* HAVE_SETAUTHDB */\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_restoreauthdb(void)\n{\n#  ifdef HAVE_SETAUTHDB\n\tif (setauthdb(old_registry, NULL) == 0)\n\t\tdebug3(\"%s: restoring old registry '%s'\", __func__,\n\t\t    old_registry);\n\telse\n\t\tdebug3(\"%s: failed to restore old registry %s\", __func__,\n\t\t    old_registry);\n#  endif /* HAVE_SETAUTHDB */\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"AIX/loginsuccess: msg %s\"",
            "msg"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "loginsuccess",
          "args": [
            "(char *)user",
            "(char *)host",
            "(char *)ttynm",
            "&msg"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aix_setauthdb",
          "args": [
            "user"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "aix_setauthdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "338-360",
          "snippet": "void\naix_setauthdb(const char *user)\n{\n#  ifdef HAVE_SETAUTHDB\n\tchar *registry;\n\n\tif (setuserdb(S_READ) == -1) {\n\t\tdebug3(\"%s: Could not open userdb to read\", __func__);\n\t\treturn;\n\t}\n\n\tif (getuserattr((char *)user, S_REGISTRY, &registry, SEC_CHAR) == 0) {\n\t\tif (setauthdb(registry, old_registry) == 0)\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s'\", registry);\n\t\telse\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s' failed: %s\",\n\t\t\t    registry, strerror(errno));\n\t} else\n\t\tdebug3(\"%s: Could not read S_REGISTRY for user: %s\", __func__,\n\t\t    strerror(errno));\n\tenduserdb();\n#  endif /* HAVE_SETAUTHDB */\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_setauthdb(const char *user)\n{\n#  ifdef HAVE_SETAUTHDB\n\tchar *registry;\n\n\tif (setuserdb(S_READ) == -1) {\n\t\tdebug3(\"%s: Could not open userdb to read\", __func__);\n\t\treturn;\n\t}\n\n\tif (getuserattr((char *)user, S_REGISTRY, &registry, SEC_CHAR) == 0) {\n\t\tif (setauthdb(registry, old_registry) == 0)\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s'\", registry);\n\t\telse\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s' failed: %s\",\n\t\t\t    registry, strerror(errno));\n\t} else\n\t\tdebug3(\"%s: Could not read S_REGISTRY for user: %s\", __func__,\n\t\t    strerror(errno));\n\tenduserdb();\n#  endif /* HAVE_SETAUTHDB */\n}"
        }
      }
    ],
    "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsys_auth_record_login(const char *user, const char *host, const char *ttynm,\n    struct sshbuf *loginmsg)\n{\n\tchar *msg = NULL;\n\tint success = 0;\n\n\taix_setauthdb(user);\n\tif (loginsuccess((char *)user, (char *)host, (char *)ttynm, &msg) == 0) {\n\t\tsuccess = 1;\n\t\tif (msg != NULL) {\n\t\t\tdebug(\"AIX/loginsuccess: msg %s\", msg);\n\t\t\tif (lastlogin_msg == NULL)\n\t\t\t\tlastlogin_msg = msg;\n\t\t}\n\t}\n\taix_restoreauthdb();\n\treturn (success);\n}"
  },
  {
    "function_name": "sys_auth_allowed_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
    "lines": "240-280",
    "snippet": "int\nsys_auth_allowed_user(struct passwd *pw, struct sshbuf *loginmsg)\n{\n\tchar *msg = NULL;\n\tint r, result, permitted = 0;\n\tstruct stat st;\n\n\t/*\n\t * Don't perform checks for root account (PermitRootLogin controls\n\t * logins via ssh) or if running as non-root user (since\n\t * loginrestrictions will always fail due to insufficient privilege).\n\t */\n\tif (pw->pw_uid == 0 || geteuid() != 0) {\n\t\tdebug3(\"%s: not checking\", __func__);\n\t\treturn 1;\n\t}\n\n\tresult = loginrestrictions(pw->pw_name, S_RLOGIN, NULL, &msg);\n\tif (result == 0)\n\t\tpermitted = 1;\n\t/*\n\t * If restricted because /etc/nologin exists, the login will be denied\n\t * in session.c after the nologin message is sent, so allow for now\n\t * and do not append the returned message.\n\t */\n\tif (result == -1 && errno == EPERM && stat(_PATH_NOLOGIN, &st) == 0)\n\t\tpermitted = 1;\n\telse if (msg != NULL) {\n\t\tif ((r = sshbuf_put(loginmsg, msg, strlen(msg))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif (msg == NULL)\n\t\tmsg = xstrdup(\"(none)\");\n\taix_remove_embedded_newlines(msg);\n\tdebug3(\"AIX/loginrestrictions returned %d msg %.100s\", result, msg);\n\n\tif (!permitted)\n\t\tlogit(\"Login restricted for %s: %.100s\", pw->pw_name, msg);\n\tfree(msg);\n\treturn permitted;\n}",
    "includes": [
      "#  include <stdlib.h>",
      "#include \"port-aix.h\"",
      "# include <usersec.h>",
      "#  include <sys/audit.h>",
      "# include <userpw.h>",
      "# include <login.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <uinfo.h>",
      "# include <netdb.h>",
      "#include <errno.h>",
      "#include \"log.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "msg"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Login restricted for %s: %.100s\"",
            "pw->pw_name",
            "msg"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"AIX/loginrestrictions returned %d msg %.100s\"",
            "result",
            "msg"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aix_remove_embedded_newlines",
          "args": [
            "msg"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "aix_remove_embedded_newlines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "100-113",
          "snippet": "void\naix_remove_embedded_newlines(char *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfor (; *p; p++) {\n\t\tif (*p == '\\n')\n\t\t\t*p = ' ';\n\t}\n\t/* Remove trailing whitespace */\n\tif (*--p == ' ')\n\t\t*p = '\\0';\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_remove_embedded_newlines(char *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfor (; *p; p++) {\n\t\tif (*p == '\\n')\n\t\t\t*p = ' ';\n\t}\n\t/* Remove trailing whitespace */\n\tif (*--p == ' ')\n\t\t*p = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"(none)\""
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "loginmsg",
            "msg",
            "strlen(msg)"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "msg"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "_PATH_NOLOGIN",
            "&st"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "fstatvfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-statvfs.c",
          "lines": "71-85",
          "snippet": "int fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}",
          "includes": [
            "#include <errno.h>",
            "# include <sys/mount.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n# include <sys/mount.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nint fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "loginrestrictions",
          "args": [
            "pw->pw_name",
            "S_RLOGIN",
            "NULL",
            "&msg"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsys_auth_allowed_user(struct passwd *pw, struct sshbuf *loginmsg)\n{\n\tchar *msg = NULL;\n\tint r, result, permitted = 0;\n\tstruct stat st;\n\n\t/*\n\t * Don't perform checks for root account (PermitRootLogin controls\n\t * logins via ssh) or if running as non-root user (since\n\t * loginrestrictions will always fail due to insufficient privilege).\n\t */\n\tif (pw->pw_uid == 0 || geteuid() != 0) {\n\t\tdebug3(\"%s: not checking\", __func__);\n\t\treturn 1;\n\t}\n\n\tresult = loginrestrictions(pw->pw_name, S_RLOGIN, NULL, &msg);\n\tif (result == 0)\n\t\tpermitted = 1;\n\t/*\n\t * If restricted because /etc/nologin exists, the login will be denied\n\t * in session.c after the nologin message is sent, so allow for now\n\t * and do not append the returned message.\n\t */\n\tif (result == -1 && errno == EPERM && stat(_PATH_NOLOGIN, &st) == 0)\n\t\tpermitted = 1;\n\telse if (msg != NULL) {\n\t\tif ((r = sshbuf_put(loginmsg, msg, strlen(msg))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif (msg == NULL)\n\t\tmsg = xstrdup(\"(none)\");\n\taix_remove_embedded_newlines(msg);\n\tdebug3(\"AIX/loginrestrictions returned %d msg %.100s\", result, msg);\n\n\tif (!permitted)\n\t\tlogit(\"Login restricted for %s: %.100s\", pw->pw_name, msg);\n\tfree(msg);\n\treturn permitted;\n}"
  },
  {
    "function_name": "sys_auth_passwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
    "lines": "175-234",
    "snippet": "int\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *ctxt = ssh->authctxt;\n\tchar *authmsg = NULL, *msg = NULL, *name = ctxt->pw->pw_name;\n\tint r, authsuccess = 0, expired, reenter, result;\n\n\tdo {\n\t\tresult = authenticate((char *)name, (char *)password, &reenter,\n\t\t    &authmsg);\n\t\taix_remove_embedded_newlines(authmsg);\n\t\tdebug3(\"AIX/authenticate result %d, authmsg %.100s\", result,\n\t\t    authmsg);\n\t} while (reenter);\n\n\tif (!aix_valid_authentications(name))\n\t\tresult = -1;\n\n\tif (result == 0) {\n\t\tauthsuccess = 1;\n\n\t\t/*\n\t\t * Record successful login.  We don't have a pty yet, so just\n\t\t * label the line as \"ssh\"\n\t\t */\n\t\taix_setauthdb(name);\n\n\t\t/*\n\t\t * Check if the user's password is expired.\n\t\t */\n\t\texpired = passwdexpired(name, &msg);\n\t\tif (msg && *msg) {\n\t\t\tif ((r = sshbuf_put(ctxt->loginmsg,\n\t\t\t    msg, strlen(msg))) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\taix_remove_embedded_newlines(msg);\n\t\t}\n\t\tdebug3(\"AIX/passwdexpired returned %d msg %.100s\", expired, msg);\n\n\t\tswitch (expired) {\n\t\tcase 0: /* password not expired */\n\t\t\tbreak;\n\t\tcase 1: /* expired, password change required */\n\t\t\tctxt->force_pwchange = 1;\n\t\t\tbreak;\n\t\tdefault: /* user can't change(2) or other error (-1) */\n\t\t\tlogit(\"Password can't be changed for user %s: %.100s\",\n\t\t\t    name, msg);\n\t\t\tfree(msg);\n\t\t\tauthsuccess = 0;\n\t\t}\n\n\t\taix_restoreauthdb();\n\t}\n\n\tfree(authmsg);\n\n\treturn authsuccess;\n}",
    "includes": [
      "#  include <stdlib.h>",
      "#include \"port-aix.h\"",
      "# include <usersec.h>",
      "#  include <sys/audit.h>",
      "# include <userpw.h>",
      "# include <login.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <uinfo.h>",
      "# include <netdb.h>",
      "#include <errno.h>",
      "#include \"log.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "authmsg"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aix_restoreauthdb",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "aix_restoreauthdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "368-379",
          "snippet": "void\naix_restoreauthdb(void)\n{\n#  ifdef HAVE_SETAUTHDB\n\tif (setauthdb(old_registry, NULL) == 0)\n\t\tdebug3(\"%s: restoring old registry '%s'\", __func__,\n\t\t    old_registry);\n\telse\n\t\tdebug3(\"%s: failed to restore old registry %s\", __func__,\n\t\t    old_registry);\n#  endif /* HAVE_SETAUTHDB */\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_restoreauthdb(void)\n{\n#  ifdef HAVE_SETAUTHDB\n\tif (setauthdb(old_registry, NULL) == 0)\n\t\tdebug3(\"%s: restoring old registry '%s'\", __func__,\n\t\t    old_registry);\n\telse\n\t\tdebug3(\"%s: failed to restore old registry %s\", __func__,\n\t\t    old_registry);\n#  endif /* HAVE_SETAUTHDB */\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Password can't be changed for user %s: %.100s\"",
            "name",
            "msg"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"AIX/passwdexpired returned %d msg %.100s\"",
            "expired",
            "msg"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aix_remove_embedded_newlines",
          "args": [
            "msg"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "aix_remove_embedded_newlines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "100-113",
          "snippet": "void\naix_remove_embedded_newlines(char *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfor (; *p; p++) {\n\t\tif (*p == '\\n')\n\t\t\t*p = ' ';\n\t}\n\t/* Remove trailing whitespace */\n\tif (*--p == ' ')\n\t\t*p = '\\0';\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_remove_embedded_newlines(char *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfor (; *p; p++) {\n\t\tif (*p == '\\n')\n\t\t\t*p = ' ';\n\t}\n\t/* Remove trailing whitespace */\n\tif (*--p == ' ')\n\t\t*p = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "ctxt->loginmsg",
            "msg",
            "strlen(msg)"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "msg"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "passwdexpired",
          "args": [
            "name",
            "&msg"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aix_setauthdb",
          "args": [
            "name"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "aix_setauthdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "338-360",
          "snippet": "void\naix_setauthdb(const char *user)\n{\n#  ifdef HAVE_SETAUTHDB\n\tchar *registry;\n\n\tif (setuserdb(S_READ) == -1) {\n\t\tdebug3(\"%s: Could not open userdb to read\", __func__);\n\t\treturn;\n\t}\n\n\tif (getuserattr((char *)user, S_REGISTRY, &registry, SEC_CHAR) == 0) {\n\t\tif (setauthdb(registry, old_registry) == 0)\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s'\", registry);\n\t\telse\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s' failed: %s\",\n\t\t\t    registry, strerror(errno));\n\t} else\n\t\tdebug3(\"%s: Could not read S_REGISTRY for user: %s\", __func__,\n\t\t    strerror(errno));\n\tenduserdb();\n#  endif /* HAVE_SETAUTHDB */\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_setauthdb(const char *user)\n{\n#  ifdef HAVE_SETAUTHDB\n\tchar *registry;\n\n\tif (setuserdb(S_READ) == -1) {\n\t\tdebug3(\"%s: Could not open userdb to read\", __func__);\n\t\treturn;\n\t}\n\n\tif (getuserattr((char *)user, S_REGISTRY, &registry, SEC_CHAR) == 0) {\n\t\tif (setauthdb(registry, old_registry) == 0)\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s'\", registry);\n\t\telse\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s' failed: %s\",\n\t\t\t    registry, strerror(errno));\n\t} else\n\t\tdebug3(\"%s: Could not read S_REGISTRY for user: %s\", __func__,\n\t\t    strerror(errno));\n\tenduserdb();\n#  endif /* HAVE_SETAUTHDB */\n}"
        }
      },
      {
        "call_info": {
          "callee": "aix_valid_authentications",
          "args": [
            "name"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "aix_valid_authentications",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "131-166",
          "snippet": "static int\naix_valid_authentications(const char *user)\n{\n\tchar *auth1, *sys, *p;\n\tint valid = 1;\n\n\tif (getuserattr((char *)user, S_AUTHSYSTEM, &sys, SEC_CHAR) != 0) {\n\t\tlogit(\"Can't retrieve attribute SYSTEM for %s: %.100s\",\n\t\t    user, strerror(errno));\n\t\treturn 0;\n\t}\n\n\tdebug3(\"AIX SYSTEM attribute %s\", sys);\n\tif (strcmp(sys, \"NONE\") != 0)\n\t\treturn 1;\t/* not \"NONE\", so is OK */\n\n\tif (getuserattr((char *)user, S_AUTH1, &auth1, SEC_LIST) != 0) {\n\t\tlogit(\"Can't retrieve attribute auth1 for %s: %.100s\",\n\t\t    user, strerror(errno));\n\t\treturn 0;\n\t}\n\n\tp = auth1;\n\t/* A SEC_LIST is concatenated strings, ending with two NULs. */\n\twhile (p[0] != '\\0' && p[1] != '\\0') {\n\t\tdebug3(\"AIX auth1 attribute list member %s\", p);\n\t\tif (strcmp(p, \"NONE\") != 0 && strcmp(p, \"SYSTEM\")) {\n\t\t\tlogit(\"Account %s has unsupported auth1 value '%s'\",\n\t\t\t    user, p);\n\t\t\tvalid = 0;\n\t\t}\n\t\tp += strlen(p) + 1;\n\t}\n\n\treturn (valid);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nstatic int\naix_valid_authentications(const char *user)\n{\n\tchar *auth1, *sys, *p;\n\tint valid = 1;\n\n\tif (getuserattr((char *)user, S_AUTHSYSTEM, &sys, SEC_CHAR) != 0) {\n\t\tlogit(\"Can't retrieve attribute SYSTEM for %s: %.100s\",\n\t\t    user, strerror(errno));\n\t\treturn 0;\n\t}\n\n\tdebug3(\"AIX SYSTEM attribute %s\", sys);\n\tif (strcmp(sys, \"NONE\") != 0)\n\t\treturn 1;\t/* not \"NONE\", so is OK */\n\n\tif (getuserattr((char *)user, S_AUTH1, &auth1, SEC_LIST) != 0) {\n\t\tlogit(\"Can't retrieve attribute auth1 for %s: %.100s\",\n\t\t    user, strerror(errno));\n\t\treturn 0;\n\t}\n\n\tp = auth1;\n\t/* A SEC_LIST is concatenated strings, ending with two NULs. */\n\twhile (p[0] != '\\0' && p[1] != '\\0') {\n\t\tdebug3(\"AIX auth1 attribute list member %s\", p);\n\t\tif (strcmp(p, \"NONE\") != 0 && strcmp(p, \"SYSTEM\")) {\n\t\t\tlogit(\"Account %s has unsupported auth1 value '%s'\",\n\t\t\t    user, p);\n\t\t\tvalid = 0;\n\t\t}\n\t\tp += strlen(p) + 1;\n\t}\n\n\treturn (valid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "authenticate",
          "args": [
            "(char *)name",
            "(char *)password",
            "&reenter",
            "&authmsg"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *ctxt = ssh->authctxt;\n\tchar *authmsg = NULL, *msg = NULL, *name = ctxt->pw->pw_name;\n\tint r, authsuccess = 0, expired, reenter, result;\n\n\tdo {\n\t\tresult = authenticate((char *)name, (char *)password, &reenter,\n\t\t    &authmsg);\n\t\taix_remove_embedded_newlines(authmsg);\n\t\tdebug3(\"AIX/authenticate result %d, authmsg %.100s\", result,\n\t\t    authmsg);\n\t} while (reenter);\n\n\tif (!aix_valid_authentications(name))\n\t\tresult = -1;\n\n\tif (result == 0) {\n\t\tauthsuccess = 1;\n\n\t\t/*\n\t\t * Record successful login.  We don't have a pty yet, so just\n\t\t * label the line as \"ssh\"\n\t\t */\n\t\taix_setauthdb(name);\n\n\t\t/*\n\t\t * Check if the user's password is expired.\n\t\t */\n\t\texpired = passwdexpired(name, &msg);\n\t\tif (msg && *msg) {\n\t\t\tif ((r = sshbuf_put(ctxt->loginmsg,\n\t\t\t    msg, strlen(msg))) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\taix_remove_embedded_newlines(msg);\n\t\t}\n\t\tdebug3(\"AIX/passwdexpired returned %d msg %.100s\", expired, msg);\n\n\t\tswitch (expired) {\n\t\tcase 0: /* password not expired */\n\t\t\tbreak;\n\t\tcase 1: /* expired, password change required */\n\t\t\tctxt->force_pwchange = 1;\n\t\t\tbreak;\n\t\tdefault: /* user can't change(2) or other error (-1) */\n\t\t\tlogit(\"Password can't be changed for user %s: %.100s\",\n\t\t\t    name, msg);\n\t\t\tfree(msg);\n\t\t\tauthsuccess = 0;\n\t\t}\n\n\t\taix_restoreauthdb();\n\t}\n\n\tfree(authmsg);\n\n\treturn authsuccess;\n}"
  },
  {
    "function_name": "aix_valid_authentications",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
    "lines": "131-166",
    "snippet": "static int\naix_valid_authentications(const char *user)\n{\n\tchar *auth1, *sys, *p;\n\tint valid = 1;\n\n\tif (getuserattr((char *)user, S_AUTHSYSTEM, &sys, SEC_CHAR) != 0) {\n\t\tlogit(\"Can't retrieve attribute SYSTEM for %s: %.100s\",\n\t\t    user, strerror(errno));\n\t\treturn 0;\n\t}\n\n\tdebug3(\"AIX SYSTEM attribute %s\", sys);\n\tif (strcmp(sys, \"NONE\") != 0)\n\t\treturn 1;\t/* not \"NONE\", so is OK */\n\n\tif (getuserattr((char *)user, S_AUTH1, &auth1, SEC_LIST) != 0) {\n\t\tlogit(\"Can't retrieve attribute auth1 for %s: %.100s\",\n\t\t    user, strerror(errno));\n\t\treturn 0;\n\t}\n\n\tp = auth1;\n\t/* A SEC_LIST is concatenated strings, ending with two NULs. */\n\twhile (p[0] != '\\0' && p[1] != '\\0') {\n\t\tdebug3(\"AIX auth1 attribute list member %s\", p);\n\t\tif (strcmp(p, \"NONE\") != 0 && strcmp(p, \"SYSTEM\")) {\n\t\t\tlogit(\"Account %s has unsupported auth1 value '%s'\",\n\t\t\t    user, p);\n\t\t\tvalid = 0;\n\t\t}\n\t\tp += strlen(p) + 1;\n\t}\n\n\treturn (valid);\n}",
    "includes": [
      "#  include <stdlib.h>",
      "#include \"port-aix.h\"",
      "# include <usersec.h>",
      "#  include <sys/audit.h>",
      "# include <userpw.h>",
      "# include <login.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <uinfo.h>",
      "# include <netdb.h>",
      "#include <errno.h>",
      "#include \"log.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Account %s has unsupported auth1 value '%s'\"",
            "user",
            "p"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"SYSTEM\""
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"AIX auth1 attribute list member %s\"",
            "p"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuserattr",
          "args": [
            "(char *)user",
            "S_AUTH1",
            "&auth1",
            "SEC_LIST"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuserattr",
          "args": [
            "(char *)user",
            "S_AUTHSYSTEM",
            "&sys",
            "SEC_CHAR"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nstatic int\naix_valid_authentications(const char *user)\n{\n\tchar *auth1, *sys, *p;\n\tint valid = 1;\n\n\tif (getuserattr((char *)user, S_AUTHSYSTEM, &sys, SEC_CHAR) != 0) {\n\t\tlogit(\"Can't retrieve attribute SYSTEM for %s: %.100s\",\n\t\t    user, strerror(errno));\n\t\treturn 0;\n\t}\n\n\tdebug3(\"AIX SYSTEM attribute %s\", sys);\n\tif (strcmp(sys, \"NONE\") != 0)\n\t\treturn 1;\t/* not \"NONE\", so is OK */\n\n\tif (getuserattr((char *)user, S_AUTH1, &auth1, SEC_LIST) != 0) {\n\t\tlogit(\"Can't retrieve attribute auth1 for %s: %.100s\",\n\t\t    user, strerror(errno));\n\t\treturn 0;\n\t}\n\n\tp = auth1;\n\t/* A SEC_LIST is concatenated strings, ending with two NULs. */\n\twhile (p[0] != '\\0' && p[1] != '\\0') {\n\t\tdebug3(\"AIX auth1 attribute list member %s\", p);\n\t\tif (strcmp(p, \"NONE\") != 0 && strcmp(p, \"SYSTEM\")) {\n\t\t\tlogit(\"Account %s has unsupported auth1 value '%s'\",\n\t\t\t    user, p);\n\t\t\tvalid = 0;\n\t\t}\n\t\tp += strlen(p) + 1;\n\t}\n\n\treturn (valid);\n}"
  },
  {
    "function_name": "aix_remove_embedded_newlines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
    "lines": "100-113",
    "snippet": "void\naix_remove_embedded_newlines(char *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfor (; *p; p++) {\n\t\tif (*p == '\\n')\n\t\t\t*p = ' ';\n\t}\n\t/* Remove trailing whitespace */\n\tif (*--p == ' ')\n\t\t*p = '\\0';\n}",
    "includes": [
      "#  include <stdlib.h>",
      "#include \"port-aix.h\"",
      "# include <usersec.h>",
      "#  include <sys/audit.h>",
      "# include <userpw.h>",
      "# include <login.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <uinfo.h>",
      "# include <netdb.h>",
      "#include <errno.h>",
      "#include \"log.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_remove_embedded_newlines(char *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfor (; *p; p++) {\n\t\tif (*p == '\\n')\n\t\t\t*p = ' ';\n\t}\n\t/* Remove trailing whitespace */\n\tif (*--p == ' ')\n\t\t*p = '\\0';\n}"
  },
  {
    "function_name": "aix_usrinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
    "lines": "75-92",
    "snippet": "void\naix_usrinfo(struct passwd *pw)\n{\n\tu_int i;\n\tsize_t len;\n\tchar *cp;\n\n\tlen = sizeof(\"LOGNAME= NAME= \") + (2 * strlen(pw->pw_name));\n\tcp = xmalloc(len);\n\n\ti = snprintf(cp, len, \"LOGNAME=%s%cNAME=%s%c\", pw->pw_name, '\\0',\n\t    pw->pw_name, '\\0');\n\tif (usrinfo(SETUINFO, cp, i) == -1)\n\t\tfatal(\"Couldn't set usrinfo: %s\", strerror(errno));\n\tdebug3(\"AIX/UsrInfo: set len %d\", i);\n\n\tfree(cp);\n}",
    "includes": [
      "#  include <stdlib.h>",
      "#include \"port-aix.h\"",
      "# include <usersec.h>",
      "#  include <sys/audit.h>",
      "# include <userpw.h>",
      "# include <login.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <uinfo.h>",
      "# include <netdb.h>",
      "#include <errno.h>",
      "#include \"log.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssh.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cp"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"AIX/UsrInfo: set len %d\"",
            "i"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Couldn't set usrinfo: %s\"",
            "strerror(errno)"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usrinfo",
          "args": [
            "SETUINFO",
            "cp",
            "i"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cp",
            "len",
            "\"LOGNAME=%s%cNAME=%s%c\"",
            "pw->pw_name",
            "'\\0'",
            "pw->pw_name",
            "'\\0'"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "len"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pw->pw_name"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_usrinfo(struct passwd *pw)\n{\n\tu_int i;\n\tsize_t len;\n\tchar *cp;\n\n\tlen = sizeof(\"LOGNAME= NAME= \") + (2 * strlen(pw->pw_name));\n\tcp = xmalloc(len);\n\n\ti = snprintf(cp, len, \"LOGNAME=%s%cNAME=%s%c\", pw->pw_name, '\\0',\n\t    pw->pw_name, '\\0');\n\tif (usrinfo(SETUINFO, cp, i) == -1)\n\t\tfatal(\"Couldn't set usrinfo: %s\", strerror(errno));\n\tdebug3(\"AIX/UsrInfo: set len %d\", i);\n\n\tfree(cp);\n}"
  }
]