[
  {
    "function_name": "sshbuf_fuzz_tests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshbuf/test_sshbuf_fuzz.c",
    "lines": "28-127",
    "snippet": "void\nsshbuf_fuzz_tests(void)\n{\n\tstruct sshbuf *p1;\n\tu_char *dp;\n\tsize_t sz, sz2, i;\n\tu_int32_t r;\n\tint ret;\n\n\t/* NB. uses sshbuf internals */\n\tTEST_START(\"fuzz alloc/dealloc\");\n\tp1 = sshbuf_new();\n\tASSERT_INT_EQ(sshbuf_set_max_size(p1, 16 * 1024), 0);\n\tASSERT_PTR_NE(p1, NULL);\n\tASSERT_PTR_NE(sshbuf_ptr(p1), NULL);\n\tASSERT_MEM_ZERO_NE(sshbuf_ptr(p1), sshbuf_len(p1));\n\tfor (i = 0; i < NUM_FUZZ_TESTS; i++) {\n\t\tr = arc4random_uniform(10);\n\t\tif (r == 0) {\n\t\t\t/* 10% chance: small reserve */\n\t\t\tr = arc4random_uniform(10);\n fuzz_reserve:\n\t\t\tsz = sshbuf_avail(p1);\n\t\t\tsz2 = sshbuf_len(p1);\n\t\t\tret = sshbuf_reserve(p1, r, &dp);\n\t\t\tif (ret < 0) {\n\t\t\t\tASSERT_PTR_EQ(dp, NULL);\n\t\t\t\tASSERT_SIZE_T_LT(sz, r);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_avail(p1), sz);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_len(p1), sz2);\n\t\t\t} else {\n\t\t\t\tASSERT_PTR_NE(dp, NULL);\n\t\t\t\tASSERT_SIZE_T_GE(sz, r);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_avail(p1), sz - r);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_len(p1), sz2 + r);\n\t\t\t\tmemset(dp, arc4random_uniform(255) + 1, r);\n\t\t\t}\n\t\t} else if (r < 3) {\n\t\t\t/* 20% chance: big reserve */\n\t\t\tr = arc4random_uniform(8 * 1024);\n\t\t\tgoto fuzz_reserve;\n\t\t} else if (r == 3) {\n\t\t\t/* 10% chance: small consume */\n\t\t\tr = arc4random_uniform(10);\n fuzz_consume:\n\t\t\tsz = sshbuf_avail(p1);\n\t\t\tsz2 = sshbuf_len(p1);\n\t\t\t/* 50% change consume from end, otherwise start */\n\t\t\tret = ((arc4random() & 1) ?\n\t\t\t    sshbuf_consume : sshbuf_consume_end)(p1, r);\n\t\t\tif (ret < 0) {\n\t\t\t\tASSERT_SIZE_T_LT(sz2, r);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_avail(p1), sz);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_len(p1), sz2);\n\t\t\t} else {\n\t\t\t\tASSERT_SIZE_T_GE(sz2, r);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_avail(p1), sz + r);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_len(p1), sz2 - r);\n\t\t\t}\n\t\t} else if (r < 8) {\n\t\t\t/* 40% chance: big consume */\n\t\t\tr = arc4random_uniform(2 * 1024);\n\t\t\tgoto fuzz_consume;\n\t\t} else if (r == 8) {\n\t\t\t/* 10% chance: reset max size */\n\t\t\tr = arc4random_uniform(16 * 1024);\n\t\t\tsz = sshbuf_max_size(p1);\n\t\t\tif (sshbuf_set_max_size(p1, r) < 0)\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_max_size(p1), sz);\n\t\t\telse\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_max_size(p1), r);\n\t\t} else {\n\t\t\tif (arc4random_uniform(8192) == 0) {\n\t\t\t\t/* tiny chance: new buffer */\n\t\t\t\tASSERT_PTR_NE(sshbuf_ptr(p1), NULL);\n\t\t\t\tASSERT_MEM_ZERO_NE(sshbuf_ptr(p1), sshbuf_len(p1));\n\t\t\t\tsshbuf_free(p1);\n\t\t\t\tp1 = sshbuf_new();\n\t\t\t\tASSERT_PTR_NE(p1, NULL);\n\t\t\t\tASSERT_INT_EQ(sshbuf_set_max_size(p1,\n\t\t\t\t    16 * 1024), 0);\n\t\t\t} else {\n\t\t\t\t/* Almost 10%: giant reserve */\n\t\t\t\t/* use arc4random_buf for r > 2^32 on 64 bit */\n\t\t\t\tarc4random_buf(&r, sizeof(r));\n\t\t\t\twhile (r < SSHBUF_SIZE_MAX / 2) {\n\t\t\t\t\tr <<= 1;\n\t\t\t\t\tr |= arc4random() & 1;\n\t\t\t\t}\n\t\t\t\tgoto fuzz_reserve;\n\t\t\t}\n\t\t}\n\t\tASSERT_PTR_NE(sshbuf_ptr(p1), NULL);\n\t\tASSERT_SIZE_T_LE(sshbuf_max_size(p1), 16 * 1024);\n\t}\n\tASSERT_PTR_NE(sshbuf_ptr(p1), NULL);\n\tASSERT_MEM_ZERO_NE(sshbuf_ptr(p1), sshbuf_len(p1));\n\tsshbuf_free(p1);\n\tTEST_DONE();\n}",
    "includes": [
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define NUM_FUZZ_TESTS (1 << 18)"
    ],
    "globals_used": [
      "void sshbuf_fuzz_tests(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "p1"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_MEM_ZERO_NE",
          "args": [
            "sshbuf_ptr(p1)",
            "sshbuf_len(p1)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "p1"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "p1"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "sshbuf_ptr(p1)",
            "NULL"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_LE",
          "args": [
            "sshbuf_max_size(p1)",
            "16 * 1024"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_max_size",
          "args": [
            "p1"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_max_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "190-194",
          "snippet": "size_t\nsshbuf_max_size(const struct sshbuf *buf)\n{\n\treturn buf->max_size;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_max_size(const struct sshbuf *buf)\n{\n\treturn buf->max_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "sshbuf_ptr(p1)",
            "NULL"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arc4random",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "235-244",
          "snippet": "u_int32_t\narc4random(void)\n{\n\tu_int32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\narc4random(void)\n{\n\tu_int32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4random_buf",
          "args": [
            "&r",
            "sizeof(r)"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "263-277",
          "snippet": "void\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_set_max_size(p1,\n\t\t\t\t    16 * 1024)",
            "0"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_set_max_size",
          "args": [
            "p1",
            "16 * 1024"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_set_max_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "214-250",
          "snippet": "int\nsshbuf_set_max_size(struct sshbuf *buf, size_t max_size)\n{\n\tsize_t rlen;\n\tu_char *dp;\n\tint r;\n\n\tSSHBUF_DBG((\"set max buf = %p len = %zu\", buf, max_size));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (max_size == buf->max_size)\n\t\treturn 0;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tif (max_size > SSHBUF_SIZE_MAX)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t/* pack and realloc if necessary */\n\tsshbuf_maybe_pack(buf, max_size < buf->size);\n\tif (max_size < buf->alloc && max_size > buf->size) {\n\t\tif (buf->size < SSHBUF_SIZE_INIT)\n\t\t\trlen = SSHBUF_SIZE_INIT;\n\t\telse\n\t\t\trlen = ROUNDUP(buf->size, SSHBUF_SIZE_INC);\n\t\tif (rlen > max_size)\n\t\t\trlen = max_size;\n\t\tSSHBUF_DBG((\"new alloc = %zu\", rlen));\n\t\tif ((dp = recallocarray(buf->d, buf->alloc, rlen, 1)) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tbuf->cd = buf->d = dp;\n\t\tbuf->alloc = rlen;\n\t}\n\tSSHBUF_TELL(\"new-max\");\n\tif (max_size < buf->alloc)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\tbuf->max_size = max_size;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_set_max_size(struct sshbuf *buf, size_t max_size)\n{\n\tsize_t rlen;\n\tu_char *dp;\n\tint r;\n\n\tSSHBUF_DBG((\"set max buf = %p len = %zu\", buf, max_size));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (max_size == buf->max_size)\n\t\treturn 0;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tif (max_size > SSHBUF_SIZE_MAX)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t/* pack and realloc if necessary */\n\tsshbuf_maybe_pack(buf, max_size < buf->size);\n\tif (max_size < buf->alloc && max_size > buf->size) {\n\t\tif (buf->size < SSHBUF_SIZE_INIT)\n\t\t\trlen = SSHBUF_SIZE_INIT;\n\t\telse\n\t\t\trlen = ROUNDUP(buf->size, SSHBUF_SIZE_INC);\n\t\tif (rlen > max_size)\n\t\t\trlen = max_size;\n\t\tSSHBUF_DBG((\"new alloc = %zu\", rlen));\n\t\tif ((dp = recallocarray(buf->d, buf->alloc, rlen, 1)) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tbuf->cd = buf->d = dp;\n\t\tbuf->alloc = rlen;\n\t}\n\tSSHBUF_TELL(\"new-max\");\n\tif (max_size < buf->alloc)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\tbuf->max_size = max_size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "p1",
            "NULL"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_MEM_ZERO_NE",
          "args": [
            "sshbuf_ptr(p1)",
            "sshbuf_len(p1)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "sshbuf_ptr(p1)",
            "NULL"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arc4random_uniform",
          "args": [
            "8192"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_uniform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "291-315",
          "snippet": "u_int32_t\narc4random_uniform(u_int32_t upper_bound)\n{\n\tu_int32_t r, min;\n\n\tif (upper_bound < 2)\n\t\treturn 0;\n\n\t/* 2**32 % x == (2**32 - x) % x */\n\tmin = -upper_bound % upper_bound;\n\n\t/*\n\t * This could theoretically loop forever but each retry has\n\t * p > 0.5 (worst case, usually far better) of selecting a\n\t * number inside the range we need, so it should rarely need\n\t * to re-roll.\n\t */\n\tfor (;;) {\n\t\tr = arc4random();\n\t\tif (r >= min)\n\t\t\tbreak;\n\t}\n\n\treturn r % upper_bound;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\narc4random_uniform(u_int32_t upper_bound)\n{\n\tu_int32_t r, min;\n\n\tif (upper_bound < 2)\n\t\treturn 0;\n\n\t/* 2**32 % x == (2**32 - x) % x */\n\tmin = -upper_bound % upper_bound;\n\n\t/*\n\t * This could theoretically loop forever but each retry has\n\t * p > 0.5 (worst case, usually far better) of selecting a\n\t * number inside the range we need, so it should rarely need\n\t * to re-roll.\n\t */\n\tfor (;;) {\n\t\tr = arc4random();\n\t\tif (r >= min)\n\t\t\tbreak;\n\t}\n\n\treturn r % upper_bound;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_EQ",
          "args": [
            "sshbuf_max_size(p1)",
            "r"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_EQ",
          "args": [
            "sshbuf_max_size(p1)",
            "sz"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_EQ",
          "args": [
            "sshbuf_len(p1)",
            "sz2 - r"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_EQ",
          "args": [
            "sshbuf_avail(p1)",
            "sz + r"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_avail",
          "args": [
            "p1"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_avail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "260-266",
          "snippet": "size_t\nsshbuf_avail(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn 0;\n\treturn buf->max_size - (buf->size - buf->off);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_avail(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn 0;\n\treturn buf->max_size - (buf->size - buf->off);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_GE",
          "args": [
            "sz2",
            "r"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_EQ",
          "args": [
            "sshbuf_len(p1)",
            "sz2"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_EQ",
          "args": [
            "sshbuf_avail(p1)",
            "sz"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_LT",
          "args": [
            "sz2",
            "r"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "p1",
            "r"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dp",
            "arc4random_uniform(255) + 1",
            "r"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_EQ",
          "args": [
            "sshbuf_len(p1)",
            "sz2 + r"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_EQ",
          "args": [
            "sshbuf_avail(p1)",
            "sz - r"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_GE",
          "args": [
            "sz",
            "r"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "dp",
            "NULL"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_EQ",
          "args": [
            "sshbuf_len(p1)",
            "sz2"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_EQ",
          "args": [
            "sshbuf_avail(p1)",
            "sz"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_LT",
          "args": [
            "sz",
            "r"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "dp",
            "NULL"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_reserve",
          "args": [
            "p1",
            "r",
            "&dp"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "343-361",
          "snippet": "int\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_MEM_ZERO_NE",
          "args": [
            "sshbuf_ptr(p1)",
            "sshbuf_len(p1)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "sshbuf_ptr(p1)",
            "NULL"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "p1",
            "NULL"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_set_max_size(p1, 16 * 1024)",
            "0"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz alloc/dealloc\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define NUM_FUZZ_TESTS (1 << 18)\n\nvoid sshbuf_fuzz_tests(void);\n\nvoid\nsshbuf_fuzz_tests(void)\n{\n\tstruct sshbuf *p1;\n\tu_char *dp;\n\tsize_t sz, sz2, i;\n\tu_int32_t r;\n\tint ret;\n\n\t/* NB. uses sshbuf internals */\n\tTEST_START(\"fuzz alloc/dealloc\");\n\tp1 = sshbuf_new();\n\tASSERT_INT_EQ(sshbuf_set_max_size(p1, 16 * 1024), 0);\n\tASSERT_PTR_NE(p1, NULL);\n\tASSERT_PTR_NE(sshbuf_ptr(p1), NULL);\n\tASSERT_MEM_ZERO_NE(sshbuf_ptr(p1), sshbuf_len(p1));\n\tfor (i = 0; i < NUM_FUZZ_TESTS; i++) {\n\t\tr = arc4random_uniform(10);\n\t\tif (r == 0) {\n\t\t\t/* 10% chance: small reserve */\n\t\t\tr = arc4random_uniform(10);\n fuzz_reserve:\n\t\t\tsz = sshbuf_avail(p1);\n\t\t\tsz2 = sshbuf_len(p1);\n\t\t\tret = sshbuf_reserve(p1, r, &dp);\n\t\t\tif (ret < 0) {\n\t\t\t\tASSERT_PTR_EQ(dp, NULL);\n\t\t\t\tASSERT_SIZE_T_LT(sz, r);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_avail(p1), sz);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_len(p1), sz2);\n\t\t\t} else {\n\t\t\t\tASSERT_PTR_NE(dp, NULL);\n\t\t\t\tASSERT_SIZE_T_GE(sz, r);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_avail(p1), sz - r);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_len(p1), sz2 + r);\n\t\t\t\tmemset(dp, arc4random_uniform(255) + 1, r);\n\t\t\t}\n\t\t} else if (r < 3) {\n\t\t\t/* 20% chance: big reserve */\n\t\t\tr = arc4random_uniform(8 * 1024);\n\t\t\tgoto fuzz_reserve;\n\t\t} else if (r == 3) {\n\t\t\t/* 10% chance: small consume */\n\t\t\tr = arc4random_uniform(10);\n fuzz_consume:\n\t\t\tsz = sshbuf_avail(p1);\n\t\t\tsz2 = sshbuf_len(p1);\n\t\t\t/* 50% change consume from end, otherwise start */\n\t\t\tret = ((arc4random() & 1) ?\n\t\t\t    sshbuf_consume : sshbuf_consume_end)(p1, r);\n\t\t\tif (ret < 0) {\n\t\t\t\tASSERT_SIZE_T_LT(sz2, r);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_avail(p1), sz);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_len(p1), sz2);\n\t\t\t} else {\n\t\t\t\tASSERT_SIZE_T_GE(sz2, r);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_avail(p1), sz + r);\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_len(p1), sz2 - r);\n\t\t\t}\n\t\t} else if (r < 8) {\n\t\t\t/* 40% chance: big consume */\n\t\t\tr = arc4random_uniform(2 * 1024);\n\t\t\tgoto fuzz_consume;\n\t\t} else if (r == 8) {\n\t\t\t/* 10% chance: reset max size */\n\t\t\tr = arc4random_uniform(16 * 1024);\n\t\t\tsz = sshbuf_max_size(p1);\n\t\t\tif (sshbuf_set_max_size(p1, r) < 0)\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_max_size(p1), sz);\n\t\t\telse\n\t\t\t\tASSERT_SIZE_T_EQ(sshbuf_max_size(p1), r);\n\t\t} else {\n\t\t\tif (arc4random_uniform(8192) == 0) {\n\t\t\t\t/* tiny chance: new buffer */\n\t\t\t\tASSERT_PTR_NE(sshbuf_ptr(p1), NULL);\n\t\t\t\tASSERT_MEM_ZERO_NE(sshbuf_ptr(p1), sshbuf_len(p1));\n\t\t\t\tsshbuf_free(p1);\n\t\t\t\tp1 = sshbuf_new();\n\t\t\t\tASSERT_PTR_NE(p1, NULL);\n\t\t\t\tASSERT_INT_EQ(sshbuf_set_max_size(p1,\n\t\t\t\t    16 * 1024), 0);\n\t\t\t} else {\n\t\t\t\t/* Almost 10%: giant reserve */\n\t\t\t\t/* use arc4random_buf for r > 2^32 on 64 bit */\n\t\t\t\tarc4random_buf(&r, sizeof(r));\n\t\t\t\twhile (r < SSHBUF_SIZE_MAX / 2) {\n\t\t\t\t\tr <<= 1;\n\t\t\t\t\tr |= arc4random() & 1;\n\t\t\t\t}\n\t\t\t\tgoto fuzz_reserve;\n\t\t\t}\n\t\t}\n\t\tASSERT_PTR_NE(sshbuf_ptr(p1), NULL);\n\t\tASSERT_SIZE_T_LE(sshbuf_max_size(p1), 16 * 1024);\n\t}\n\tASSERT_PTR_NE(sshbuf_ptr(p1), NULL);\n\tASSERT_MEM_ZERO_NE(sshbuf_ptr(p1), sshbuf_len(p1));\n\tsshbuf_free(p1);\n\tTEST_DONE();\n}"
  }
]