[
  {
    "function_name": "sshbuf_consume_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "383-398",
    "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SSHBUF_TELL",
          "args": [
            "\"done\""
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "buf"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_check_sanity",
          "args": [
            "buf"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_sanity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "31-50",
          "snippet": "static inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSHBUF_DBG",
          "args": [
            "(\"len = %zu\", len)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
  },
  {
    "function_name": "sshbuf_consume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "363-381",
    "snippet": "int\nsshbuf_consume(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->off += len;\n\t/* deal with empty buffer */\n\tif (buf->off == buf->size)\n\t\tbuf->off = buf->size = 0;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SSHBUF_TELL",
          "args": [
            "\"done\""
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "buf"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_check_sanity",
          "args": [
            "buf"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_sanity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "31-50",
          "snippet": "static inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSHBUF_DBG",
          "args": [
            "(\"len = %zu\", len)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->off += len;\n\t/* deal with empty buffer */\n\tif (buf->off == buf->size)\n\t\tbuf->off = buf->size = 0;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
  },
  {
    "function_name": "sshbuf_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "343-361",
    "snippet": "int\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_allocate",
          "args": [
            "buf",
            "len"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_allocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "300-341",
          "snippet": "int\nsshbuf_allocate(struct sshbuf *buf, size_t len)\n{\n\tsize_t rlen, need;\n\tu_char *dp;\n\tint r;\n\n\tSSHBUF_DBG((\"allocate buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_check_reserve(buf, len)) != 0)\n\t\treturn r;\n\t/*\n\t * If the requested allocation appended would push us past max_size\n\t * then pack the buffer, zeroing buf->off.\n\t */\n\tsshbuf_maybe_pack(buf, buf->size + len > buf->max_size);\n\tSSHBUF_TELL(\"allocate\");\n\tif (len + buf->size <= buf->alloc)\n\t\treturn 0; /* already have it. */\n\n\t/*\n\t * Prefer to alloc in SSHBUF_SIZE_INC units, but\n\t * allocate less if doing so would overflow max_size.\n\t */\n\tneed = len + buf->size - buf->alloc;\n\trlen = ROUNDUP(buf->alloc + need, SSHBUF_SIZE_INC);\n\tSSHBUF_DBG((\"need %zu initial rlen %zu\", need, rlen));\n\tif (rlen > buf->max_size)\n\t\trlen = buf->alloc + need;\n\tSSHBUF_DBG((\"adjusted rlen %zu\", rlen));\n\tif ((dp = recallocarray(buf->d, buf->alloc, rlen, 1)) == NULL) {\n\t\tSSHBUF_DBG((\"realloc fail\"));\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tbuf->alloc = rlen;\n\tbuf->cd = buf->d = dp;\n\tif ((r = sshbuf_check_reserve(buf, len)) < 0) {\n\t\t/* shouldn't fail */\n\t\treturn r;\n\t}\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_allocate(struct sshbuf *buf, size_t len)\n{\n\tsize_t rlen, need;\n\tu_char *dp;\n\tint r;\n\n\tSSHBUF_DBG((\"allocate buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_check_reserve(buf, len)) != 0)\n\t\treturn r;\n\t/*\n\t * If the requested allocation appended would push us past max_size\n\t * then pack the buffer, zeroing buf->off.\n\t */\n\tsshbuf_maybe_pack(buf, buf->size + len > buf->max_size);\n\tSSHBUF_TELL(\"allocate\");\n\tif (len + buf->size <= buf->alloc)\n\t\treturn 0; /* already have it. */\n\n\t/*\n\t * Prefer to alloc in SSHBUF_SIZE_INC units, but\n\t * allocate less if doing so would overflow max_size.\n\t */\n\tneed = len + buf->size - buf->alloc;\n\trlen = ROUNDUP(buf->alloc + need, SSHBUF_SIZE_INC);\n\tSSHBUF_DBG((\"need %zu initial rlen %zu\", need, rlen));\n\tif (rlen > buf->max_size)\n\t\trlen = buf->alloc + need;\n\tSSHBUF_DBG((\"adjusted rlen %zu\", rlen));\n\tif ((dp = recallocarray(buf->d, buf->alloc, rlen, 1)) == NULL) {\n\t\tSSHBUF_DBG((\"realloc fail\"));\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tbuf->alloc = rlen;\n\tbuf->cd = buf->d = dp;\n\tif ((r = sshbuf_check_reserve(buf, len)) < 0) {\n\t\t/* shouldn't fail */\n\t\treturn r;\n\t}\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSHBUF_DBG",
          "args": [
            "(\"reserve buf = %p len = %zu\", buf, len)"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}"
  },
  {
    "function_name": "sshbuf_allocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "300-341",
    "snippet": "int\nsshbuf_allocate(struct sshbuf *buf, size_t len)\n{\n\tsize_t rlen, need;\n\tu_char *dp;\n\tint r;\n\n\tSSHBUF_DBG((\"allocate buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_check_reserve(buf, len)) != 0)\n\t\treturn r;\n\t/*\n\t * If the requested allocation appended would push us past max_size\n\t * then pack the buffer, zeroing buf->off.\n\t */\n\tsshbuf_maybe_pack(buf, buf->size + len > buf->max_size);\n\tSSHBUF_TELL(\"allocate\");\n\tif (len + buf->size <= buf->alloc)\n\t\treturn 0; /* already have it. */\n\n\t/*\n\t * Prefer to alloc in SSHBUF_SIZE_INC units, but\n\t * allocate less if doing so would overflow max_size.\n\t */\n\tneed = len + buf->size - buf->alloc;\n\trlen = ROUNDUP(buf->alloc + need, SSHBUF_SIZE_INC);\n\tSSHBUF_DBG((\"need %zu initial rlen %zu\", need, rlen));\n\tif (rlen > buf->max_size)\n\t\trlen = buf->alloc + need;\n\tSSHBUF_DBG((\"adjusted rlen %zu\", rlen));\n\tif ((dp = recallocarray(buf->d, buf->alloc, rlen, 1)) == NULL) {\n\t\tSSHBUF_DBG((\"realloc fail\"));\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tbuf->alloc = rlen;\n\tbuf->cd = buf->d = dp;\n\tif ((r = sshbuf_check_reserve(buf, len)) < 0) {\n\t\t/* shouldn't fail */\n\t\treturn r;\n\t}\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SSHBUF_TELL",
          "args": [
            "\"done\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_check_reserve",
          "args": [
            "buf",
            "len"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "284-298",
          "snippet": "int\nsshbuf_check_reserve(const struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tSSHBUF_TELL(\"check\");\n\t/* Check that len is reasonable and that max_size + available < len */\n\tif (len > buf->max_size || buf->max_size - len < buf->size - buf->off)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_check_reserve(const struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tSSHBUF_TELL(\"check\");\n\t/* Check that len is reasonable and that max_size + available < len */\n\tif (len > buf->max_size || buf->max_size - len < buf->size - buf->off)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSHBUF_DBG",
          "args": [
            "(\"realloc fail\")"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recallocarray",
          "args": [
            "buf->d",
            "buf->alloc",
            "rlen",
            "1"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSHBUF_DBG",
          "args": [
            "(\"adjusted rlen %zu\", rlen)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSHBUF_DBG",
          "args": [
            "(\"need %zu initial rlen %zu\", need, rlen)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUNDUP",
          "args": [
            "buf->alloc + need",
            "SSHBUF_SIZE_INC"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSHBUF_TELL",
          "args": [
            "\"allocate\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_maybe_pack",
          "args": [
            "buf",
            "buf->size + len > buf->max_size"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_maybe_pack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "52-66",
          "snippet": "static void\nsshbuf_maybe_pack(struct sshbuf *buf, int force)\n{\n\tSSHBUF_DBG((\"force %d\", force));\n\tSSHBUF_TELL(\"pre-pack\");\n\tif (buf->off == 0 || buf->readonly || buf->refcount > 1)\n\t\treturn;\n\tif (force ||\n\t    (buf->off >= SSHBUF_PACK_MIN && buf->off >= buf->size / 2)) {\n\t\tmemmove(buf->d, buf->d + buf->off, buf->size - buf->off);\n\t\tbuf->size -= buf->off;\n\t\tbuf->off = 0;\n\t\tSSHBUF_TELL(\"packed\");\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsshbuf_maybe_pack(struct sshbuf *buf, int force)\n{\n\tSSHBUF_DBG((\"force %d\", force));\n\tSSHBUF_TELL(\"pre-pack\");\n\tif (buf->off == 0 || buf->readonly || buf->refcount > 1)\n\t\treturn;\n\tif (force ||\n\t    (buf->off >= SSHBUF_PACK_MIN && buf->off >= buf->size / 2)) {\n\t\tmemmove(buf->d, buf->d + buf->off, buf->size - buf->off);\n\t\tbuf->size -= buf->off;\n\t\tbuf->off = 0;\n\t\tSSHBUF_TELL(\"packed\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSHBUF_DBG",
          "args": [
            "(\"allocate buf = %p len = %zu\", buf, len)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_allocate(struct sshbuf *buf, size_t len)\n{\n\tsize_t rlen, need;\n\tu_char *dp;\n\tint r;\n\n\tSSHBUF_DBG((\"allocate buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_check_reserve(buf, len)) != 0)\n\t\treturn r;\n\t/*\n\t * If the requested allocation appended would push us past max_size\n\t * then pack the buffer, zeroing buf->off.\n\t */\n\tsshbuf_maybe_pack(buf, buf->size + len > buf->max_size);\n\tSSHBUF_TELL(\"allocate\");\n\tif (len + buf->size <= buf->alloc)\n\t\treturn 0; /* already have it. */\n\n\t/*\n\t * Prefer to alloc in SSHBUF_SIZE_INC units, but\n\t * allocate less if doing so would overflow max_size.\n\t */\n\tneed = len + buf->size - buf->alloc;\n\trlen = ROUNDUP(buf->alloc + need, SSHBUF_SIZE_INC);\n\tSSHBUF_DBG((\"need %zu initial rlen %zu\", need, rlen));\n\tif (rlen > buf->max_size)\n\t\trlen = buf->alloc + need;\n\tSSHBUF_DBG((\"adjusted rlen %zu\", rlen));\n\tif ((dp = recallocarray(buf->d, buf->alloc, rlen, 1)) == NULL) {\n\t\tSSHBUF_DBG((\"realloc fail\"));\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tbuf->alloc = rlen;\n\tbuf->cd = buf->d = dp;\n\tif ((r = sshbuf_check_reserve(buf, len)) < 0) {\n\t\t/* shouldn't fail */\n\t\treturn r;\n\t}\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
  },
  {
    "function_name": "sshbuf_check_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "284-298",
    "snippet": "int\nsshbuf_check_reserve(const struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tSSHBUF_TELL(\"check\");\n\t/* Check that len is reasonable and that max_size + available < len */\n\tif (len > buf->max_size || buf->max_size - len < buf->size - buf->off)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\treturn 0;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SSHBUF_TELL",
          "args": [
            "\"check\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_check_sanity",
          "args": [
            "buf"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_sanity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "31-50",
          "snippet": "static inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_check_reserve(const struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tSSHBUF_TELL(\"check\");\n\t/* Check that len is reasonable and that max_size + available < len */\n\tif (len > buf->max_size || buf->max_size - len < buf->size - buf->off)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\treturn 0;\n}"
  },
  {
    "function_name": "sshbuf_mutable_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "276-282",
    "snippet": "u_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_check_sanity",
          "args": [
            "buf"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_sanity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "31-50",
          "snippet": "static inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}"
  },
  {
    "function_name": "sshbuf_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "268-274",
    "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_check_sanity",
          "args": [
            "buf"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_sanity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "31-50",
          "snippet": "static inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
  },
  {
    "function_name": "sshbuf_avail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "260-266",
    "snippet": "size_t\nsshbuf_avail(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn 0;\n\treturn buf->max_size - (buf->size - buf->off);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_check_sanity",
          "args": [
            "buf"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_sanity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "31-50",
          "snippet": "static inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_avail(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn 0;\n\treturn buf->max_size - (buf->size - buf->off);\n}"
  },
  {
    "function_name": "sshbuf_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "252-258",
    "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_check_sanity",
          "args": [
            "buf"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_sanity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "31-50",
          "snippet": "static inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
  },
  {
    "function_name": "sshbuf_set_max_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "214-250",
    "snippet": "int\nsshbuf_set_max_size(struct sshbuf *buf, size_t max_size)\n{\n\tsize_t rlen;\n\tu_char *dp;\n\tint r;\n\n\tSSHBUF_DBG((\"set max buf = %p len = %zu\", buf, max_size));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (max_size == buf->max_size)\n\t\treturn 0;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tif (max_size > SSHBUF_SIZE_MAX)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t/* pack and realloc if necessary */\n\tsshbuf_maybe_pack(buf, max_size < buf->size);\n\tif (max_size < buf->alloc && max_size > buf->size) {\n\t\tif (buf->size < SSHBUF_SIZE_INIT)\n\t\t\trlen = SSHBUF_SIZE_INIT;\n\t\telse\n\t\t\trlen = ROUNDUP(buf->size, SSHBUF_SIZE_INC);\n\t\tif (rlen > max_size)\n\t\t\trlen = max_size;\n\t\tSSHBUF_DBG((\"new alloc = %zu\", rlen));\n\t\tif ((dp = recallocarray(buf->d, buf->alloc, rlen, 1)) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tbuf->cd = buf->d = dp;\n\t\tbuf->alloc = rlen;\n\t}\n\tSSHBUF_TELL(\"new-max\");\n\tif (max_size < buf->alloc)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\tbuf->max_size = max_size;\n\treturn 0;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SSHBUF_TELL",
          "args": [
            "\"new-max\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recallocarray",
          "args": [
            "buf->d",
            "buf->alloc",
            "rlen",
            "1"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSHBUF_DBG",
          "args": [
            "(\"new alloc = %zu\", rlen)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUNDUP",
          "args": [
            "buf->size",
            "SSHBUF_SIZE_INC"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_maybe_pack",
          "args": [
            "buf",
            "max_size < buf->size"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_maybe_pack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "52-66",
          "snippet": "static void\nsshbuf_maybe_pack(struct sshbuf *buf, int force)\n{\n\tSSHBUF_DBG((\"force %d\", force));\n\tSSHBUF_TELL(\"pre-pack\");\n\tif (buf->off == 0 || buf->readonly || buf->refcount > 1)\n\t\treturn;\n\tif (force ||\n\t    (buf->off >= SSHBUF_PACK_MIN && buf->off >= buf->size / 2)) {\n\t\tmemmove(buf->d, buf->d + buf->off, buf->size - buf->off);\n\t\tbuf->size -= buf->off;\n\t\tbuf->off = 0;\n\t\tSSHBUF_TELL(\"packed\");\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsshbuf_maybe_pack(struct sshbuf *buf, int force)\n{\n\tSSHBUF_DBG((\"force %d\", force));\n\tSSHBUF_TELL(\"pre-pack\");\n\tif (buf->off == 0 || buf->readonly || buf->refcount > 1)\n\t\treturn;\n\tif (force ||\n\t    (buf->off >= SSHBUF_PACK_MIN && buf->off >= buf->size / 2)) {\n\t\tmemmove(buf->d, buf->d + buf->off, buf->size - buf->off);\n\t\tbuf->size -= buf->off;\n\t\tbuf->off = 0;\n\t\tSSHBUF_TELL(\"packed\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_check_sanity",
          "args": [
            "buf"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_sanity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "31-50",
          "snippet": "static inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSHBUF_DBG",
          "args": [
            "(\"set max buf = %p len = %zu\", buf, max_size)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_set_max_size(struct sshbuf *buf, size_t max_size)\n{\n\tsize_t rlen;\n\tu_char *dp;\n\tint r;\n\n\tSSHBUF_DBG((\"set max buf = %p len = %zu\", buf, max_size));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (max_size == buf->max_size)\n\t\treturn 0;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tif (max_size > SSHBUF_SIZE_MAX)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t/* pack and realloc if necessary */\n\tsshbuf_maybe_pack(buf, max_size < buf->size);\n\tif (max_size < buf->alloc && max_size > buf->size) {\n\t\tif (buf->size < SSHBUF_SIZE_INIT)\n\t\t\trlen = SSHBUF_SIZE_INIT;\n\t\telse\n\t\t\trlen = ROUNDUP(buf->size, SSHBUF_SIZE_INC);\n\t\tif (rlen > max_size)\n\t\t\trlen = max_size;\n\t\tSSHBUF_DBG((\"new alloc = %zu\", rlen));\n\t\tif ((dp = recallocarray(buf->d, buf->alloc, rlen, 1)) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tbuf->cd = buf->d = dp;\n\t\tbuf->alloc = rlen;\n\t}\n\tSSHBUF_TELL(\"new-max\");\n\tif (max_size < buf->alloc)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\tbuf->max_size = max_size;\n\treturn 0;\n}"
  },
  {
    "function_name": "sshbuf_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "208-212",
    "snippet": "u_int\nsshbuf_refcount(const struct sshbuf *buf)\n{\n\treturn buf->refcount;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\nsshbuf_refcount(const struct sshbuf *buf)\n{\n\treturn buf->refcount;\n}"
  },
  {
    "function_name": "sshbuf_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "202-206",
    "snippet": "const struct sshbuf *\nsshbuf_parent(const struct sshbuf *buf)\n{\n\treturn buf->parent;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst struct sshbuf *\nsshbuf_parent(const struct sshbuf *buf)\n{\n\treturn buf->parent;\n}"
  },
  {
    "function_name": "sshbuf_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "196-200",
    "snippet": "size_t\nsshbuf_alloc(const struct sshbuf *buf)\n{\n\treturn buf->alloc;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_alloc(const struct sshbuf *buf)\n{\n\treturn buf->alloc;\n}"
  },
  {
    "function_name": "sshbuf_max_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "190-194",
    "snippet": "size_t\nsshbuf_max_size(const struct sshbuf *buf)\n{\n\treturn buf->max_size;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_max_size(const struct sshbuf *buf)\n{\n\treturn buf->max_size;\n}"
  },
  {
    "function_name": "sshbuf_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "168-188",
    "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "buf->d",
            "SSHBUF_SIZE_INIT"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recallocarray",
          "args": [
            "buf->d",
            "buf->alloc",
            "SSHBUF_SIZE_INIT",
            "1"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_check_sanity",
          "args": [
            "buf"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_sanity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "31-50",
          "snippet": "static inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
  },
  {
    "function_name": "sshbuf_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "133-166",
    "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "buf",
            "sizeof(*buf)"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_check_sanity",
          "args": [
            "buf"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_sanity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "31-50",
          "snippet": "static inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
  },
  {
    "function_name": "sshbuf_fromb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "117-131",
    "snippet": "struct sshbuf *\nsshbuf_fromb(struct sshbuf *buf)\n{\n\tstruct sshbuf *ret;\n\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\tif ((ret = sshbuf_from(sshbuf_ptr(buf), sshbuf_len(buf))) == NULL)\n\t\treturn NULL;\n\tif (sshbuf_set_parent(ret, buf) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "ret"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_set_parent",
          "args": [
            "ret",
            "buf"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_set_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "104-115",
          "snippet": "int\nsshbuf_set_parent(struct sshbuf *child, struct sshbuf *parent)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(child)) != 0 ||\n\t    (r = sshbuf_check_sanity(parent)) != 0)\n\t\treturn r;\n\tchild->parent = parent;\n\tchild->parent->refcount++;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_set_parent(struct sshbuf *child, struct sshbuf *parent)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(child)) != 0 ||\n\t    (r = sshbuf_check_sanity(parent)) != 0)\n\t\treturn r;\n\tchild->parent = parent;\n\tchild->parent->refcount++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_from",
          "args": [
            "sshbuf_ptr(buf)",
            "sshbuf_len(buf)"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "87-102",
          "snippet": "struct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "buf"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "buf"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_check_sanity",
          "args": [
            "buf"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_sanity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "31-50",
          "snippet": "static inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_fromb(struct sshbuf *buf)\n{\n\tstruct sshbuf *ret;\n\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\tif ((ret = sshbuf_from(sshbuf_ptr(buf), sshbuf_len(buf))) == NULL)\n\t\treturn NULL;\n\tif (sshbuf_set_parent(ret, buf) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sshbuf_set_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "104-115",
    "snippet": "int\nsshbuf_set_parent(struct sshbuf *child, struct sshbuf *parent)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(child)) != 0 ||\n\t    (r = sshbuf_check_sanity(parent)) != 0)\n\t\treturn r;\n\tchild->parent = parent;\n\tchild->parent->refcount++;\n\treturn 0;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_check_sanity",
          "args": [
            "parent"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_sanity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "31-50",
          "snippet": "static inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_set_parent(struct sshbuf *child, struct sshbuf *parent)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(child)) != 0 ||\n\t    (r = sshbuf_check_sanity(parent)) != 0)\n\t\treturn r;\n\tchild->parent = parent;\n\tchild->parent->refcount++;\n\treturn 0;\n}"
  },
  {
    "function_name": "sshbuf_from",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "87-102",
    "snippet": "struct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "sizeof(*ret)",
            "1"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "sshbuf_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "68-85",
    "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ret"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "ret->alloc"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sshbuf_maybe_pack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "52-66",
    "snippet": "static void\nsshbuf_maybe_pack(struct sshbuf *buf, int force)\n{\n\tSSHBUF_DBG((\"force %d\", force));\n\tSSHBUF_TELL(\"pre-pack\");\n\tif (buf->off == 0 || buf->readonly || buf->refcount > 1)\n\t\treturn;\n\tif (force ||\n\t    (buf->off >= SSHBUF_PACK_MIN && buf->off >= buf->size / 2)) {\n\t\tmemmove(buf->d, buf->d + buf->off, buf->size - buf->off);\n\t\tbuf->size -= buf->off;\n\t\tbuf->off = 0;\n\t\tSSHBUF_TELL(\"packed\");\n\t}\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SSHBUF_TELL",
          "args": [
            "\"packed\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "buf->d",
            "buf->d + buf->off",
            "buf->size - buf->off"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSHBUF_TELL",
          "args": [
            "\"pre-pack\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSHBUF_DBG",
          "args": [
            "(\"force %d\", force)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsshbuf_maybe_pack(struct sshbuf *buf, int force)\n{\n\tSSHBUF_DBG((\"force %d\", force));\n\tSSHBUF_TELL(\"pre-pack\");\n\tif (buf->off == 0 || buf->readonly || buf->refcount > 1)\n\t\treturn;\n\tif (force ||\n\t    (buf->off >= SSHBUF_PACK_MIN && buf->off >= buf->size / 2)) {\n\t\tmemmove(buf->d, buf->d + buf->off, buf->size - buf->off);\n\t\tbuf->size -= buf->off;\n\t\tbuf->off = 0;\n\t\tSSHBUF_TELL(\"packed\");\n\t}\n}"
  },
  {
    "function_name": "sshbuf_check_sanity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
    "lines": "31-50",
    "snippet": "static inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raise",
          "args": [
            "SIGSEGV"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "raise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "296-300",
          "snippet": "int\nraise(int sig)\n{\n\tkill(getpid(), sig);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nraise(int sig)\n{\n\tkill(getpid(), sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGSEGV",
            "SIG_DFL"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSHBUF_DBG",
          "args": [
            "(\"SSH_ERR_INTERNAL_ERROR\")"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__predict_false",
          "args": [
            "buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSHBUF_TELL",
          "args": [
            "\"sanity\""
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t/* Do not try to recover from corrupted buffer internals */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tsignal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
  }
]