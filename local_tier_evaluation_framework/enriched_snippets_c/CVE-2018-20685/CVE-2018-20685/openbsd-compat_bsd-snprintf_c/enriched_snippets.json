[
  {
    "function_name": "snprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
    "lines": "869-879",
    "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "str",
            "count",
            "fmt",
            "ap"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "vsnprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "861-865",
          "snippet": "int\nvsnprintf (char *str, size_t count, const char *fmt, va_list args)\n{\n\treturn dopr(str, count, fmt, args);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nvsnprintf (char *str, size_t count, const char *fmt, va_list args)\n{\n\treturn dopr(str, count, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
  },
  {
    "function_name": "vsnprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
    "lines": "861-865",
    "snippet": "int\nvsnprintf (char *str, size_t count, const char *fmt, va_list args)\n{\n\treturn dopr(str, count, fmt, args);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dopr",
          "args": [
            "str",
            "count",
            "fmt",
            "args"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "dopr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "179-499",
          "snippet": "static int\ndopr(char *buffer, size_t maxlen, const char *format, va_list args_in)\n{\n\tchar ch;\n\tintmax_t value;\n\tLDOUBLE fvalue;\n\tchar *strvalue;\n\tint min;\n\tint max;\n\tint state;\n\tint flags;\n\tint cflags;\n\tsize_t currlen;\n\tva_list args;\n\n\tVA_COPY(args, args_in);\n\t\n\tstate = DP_S_DEFAULT;\n\tcurrlen = flags = cflags = min = 0;\n\tmax = -1;\n\tch = *format++;\n\t\n\twhile (state != DP_S_DONE) {\n\t\tif (ch == '\\0') \n\t\t\tstate = DP_S_DONE;\n\n\t\tswitch(state) {\n\t\tcase DP_S_DEFAULT:\n\t\t\tif (ch == '%') \n\t\t\t\tstate = DP_S_FLAGS;\n\t\t\telse\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen, ch);\n\t\t\tch = *format++;\n\t\t\tbreak;\n\t\tcase DP_S_FLAGS:\n\t\t\tswitch (ch) {\n\t\t\tcase '-':\n\t\t\t\tflags |= DP_F_MINUS;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tflags |= DP_F_PLUS;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tflags |= DP_F_SPACE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tflags |= DP_F_NUM;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\t\tflags |= DP_F_ZERO;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstate = DP_S_MIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MIN:\n\t\t\tif (isdigit((unsigned char)ch)) {\n\t\t\t\tmin = 10*min + char_to_int (ch);\n\t\t\t\tch = *format++;\n\t\t\t} else if (ch == '*') {\n\t\t\t\tmin = va_arg (args, int);\n\t\t\t\tch = *format++;\n\t\t\t\tstate = DP_S_DOT;\n\t\t\t} else {\n\t\t\t\tstate = DP_S_DOT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_DOT:\n\t\t\tif (ch == '.') {\n\t\t\t\tstate = DP_S_MAX;\n\t\t\t\tch = *format++;\n\t\t\t} else { \n\t\t\t\tstate = DP_S_MOD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MAX:\n\t\t\tif (isdigit((unsigned char)ch)) {\n\t\t\t\tif (max < 0)\n\t\t\t\t\tmax = 0;\n\t\t\t\tmax = 10*max + char_to_int (ch);\n\t\t\t\tch = *format++;\n\t\t\t} else if (ch == '*') {\n\t\t\t\tmax = va_arg (args, int);\n\t\t\t\tch = *format++;\n\t\t\t\tstate = DP_S_MOD;\n\t\t\t} else {\n\t\t\t\tstate = DP_S_MOD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MOD:\n\t\t\tswitch (ch) {\n\t\t\tcase 'h':\n\t\t\t\tcflags = DP_C_SHORT;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'j':\n\t\t\t\tcflags = DP_C_INTMAX;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tcflags = DP_C_LONG;\n\t\t\t\tch = *format++;\n\t\t\t\tif (ch == 'l') {\t/* It's a long long */\n\t\t\t\t\tcflags = DP_C_LLONG;\n\t\t\t\t\tch = *format++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tcflags = DP_C_LDOUBLE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tcflags = DP_C_SIZE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstate = DP_S_CONV;\n\t\t\tbreak;\n\t\tcase DP_S_CONV:\n\t\t\tswitch (ch) {\n\t\t\tcase 'd':\n\t\t\tcase 'i':\n\t\t\t\tif (cflags == DP_C_SHORT) \n\t\t\t\t\tvalue = va_arg (args, int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = va_arg (args, long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = va_arg (args, LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, ssize_t);\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, intmax_t);\n\t\t\t\telse\n\t\t\t\t\tvalue = va_arg (args, int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen,\n\t\t\t\t    value, 10, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    8, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (LLONG)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    10, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'x':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (LLONG)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    16, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'e':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'G':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'g':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen,\n\t\t\t\t    va_arg (args, int));\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tstrvalue = va_arg (args, char *);\n\t\t\t\tif (!strvalue) strvalue = \"(NULL)\";\n\t\t\t\tif (max == -1) {\n\t\t\t\t\tmax = strlen(strvalue);\n\t\t\t\t}\n\t\t\t\tif (min > 0 && max >= 0 && min > max) max = min;\n\t\t\t\tif (fmtstr(buffer, &currlen, maxlen,\n\t\t\t\t    strvalue, flags, min, max) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tstrvalue = va_arg (args, void *);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen,\n\t\t\t\t    (long) strvalue, 16, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n#if we_dont_want_this_in_openssh\n\t\t\tcase 'n':\n\t\t\t\tif (cflags == DP_C_SHORT) {\n\t\t\t\t\tshort int *num;\n\t\t\t\t\tnum = va_arg (args, short int *);\n\t\t\t\t\t*num = currlen;\n\t\t\t\t} else if (cflags == DP_C_LONG) {\n\t\t\t\t\tlong int *num;\n\t\t\t\t\tnum = va_arg (args, long int *);\n\t\t\t\t\t*num = (long int)currlen;\n\t\t\t\t} else if (cflags == DP_C_LLONG) {\n\t\t\t\t\tLLONG *num;\n\t\t\t\t\tnum = va_arg (args, LLONG *);\n\t\t\t\t\t*num = (LLONG)currlen;\n\t\t\t\t} else if (cflags == DP_C_SIZE) {\n\t\t\t\t\tssize_t *num;\n\t\t\t\t\tnum = va_arg (args, ssize_t *);\n\t\t\t\t\t*num = (ssize_t)currlen;\n\t\t\t\t} else if (cflags == DP_C_INTMAX) {\n\t\t\t\t\tintmax_t *num;\n\t\t\t\t\tnum = va_arg (args, intmax_t *);\n\t\t\t\t\t*num = (intmax_t)currlen;\n\t\t\t\t} else {\n\t\t\t\t\tint *num;\n\t\t\t\t\tnum = va_arg (args, int *);\n\t\t\t\t\t*num = currlen;\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\t\t\tcase '%':\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen, ch);\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\t/* not supported yet, treat as next char */\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Unknown, skip */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tch = *format++;\n\t\t\tstate = DP_S_DEFAULT;\n\t\t\tflags = cflags = min = 0;\n\t\t\tmax = -1;\n\t\t\tbreak;\n\t\tcase DP_S_DONE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* hmm? */\n\t\t\tbreak; /* some picky compilers need this */\n\t\t}\n\t}\n\tif (maxlen != 0) {\n\t\tif (currlen < maxlen - 1) \n\t\t\tbuffer[currlen] = '\\0';\n\t\telse if (maxlen > 0) \n\t\t\tbuffer[maxlen - 1] = '\\0';\n\t}\n\t\n\treturn currlen < INT_MAX ? (int)currlen : -1;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define DP_C_INTMAX  6",
            "#define DP_C_SIZE    5",
            "#define DP_C_LLONG   4",
            "#define DP_C_LDOUBLE 3",
            "#define DP_C_LONG    2",
            "#define DP_C_SHORT   1",
            "#define DP_F_UNSIGNED \t(1 << 6)",
            "#define DP_F_UP    \t(1 << 5)",
            "#define DP_F_ZERO  \t(1 << 4)",
            "#define DP_F_NUM   \t(1 << 3)",
            "#define DP_F_SPACE \t(1 << 2)",
            "#define DP_F_PLUS  \t(1 << 1)",
            "#define DP_F_MINUS \t(1 << 0)",
            "#define DP_S_DONE    7",
            "#define DP_S_CONV    6",
            "#define DP_S_MOD     5",
            "#define DP_S_MAX     4",
            "#define DP_S_DOT     3",
            "#define DP_S_MIN     2",
            "#define DP_S_FLAGS   1",
            "#define DP_S_DEFAULT 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\n#define DP_C_INTMAX  6\n#define DP_C_SIZE    5\n#define DP_C_LLONG   4\n#define DP_C_LDOUBLE 3\n#define DP_C_LONG    2\n#define DP_C_SHORT   1\n#define DP_F_UNSIGNED \t(1 << 6)\n#define DP_F_UP    \t(1 << 5)\n#define DP_F_ZERO  \t(1 << 4)\n#define DP_F_NUM   \t(1 << 3)\n#define DP_F_SPACE \t(1 << 2)\n#define DP_F_PLUS  \t(1 << 1)\n#define DP_F_MINUS \t(1 << 0)\n#define DP_S_DONE    7\n#define DP_S_CONV    6\n#define DP_S_MOD     5\n#define DP_S_MAX     4\n#define DP_S_DOT     3\n#define DP_S_MIN     2\n#define DP_S_FLAGS   1\n#define DP_S_DEFAULT 0\n\nstatic int\ndopr(char *buffer, size_t maxlen, const char *format, va_list args_in)\n{\n\tchar ch;\n\tintmax_t value;\n\tLDOUBLE fvalue;\n\tchar *strvalue;\n\tint min;\n\tint max;\n\tint state;\n\tint flags;\n\tint cflags;\n\tsize_t currlen;\n\tva_list args;\n\n\tVA_COPY(args, args_in);\n\t\n\tstate = DP_S_DEFAULT;\n\tcurrlen = flags = cflags = min = 0;\n\tmax = -1;\n\tch = *format++;\n\t\n\twhile (state != DP_S_DONE) {\n\t\tif (ch == '\\0') \n\t\t\tstate = DP_S_DONE;\n\n\t\tswitch(state) {\n\t\tcase DP_S_DEFAULT:\n\t\t\tif (ch == '%') \n\t\t\t\tstate = DP_S_FLAGS;\n\t\t\telse\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen, ch);\n\t\t\tch = *format++;\n\t\t\tbreak;\n\t\tcase DP_S_FLAGS:\n\t\t\tswitch (ch) {\n\t\t\tcase '-':\n\t\t\t\tflags |= DP_F_MINUS;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tflags |= DP_F_PLUS;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tflags |= DP_F_SPACE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tflags |= DP_F_NUM;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\t\tflags |= DP_F_ZERO;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstate = DP_S_MIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MIN:\n\t\t\tif (isdigit((unsigned char)ch)) {\n\t\t\t\tmin = 10*min + char_to_int (ch);\n\t\t\t\tch = *format++;\n\t\t\t} else if (ch == '*') {\n\t\t\t\tmin = va_arg (args, int);\n\t\t\t\tch = *format++;\n\t\t\t\tstate = DP_S_DOT;\n\t\t\t} else {\n\t\t\t\tstate = DP_S_DOT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_DOT:\n\t\t\tif (ch == '.') {\n\t\t\t\tstate = DP_S_MAX;\n\t\t\t\tch = *format++;\n\t\t\t} else { \n\t\t\t\tstate = DP_S_MOD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MAX:\n\t\t\tif (isdigit((unsigned char)ch)) {\n\t\t\t\tif (max < 0)\n\t\t\t\t\tmax = 0;\n\t\t\t\tmax = 10*max + char_to_int (ch);\n\t\t\t\tch = *format++;\n\t\t\t} else if (ch == '*') {\n\t\t\t\tmax = va_arg (args, int);\n\t\t\t\tch = *format++;\n\t\t\t\tstate = DP_S_MOD;\n\t\t\t} else {\n\t\t\t\tstate = DP_S_MOD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MOD:\n\t\t\tswitch (ch) {\n\t\t\tcase 'h':\n\t\t\t\tcflags = DP_C_SHORT;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'j':\n\t\t\t\tcflags = DP_C_INTMAX;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tcflags = DP_C_LONG;\n\t\t\t\tch = *format++;\n\t\t\t\tif (ch == 'l') {\t/* It's a long long */\n\t\t\t\t\tcflags = DP_C_LLONG;\n\t\t\t\t\tch = *format++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tcflags = DP_C_LDOUBLE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tcflags = DP_C_SIZE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstate = DP_S_CONV;\n\t\t\tbreak;\n\t\tcase DP_S_CONV:\n\t\t\tswitch (ch) {\n\t\t\tcase 'd':\n\t\t\tcase 'i':\n\t\t\t\tif (cflags == DP_C_SHORT) \n\t\t\t\t\tvalue = va_arg (args, int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = va_arg (args, long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = va_arg (args, LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, ssize_t);\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, intmax_t);\n\t\t\t\telse\n\t\t\t\t\tvalue = va_arg (args, int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen,\n\t\t\t\t    value, 10, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    8, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (LLONG)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    10, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'x':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (LLONG)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    16, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'e':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'G':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'g':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen,\n\t\t\t\t    va_arg (args, int));\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tstrvalue = va_arg (args, char *);\n\t\t\t\tif (!strvalue) strvalue = \"(NULL)\";\n\t\t\t\tif (max == -1) {\n\t\t\t\t\tmax = strlen(strvalue);\n\t\t\t\t}\n\t\t\t\tif (min > 0 && max >= 0 && min > max) max = min;\n\t\t\t\tif (fmtstr(buffer, &currlen, maxlen,\n\t\t\t\t    strvalue, flags, min, max) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tstrvalue = va_arg (args, void *);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen,\n\t\t\t\t    (long) strvalue, 16, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n#if we_dont_want_this_in_openssh\n\t\t\tcase 'n':\n\t\t\t\tif (cflags == DP_C_SHORT) {\n\t\t\t\t\tshort int *num;\n\t\t\t\t\tnum = va_arg (args, short int *);\n\t\t\t\t\t*num = currlen;\n\t\t\t\t} else if (cflags == DP_C_LONG) {\n\t\t\t\t\tlong int *num;\n\t\t\t\t\tnum = va_arg (args, long int *);\n\t\t\t\t\t*num = (long int)currlen;\n\t\t\t\t} else if (cflags == DP_C_LLONG) {\n\t\t\t\t\tLLONG *num;\n\t\t\t\t\tnum = va_arg (args, LLONG *);\n\t\t\t\t\t*num = (LLONG)currlen;\n\t\t\t\t} else if (cflags == DP_C_SIZE) {\n\t\t\t\t\tssize_t *num;\n\t\t\t\t\tnum = va_arg (args, ssize_t *);\n\t\t\t\t\t*num = (ssize_t)currlen;\n\t\t\t\t} else if (cflags == DP_C_INTMAX) {\n\t\t\t\t\tintmax_t *num;\n\t\t\t\t\tnum = va_arg (args, intmax_t *);\n\t\t\t\t\t*num = (intmax_t)currlen;\n\t\t\t\t} else {\n\t\t\t\t\tint *num;\n\t\t\t\t\tnum = va_arg (args, int *);\n\t\t\t\t\t*num = currlen;\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\t\t\tcase '%':\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen, ch);\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\t/* not supported yet, treat as next char */\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Unknown, skip */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tch = *format++;\n\t\t\tstate = DP_S_DEFAULT;\n\t\t\tflags = cflags = min = 0;\n\t\t\tmax = -1;\n\t\t\tbreak;\n\t\tcase DP_S_DONE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* hmm? */\n\t\t\tbreak; /* some picky compilers need this */\n\t\t}\n\t}\n\tif (maxlen != 0) {\n\t\tif (currlen < maxlen - 1) \n\t\t\tbuffer[currlen] = '\\0';\n\t\telse if (maxlen > 0) \n\t\t\tbuffer[maxlen - 1] = '\\0';\n\t}\n\t\n\treturn currlen < INT_MAX ? (int)currlen : -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nvsnprintf (char *str, size_t count, const char *fmt, va_list args)\n{\n\treturn dopr(str, count, fmt, args);\n}"
  },
  {
    "function_name": "fmtfp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
    "lines": "702-857",
    "snippet": "static int\nfmtfp (char *buffer, size_t *currlen, size_t maxlen,\n    LDOUBLE fvalue, int min, int max, int flags)\n{\n\tint signvalue = 0;\n\tdouble ufvalue;\n\tchar iconvert[311];\n\tchar fconvert[311];\n\tint iplace = 0;\n\tint fplace = 0;\n\tint padlen = 0; /* amount to pad */\n\tint zpadlen = 0; \n\tint caps = 0;\n\tint idx;\n\tdouble intpart;\n\tdouble fracpart;\n\tdouble temp;\n  \n\t/* \n\t * AIX manpage says the default is 0, but Solaris says the default\n\t * is 6, and sprintf on AIX defaults to 6\n\t */\n\tif (max < 0)\n\t\tmax = 6;\n\n\tufvalue = abs_val (fvalue);\n\n\tif (fvalue < 0) {\n\t\tsignvalue = '-';\n\t} else {\n\t\tif (flags & DP_F_PLUS) { /* Do a sign (+/i) */\n\t\t\tsignvalue = '+';\n\t\t} else {\n\t\t\tif (flags & DP_F_SPACE)\n\t\t\t\tsignvalue = ' ';\n\t\t}\n\t}\n\n#if 0\n\tif (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */\n#endif\n\n#if 0\n\t if (max == 0) ufvalue += 0.5; /* if max = 0 we must round */\n#endif\n\n\t/* \n\t * Sorry, we only support 16 digits past the decimal because of our \n\t * conversion method\n\t */\n\tif (max > 16)\n\t\tmax = 16;\n\n\t/* We \"cheat\" by converting the fractional part to integer by\n\t * multiplying by a factor of 10\n\t */\n\n\ttemp = ufvalue;\n\tmy_modf(temp, &intpart);\n\n\tfracpart = ROUND((POW10(max)) * (ufvalue - intpart));\n\t\n\tif (fracpart >= POW10(max)) {\n\t\tintpart++;\n\t\tfracpart -= POW10(max);\n\t}\n\n\t/* Convert integer part */\n\tdo {\n\t\ttemp = intpart*0.1;\n\t\tmy_modf(temp, &intpart);\n\t\tidx = (int) ((temp -intpart +0.05)* 10.0);\n\t\t/* idx = (int) (((double)(temp*0.1) -intpart +0.05) *10.0); */\n\t\t/* printf (\"%llf, %f, %x\\n\", temp, intpart, idx); */\n\t\ticonvert[iplace++] =\n\t\t\t(caps? \"0123456789ABCDEF\":\"0123456789abcdef\")[idx];\n\t} while (intpart && (iplace < 311));\n\tif (iplace == 311) iplace--;\n\ticonvert[iplace] = 0;\n\n\t/* Convert fractional part */\n\tif (fracpart)\n\t{\n\t\tdo {\n\t\t\ttemp = fracpart*0.1;\n\t\t\tmy_modf(temp, &fracpart);\n\t\t\tidx = (int) ((temp -fracpart +0.05)* 10.0);\n\t\t\t/* idx = (int) ((((temp/10) -fracpart) +0.05) *10); */\n\t\t\t/* printf (\"%lf, %lf, %ld\\n\", temp, fracpart, idx ); */\n\t\t\tfconvert[fplace++] =\n\t\t\t(caps? \"0123456789ABCDEF\":\"0123456789abcdef\")[idx];\n\t\t} while(fracpart && (fplace < 311));\n\t\tif (fplace == 311) fplace--;\n\t}\n\tfconvert[fplace] = 0;\n  \n\t/* -1 for decimal point, another -1 if we are printing a sign */\n\tpadlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0); \n\tzpadlen = max - fplace;\n\tif (zpadlen < 0) zpadlen = 0;\n\tif (padlen < 0) \n\t\tpadlen = 0;\n\tif (flags & DP_F_MINUS) \n\t\tpadlen = -padlen; /* Left Justifty */\n\t\n\tif ((flags & DP_F_ZERO) && (padlen > 0)) {\n\t\tif (signvalue) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\t\t\t--padlen;\n\t\t\tsignvalue = 0;\n\t\t}\n\t\twhile (padlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--padlen;\n\t\t}\n\t}\n\twhile (padlen > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--padlen;\n\t}\n\tif (signvalue) \n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\t\n\twhile (iplace > 0) {\n\t\t--iplace;\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, iconvert[iplace]);\n\t}\n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"fmtfp: fplace=%d zpadlen=%d\\n\", fplace, zpadlen);\n#endif\n\n\t/*\n\t * Decimal point.  This should probably use locale to find the correct\n\t * char to print out.\n\t */\n\tif (max > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '.');\n\t\t\n\t\twhile (zpadlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--zpadlen;\n\t\t}\n\n\t\twhile (fplace > 0) {\n\t\t\t--fplace;\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, fconvert[fplace]);\n\t\t}\n\t}\n\n\twhile (padlen < 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++padlen;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define DP_F_UP    \t(1 << 5)",
      "#define DP_F_ZERO  \t(1 << 4)",
      "#define DP_F_SPACE \t(1 << 2)",
      "#define DP_F_PLUS  \t(1 << 1)",
      "#define DP_F_MINUS \t(1 << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "' '"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "fconvert[fplace]"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "'0'"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "'.'"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"fmtfp: fplace=%d zpadlen=%d\\n\"",
            "fplace",
            "zpadlen"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "iconvert[iplace]"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "signvalue"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "' '"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "'0'"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "signvalue"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_modf",
          "args": [
            "temp",
            "&fracpart"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "my_modf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "665-699",
          "snippet": "static double my_modf(double x0, double *iptr)\n{\n\tint i;\n\tlong l;\n\tdouble x = x0;\n\tdouble f = 1.0;\n\n\tfor (i=0;i<100;i++) {\n\t\tl = (long)x;\n\t\tif (l <= (x+1) && l >= (x-1)) break;\n\t\tx *= 0.1;\n\t\tf *= 10.0;\n\t}\n\n\tif (i == 100) {\n\t\t/*\n\t\t * yikes! the number is beyond what we can handle.\n\t\t * What do we do?\n\t\t */\n\t\t(*iptr) = 0;\n\t\treturn 0;\n\t}\n\n\tif (i != 0) {\n\t\tdouble i2;\n\t\tdouble ret;\n\n\t\tret = my_modf(x0-l*f, &i2);\n\t\t(*iptr) = l*f + i2;\n\t\treturn ret;\n\t} \n\n\t(*iptr) = l;\n\treturn x - (*iptr);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nstatic double my_modf(double x0, double *iptr)\n{\n\tint i;\n\tlong l;\n\tdouble x = x0;\n\tdouble f = 1.0;\n\n\tfor (i=0;i<100;i++) {\n\t\tl = (long)x;\n\t\tif (l <= (x+1) && l >= (x-1)) break;\n\t\tx *= 0.1;\n\t\tf *= 10.0;\n\t}\n\n\tif (i == 100) {\n\t\t/*\n\t\t * yikes! the number is beyond what we can handle.\n\t\t * What do we do?\n\t\t */\n\t\t(*iptr) = 0;\n\t\treturn 0;\n\t}\n\n\tif (i != 0) {\n\t\tdouble i2;\n\t\tdouble ret;\n\n\t\tret = my_modf(x0-l*f, &i2);\n\t\t(*iptr) = l*f + i2;\n\t\treturn ret;\n\t} \n\n\t(*iptr) = l;\n\treturn x - (*iptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "POW10",
          "args": [
            "max"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "POW10",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "640-650",
          "snippet": "static LDOUBLE POW10(int val)\n{\n\tLDOUBLE result = 1;\n\t\n\twhile (val) {\n\t\tresult *= 10;\n\t\tval--;\n\t}\n  \n\treturn result;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nstatic LDOUBLE POW10(int val)\n{\n\tLDOUBLE result = 1;\n\t\n\twhile (val) {\n\t\tresult *= 10;\n\t\tval--;\n\t}\n  \n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ROUND",
          "args": [
            "(POW10(max)) * (ufvalue - intpart)"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "ROUND",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "652-661",
          "snippet": "static LLONG ROUND(LDOUBLE value)\n{\n\tLLONG intpart;\n\n\tintpart = (LLONG)value;\n\tvalue = value - intpart;\n\tif (value >= 0.5) intpart++;\n\t\n\treturn intpart;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nstatic LLONG ROUND(LDOUBLE value)\n{\n\tLLONG intpart;\n\n\tintpart = (LLONG)value;\n\tvalue = value - intpart;\n\tif (value >= 0.5) intpart++;\n\t\n\treturn intpart;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs_val",
          "args": [
            "fvalue"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "abs_val",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "630-638",
          "snippet": "static LDOUBLE abs_val(LDOUBLE value)\n{\n\tLDOUBLE result = value;\n\n\tif (value < 0)\n\t\tresult = -value;\n\t\n\treturn result;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nstatic LDOUBLE abs_val(LDOUBLE value)\n{\n\tLDOUBLE result = value;\n\n\tif (value < 0)\n\t\tresult = -value;\n\t\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\n#define DP_F_UP    \t(1 << 5)\n#define DP_F_ZERO  \t(1 << 4)\n#define DP_F_SPACE \t(1 << 2)\n#define DP_F_PLUS  \t(1 << 1)\n#define DP_F_MINUS \t(1 << 0)\n\nstatic int\nfmtfp (char *buffer, size_t *currlen, size_t maxlen,\n    LDOUBLE fvalue, int min, int max, int flags)\n{\n\tint signvalue = 0;\n\tdouble ufvalue;\n\tchar iconvert[311];\n\tchar fconvert[311];\n\tint iplace = 0;\n\tint fplace = 0;\n\tint padlen = 0; /* amount to pad */\n\tint zpadlen = 0; \n\tint caps = 0;\n\tint idx;\n\tdouble intpart;\n\tdouble fracpart;\n\tdouble temp;\n  \n\t/* \n\t * AIX manpage says the default is 0, but Solaris says the default\n\t * is 6, and sprintf on AIX defaults to 6\n\t */\n\tif (max < 0)\n\t\tmax = 6;\n\n\tufvalue = abs_val (fvalue);\n\n\tif (fvalue < 0) {\n\t\tsignvalue = '-';\n\t} else {\n\t\tif (flags & DP_F_PLUS) { /* Do a sign (+/i) */\n\t\t\tsignvalue = '+';\n\t\t} else {\n\t\t\tif (flags & DP_F_SPACE)\n\t\t\t\tsignvalue = ' ';\n\t\t}\n\t}\n\n#if 0\n\tif (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */\n#endif\n\n#if 0\n\t if (max == 0) ufvalue += 0.5; /* if max = 0 we must round */\n#endif\n\n\t/* \n\t * Sorry, we only support 16 digits past the decimal because of our \n\t * conversion method\n\t */\n\tif (max > 16)\n\t\tmax = 16;\n\n\t/* We \"cheat\" by converting the fractional part to integer by\n\t * multiplying by a factor of 10\n\t */\n\n\ttemp = ufvalue;\n\tmy_modf(temp, &intpart);\n\n\tfracpart = ROUND((POW10(max)) * (ufvalue - intpart));\n\t\n\tif (fracpart >= POW10(max)) {\n\t\tintpart++;\n\t\tfracpart -= POW10(max);\n\t}\n\n\t/* Convert integer part */\n\tdo {\n\t\ttemp = intpart*0.1;\n\t\tmy_modf(temp, &intpart);\n\t\tidx = (int) ((temp -intpart +0.05)* 10.0);\n\t\t/* idx = (int) (((double)(temp*0.1) -intpart +0.05) *10.0); */\n\t\t/* printf (\"%llf, %f, %x\\n\", temp, intpart, idx); */\n\t\ticonvert[iplace++] =\n\t\t\t(caps? \"0123456789ABCDEF\":\"0123456789abcdef\")[idx];\n\t} while (intpart && (iplace < 311));\n\tif (iplace == 311) iplace--;\n\ticonvert[iplace] = 0;\n\n\t/* Convert fractional part */\n\tif (fracpart)\n\t{\n\t\tdo {\n\t\t\ttemp = fracpart*0.1;\n\t\t\tmy_modf(temp, &fracpart);\n\t\t\tidx = (int) ((temp -fracpart +0.05)* 10.0);\n\t\t\t/* idx = (int) ((((temp/10) -fracpart) +0.05) *10); */\n\t\t\t/* printf (\"%lf, %lf, %ld\\n\", temp, fracpart, idx ); */\n\t\t\tfconvert[fplace++] =\n\t\t\t(caps? \"0123456789ABCDEF\":\"0123456789abcdef\")[idx];\n\t\t} while(fracpart && (fplace < 311));\n\t\tif (fplace == 311) fplace--;\n\t}\n\tfconvert[fplace] = 0;\n  \n\t/* -1 for decimal point, another -1 if we are printing a sign */\n\tpadlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0); \n\tzpadlen = max - fplace;\n\tif (zpadlen < 0) zpadlen = 0;\n\tif (padlen < 0) \n\t\tpadlen = 0;\n\tif (flags & DP_F_MINUS) \n\t\tpadlen = -padlen; /* Left Justifty */\n\t\n\tif ((flags & DP_F_ZERO) && (padlen > 0)) {\n\t\tif (signvalue) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\t\t\t--padlen;\n\t\t\tsignvalue = 0;\n\t\t}\n\t\twhile (padlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--padlen;\n\t\t}\n\t}\n\twhile (padlen > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--padlen;\n\t}\n\tif (signvalue) \n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\t\n\twhile (iplace > 0) {\n\t\t--iplace;\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, iconvert[iplace]);\n\t}\n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"fmtfp: fplace=%d zpadlen=%d\\n\", fplace, zpadlen);\n#endif\n\n\t/*\n\t * Decimal point.  This should probably use locale to find the correct\n\t * char to print out.\n\t */\n\tif (max > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '.');\n\t\t\n\t\twhile (zpadlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--zpadlen;\n\t\t}\n\n\t\twhile (fplace > 0) {\n\t\t\t--fplace;\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, fconvert[fplace]);\n\t\t}\n\t}\n\n\twhile (padlen < 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++padlen;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "my_modf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
    "lines": "665-699",
    "snippet": "static double my_modf(double x0, double *iptr)\n{\n\tint i;\n\tlong l;\n\tdouble x = x0;\n\tdouble f = 1.0;\n\n\tfor (i=0;i<100;i++) {\n\t\tl = (long)x;\n\t\tif (l <= (x+1) && l >= (x-1)) break;\n\t\tx *= 0.1;\n\t\tf *= 10.0;\n\t}\n\n\tif (i == 100) {\n\t\t/*\n\t\t * yikes! the number is beyond what we can handle.\n\t\t * What do we do?\n\t\t */\n\t\t(*iptr) = 0;\n\t\treturn 0;\n\t}\n\n\tif (i != 0) {\n\t\tdouble i2;\n\t\tdouble ret;\n\n\t\tret = my_modf(x0-l*f, &i2);\n\t\t(*iptr) = l*f + i2;\n\t\treturn ret;\n\t} \n\n\t(*iptr) = l;\n\treturn x - (*iptr);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "my_modf",
          "args": [
            "x0-l*f",
            "&i2"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "my_modf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "665-699",
          "snippet": "static double my_modf(double x0, double *iptr)\n{\n\tint i;\n\tlong l;\n\tdouble x = x0;\n\tdouble f = 1.0;\n\n\tfor (i=0;i<100;i++) {\n\t\tl = (long)x;\n\t\tif (l <= (x+1) && l >= (x-1)) break;\n\t\tx *= 0.1;\n\t\tf *= 10.0;\n\t}\n\n\tif (i == 100) {\n\t\t/*\n\t\t * yikes! the number is beyond what we can handle.\n\t\t * What do we do?\n\t\t */\n\t\t(*iptr) = 0;\n\t\treturn 0;\n\t}\n\n\tif (i != 0) {\n\t\tdouble i2;\n\t\tdouble ret;\n\n\t\tret = my_modf(x0-l*f, &i2);\n\t\t(*iptr) = l*f + i2;\n\t\treturn ret;\n\t} \n\n\t(*iptr) = l;\n\treturn x - (*iptr);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nstatic double my_modf(double x0, double *iptr)\n{\n\tint i;\n\tlong l;\n\tdouble x = x0;\n\tdouble f = 1.0;\n\n\tfor (i=0;i<100;i++) {\n\t\tl = (long)x;\n\t\tif (l <= (x+1) && l >= (x-1)) break;\n\t\tx *= 0.1;\n\t\tf *= 10.0;\n\t}\n\n\tif (i == 100) {\n\t\t/*\n\t\t * yikes! the number is beyond what we can handle.\n\t\t * What do we do?\n\t\t */\n\t\t(*iptr) = 0;\n\t\treturn 0;\n\t}\n\n\tif (i != 0) {\n\t\tdouble i2;\n\t\tdouble ret;\n\n\t\tret = my_modf(x0-l*f, &i2);\n\t\t(*iptr) = l*f + i2;\n\t\treturn ret;\n\t} \n\n\t(*iptr) = l;\n\treturn x - (*iptr);\n}"
  },
  {
    "function_name": "ROUND",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
    "lines": "652-661",
    "snippet": "static LLONG ROUND(LDOUBLE value)\n{\n\tLLONG intpart;\n\n\tintpart = (LLONG)value;\n\tvalue = value - intpart;\n\tif (value >= 0.5) intpart++;\n\t\n\treturn intpart;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nstatic LLONG ROUND(LDOUBLE value)\n{\n\tLLONG intpart;\n\n\tintpart = (LLONG)value;\n\tvalue = value - intpart;\n\tif (value >= 0.5) intpart++;\n\t\n\treturn intpart;\n}"
  },
  {
    "function_name": "POW10",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
    "lines": "640-650",
    "snippet": "static LDOUBLE POW10(int val)\n{\n\tLDOUBLE result = 1;\n\t\n\twhile (val) {\n\t\tresult *= 10;\n\t\tval--;\n\t}\n  \n\treturn result;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nstatic LDOUBLE POW10(int val)\n{\n\tLDOUBLE result = 1;\n\t\n\twhile (val) {\n\t\tresult *= 10;\n\t\tval--;\n\t}\n  \n\treturn result;\n}"
  },
  {
    "function_name": "abs_val",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
    "lines": "630-638",
    "snippet": "static LDOUBLE abs_val(LDOUBLE value)\n{\n\tLDOUBLE result = value;\n\n\tif (value < 0)\n\t\tresult = -value;\n\t\n\treturn result;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nstatic LDOUBLE abs_val(LDOUBLE value)\n{\n\tLDOUBLE result = value;\n\n\tif (value < 0)\n\t\tresult = -value;\n\t\n\treturn result;\n}"
  },
  {
    "function_name": "fmtint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
    "lines": "542-628",
    "snippet": "static int\nfmtint(char *buffer, size_t *currlen, size_t maxlen,\n    intmax_t value, int base, int min, int max, int flags)\n{\n\tint signvalue = 0;\n\tunsigned LLONG uvalue;\n\tchar convert[20];\n\tint place = 0;\n\tint spadlen = 0; /* amount to space pad */\n\tint zpadlen = 0; /* amount to zero pad */\n\tint caps = 0;\n\t\n\tif (max < 0)\n\t\tmax = 0;\n\t\n\tuvalue = value;\n\t\n\tif(!(flags & DP_F_UNSIGNED)) {\n\t\tif( value < 0 ) {\n\t\t\tsignvalue = '-';\n\t\t\tuvalue = -value;\n\t\t} else {\n\t\t\tif (flags & DP_F_PLUS)  /* Do a sign (+/i) */\n\t\t\t\tsignvalue = '+';\n\t\t\telse if (flags & DP_F_SPACE)\n\t\t\t\tsignvalue = ' ';\n\t\t}\n\t}\n  \n\tif (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */\n\n\tdo {\n\t\tconvert[place++] =\n\t\t\t(caps? \"0123456789ABCDEF\":\"0123456789abcdef\")\n\t\t\t[uvalue % (unsigned)base  ];\n\t\tuvalue = (uvalue / (unsigned)base );\n\t} while(uvalue && (place < 20));\n\tif (place == 20) place--;\n\tconvert[place] = 0;\n\n\tzpadlen = max - place;\n\tspadlen = min - MAX (max, place) - (signvalue ? 1 : 0);\n\tif (zpadlen < 0) zpadlen = 0;\n\tif (spadlen < 0) spadlen = 0;\n\tif (flags & DP_F_ZERO) {\n\t\tzpadlen = MAX(zpadlen, spadlen);\n\t\tspadlen = 0;\n\t}\n\tif (flags & DP_F_MINUS) \n\t\tspadlen = -spadlen; /* Left Justifty */\n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"zpad: %d, spad: %d, min: %d, max: %d, place: %d\\n\",\n\t       zpadlen, spadlen, min, max, place);\n#endif\n\n\t/* Spaces */\n\twhile (spadlen > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--spadlen;\n\t}\n\n\t/* Sign */\n\tif (signvalue) \n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\n\t/* Zeros */\n\tif (zpadlen > 0) {\n\t\twhile (zpadlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--zpadlen;\n\t\t}\n\t}\n\n\t/* Digits */\n\twhile (place > 0) {\n\t\t--place;\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, convert[place]);\n\t}\n  \n\t/* Left Justified spaces */\n\twhile (spadlen < 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++spadlen;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define DP_F_UNSIGNED \t(1 << 6)",
      "#define DP_F_UP    \t(1 << 5)",
      "#define DP_F_ZERO  \t(1 << 4)",
      "#define DP_F_SPACE \t(1 << 2)",
      "#define DP_F_PLUS  \t(1 << 1)",
      "#define DP_F_MINUS \t(1 << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "' '"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "convert[place]"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "'0'"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "signvalue"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "' '"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"zpad: %d, spad: %d, min: %d, max: %d, place: %d\\n\"",
            "zpadlen",
            "spadlen",
            "min",
            "max",
            "place"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "zpadlen",
            "spadlen"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "_SPLAY_MINMAX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sys-tree.h",
          "lines": "247-278",
          "snippet": "void name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}",
          "includes": [
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n\nvoid name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\n#define DP_F_UNSIGNED \t(1 << 6)\n#define DP_F_UP    \t(1 << 5)\n#define DP_F_ZERO  \t(1 << 4)\n#define DP_F_SPACE \t(1 << 2)\n#define DP_F_PLUS  \t(1 << 1)\n#define DP_F_MINUS \t(1 << 0)\n\nstatic int\nfmtint(char *buffer, size_t *currlen, size_t maxlen,\n    intmax_t value, int base, int min, int max, int flags)\n{\n\tint signvalue = 0;\n\tunsigned LLONG uvalue;\n\tchar convert[20];\n\tint place = 0;\n\tint spadlen = 0; /* amount to space pad */\n\tint zpadlen = 0; /* amount to zero pad */\n\tint caps = 0;\n\t\n\tif (max < 0)\n\t\tmax = 0;\n\t\n\tuvalue = value;\n\t\n\tif(!(flags & DP_F_UNSIGNED)) {\n\t\tif( value < 0 ) {\n\t\t\tsignvalue = '-';\n\t\t\tuvalue = -value;\n\t\t} else {\n\t\t\tif (flags & DP_F_PLUS)  /* Do a sign (+/i) */\n\t\t\t\tsignvalue = '+';\n\t\t\telse if (flags & DP_F_SPACE)\n\t\t\t\tsignvalue = ' ';\n\t\t}\n\t}\n  \n\tif (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */\n\n\tdo {\n\t\tconvert[place++] =\n\t\t\t(caps? \"0123456789ABCDEF\":\"0123456789abcdef\")\n\t\t\t[uvalue % (unsigned)base  ];\n\t\tuvalue = (uvalue / (unsigned)base );\n\t} while(uvalue && (place < 20));\n\tif (place == 20) place--;\n\tconvert[place] = 0;\n\n\tzpadlen = max - place;\n\tspadlen = min - MAX (max, place) - (signvalue ? 1 : 0);\n\tif (zpadlen < 0) zpadlen = 0;\n\tif (spadlen < 0) spadlen = 0;\n\tif (flags & DP_F_ZERO) {\n\t\tzpadlen = MAX(zpadlen, spadlen);\n\t\tspadlen = 0;\n\t}\n\tif (flags & DP_F_MINUS) \n\t\tspadlen = -spadlen; /* Left Justifty */\n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"zpad: %d, spad: %d, min: %d, max: %d, place: %d\\n\",\n\t       zpadlen, spadlen, min, max, place);\n#endif\n\n\t/* Spaces */\n\twhile (spadlen > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--spadlen;\n\t}\n\n\t/* Sign */\n\tif (signvalue) \n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\n\t/* Zeros */\n\tif (zpadlen > 0) {\n\t\twhile (zpadlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--zpadlen;\n\t\t}\n\t}\n\n\t/* Digits */\n\twhile (place > 0) {\n\t\t--place;\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, convert[place]);\n\t}\n  \n\t/* Left Justified spaces */\n\twhile (spadlen < 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++spadlen;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fmtstr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
    "lines": "501-538",
    "snippet": "static int\nfmtstr(char *buffer, size_t *currlen, size_t maxlen,\n    char *value, int flags, int min, int max)\n{\n\tint padlen, strln;     /* amount to pad */\n\tint cnt = 0;\n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"fmtstr min=%d max=%d s=[%s]\\n\", min, max, value);\n#endif\n\tif (value == 0) {\n\t\tvalue = \"<NULL>\";\n\t}\n\n\tfor (strln = 0; strln < max && value[strln]; ++strln); /* strlen */\n\tpadlen = min - strln;\n\tif (padlen < 0) \n\t\tpadlen = 0;\n\tif (flags & DP_F_MINUS) \n\t\tpadlen = -padlen; /* Left Justify */\n\t\n\twhile ((padlen > 0) && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--padlen;\n\t\t++cnt;\n\t}\n\twhile (*value && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, *value);\n\t\tvalue++;\n\t\t++cnt;\n\t}\n\twhile ((padlen < 0) && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++padlen;\n\t\t++cnt;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define DP_F_MINUS \t(1 << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "' '"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "*value"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "*currlen",
            "maxlen",
            "' '"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"fmtstr min=%d max=%d s=[%s]\\n\"",
            "min",
            "max",
            "value"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\n#define DP_F_MINUS \t(1 << 0)\n\nstatic int\nfmtstr(char *buffer, size_t *currlen, size_t maxlen,\n    char *value, int flags, int min, int max)\n{\n\tint padlen, strln;     /* amount to pad */\n\tint cnt = 0;\n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"fmtstr min=%d max=%d s=[%s]\\n\", min, max, value);\n#endif\n\tif (value == 0) {\n\t\tvalue = \"<NULL>\";\n\t}\n\n\tfor (strln = 0; strln < max && value[strln]; ++strln); /* strlen */\n\tpadlen = min - strln;\n\tif (padlen < 0) \n\t\tpadlen = 0;\n\tif (flags & DP_F_MINUS) \n\t\tpadlen = -padlen; /* Left Justify */\n\t\n\twhile ((padlen > 0) && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--padlen;\n\t\t++cnt;\n\t}\n\twhile (*value && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, *value);\n\t\tvalue++;\n\t\t++cnt;\n\t}\n\twhile ((padlen < 0) && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++padlen;\n\t\t++cnt;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dopr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
    "lines": "179-499",
    "snippet": "static int\ndopr(char *buffer, size_t maxlen, const char *format, va_list args_in)\n{\n\tchar ch;\n\tintmax_t value;\n\tLDOUBLE fvalue;\n\tchar *strvalue;\n\tint min;\n\tint max;\n\tint state;\n\tint flags;\n\tint cflags;\n\tsize_t currlen;\n\tva_list args;\n\n\tVA_COPY(args, args_in);\n\t\n\tstate = DP_S_DEFAULT;\n\tcurrlen = flags = cflags = min = 0;\n\tmax = -1;\n\tch = *format++;\n\t\n\twhile (state != DP_S_DONE) {\n\t\tif (ch == '\\0') \n\t\t\tstate = DP_S_DONE;\n\n\t\tswitch(state) {\n\t\tcase DP_S_DEFAULT:\n\t\t\tif (ch == '%') \n\t\t\t\tstate = DP_S_FLAGS;\n\t\t\telse\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen, ch);\n\t\t\tch = *format++;\n\t\t\tbreak;\n\t\tcase DP_S_FLAGS:\n\t\t\tswitch (ch) {\n\t\t\tcase '-':\n\t\t\t\tflags |= DP_F_MINUS;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tflags |= DP_F_PLUS;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tflags |= DP_F_SPACE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tflags |= DP_F_NUM;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\t\tflags |= DP_F_ZERO;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstate = DP_S_MIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MIN:\n\t\t\tif (isdigit((unsigned char)ch)) {\n\t\t\t\tmin = 10*min + char_to_int (ch);\n\t\t\t\tch = *format++;\n\t\t\t} else if (ch == '*') {\n\t\t\t\tmin = va_arg (args, int);\n\t\t\t\tch = *format++;\n\t\t\t\tstate = DP_S_DOT;\n\t\t\t} else {\n\t\t\t\tstate = DP_S_DOT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_DOT:\n\t\t\tif (ch == '.') {\n\t\t\t\tstate = DP_S_MAX;\n\t\t\t\tch = *format++;\n\t\t\t} else { \n\t\t\t\tstate = DP_S_MOD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MAX:\n\t\t\tif (isdigit((unsigned char)ch)) {\n\t\t\t\tif (max < 0)\n\t\t\t\t\tmax = 0;\n\t\t\t\tmax = 10*max + char_to_int (ch);\n\t\t\t\tch = *format++;\n\t\t\t} else if (ch == '*') {\n\t\t\t\tmax = va_arg (args, int);\n\t\t\t\tch = *format++;\n\t\t\t\tstate = DP_S_MOD;\n\t\t\t} else {\n\t\t\t\tstate = DP_S_MOD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MOD:\n\t\t\tswitch (ch) {\n\t\t\tcase 'h':\n\t\t\t\tcflags = DP_C_SHORT;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'j':\n\t\t\t\tcflags = DP_C_INTMAX;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tcflags = DP_C_LONG;\n\t\t\t\tch = *format++;\n\t\t\t\tif (ch == 'l') {\t/* It's a long long */\n\t\t\t\t\tcflags = DP_C_LLONG;\n\t\t\t\t\tch = *format++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tcflags = DP_C_LDOUBLE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tcflags = DP_C_SIZE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstate = DP_S_CONV;\n\t\t\tbreak;\n\t\tcase DP_S_CONV:\n\t\t\tswitch (ch) {\n\t\t\tcase 'd':\n\t\t\tcase 'i':\n\t\t\t\tif (cflags == DP_C_SHORT) \n\t\t\t\t\tvalue = va_arg (args, int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = va_arg (args, long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = va_arg (args, LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, ssize_t);\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, intmax_t);\n\t\t\t\telse\n\t\t\t\t\tvalue = va_arg (args, int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen,\n\t\t\t\t    value, 10, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    8, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (LLONG)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    10, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'x':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (LLONG)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    16, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'e':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'G':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'g':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen,\n\t\t\t\t    va_arg (args, int));\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tstrvalue = va_arg (args, char *);\n\t\t\t\tif (!strvalue) strvalue = \"(NULL)\";\n\t\t\t\tif (max == -1) {\n\t\t\t\t\tmax = strlen(strvalue);\n\t\t\t\t}\n\t\t\t\tif (min > 0 && max >= 0 && min > max) max = min;\n\t\t\t\tif (fmtstr(buffer, &currlen, maxlen,\n\t\t\t\t    strvalue, flags, min, max) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tstrvalue = va_arg (args, void *);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen,\n\t\t\t\t    (long) strvalue, 16, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n#if we_dont_want_this_in_openssh\n\t\t\tcase 'n':\n\t\t\t\tif (cflags == DP_C_SHORT) {\n\t\t\t\t\tshort int *num;\n\t\t\t\t\tnum = va_arg (args, short int *);\n\t\t\t\t\t*num = currlen;\n\t\t\t\t} else if (cflags == DP_C_LONG) {\n\t\t\t\t\tlong int *num;\n\t\t\t\t\tnum = va_arg (args, long int *);\n\t\t\t\t\t*num = (long int)currlen;\n\t\t\t\t} else if (cflags == DP_C_LLONG) {\n\t\t\t\t\tLLONG *num;\n\t\t\t\t\tnum = va_arg (args, LLONG *);\n\t\t\t\t\t*num = (LLONG)currlen;\n\t\t\t\t} else if (cflags == DP_C_SIZE) {\n\t\t\t\t\tssize_t *num;\n\t\t\t\t\tnum = va_arg (args, ssize_t *);\n\t\t\t\t\t*num = (ssize_t)currlen;\n\t\t\t\t} else if (cflags == DP_C_INTMAX) {\n\t\t\t\t\tintmax_t *num;\n\t\t\t\t\tnum = va_arg (args, intmax_t *);\n\t\t\t\t\t*num = (intmax_t)currlen;\n\t\t\t\t} else {\n\t\t\t\t\tint *num;\n\t\t\t\t\tnum = va_arg (args, int *);\n\t\t\t\t\t*num = currlen;\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\t\t\tcase '%':\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen, ch);\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\t/* not supported yet, treat as next char */\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Unknown, skip */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tch = *format++;\n\t\t\tstate = DP_S_DEFAULT;\n\t\t\tflags = cflags = min = 0;\n\t\t\tmax = -1;\n\t\t\tbreak;\n\t\tcase DP_S_DONE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* hmm? */\n\t\t\tbreak; /* some picky compilers need this */\n\t\t}\n\t}\n\tif (maxlen != 0) {\n\t\tif (currlen < maxlen - 1) \n\t\t\tbuffer[currlen] = '\\0';\n\t\telse if (maxlen > 0) \n\t\t\tbuffer[maxlen - 1] = '\\0';\n\t}\n\t\n\treturn currlen < INT_MAX ? (int)currlen : -1;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define DP_C_INTMAX  6",
      "#define DP_C_SIZE    5",
      "#define DP_C_LLONG   4",
      "#define DP_C_LDOUBLE 3",
      "#define DP_C_LONG    2",
      "#define DP_C_SHORT   1",
      "#define DP_F_UNSIGNED \t(1 << 6)",
      "#define DP_F_UP    \t(1 << 5)",
      "#define DP_F_ZERO  \t(1 << 4)",
      "#define DP_F_NUM   \t(1 << 3)",
      "#define DP_F_SPACE \t(1 << 2)",
      "#define DP_F_PLUS  \t(1 << 1)",
      "#define DP_F_MINUS \t(1 << 0)",
      "#define DP_S_DONE    7",
      "#define DP_S_CONV    6",
      "#define DP_S_MOD     5",
      "#define DP_S_MAX     4",
      "#define DP_S_DOT     3",
      "#define DP_S_MIN     2",
      "#define DP_S_FLAGS   1",
      "#define DP_S_DEFAULT 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "currlen",
            "maxlen",
            "ch"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "int*"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "intmax_t*"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "ssize_t*"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "LLONG*"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "longint *"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "shortint *"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmtint",
          "args": [
            "buffer",
            "&currlen",
            "maxlen",
            "(long) strvalue",
            "16",
            "min",
            "max",
            "flags"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "fmtint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "542-628",
          "snippet": "static int\nfmtint(char *buffer, size_t *currlen, size_t maxlen,\n    intmax_t value, int base, int min, int max, int flags)\n{\n\tint signvalue = 0;\n\tunsigned LLONG uvalue;\n\tchar convert[20];\n\tint place = 0;\n\tint spadlen = 0; /* amount to space pad */\n\tint zpadlen = 0; /* amount to zero pad */\n\tint caps = 0;\n\t\n\tif (max < 0)\n\t\tmax = 0;\n\t\n\tuvalue = value;\n\t\n\tif(!(flags & DP_F_UNSIGNED)) {\n\t\tif( value < 0 ) {\n\t\t\tsignvalue = '-';\n\t\t\tuvalue = -value;\n\t\t} else {\n\t\t\tif (flags & DP_F_PLUS)  /* Do a sign (+/i) */\n\t\t\t\tsignvalue = '+';\n\t\t\telse if (flags & DP_F_SPACE)\n\t\t\t\tsignvalue = ' ';\n\t\t}\n\t}\n  \n\tif (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */\n\n\tdo {\n\t\tconvert[place++] =\n\t\t\t(caps? \"0123456789ABCDEF\":\"0123456789abcdef\")\n\t\t\t[uvalue % (unsigned)base  ];\n\t\tuvalue = (uvalue / (unsigned)base );\n\t} while(uvalue && (place < 20));\n\tif (place == 20) place--;\n\tconvert[place] = 0;\n\n\tzpadlen = max - place;\n\tspadlen = min - MAX (max, place) - (signvalue ? 1 : 0);\n\tif (zpadlen < 0) zpadlen = 0;\n\tif (spadlen < 0) spadlen = 0;\n\tif (flags & DP_F_ZERO) {\n\t\tzpadlen = MAX(zpadlen, spadlen);\n\t\tspadlen = 0;\n\t}\n\tif (flags & DP_F_MINUS) \n\t\tspadlen = -spadlen; /* Left Justifty */\n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"zpad: %d, spad: %d, min: %d, max: %d, place: %d\\n\",\n\t       zpadlen, spadlen, min, max, place);\n#endif\n\n\t/* Spaces */\n\twhile (spadlen > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--spadlen;\n\t}\n\n\t/* Sign */\n\tif (signvalue) \n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\n\t/* Zeros */\n\tif (zpadlen > 0) {\n\t\twhile (zpadlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--zpadlen;\n\t\t}\n\t}\n\n\t/* Digits */\n\twhile (place > 0) {\n\t\t--place;\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, convert[place]);\n\t}\n  \n\t/* Left Justified spaces */\n\twhile (spadlen < 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++spadlen;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define DP_F_UNSIGNED \t(1 << 6)",
            "#define DP_F_UP    \t(1 << 5)",
            "#define DP_F_ZERO  \t(1 << 4)",
            "#define DP_F_SPACE \t(1 << 2)",
            "#define DP_F_PLUS  \t(1 << 1)",
            "#define DP_F_MINUS \t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\n#define DP_F_UNSIGNED \t(1 << 6)\n#define DP_F_UP    \t(1 << 5)\n#define DP_F_ZERO  \t(1 << 4)\n#define DP_F_SPACE \t(1 << 2)\n#define DP_F_PLUS  \t(1 << 1)\n#define DP_F_MINUS \t(1 << 0)\n\nstatic int\nfmtint(char *buffer, size_t *currlen, size_t maxlen,\n    intmax_t value, int base, int min, int max, int flags)\n{\n\tint signvalue = 0;\n\tunsigned LLONG uvalue;\n\tchar convert[20];\n\tint place = 0;\n\tint spadlen = 0; /* amount to space pad */\n\tint zpadlen = 0; /* amount to zero pad */\n\tint caps = 0;\n\t\n\tif (max < 0)\n\t\tmax = 0;\n\t\n\tuvalue = value;\n\t\n\tif(!(flags & DP_F_UNSIGNED)) {\n\t\tif( value < 0 ) {\n\t\t\tsignvalue = '-';\n\t\t\tuvalue = -value;\n\t\t} else {\n\t\t\tif (flags & DP_F_PLUS)  /* Do a sign (+/i) */\n\t\t\t\tsignvalue = '+';\n\t\t\telse if (flags & DP_F_SPACE)\n\t\t\t\tsignvalue = ' ';\n\t\t}\n\t}\n  \n\tif (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */\n\n\tdo {\n\t\tconvert[place++] =\n\t\t\t(caps? \"0123456789ABCDEF\":\"0123456789abcdef\")\n\t\t\t[uvalue % (unsigned)base  ];\n\t\tuvalue = (uvalue / (unsigned)base );\n\t} while(uvalue && (place < 20));\n\tif (place == 20) place--;\n\tconvert[place] = 0;\n\n\tzpadlen = max - place;\n\tspadlen = min - MAX (max, place) - (signvalue ? 1 : 0);\n\tif (zpadlen < 0) zpadlen = 0;\n\tif (spadlen < 0) spadlen = 0;\n\tif (flags & DP_F_ZERO) {\n\t\tzpadlen = MAX(zpadlen, spadlen);\n\t\tspadlen = 0;\n\t}\n\tif (flags & DP_F_MINUS) \n\t\tspadlen = -spadlen; /* Left Justifty */\n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"zpad: %d, spad: %d, min: %d, max: %d, place: %d\\n\",\n\t       zpadlen, spadlen, min, max, place);\n#endif\n\n\t/* Spaces */\n\twhile (spadlen > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--spadlen;\n\t}\n\n\t/* Sign */\n\tif (signvalue) \n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\n\t/* Zeros */\n\tif (zpadlen > 0) {\n\t\twhile (zpadlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--zpadlen;\n\t\t}\n\t}\n\n\t/* Digits */\n\twhile (place > 0) {\n\t\t--place;\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, convert[place]);\n\t}\n  \n\t/* Left Justified spaces */\n\twhile (spadlen < 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++spadlen;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "void*"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmtstr",
          "args": [
            "buffer",
            "&currlen",
            "maxlen",
            "strvalue",
            "flags",
            "min",
            "max"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "fmtstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "501-538",
          "snippet": "static int\nfmtstr(char *buffer, size_t *currlen, size_t maxlen,\n    char *value, int flags, int min, int max)\n{\n\tint padlen, strln;     /* amount to pad */\n\tint cnt = 0;\n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"fmtstr min=%d max=%d s=[%s]\\n\", min, max, value);\n#endif\n\tif (value == 0) {\n\t\tvalue = \"<NULL>\";\n\t}\n\n\tfor (strln = 0; strln < max && value[strln]; ++strln); /* strlen */\n\tpadlen = min - strln;\n\tif (padlen < 0) \n\t\tpadlen = 0;\n\tif (flags & DP_F_MINUS) \n\t\tpadlen = -padlen; /* Left Justify */\n\t\n\twhile ((padlen > 0) && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--padlen;\n\t\t++cnt;\n\t}\n\twhile (*value && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, *value);\n\t\tvalue++;\n\t\t++cnt;\n\t}\n\twhile ((padlen < 0) && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++padlen;\n\t\t++cnt;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define DP_F_MINUS \t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\n#define DP_F_MINUS \t(1 << 0)\n\nstatic int\nfmtstr(char *buffer, size_t *currlen, size_t maxlen,\n    char *value, int flags, int min, int max)\n{\n\tint padlen, strln;     /* amount to pad */\n\tint cnt = 0;\n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"fmtstr min=%d max=%d s=[%s]\\n\", min, max, value);\n#endif\n\tif (value == 0) {\n\t\tvalue = \"<NULL>\";\n\t}\n\n\tfor (strln = 0; strln < max && value[strln]; ++strln); /* strlen */\n\tpadlen = min - strln;\n\tif (padlen < 0) \n\t\tpadlen = 0;\n\tif (flags & DP_F_MINUS) \n\t\tpadlen = -padlen; /* Left Justify */\n\t\n\twhile ((padlen > 0) && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--padlen;\n\t\t++cnt;\n\t}\n\twhile (*value && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, *value);\n\t\tvalue++;\n\t\t++cnt;\n\t}\n\twhile ((padlen < 0) && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++padlen;\n\t\t++cnt;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "strvalue"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "char*"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "currlen",
            "maxlen",
            "va_arg (args, int)"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "int"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmtfp",
          "args": [
            "buffer",
            "&currlen",
            "maxlen",
            "fvalue",
            "min",
            "max",
            "flags"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "fmtfp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "702-857",
          "snippet": "static int\nfmtfp (char *buffer, size_t *currlen, size_t maxlen,\n    LDOUBLE fvalue, int min, int max, int flags)\n{\n\tint signvalue = 0;\n\tdouble ufvalue;\n\tchar iconvert[311];\n\tchar fconvert[311];\n\tint iplace = 0;\n\tint fplace = 0;\n\tint padlen = 0; /* amount to pad */\n\tint zpadlen = 0; \n\tint caps = 0;\n\tint idx;\n\tdouble intpart;\n\tdouble fracpart;\n\tdouble temp;\n  \n\t/* \n\t * AIX manpage says the default is 0, but Solaris says the default\n\t * is 6, and sprintf on AIX defaults to 6\n\t */\n\tif (max < 0)\n\t\tmax = 6;\n\n\tufvalue = abs_val (fvalue);\n\n\tif (fvalue < 0) {\n\t\tsignvalue = '-';\n\t} else {\n\t\tif (flags & DP_F_PLUS) { /* Do a sign (+/i) */\n\t\t\tsignvalue = '+';\n\t\t} else {\n\t\t\tif (flags & DP_F_SPACE)\n\t\t\t\tsignvalue = ' ';\n\t\t}\n\t}\n\n#if 0\n\tif (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */\n#endif\n\n#if 0\n\t if (max == 0) ufvalue += 0.5; /* if max = 0 we must round */\n#endif\n\n\t/* \n\t * Sorry, we only support 16 digits past the decimal because of our \n\t * conversion method\n\t */\n\tif (max > 16)\n\t\tmax = 16;\n\n\t/* We \"cheat\" by converting the fractional part to integer by\n\t * multiplying by a factor of 10\n\t */\n\n\ttemp = ufvalue;\n\tmy_modf(temp, &intpart);\n\n\tfracpart = ROUND((POW10(max)) * (ufvalue - intpart));\n\t\n\tif (fracpart >= POW10(max)) {\n\t\tintpart++;\n\t\tfracpart -= POW10(max);\n\t}\n\n\t/* Convert integer part */\n\tdo {\n\t\ttemp = intpart*0.1;\n\t\tmy_modf(temp, &intpart);\n\t\tidx = (int) ((temp -intpart +0.05)* 10.0);\n\t\t/* idx = (int) (((double)(temp*0.1) -intpart +0.05) *10.0); */\n\t\t/* printf (\"%llf, %f, %x\\n\", temp, intpart, idx); */\n\t\ticonvert[iplace++] =\n\t\t\t(caps? \"0123456789ABCDEF\":\"0123456789abcdef\")[idx];\n\t} while (intpart && (iplace < 311));\n\tif (iplace == 311) iplace--;\n\ticonvert[iplace] = 0;\n\n\t/* Convert fractional part */\n\tif (fracpart)\n\t{\n\t\tdo {\n\t\t\ttemp = fracpart*0.1;\n\t\t\tmy_modf(temp, &fracpart);\n\t\t\tidx = (int) ((temp -fracpart +0.05)* 10.0);\n\t\t\t/* idx = (int) ((((temp/10) -fracpart) +0.05) *10); */\n\t\t\t/* printf (\"%lf, %lf, %ld\\n\", temp, fracpart, idx ); */\n\t\t\tfconvert[fplace++] =\n\t\t\t(caps? \"0123456789ABCDEF\":\"0123456789abcdef\")[idx];\n\t\t} while(fracpart && (fplace < 311));\n\t\tif (fplace == 311) fplace--;\n\t}\n\tfconvert[fplace] = 0;\n  \n\t/* -1 for decimal point, another -1 if we are printing a sign */\n\tpadlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0); \n\tzpadlen = max - fplace;\n\tif (zpadlen < 0) zpadlen = 0;\n\tif (padlen < 0) \n\t\tpadlen = 0;\n\tif (flags & DP_F_MINUS) \n\t\tpadlen = -padlen; /* Left Justifty */\n\t\n\tif ((flags & DP_F_ZERO) && (padlen > 0)) {\n\t\tif (signvalue) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\t\t\t--padlen;\n\t\t\tsignvalue = 0;\n\t\t}\n\t\twhile (padlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--padlen;\n\t\t}\n\t}\n\twhile (padlen > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--padlen;\n\t}\n\tif (signvalue) \n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\t\n\twhile (iplace > 0) {\n\t\t--iplace;\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, iconvert[iplace]);\n\t}\n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"fmtfp: fplace=%d zpadlen=%d\\n\", fplace, zpadlen);\n#endif\n\n\t/*\n\t * Decimal point.  This should probably use locale to find the correct\n\t * char to print out.\n\t */\n\tif (max > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '.');\n\t\t\n\t\twhile (zpadlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--zpadlen;\n\t\t}\n\n\t\twhile (fplace > 0) {\n\t\t\t--fplace;\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, fconvert[fplace]);\n\t\t}\n\t}\n\n\twhile (padlen < 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++padlen;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define DP_F_UP    \t(1 << 5)",
            "#define DP_F_ZERO  \t(1 << 4)",
            "#define DP_F_SPACE \t(1 << 2)",
            "#define DP_F_PLUS  \t(1 << 1)",
            "#define DP_F_MINUS \t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\n#define DP_F_UP    \t(1 << 5)\n#define DP_F_ZERO  \t(1 << 4)\n#define DP_F_SPACE \t(1 << 2)\n#define DP_F_PLUS  \t(1 << 1)\n#define DP_F_MINUS \t(1 << 0)\n\nstatic int\nfmtfp (char *buffer, size_t *currlen, size_t maxlen,\n    LDOUBLE fvalue, int min, int max, int flags)\n{\n\tint signvalue = 0;\n\tdouble ufvalue;\n\tchar iconvert[311];\n\tchar fconvert[311];\n\tint iplace = 0;\n\tint fplace = 0;\n\tint padlen = 0; /* amount to pad */\n\tint zpadlen = 0; \n\tint caps = 0;\n\tint idx;\n\tdouble intpart;\n\tdouble fracpart;\n\tdouble temp;\n  \n\t/* \n\t * AIX manpage says the default is 0, but Solaris says the default\n\t * is 6, and sprintf on AIX defaults to 6\n\t */\n\tif (max < 0)\n\t\tmax = 6;\n\n\tufvalue = abs_val (fvalue);\n\n\tif (fvalue < 0) {\n\t\tsignvalue = '-';\n\t} else {\n\t\tif (flags & DP_F_PLUS) { /* Do a sign (+/i) */\n\t\t\tsignvalue = '+';\n\t\t} else {\n\t\t\tif (flags & DP_F_SPACE)\n\t\t\t\tsignvalue = ' ';\n\t\t}\n\t}\n\n#if 0\n\tif (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */\n#endif\n\n#if 0\n\t if (max == 0) ufvalue += 0.5; /* if max = 0 we must round */\n#endif\n\n\t/* \n\t * Sorry, we only support 16 digits past the decimal because of our \n\t * conversion method\n\t */\n\tif (max > 16)\n\t\tmax = 16;\n\n\t/* We \"cheat\" by converting the fractional part to integer by\n\t * multiplying by a factor of 10\n\t */\n\n\ttemp = ufvalue;\n\tmy_modf(temp, &intpart);\n\n\tfracpart = ROUND((POW10(max)) * (ufvalue - intpart));\n\t\n\tif (fracpart >= POW10(max)) {\n\t\tintpart++;\n\t\tfracpart -= POW10(max);\n\t}\n\n\t/* Convert integer part */\n\tdo {\n\t\ttemp = intpart*0.1;\n\t\tmy_modf(temp, &intpart);\n\t\tidx = (int) ((temp -intpart +0.05)* 10.0);\n\t\t/* idx = (int) (((double)(temp*0.1) -intpart +0.05) *10.0); */\n\t\t/* printf (\"%llf, %f, %x\\n\", temp, intpart, idx); */\n\t\ticonvert[iplace++] =\n\t\t\t(caps? \"0123456789ABCDEF\":\"0123456789abcdef\")[idx];\n\t} while (intpart && (iplace < 311));\n\tif (iplace == 311) iplace--;\n\ticonvert[iplace] = 0;\n\n\t/* Convert fractional part */\n\tif (fracpart)\n\t{\n\t\tdo {\n\t\t\ttemp = fracpart*0.1;\n\t\t\tmy_modf(temp, &fracpart);\n\t\t\tidx = (int) ((temp -fracpart +0.05)* 10.0);\n\t\t\t/* idx = (int) ((((temp/10) -fracpart) +0.05) *10); */\n\t\t\t/* printf (\"%lf, %lf, %ld\\n\", temp, fracpart, idx ); */\n\t\t\tfconvert[fplace++] =\n\t\t\t(caps? \"0123456789ABCDEF\":\"0123456789abcdef\")[idx];\n\t\t} while(fracpart && (fplace < 311));\n\t\tif (fplace == 311) fplace--;\n\t}\n\tfconvert[fplace] = 0;\n  \n\t/* -1 for decimal point, another -1 if we are printing a sign */\n\tpadlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0); \n\tzpadlen = max - fplace;\n\tif (zpadlen < 0) zpadlen = 0;\n\tif (padlen < 0) \n\t\tpadlen = 0;\n\tif (flags & DP_F_MINUS) \n\t\tpadlen = -padlen; /* Left Justifty */\n\t\n\tif ((flags & DP_F_ZERO) && (padlen > 0)) {\n\t\tif (signvalue) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\t\t\t--padlen;\n\t\t\tsignvalue = 0;\n\t\t}\n\t\twhile (padlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--padlen;\n\t\t}\n\t}\n\twhile (padlen > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--padlen;\n\t}\n\tif (signvalue) \n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\t\n\twhile (iplace > 0) {\n\t\t--iplace;\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, iconvert[iplace]);\n\t}\n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"fmtfp: fplace=%d zpadlen=%d\\n\", fplace, zpadlen);\n#endif\n\n\t/*\n\t * Decimal point.  This should probably use locale to find the correct\n\t * char to print out.\n\t */\n\tif (max > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '.');\n\t\t\n\t\twhile (zpadlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--zpadlen;\n\t\t}\n\n\t\twhile (fplace > 0) {\n\t\t\t--fplace;\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, fconvert[fplace]);\n\t\t}\n\t}\n\n\twhile (padlen < 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++padlen;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "double"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "LDOUBLE"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "double"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "LDOUBLE"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "double"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "LDOUBLE"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "unsignedint"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "uintmax_t"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "size_t"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "unsignedLLONG"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "unsignedlong int"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "unsignedint"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "unsignedint"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "uintmax_t"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "size_t"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "unsignedLLONG"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "unsignedlong int"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "unsignedint"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "unsignedint"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "uintmax_t"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "size_t"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "unsignedLLONG"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "unsignedlong int"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "unsignedint"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "int"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "intmax_t"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "ssize_t"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "LLONG"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "longint"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "int"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "int"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "char_to_int",
          "args": [
            "ch"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char)ch"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "int"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "char_to_int",
          "args": [
            "ch"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char)ch"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOPR_OUTCH",
          "args": [
            "buffer",
            "currlen",
            "maxlen",
            "ch"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VA_COPY",
          "args": [
            "args",
            "args_in"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\n#define DP_C_INTMAX  6\n#define DP_C_SIZE    5\n#define DP_C_LLONG   4\n#define DP_C_LDOUBLE 3\n#define DP_C_LONG    2\n#define DP_C_SHORT   1\n#define DP_F_UNSIGNED \t(1 << 6)\n#define DP_F_UP    \t(1 << 5)\n#define DP_F_ZERO  \t(1 << 4)\n#define DP_F_NUM   \t(1 << 3)\n#define DP_F_SPACE \t(1 << 2)\n#define DP_F_PLUS  \t(1 << 1)\n#define DP_F_MINUS \t(1 << 0)\n#define DP_S_DONE    7\n#define DP_S_CONV    6\n#define DP_S_MOD     5\n#define DP_S_MAX     4\n#define DP_S_DOT     3\n#define DP_S_MIN     2\n#define DP_S_FLAGS   1\n#define DP_S_DEFAULT 0\n\nstatic int\ndopr(char *buffer, size_t maxlen, const char *format, va_list args_in)\n{\n\tchar ch;\n\tintmax_t value;\n\tLDOUBLE fvalue;\n\tchar *strvalue;\n\tint min;\n\tint max;\n\tint state;\n\tint flags;\n\tint cflags;\n\tsize_t currlen;\n\tva_list args;\n\n\tVA_COPY(args, args_in);\n\t\n\tstate = DP_S_DEFAULT;\n\tcurrlen = flags = cflags = min = 0;\n\tmax = -1;\n\tch = *format++;\n\t\n\twhile (state != DP_S_DONE) {\n\t\tif (ch == '\\0') \n\t\t\tstate = DP_S_DONE;\n\n\t\tswitch(state) {\n\t\tcase DP_S_DEFAULT:\n\t\t\tif (ch == '%') \n\t\t\t\tstate = DP_S_FLAGS;\n\t\t\telse\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen, ch);\n\t\t\tch = *format++;\n\t\t\tbreak;\n\t\tcase DP_S_FLAGS:\n\t\t\tswitch (ch) {\n\t\t\tcase '-':\n\t\t\t\tflags |= DP_F_MINUS;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tflags |= DP_F_PLUS;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tflags |= DP_F_SPACE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tflags |= DP_F_NUM;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\t\tflags |= DP_F_ZERO;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstate = DP_S_MIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MIN:\n\t\t\tif (isdigit((unsigned char)ch)) {\n\t\t\t\tmin = 10*min + char_to_int (ch);\n\t\t\t\tch = *format++;\n\t\t\t} else if (ch == '*') {\n\t\t\t\tmin = va_arg (args, int);\n\t\t\t\tch = *format++;\n\t\t\t\tstate = DP_S_DOT;\n\t\t\t} else {\n\t\t\t\tstate = DP_S_DOT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_DOT:\n\t\t\tif (ch == '.') {\n\t\t\t\tstate = DP_S_MAX;\n\t\t\t\tch = *format++;\n\t\t\t} else { \n\t\t\t\tstate = DP_S_MOD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MAX:\n\t\t\tif (isdigit((unsigned char)ch)) {\n\t\t\t\tif (max < 0)\n\t\t\t\t\tmax = 0;\n\t\t\t\tmax = 10*max + char_to_int (ch);\n\t\t\t\tch = *format++;\n\t\t\t} else if (ch == '*') {\n\t\t\t\tmax = va_arg (args, int);\n\t\t\t\tch = *format++;\n\t\t\t\tstate = DP_S_MOD;\n\t\t\t} else {\n\t\t\t\tstate = DP_S_MOD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MOD:\n\t\t\tswitch (ch) {\n\t\t\tcase 'h':\n\t\t\t\tcflags = DP_C_SHORT;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'j':\n\t\t\t\tcflags = DP_C_INTMAX;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tcflags = DP_C_LONG;\n\t\t\t\tch = *format++;\n\t\t\t\tif (ch == 'l') {\t/* It's a long long */\n\t\t\t\t\tcflags = DP_C_LLONG;\n\t\t\t\t\tch = *format++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tcflags = DP_C_LDOUBLE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tcflags = DP_C_SIZE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstate = DP_S_CONV;\n\t\t\tbreak;\n\t\tcase DP_S_CONV:\n\t\t\tswitch (ch) {\n\t\t\tcase 'd':\n\t\t\tcase 'i':\n\t\t\t\tif (cflags == DP_C_SHORT) \n\t\t\t\t\tvalue = va_arg (args, int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = va_arg (args, long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = va_arg (args, LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, ssize_t);\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, intmax_t);\n\t\t\t\telse\n\t\t\t\t\tvalue = va_arg (args, int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen,\n\t\t\t\t    value, 10, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    8, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (LLONG)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    10, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'x':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (LLONG)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    16, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'e':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'G':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'g':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen,\n\t\t\t\t    va_arg (args, int));\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tstrvalue = va_arg (args, char *);\n\t\t\t\tif (!strvalue) strvalue = \"(NULL)\";\n\t\t\t\tif (max == -1) {\n\t\t\t\t\tmax = strlen(strvalue);\n\t\t\t\t}\n\t\t\t\tif (min > 0 && max >= 0 && min > max) max = min;\n\t\t\t\tif (fmtstr(buffer, &currlen, maxlen,\n\t\t\t\t    strvalue, flags, min, max) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tstrvalue = va_arg (args, void *);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen,\n\t\t\t\t    (long) strvalue, 16, min, max, flags) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n#if we_dont_want_this_in_openssh\n\t\t\tcase 'n':\n\t\t\t\tif (cflags == DP_C_SHORT) {\n\t\t\t\t\tshort int *num;\n\t\t\t\t\tnum = va_arg (args, short int *);\n\t\t\t\t\t*num = currlen;\n\t\t\t\t} else if (cflags == DP_C_LONG) {\n\t\t\t\t\tlong int *num;\n\t\t\t\t\tnum = va_arg (args, long int *);\n\t\t\t\t\t*num = (long int)currlen;\n\t\t\t\t} else if (cflags == DP_C_LLONG) {\n\t\t\t\t\tLLONG *num;\n\t\t\t\t\tnum = va_arg (args, LLONG *);\n\t\t\t\t\t*num = (LLONG)currlen;\n\t\t\t\t} else if (cflags == DP_C_SIZE) {\n\t\t\t\t\tssize_t *num;\n\t\t\t\t\tnum = va_arg (args, ssize_t *);\n\t\t\t\t\t*num = (ssize_t)currlen;\n\t\t\t\t} else if (cflags == DP_C_INTMAX) {\n\t\t\t\t\tintmax_t *num;\n\t\t\t\t\tnum = va_arg (args, intmax_t *);\n\t\t\t\t\t*num = (intmax_t)currlen;\n\t\t\t\t} else {\n\t\t\t\t\tint *num;\n\t\t\t\t\tnum = va_arg (args, int *);\n\t\t\t\t\t*num = currlen;\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\t\t\tcase '%':\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen, ch);\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\t/* not supported yet, treat as next char */\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Unknown, skip */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tch = *format++;\n\t\t\tstate = DP_S_DEFAULT;\n\t\t\tflags = cflags = min = 0;\n\t\t\tmax = -1;\n\t\t\tbreak;\n\t\tcase DP_S_DONE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* hmm? */\n\t\t\tbreak; /* some picky compilers need this */\n\t\t}\n\t}\n\tif (maxlen != 0) {\n\t\tif (currlen < maxlen - 1) \n\t\t\tbuffer[currlen] = '\\0';\n\t\telse if (maxlen > 0) \n\t\t\tbuffer[maxlen - 1] = '\\0';\n\t}\n\t\n\treturn currlen < INT_MAX ? (int)currlen : -1;\n}"
  }
]