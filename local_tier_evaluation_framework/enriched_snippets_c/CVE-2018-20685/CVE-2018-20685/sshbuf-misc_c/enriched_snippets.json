[
  {
    "function_name": "sshbuf_dup_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
    "lines": "139-160",
    "snippet": "char *\nsshbuf_dup_string(struct sshbuf *buf)\n{\n\tconst u_char *p = NULL, *s = sshbuf_ptr(buf);\n\tsize_t l = sshbuf_len(buf);\n\tchar *r;\n\n\tif (s == NULL || l > SIZE_MAX)\n\t\treturn NULL;\n\t/* accept a nul only as the last character in the buffer */\n\tif (l > 0 && (p = memchr(s, '\\0', l)) != NULL) {\n\t\tif (p != s + l - 1)\n\t\t\treturn NULL;\n\t\tl--; /* the nul is put back below */\n\t}\n\tif ((r = malloc(l + 1)) == NULL)\n\t\treturn NULL;\n\tif (l > 0)\n\t\tmemcpy(r, s, l);\n\tr[l] = '\\0';\n\treturn r;\n}",
    "includes": [
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <ctype.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r",
            "s",
            "l"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "l + 1"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "s",
            "'\\0'",
            "l"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "buf"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "buf"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshbuf_dup_string(struct sshbuf *buf)\n{\n\tconst u_char *p = NULL, *s = sshbuf_ptr(buf);\n\tsize_t l = sshbuf_len(buf);\n\tchar *r;\n\n\tif (s == NULL || l > SIZE_MAX)\n\t\treturn NULL;\n\t/* accept a nul only as the last character in the buffer */\n\tif (l > 0 && (p = memchr(s, '\\0', l)) != NULL) {\n\t\tif (p != s + l - 1)\n\t\t\treturn NULL;\n\t\tl--; /* the nul is put back below */\n\t}\n\tif ((r = malloc(l + 1)) == NULL)\n\t\treturn NULL;\n\tif (l > 0)\n\t\tmemcpy(r, s, l);\n\tr[l] = '\\0';\n\treturn r;\n}"
  },
  {
    "function_name": "sshbuf_b64tod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
    "lines": "113-137",
    "snippet": "int\nsshbuf_b64tod(struct sshbuf *buf, const char *b64)\n{\n\tsize_t plen = strlen(b64);\n\tint nlen, r;\n\tu_char *p;\n\n\tif (plen == 0)\n\t\treturn 0;\n\tif ((p = malloc(plen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((nlen = b64_pton(b64, p, plen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_put(buf, p, nlen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn r;\n\t}\n\texplicit_bzero(p, plen);\n\tfree(p);\n\treturn 0;\n}",
    "includes": [
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <ctype.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "p",
            "plen"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "buf",
            "p",
            "nlen"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "b64_pton",
          "args": [
            "b64",
            "p",
            "plen"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "b64_pton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/base64.c",
          "lines": "196-312",
          "snippet": "int\nb64_pton(char const *src, u_char *target, size_t targsize)\n{\n\tu_int tarindex, state;\n\tint ch;\n\tchar *pos;\n\n\tstate = 0;\n\ttarindex = 0;\n\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (isspace(ch))\t/* Skip whitespace anywhere. */\n\t\t\tcontinue;\n\n\t\tif (ch == Pad64)\n\t\t\tbreak;\n\n\t\tpos = strchr(Base64, ch);\n\t\tif (pos == 0) \t\t/* A non-base64 character. */\n\t\t\treturn (-1);\n\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] = (pos - Base64) << 2;\n\t\t\t}\n\t\t\tstate = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 4;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x0f)\n\t\t\t\t\t\t\t<< 4 ;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 2;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x03)\n\t\t\t\t\t\t\t<< 6;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] |= (pos - Base64);\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * We are done decoding Base-64 chars.  Let's see if we ended\n\t * on a byte boundary, and/or with erroneous trailing characters.\n\t */\n\n\tif (ch == Pad64) {\t\t/* We got a pad char. */\n\t\tch = *src++;\t\t/* Skip it, get next. */\n\t\tswitch (state) {\n\t\tcase 0:\t\t/* Invalid = in first position */\n\t\tcase 1:\t\t/* Invalid = in second position */\n\t\t\treturn (-1);\n\n\t\tcase 2:\t\t/* Valid, means one byte of info */\n\t\t\t/* Skip any number of spaces. */\n\t\t\tfor (; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\tbreak;\n\t\t\t/* Make sure there is another trailing = sign. */\n\t\t\tif (ch != Pad64)\n\t\t\t\treturn (-1);\n\t\t\tch = *src++;\t\t/* Skip the = */\n\t\t\t/* Fall through to \"single trailing =\" case. */\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase 3:\t\t/* Valid, means two bytes of info */\n\t\t\t/*\n\t\t\t * We know this char is an =.  Is there anything but\n\t\t\t * whitespace after it?\n\t\t\t */\n\t\t\tfor (; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\treturn (-1);\n\n\t\t\t/*\n\t\t\t * Now make sure for cases 2 and 3 that the \"extra\"\n\t\t\t * bits that slopped past the last full byte were\n\t\t\t * zeros.  If we don't check them, they become a\n\t\t\t * subliminal channel.\n\t\t\t */\n\t\t\tif (target && target[tarindex] != 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We ended by seeing the end of the string.  Make sure we\n\t\t * have no partial bytes lying around.\n\t\t */\n\t\tif (state != 0)\n\t\t\treturn (-1);\n\t}\n\n\treturn (tarindex);\n}",
          "includes": [
            "#include \"base64.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base64.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nb64_pton(char const *src, u_char *target, size_t targsize)\n{\n\tu_int tarindex, state;\n\tint ch;\n\tchar *pos;\n\n\tstate = 0;\n\ttarindex = 0;\n\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (isspace(ch))\t/* Skip whitespace anywhere. */\n\t\t\tcontinue;\n\n\t\tif (ch == Pad64)\n\t\t\tbreak;\n\n\t\tpos = strchr(Base64, ch);\n\t\tif (pos == 0) \t\t/* A non-base64 character. */\n\t\t\treturn (-1);\n\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] = (pos - Base64) << 2;\n\t\t\t}\n\t\t\tstate = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 4;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x0f)\n\t\t\t\t\t\t\t<< 4 ;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 2;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x03)\n\t\t\t\t\t\t\t<< 6;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] |= (pos - Base64);\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * We are done decoding Base-64 chars.  Let's see if we ended\n\t * on a byte boundary, and/or with erroneous trailing characters.\n\t */\n\n\tif (ch == Pad64) {\t\t/* We got a pad char. */\n\t\tch = *src++;\t\t/* Skip it, get next. */\n\t\tswitch (state) {\n\t\tcase 0:\t\t/* Invalid = in first position */\n\t\tcase 1:\t\t/* Invalid = in second position */\n\t\t\treturn (-1);\n\n\t\tcase 2:\t\t/* Valid, means one byte of info */\n\t\t\t/* Skip any number of spaces. */\n\t\t\tfor (; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\tbreak;\n\t\t\t/* Make sure there is another trailing = sign. */\n\t\t\tif (ch != Pad64)\n\t\t\t\treturn (-1);\n\t\t\tch = *src++;\t\t/* Skip the = */\n\t\t\t/* Fall through to \"single trailing =\" case. */\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase 3:\t\t/* Valid, means two bytes of info */\n\t\t\t/*\n\t\t\t * We know this char is an =.  Is there anything but\n\t\t\t * whitespace after it?\n\t\t\t */\n\t\t\tfor (; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\treturn (-1);\n\n\t\t\t/*\n\t\t\t * Now make sure for cases 2 and 3 that the \"extra\"\n\t\t\t * bits that slopped past the last full byte were\n\t\t\t * zeros.  If we don't check them, they become a\n\t\t\t * subliminal channel.\n\t\t\t */\n\t\t\tif (target && target[tarindex] != 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We ended by seeing the end of the string.  Make sure we\n\t\t * have no partial bytes lying around.\n\t\t */\n\t\tif (state != 0)\n\t\t\treturn (-1);\n\t}\n\n\treturn (tarindex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "plen"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "b64"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_b64tod(struct sshbuf *buf, const char *b64)\n{\n\tsize_t plen = strlen(b64);\n\tint nlen, r;\n\tu_char *p;\n\n\tif (plen == 0)\n\t\treturn 0;\n\tif ((p = malloc(plen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((nlen = b64_pton(b64, p, plen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_put(buf, p, nlen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn r;\n\t}\n\texplicit_bzero(p, plen);\n\tfree(p);\n\treturn 0;\n}"
  },
  {
    "function_name": "sshbuf_dtob64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
    "lines": "92-111",
    "snippet": "char *\nsshbuf_dtob64(struct sshbuf *buf)\n{\n\tsize_t len = sshbuf_len(buf), plen;\n\tconst u_char *p = sshbuf_ptr(buf);\n\tchar *ret;\n\tint r;\n\n\tif (len == 0)\n\t\treturn strdup(\"\");\n\tplen = ((len + 2) / 3) * 4 + 1;\n\tif (SIZE_MAX / 2 <= len || (ret = malloc(plen)) == NULL)\n\t\treturn NULL;\n\tif ((r = b64_ntop(p, len, ret, plen)) == -1) {\n\t\texplicit_bzero(ret, plen);\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <ctype.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ret"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "ret",
            "plen"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "b64_ntop",
          "args": [
            "p",
            "len",
            "ret",
            "plen"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "b64_ntop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/base64.c",
          "lines": "133-185",
          "snippet": "int\nb64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize)\n{\n\tsize_t datalength = 0;\n\tu_char input[3];\n\tu_char output[4];\n\tu_int i;\n\n\twhile (2 < srclength) {\n\t\tinput[0] = *src++;\n\t\tinput[1] = *src++;\n\t\tinput[2] = *src++;\n\t\tsrclength -= 3;\n\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\t\toutput[3] = input[2] & 0x3f;\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Base64[output[3]];\n\t}\n    \n\t/* Now we worry about padding. */\n\tif (0 != srclength) {\n\t\t/* Get what's left. */\n\t\tinput[0] = input[1] = input[2] = '\\0';\n\t\tfor (i = 0; i < srclength; i++)\n\t\t\tinput[i] = *src++;\n\t\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\tif (srclength == 1)\n\t\t\ttarget[datalength++] = Pad64;\n\t\telse\n\t\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Pad64;\n\t}\n\tif (datalength >= targsize)\n\t\treturn (-1);\n\ttarget[datalength] = '\\0';\t/* Returned value doesn't count \\0. */\n\treturn (datalength);\n}",
          "includes": [
            "#include \"base64.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base64.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nb64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize)\n{\n\tsize_t datalength = 0;\n\tu_char input[3];\n\tu_char output[4];\n\tu_int i;\n\n\twhile (2 < srclength) {\n\t\tinput[0] = *src++;\n\t\tinput[1] = *src++;\n\t\tinput[2] = *src++;\n\t\tsrclength -= 3;\n\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\t\toutput[3] = input[2] & 0x3f;\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Base64[output[3]];\n\t}\n    \n\t/* Now we worry about padding. */\n\tif (0 != srclength) {\n\t\t/* Get what's left. */\n\t\tinput[0] = input[1] = input[2] = '\\0';\n\t\tfor (i = 0; i < srclength; i++)\n\t\t\tinput[i] = *src++;\n\t\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\tif (srclength == 1)\n\t\t\ttarget[datalength++] = Pad64;\n\t\telse\n\t\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Pad64;\n\t}\n\tif (datalength >= targsize)\n\t\treturn (-1);\n\ttarget[datalength] = '\\0';\t/* Returned value doesn't count \\0. */\n\treturn (datalength);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "plen"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "buf"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "buf"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshbuf_dtob64(struct sshbuf *buf)\n{\n\tsize_t len = sshbuf_len(buf), plen;\n\tconst u_char *p = sshbuf_ptr(buf);\n\tchar *ret;\n\tint r;\n\n\tif (len == 0)\n\t\treturn strdup(\"\");\n\tplen = ((len + 2) / 3) * 4 + 1;\n\tif (SIZE_MAX / 2 <= len || (ret = malloc(plen)) == NULL)\n\t\treturn NULL;\n\tif ((r = b64_ntop(p, len, ret, plen)) == -1) {\n\t\texplicit_bzero(ret, plen);\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sshbuf_dtob16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
    "lines": "72-90",
    "snippet": "char *\nsshbuf_dtob16(struct sshbuf *buf)\n{\n\tsize_t i, j, len = sshbuf_len(buf);\n\tconst u_char *p = sshbuf_ptr(buf);\n\tchar *ret;\n\tconst char hex[] = \"0123456789abcdef\";\n\n\tif (len == 0)\n\t\treturn strdup(\"\");\n\tif (SIZE_MAX / 2 <= len || (ret = malloc(len * 2 + 1)) == NULL)\n\t\treturn NULL;\n\tfor (i = j = 0; i < len; i++) {\n\t\tret[j++] = hex[(p[i] >> 4) & 0xf];\n\t\tret[j++] = hex[p[i] & 0xf];\n\t}\n\tret[j] = '\\0';\n\treturn ret;\n}",
    "includes": [
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <ctype.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len * 2 + 1"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "buf"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "buf"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshbuf_dtob16(struct sshbuf *buf)\n{\n\tsize_t i, j, len = sshbuf_len(buf);\n\tconst u_char *p = sshbuf_ptr(buf);\n\tchar *ret;\n\tconst char hex[] = \"0123456789abcdef\";\n\n\tif (len == 0)\n\t\treturn strdup(\"\");\n\tif (SIZE_MAX / 2 <= len || (ret = malloc(len * 2 + 1)) == NULL)\n\t\treturn NULL;\n\tfor (i = j = 0; i < len; i++) {\n\t\tret[j++] = hex[(p[i] >> 4) & 0xf];\n\t\tret[j++] = hex[p[i] & 0xf];\n\t}\n\tret[j] = '\\0';\n\treturn ret;\n}"
  },
  {
    "function_name": "sshbuf_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
    "lines": "65-70",
    "snippet": "void\nsshbuf_dump(struct sshbuf *buf, FILE *f)\n{\n\tfprintf(f, \"buffer %p len = %zu\\n\", buf, sshbuf_len(buf));\n\tsshbuf_dump_data(sshbuf_ptr(buf), sshbuf_len(buf), f);\n}",
    "includes": [
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <ctype.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_dump_data",
          "args": [
            "sshbuf_ptr(buf)",
            "sshbuf_len(buf)",
            "f"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_dump_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "38-63",
          "snippet": "void\nsshbuf_dump_data(const void *s, size_t len, FILE *f)\n{\n\tsize_t i, j;\n\tconst u_char *p = (const u_char *)s;\n\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(f, \"%.4zu: \", i);\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len)\n\t\t\t\tfprintf(f, \"%02x \", p[j]);\n\t\t\telse\n\t\t\t\tfprintf(f, \"   \");\n\t\t}\n\t\tfprintf(f, \" \");\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len) {\n\t\t\t\tif  (isascii(p[j]) && isprint(p[j]))\n\t\t\t\t\tfprintf(f, \"%c\", p[j]);\n\t\t\t\telse\n\t\t\t\t\tfprintf(f, \".\");\n\t\t\t}\n\t\t}\n\t\tfprintf(f, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_dump_data(const void *s, size_t len, FILE *f)\n{\n\tsize_t i, j;\n\tconst u_char *p = (const u_char *)s;\n\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(f, \"%.4zu: \", i);\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len)\n\t\t\t\tfprintf(f, \"%02x \", p[j]);\n\t\t\telse\n\t\t\t\tfprintf(f, \"   \");\n\t\t}\n\t\tfprintf(f, \" \");\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len) {\n\t\t\t\tif  (isascii(p[j]) && isprint(p[j]))\n\t\t\t\t\tfprintf(f, \"%c\", p[j]);\n\t\t\t\telse\n\t\t\t\t\tfprintf(f, \".\");\n\t\t\t}\n\t\t}\n\t\tfprintf(f, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "buf"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "buf"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"buffer %p len = %zu\\n\"",
            "buf",
            "sshbuf_len(buf)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_dump(struct sshbuf *buf, FILE *f)\n{\n\tfprintf(f, \"buffer %p len = %zu\\n\", buf, sshbuf_len(buf));\n\tsshbuf_dump_data(sshbuf_ptr(buf), sshbuf_len(buf), f);\n}"
  },
  {
    "function_name": "sshbuf_dump_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
    "lines": "38-63",
    "snippet": "void\nsshbuf_dump_data(const void *s, size_t len, FILE *f)\n{\n\tsize_t i, j;\n\tconst u_char *p = (const u_char *)s;\n\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(f, \"%.4zu: \", i);\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len)\n\t\t\t\tfprintf(f, \"%02x \", p[j]);\n\t\t\telse\n\t\t\t\tfprintf(f, \"   \");\n\t\t}\n\t\tfprintf(f, \" \");\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len) {\n\t\t\t\tif  (isascii(p[j]) && isprint(p[j]))\n\t\t\t\t\tfprintf(f, \"%c\", p[j]);\n\t\t\t\telse\n\t\t\t\t\tfprintf(f, \".\");\n\t\t\t}\n\t\t}\n\t\tfprintf(f, \"\\n\");\n\t}\n}",
    "includes": [
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include <ctype.h>",
      "#include <resolv.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"\\n\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\".\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%c\"",
            "p[j]"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "p[j]"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isascii",
          "args": [
            "p[j]"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\" \""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"   \""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%02x \"",
            "p[j]"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%.4zu: \"",
            "i"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_dump_data(const void *s, size_t len, FILE *f)\n{\n\tsize_t i, j;\n\tconst u_char *p = (const u_char *)s;\n\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(f, \"%.4zu: \", i);\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len)\n\t\t\t\tfprintf(f, \"%02x \", p[j]);\n\t\t\telse\n\t\t\t\tfprintf(f, \"   \");\n\t\t}\n\t\tfprintf(f, \" \");\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len) {\n\t\t\t\tif  (isascii(p[j]) && isprint(p[j]))\n\t\t\t\t\tfprintf(f, \"%c\", p[j]);\n\t\t\t\telse\n\t\t\t\t\tfprintf(f, \".\");\n\t\t\t}\n\t\t}\n\t\tfprintf(f, \"\\n\");\n\t}\n}"
  }
]